package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"encoding/json"
	"fmt"
	"frameworks/api_gateway/graph/generated"
	"frameworks/api_gateway/graph/model"
	"frameworks/api_gateway/internal/loaders"
	"frameworks/api_gateway/internal/middleware"
	"frameworks/api_gateway/internal/resolvers"
	"frameworks/pkg/logging"
	"frameworks/pkg/proto"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// ProgressPercent is the resolver for the progressPercent field.
func (r *artifactStateResolver) ProgressPercent(ctx context.Context, obj *proto.ArtifactState) (int, error) {
	return int(obj.ProgressPercent), nil
}

// RequestedAt is the resolver for the requestedAt field.
func (r *artifactStateResolver) RequestedAt(ctx context.Context, obj *proto.ArtifactState) (*time.Time, error) {
	if obj.RequestedAt == nil {
		return nil, nil
	}
	t := obj.RequestedAt.AsTime()
	return &t, nil
}

// StartedAt is the resolver for the startedAt field.
func (r *artifactStateResolver) StartedAt(ctx context.Context, obj *proto.ArtifactState) (*time.Time, error) {
	if obj.StartedAt == nil {
		return nil, nil
	}
	t := obj.StartedAt.AsTime()
	return &t, nil
}

// CompletedAt is the resolver for the completedAt field.
func (r *artifactStateResolver) CompletedAt(ctx context.Context, obj *proto.ArtifactState) (*time.Time, error) {
	if obj.CompletedAt == nil {
		return nil, nil
	}
	t := obj.CompletedAt.AsTime()
	return &t, nil
}

// SegmentCount is the resolver for the segmentCount field.
func (r *artifactStateResolver) SegmentCount(ctx context.Context, obj *proto.ArtifactState) (*int, error) {
	if obj.SegmentCount == nil {
		return nil, nil
	}
	v := int(*obj.SegmentCount)
	return &v, nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *artifactStateResolver) SizeBytes(ctx context.Context, obj *proto.ArtifactState) (*float64, error) {
	if obj.SizeBytes == nil {
		return nil, nil
	}
	v := float64(*obj.SizeBytes)
	return &v, nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *artifactStateResolver) ExpiresAt(ctx context.Context, obj *proto.ArtifactState) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// CurrentTier is the resolver for the currentTier field.
func (r *billingStatusResolver) CurrentTier(ctx context.Context, obj *proto.BillingStatusResponse) (*proto.BillingTier, error) {
	return obj.Tier, nil
}

// NextBillingDate is the resolver for the nextBillingDate field.
func (r *billingStatusResolver) NextBillingDate(ctx context.Context, obj *proto.BillingStatusResponse) (*time.Time, error) {
	if obj.NextBillingDate == nil {
		return nil, nil
	}
	t := obj.NextBillingDate.AsTime()
	return &t, nil
}

// TrialEndsAt is the resolver for the trialEndsAt field.
func (r *billingStatusResolver) TrialEndsAt(ctx context.Context, obj *proto.BillingStatusResponse) (*time.Time, error) {
	if obj.Subscription == nil || obj.Subscription.TrialEndsAt == nil || !obj.Subscription.TrialEndsAt.IsValid() {
		return nil, nil
	}
	t := obj.Subscription.TrialEndsAt.AsTime()
	return &t, nil
}

// Name is the resolver for the name field.
func (r *billingTierResolver) Name(ctx context.Context, obj *proto.BillingTier) (string, error) {
	return obj.DisplayName, nil
}

// Metadata is the resolver for the metadata field.
func (r *bootstrapTokenResolver) Metadata(ctx context.Context, obj *proto.BootstrapToken) (*string, error) {
	if obj.Metadata == nil {
		return nil, nil
	}
	b, err := json.Marshal(obj.Metadata.AsMap())
	if err != nil {
		return nil, err
	}
	s := string(b)
	return &s, nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *bootstrapTokenResolver) ExpiresAt(ctx context.Context, obj *proto.BootstrapToken) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// UsedAt is the resolver for the usedAt field.
func (r *bootstrapTokenResolver) UsedAt(ctx context.Context, obj *proto.BootstrapToken) (*time.Time, error) {
	if obj.UsedAt == nil {
		return nil, nil
	}
	t := obj.UsedAt.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *bootstrapTokenResolver) CreatedAt(ctx context.Context, obj *proto.BootstrapToken) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// Percentage is the resolver for the percentage field.
func (r *cityMetricResolver) Percentage(ctx context.Context, obj *proto.CityMetric) (float64, error) {
	return float64(obj.Percentage), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *clientMetrics5mResolver) Timestamp(ctx context.Context, obj *proto.ClientMetrics5M) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// ActiveSessions is the resolver for the activeSessions field.
func (r *clientMetrics5mResolver) ActiveSessions(ctx context.Context, obj *proto.ClientMetrics5M) (int, error) {
	return int(obj.ActiveSessions), nil
}

// AvgConnectionTime is the resolver for the avgConnectionTime field.
func (r *clientMetrics5mResolver) AvgConnectionTime(ctx context.Context, obj *proto.ClientMetrics5M) (float64, error) {
	return float64(obj.AvgConnectionTime), nil
}

// PacketLossRate is the resolver for the packetLossRate field.
func (r *clientMetrics5mResolver) PacketLossRate(ctx context.Context, obj *proto.ClientMetrics5M) (*float64, error) {
	if obj.PacketLossRate == nil {
		return nil, nil
	}
	value := float64(*obj.PacketLossRate)
	return &value, nil
}

// NodeID is the resolver for the nodeId field.
func (r *clipResolver) NodeID(ctx context.Context, obj *proto.ClipInfo) (*string, error) {
	if state := r.getLifecycleData(ctx, obj.ClipHash); state != nil && state.ProcessingNodeId != nil && *state.ProcessingNodeId != "" {
		return state.ProcessingNodeId, nil
	}
	return nil, nil
}

// StoragePath is the resolver for the storagePath field.
func (r *clipResolver) StoragePath(ctx context.Context, obj *proto.ClipInfo) (*string, error) {
	if state := r.getLifecycleData(ctx, obj.ClipHash); state != nil && state.FilePath != nil && *state.FilePath != "" {
		return state.FilePath, nil
	}
	return nil, nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *clipResolver) SizeBytes(ctx context.Context, obj *proto.ClipInfo) (*float64, error) {
	if state := r.getLifecycleData(ctx, obj.ClipHash); state != nil && state.SizeBytes != nil {
		size := float64(*state.SizeBytes)
		return &size, nil
	}
	return nil, nil
}

// Status is the resolver for the status field.
// Fetches lifecycle data from Periscope - the source of truth for processing status.
func (r *clipResolver) Status(ctx context.Context, obj *proto.ClipInfo) (string, error) {
	if state := r.getLifecycleData(ctx, obj.ClipHash); state != nil && state.Stage != "" {
		return state.Stage, nil
	}
	// No fallback - return "unknown" to let frontend handle missing lifecycle data.
	// Previously assumed "completed" when lifecycle data unavailable, but this
	// incorrectly showed deleted items as completed.
	return "unknown", nil
}

// AccessCount is the resolver for the accessCount field.
func (r *clipResolver) AccessCount(ctx context.Context, obj *proto.ClipInfo) (*int, error) {
	// Access count is not tracked in ClickHouse lifecycle data
	// Return nil to indicate it's not available
	return nil, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *clipResolver) CreatedAt(ctx context.Context, obj *proto.ClipInfo) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *clipResolver) UpdatedAt(ctx context.Context, obj *proto.ClipInfo) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// StorageLocation is the resolver for the storageLocation field.
func (r *clipResolver) StorageLocation(ctx context.Context, obj *proto.ClipInfo) (*string, error) {
	state := r.getLifecycleData(ctx, obj.ClipHash)
	if state != nil && state.S3Url != nil && *state.S3Url != "" {
		loc := "s3"
		return &loc, nil
	}
	loc := "local"
	return &loc, nil
}

// IsFrozen is the resolver for the isFrozen field.
func (r *clipResolver) IsFrozen(ctx context.Context, obj *proto.ClipInfo) (bool, error) {
	// Frozen if stored in S3 (has S3 URL in lifecycle data)
	state := r.getLifecycleData(ctx, obj.ClipHash)
	return state != nil && state.S3Url != nil && *state.S3Url != "", nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *clipResolver) ExpiresAt(ctx context.Context, obj *proto.ClipInfo) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *clipEventResolver) Timestamp(ctx context.Context, obj *proto.ClipEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// Percent is the resolver for the percent field.
func (r *clipEventResolver) Percent(ctx context.Context, obj *proto.ClipEvent) (*int, error) {
	if obj.Percent == nil {
		return nil, nil
	}
	v := int(*obj.Percent)
	return &v, nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *clipEventResolver) SizeBytes(ctx context.Context, obj *proto.ClipEvent) (*float64, error) {
	if obj.SizeBytes == nil {
		return nil, nil
	}
	v := float64(*obj.SizeBytes)
	return &v, nil
}

// Stage is the resolver for the stage field.
func (r *clipLifecycleResolver) Stage(ctx context.Context, obj *proto.ClipLifecycleData) (int, error) {
	return int(obj.Stage), nil
}

// ProgressPercent is the resolver for the progressPercent field.
func (r *clipLifecycleResolver) ProgressPercent(ctx context.Context, obj *proto.ClipLifecycleData) (*int, error) {
	if obj.ProgressPercent == nil {
		return nil, nil
	}
	v := int(*obj.ProgressPercent)
	return &v, nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *clipLifecycleResolver) SizeBytes(ctx context.Context, obj *proto.ClipLifecycleData) (*float64, error) {
	if obj.SizeBytes == nil {
		return nil, nil
	}
	v := float64(*obj.SizeBytes)
	return &v, nil
}

// Urls is the resolver for the urls field.
func (r *clipViewingUrlsResolver) Urls(ctx context.Context, obj *proto.ClipViewingURLs) (*string, error) {
	if obj.Urls == nil {
		return nil, nil
	}
	b, err := json.Marshal(obj.Urls)
	if err != nil {
		return nil, err
	}
	s := string(b)
	return &s, nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *clipViewingUrlsResolver) ExpiresAt(ctx context.Context, obj *proto.ClipViewingURLs) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// IsSubscribed is the resolver for the isSubscribed field.
func (r *clusterResolver) IsSubscribed(ctx context.Context, obj *proto.InfrastructureCluster) (bool, error) {
	return r.Resolver.DoCheckIsSubscribed(ctx, obj)
}

// CreatedAt is the resolver for the createdAt field.
func (r *clusterResolver) CreatedAt(ctx context.Context, obj *proto.InfrastructureCluster) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *clusterResolver) UpdatedAt(ctx context.Context, obj *proto.InfrastructureCluster) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// NodesConnection is the resolver for the nodesConnection field.
func (r *clusterResolver) NodesConnection(ctx context.Context, obj *proto.InfrastructureCluster, first *int, after *string, last *int, before *string) (*model.NodesConnection, error) {
	// Reuse DoGetNodesConnection with cluster ID filter
	return r.Resolver.DoGetNodesConnection(ctx, &obj.Id, nil, nil, first, after, last, before)
}

// ResourceLimits is the resolver for the resourceLimits field.
func (r *clusterInviteResolver) ResourceLimits(ctx context.Context, obj *proto.ClusterInvite) (*string, error) {
	if obj.ResourceLimits == nil {
		return nil, nil
	}
	b, err := obj.ResourceLimits.MarshalJSON()
	if err != nil {
		return nil, nil
	}
	s := string(b)
	return &s, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *clusterInviteResolver) CreatedAt(ctx context.Context, obj *proto.ClusterInvite) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *clusterInviteResolver) ExpiresAt(ctx context.Context, obj *proto.ClusterInvite) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// AcceptedAt is the resolver for the acceptedAt field.
func (r *clusterInviteResolver) AcceptedAt(ctx context.Context, obj *proto.ClusterInvite) (*time.Time, error) {
	if obj.AcceptedAt == nil {
		return nil, nil
	}
	t := obj.AcceptedAt.AsTime()
	return &t, nil
}

// ResourceLimits is the resolver for the resourceLimits field.
func (r *clusterSubscriptionResolver) ResourceLimits(ctx context.Context, obj *proto.ClusterSubscription) (*string, error) {
	if obj.ResourceLimits == nil {
		return nil, nil
	}
	b, err := obj.ResourceLimits.MarshalJSON()
	if err != nil {
		return nil, nil
	}
	s := string(b)
	return &s, nil
}

// RequestedAt is the resolver for the requestedAt field.
func (r *clusterSubscriptionResolver) RequestedAt(ctx context.Context, obj *proto.ClusterSubscription) (*time.Time, error) {
	if obj.RequestedAt == nil {
		return nil, nil
	}
	t := obj.RequestedAt.AsTime()
	return &t, nil
}

// ApprovedAt is the resolver for the approvedAt field.
func (r *clusterSubscriptionResolver) ApprovedAt(ctx context.Context, obj *proto.ClusterSubscription) (*time.Time, error) {
	if obj.ApprovedAt == nil {
		return nil, nil
	}
	t := obj.ApprovedAt.AsTime()
	return &t, nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *clusterSubscriptionResolver) ExpiresAt(ctx context.Context, obj *proto.ClusterSubscription) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *clusterSubscriptionResolver) CreatedAt(ctx context.Context, obj *proto.ClusterSubscription) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *clusterSubscriptionResolver) UpdatedAt(ctx context.Context, obj *proto.ClusterSubscription) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *connectionEventResolver) Timestamp(ctx context.Context, obj *proto.ConnectionEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// ConnectionAddr is the resolver for the connectionAddr field.
func (r *connectionEventResolver) ConnectionAddr(ctx context.Context, obj *proto.ConnectionEvent) (*string, error) {
	// Redacted for privacy - client IPs are not exposed via API
	return nil, nil
}

// SessionDurationSeconds is the resolver for the sessionDurationSeconds field.
func (r *connectionEventResolver) SessionDurationSeconds(ctx context.Context, obj *proto.ConnectionEvent) (*int, error) {
	if obj.SessionDurationSeconds == 0 {
		return nil, nil
	}
	v := int(obj.SessionDurationSeconds)
	return &v, nil
}

// BytesTransferred is the resolver for the bytesTransferred field.
func (r *connectionEventResolver) BytesTransferred(ctx context.Context, obj *proto.ConnectionEvent) (*int, error) {
	if obj.BytesTransferred == 0 {
		return nil, nil
	}
	v := int(obj.BytesTransferred)
	return &v, nil
}

// Percentage is the resolver for the percentage field.
func (r *countryMetricResolver) Percentage(ctx context.Context, obj *proto.CountryMetric) (float64, error) {
	return float64(obj.GetPercentage()), nil
}

// Status is the resolver for the status field.
func (r *dVREventResolver) Status(ctx context.Context, obj *proto.DVRLifecycleData) (string, error) {
	return obj.Status.String(), nil
}

// RequestID is the resolver for the requestId field.
func (r *dVREventResolver) RequestID(ctx context.Context, obj *proto.DVRLifecycleData) (*string, error) {
	if obj.DvrHash == "" {
		return nil, nil
	}
	return &obj.DvrHash, nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *dVREventResolver) SizeBytes(ctx context.Context, obj *proto.DVRLifecycleData) (*float64, error) {
	if obj.SizeBytes == nil {
		return nil, nil
	}
	v := float64(*obj.SizeBytes)
	return &v, nil
}

// CreatedAt is the resolver for the createdAt field.
// Business metadata - from Commodore registry.
func (r *dVRRequestResolver) CreatedAt(ctx context.Context, obj *proto.DVRInfo) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
// Business metadata - from Commodore registry.
func (r *dVRRequestResolver) UpdatedAt(ctx context.Context, obj *proto.DVRInfo) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// ExpiresAt is the resolver for the expiresAt field.
// Business metadata - from Commodore registry.
func (r *dVRRequestResolver) ExpiresAt(ctx context.Context, obj *proto.DVRInfo) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// StorageNodeID is the resolver for the storageNodeId field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) StorageNodeID(ctx context.Context, obj *proto.DVRInfo) (*string, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.ProcessingNodeId != nil && *state.ProcessingNodeId != "" {
		return state.ProcessingNodeId, nil
	}
	return nil, nil
}

// Status is the resolver for the status field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) Status(ctx context.Context, obj *proto.DVRInfo) (*string, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.Stage != "" {
		return &state.Stage, nil
	}
	// No fallback - return nil to let frontend handle unknown status.
	// Previously assumed "completed" when lifecycle data unavailable, but this
	// incorrectly showed deleted items as completed.
	return nil, nil
}

// StartedAt is the resolver for the startedAt field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) StartedAt(ctx context.Context, obj *proto.DVRInfo) (*time.Time, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.StartedAt != nil {
		t := state.StartedAt.AsTime()
		return &t, nil
	}
	return nil, nil
}

// EndedAt is the resolver for the endedAt field.
// Lifecycle data - from Periscope (CompletedAt maps to EndedAt).
func (r *dVRRequestResolver) EndedAt(ctx context.Context, obj *proto.DVRInfo) (*time.Time, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.CompletedAt != nil {
		t := state.CompletedAt.AsTime()
		return &t, nil
	}
	return nil, nil
}

// DurationSeconds is the resolver for the durationSeconds field.
// Note: Duration may need to be computed from start/end times in lifecycle data.
// For now, we rely on business registry data as duration is often stored there.
func (r *dVRRequestResolver) DurationSeconds(ctx context.Context, obj *proto.DVRInfo) (*int, error) {
	// Try to calculate from lifecycle data timestamps
	state := r.getLifecycleData(ctx, obj.DvrHash)
	if state != nil && state.StartedAt != nil && state.CompletedAt != nil {
		duration := int(state.CompletedAt.AsTime().Sub(state.StartedAt.AsTime()).Seconds())
		if duration > 0 {
			return &duration, nil
		}
	}
	// Fallback to business data
	if obj.DurationSeconds != nil {
		duration := int(*obj.DurationSeconds)
		return &duration, nil
	}
	return nil, nil
}

// SizeBytes is the resolver for the sizeBytes field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) SizeBytes(ctx context.Context, obj *proto.DVRInfo) (*float64, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.SizeBytes != nil {
		size := float64(*state.SizeBytes)
		return &size, nil
	}
	return nil, nil
}

// ManifestPath is the resolver for the manifestPath field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) ManifestPath(ctx context.Context, obj *proto.DVRInfo) (*string, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.ManifestPath != nil && *state.ManifestPath != "" {
		return state.ManifestPath, nil
	}
	return nil, nil
}

// ErrorMessage is the resolver for the errorMessage field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) ErrorMessage(ctx context.Context, obj *proto.DVRInfo) (*string, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.ErrorMessage != nil && *state.ErrorMessage != "" {
		return state.ErrorMessage, nil
	}
	return nil, nil
}

// StorageLocation is the resolver for the storageLocation field.
// Lifecycle data - derived from S3 URL presence.
func (r *dVRRequestResolver) StorageLocation(ctx context.Context, obj *proto.DVRInfo) (*string, error) {
	state := r.getLifecycleData(ctx, obj.DvrHash)
	if state != nil && state.S3Url != nil && *state.S3Url != "" {
		loc := "s3"
		return &loc, nil
	}
	loc := "local"
	return &loc, nil
}

// IsFrozen is the resolver for the isFrozen field.
// Lifecycle data - true if stored in S3.
func (r *dVRRequestResolver) IsFrozen(ctx context.Context, obj *proto.DVRInfo) (bool, error) {
	state := r.getLifecycleData(ctx, obj.DvrHash)
	return state != nil && state.S3Url != nil && *state.S3Url != "", nil
}

// FrozenAt is the resolver for the frozenAt field.
// Business metadata - from Commodore registry (or could derive from lifecycle updates).
func (r *dVRRequestResolver) FrozenAt(ctx context.Context, obj *proto.DVRInfo) (*time.Time, error) {
	if obj.FrozenAt == nil {
		return nil, nil
	}
	t := obj.FrozenAt.AsTime()
	return &t, nil
}

// S3Url is the resolver for the s3Url field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) S3Url(ctx context.Context, obj *proto.DVRInfo) (*string, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.S3Url != nil && *state.S3Url != "" {
		return state.S3Url, nil
	}
	return nil, nil
}

// LastUsedAt is the resolver for the lastUsedAt field.
func (r *developerTokenResolver) LastUsedAt(ctx context.Context, obj *proto.APITokenInfo) (*time.Time, error) {
	if obj.LastUsedAt == nil {
		return nil, nil
	}
	t := obj.LastUsedAt.AsTime()
	return &t, nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *developerTokenResolver) ExpiresAt(ctx context.Context, obj *proto.APITokenInfo) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *developerTokenResolver) CreatedAt(ctx context.Context, obj *proto.APITokenInfo) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// H3Index is the resolver for the h3Index field.
func (r *geoBucketResolver) H3Index(ctx context.Context, obj *proto.GeoBucket) (string, error) {
	if obj == nil {
		return "", nil
	}
	// ClickHouse stores H3 as UInt64; present as hex string for frontend (h3-js expects hex)
	return strings.ToLower(strconv.FormatUint(obj.H3Index, 16)), nil
}

// Resolution is the resolver for the resolution field.
func (r *geoBucketResolver) Resolution(ctx context.Context, obj *proto.GeoBucket) (int, error) {
	if obj == nil {
		return 0, nil
	}
	return int(obj.Resolution), nil
}

// Status is the resolver for the status field.
func (r *invoiceResolver) Status(ctx context.Context, obj *proto.Invoice) (model.InvoiceStatus, error) {
	s := strings.ToLower(obj.Status)
	switch s {
	case "pending":
		return model.InvoiceStatusPending, nil
	case "paid":
		return model.InvoiceStatusPaid, nil
	case "failed":
		return model.InvoiceStatusFailed, nil
	case "cancelled":
		return model.InvoiceStatusCancelled, nil
	default:
		return model.InvoiceStatusPending, fmt.Errorf("unknown invoice status: %s", obj.Status)
	}
}

// DueDate is the resolver for the dueDate field.
func (r *invoiceResolver) DueDate(ctx context.Context, obj *proto.Invoice) (*time.Time, error) {
	if obj.DueDate == nil {
		return nil, nil
	}
	t := obj.DueDate.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *invoiceResolver) CreatedAt(ctx context.Context, obj *proto.Invoice) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// LineItems is the resolver for the lineItems field.
func (r *invoiceResolver) LineItems(ctx context.Context, obj *proto.Invoice) ([]*model.LineItem, error) {
	var lineItems []*model.LineItem

	// 1. Base tier line item (always present)
	tierName := "Service"
	basePrice := obj.BaseAmount
	if basePrice == 0 {
		basePrice = obj.Amount
	}

	// Try to extract tier info from usage_details
	if obj.UsageDetails != nil && obj.UsageDetails.Fields != nil {
		if tierInfo := obj.UsageDetails.Fields["tier_info"]; tierInfo != nil {
			if ts := tierInfo.GetStructValue(); ts != nil && ts.Fields != nil {
				if dn := ts.Fields["display_name"]; dn != nil {
					tierName = dn.GetStringValue()
				}
				if bp := ts.Fields["base_price"]; bp != nil {
					basePrice = bp.GetNumberValue()
				}
			}
		}
	}

	lineItems = append(lineItems, &model.LineItem{
		Description: tierName + " Tier",
		Quantity:    1,
		UnitPrice:   basePrice,
		Total:       basePrice,
	})

	// 2. Usage metrics (from usage_data or flat keys)
	usageData := make(map[string]float64)
	if obj.UsageDetails != nil && obj.UsageDetails.Fields != nil {
		if ud := obj.UsageDetails.Fields["usage_data"]; ud != nil {
			if us := ud.GetStructValue(); us != nil && us.Fields != nil {
				for k, v := range us.Fields {
					usageData[k] = v.GetNumberValue()
				}
			}
		} else {
			// Legacy flat format - extract numeric fields
			for k, v := range obj.UsageDetails.Fields {
				if k != "tier" && k != "tier_info" {
					if num := v.GetNumberValue(); num > 0 {
						usageData[k] = num
					}
				}
			}
		}
	}

	// Add usage line items with â‚¬0.00 unit price (ordered for presentation)
	orderedMetrics := []string{"viewer_hours", "average_storage_gb", "gpu_hours", "stream_hours", "egress_gb", "recording_gb"}
	for _, metric := range orderedMetrics {
		qty, exists := usageData[metric]
		if !exists || qty == 0 {
			continue
		}
		displayQty := qty
		// Convert viewer_hours to delivered minutes for display
		if metric == "viewer_hours" {
			displayQty = qty * 60
		}
		lineItems = append(lineItems, &model.LineItem{
			Description: formatMetricName(metric),
			Quantity:    int(displayQty),
			UnitPrice:   0.0,
			Total:       0.0,
		})
	}

	// Add processing/transcoding line items per-codec
	type codecLineItem struct {
		key         string
		description string
	}
	processingItems := []codecLineItem{
		{"livepeer_h264_seconds", "Livepeer H264 Transcoding"},
		{"livepeer_vp9_seconds", "Livepeer VP9 Transcoding"},
		{"livepeer_av1_seconds", "Livepeer AV1 Transcoding"},
		{"livepeer_hevc_seconds", "Livepeer HEVC Transcoding"},
		{"native_av_h264_seconds", "Native AV H264 Processing"},
		{"native_av_vp9_seconds", "Native AV VP9 Processing"},
		{"native_av_av1_seconds", "Native AV AV1 Processing"},
		{"native_av_hevc_seconds", "Native AV HEVC Processing"},
		{"native_av_aac_seconds", "Audio Transcoding (AAC)"},
		{"native_av_opus_seconds", "Audio Transcoding (Opus)"},
	}

	for _, item := range processingItems {
		seconds, exists := usageData[item.key]
		if !exists || seconds == 0 {
			continue
		}
		minutes := int(seconds / 60)
		if minutes == 0 && seconds > 0 {
			minutes = 1 // Show at least 1 minute if there's any usage
		}
		lineItems = append(lineItems, &model.LineItem{
			Description: item.description,
			Quantity:    minutes,
			UnitPrice:   0.0, // Actual cost rolled into metered_amount
			Total:       0.0,
		})
	}

	// 3. Overage charges (if any)
	if obj.MeteredAmount > 0 {
		lineItems = append(lineItems, &model.LineItem{
			Description: "Overage charges",
			Quantity:    1,
			UnitPrice:   obj.MeteredAmount,
			Total:       obj.MeteredAmount,
		})
	}

	return lineItems, nil
}

// CPUPercent is the resolver for the cpuPercent field.
func (r *liveNodeResolver) CPUPercent(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	panic(fmt.Errorf("not implemented: CPUPercent - cpuPercent"))
}

// RAMUsedBytes is the resolver for the ramUsedBytes field.
func (r *liveNodeResolver) RAMUsedBytes(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	panic(fmt.Errorf("not implemented: RAMUsedBytes - ramUsedBytes"))
}

// RAMTotalBytes is the resolver for the ramTotalBytes field.
func (r *liveNodeResolver) RAMTotalBytes(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	panic(fmt.Errorf("not implemented: RAMTotalBytes - ramTotalBytes"))
}

// DiskUsedBytes is the resolver for the diskUsedBytes field.
func (r *liveNodeResolver) DiskUsedBytes(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	panic(fmt.Errorf("not implemented: DiskUsedBytes - diskUsedBytes"))
}

// DiskTotalBytes is the resolver for the diskTotalBytes field.
func (r *liveNodeResolver) DiskTotalBytes(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	panic(fmt.Errorf("not implemented: DiskTotalBytes - diskTotalBytes"))
}

// UpSpeed is the resolver for the upSpeed field.
func (r *liveNodeResolver) UpSpeed(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	panic(fmt.Errorf("not implemented: UpSpeed - upSpeed"))
}

// DownSpeed is the resolver for the downSpeed field.
func (r *liveNodeResolver) DownSpeed(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	panic(fmt.Errorf("not implemented: DownSpeed - downSpeed"))
}

// ActiveStreams is the resolver for the activeStreams field.
func (r *liveNodeResolver) ActiveStreams(ctx context.Context, obj *proto.LiveNode) (int, error) {
	panic(fmt.Errorf("not implemented: ActiveStreams - activeStreams"))
}

// Metadata is the resolver for the metadata field.
func (r *liveNodeResolver) Metadata(ctx context.Context, obj *proto.LiveNode) (*string, error) {
	panic(fmt.Errorf("not implemented: Metadata - metadata"))
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *liveNodeResolver) UpdatedAt(ctx context.Context, obj *proto.LiveNode) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: UpdatedAt - updatedAt"))
}

// CreateStream is the resolver for the createStream field.
func (r *mutationResolver) CreateStream(ctx context.Context, input model.CreateStreamInput) (model.CreateStreamResult, error) {
	return r.DoCreateStream(ctx, input)
}

// UpdateStream is the resolver for the updateStream field.
func (r *mutationResolver) UpdateStream(ctx context.Context, id string, input model.UpdateStreamInput) (model.UpdateStreamResult, error) {
	return r.DoUpdateStream(ctx, id, input)
}

// DeleteStream is the resolver for the deleteStream field.
func (r *mutationResolver) DeleteStream(ctx context.Context, id string) (model.DeleteStreamResult, error) {
	return r.DoDeleteStream(ctx, id)
}

// RefreshStreamKey is the resolver for the refreshStreamKey field.
func (r *mutationResolver) RefreshStreamKey(ctx context.Context, id string) (model.UpdateStreamResult, error) {
	return r.Resolver.DoRefreshStreamKey(ctx, id)
}

// CreateClip is the resolver for the createClip field.
func (r *mutationResolver) CreateClip(ctx context.Context, input model.CreateClipInput) (model.CreateClipResult, error) {
	return r.DoCreateClip(ctx, input)
}

// DeleteClip is the resolver for the deleteClip field.
func (r *mutationResolver) DeleteClip(ctx context.Context, id string) (model.DeleteClipResult, error) {
	return r.DoDeleteClip(ctx, id)
}

// StartDvr is the resolver for the startDVR field.
func (r *mutationResolver) StartDvr(ctx context.Context, internalName string, streamID *string, expiresAt *int) (model.StartDVRResult, error) {
	res, err := r.Resolver.DoStartDVR(ctx, internalName, streamID, expiresAt)
	if err != nil {
		return nil, err
	}
	// Map StartDVRResponse into DVRInfo (bound to GraphQL DVRRequest)
	now := timestamppb.Now()
	return &proto.DVRInfo{
		DvrHash:       res.DvrHash,
		InternalName:  internalName,
		StorageNodeId: res.StorageNodeId,
		Status:        res.Status,
		CreatedAt:     now,
		UpdatedAt:     now,
	}, nil
}

// StopDvr is the resolver for the stopDVR field.
func (r *mutationResolver) StopDvr(ctx context.Context, dvrHash string) (model.StopDVRResult, error) {
	return r.Resolver.DoStopDVR(ctx, dvrHash)
}

// DeleteDvr is the resolver for the deleteDVR field.
func (r *mutationResolver) DeleteDvr(ctx context.Context, dvrHash string) (model.DeleteDVRResult, error) {
	return r.Resolver.DoDeleteDVR(ctx, dvrHash)
}

// CreateVodUpload is the resolver for the createVodUpload field.
func (r *mutationResolver) CreateVodUpload(ctx context.Context, input model.CreateVodUploadInput) (model.CreateVodUploadResult, error) {
	return r.Resolver.DoCreateVodUpload(ctx, input)
}

// CompleteVodUpload is the resolver for the completeVodUpload field.
func (r *mutationResolver) CompleteVodUpload(ctx context.Context, input model.CompleteVodUploadInput) (model.CompleteVodUploadResult, error) {
	return r.Resolver.DoCompleteVodUpload(ctx, input)
}

// AbortVodUpload is the resolver for the abortVodUpload field.
func (r *mutationResolver) AbortVodUpload(ctx context.Context, uploadID string) (model.AbortVodUploadResult, error) {
	return r.Resolver.DoAbortVodUpload(ctx, uploadID)
}

// DeleteVodAsset is the resolver for the deleteVodAsset field.
func (r *mutationResolver) DeleteVodAsset(ctx context.Context, id string) (model.DeleteVodAssetResult, error) {
	return r.Resolver.DoDeleteVodAsset(ctx, id)
}

// CreatePayment is the resolver for the createPayment field.
func (r *mutationResolver) CreatePayment(ctx context.Context, input model.CreatePaymentInput) (model.CreatePaymentResult, error) {
	return r.DoCreatePayment(ctx, input)
}

// UpdateSubscriptionCustomTerms is the resolver for the updateSubscriptionCustomTerms field.
func (r *mutationResolver) UpdateSubscriptionCustomTerms(ctx context.Context, tenantID string, input model.UpdateSubscriptionCustomTermsInput) (*proto.TenantSubscription, error) {
	return r.Resolver.DoUpdateSubscriptionCustomTerms(ctx, tenantID, input)
}

// UpdateTenant is the resolver for the updateTenant field.
func (r *mutationResolver) UpdateTenant(ctx context.Context, input model.UpdateTenantInput) (model.UpdateTenantResult, error) {
	return r.DoUpdateTenant(ctx, input)
}

// SubscribeToCluster is the resolver for the subscribeToCluster field.
func (r *mutationResolver) SubscribeToCluster(ctx context.Context, clusterID string) (bool, error) {
	return r.Resolver.DoSubscribeToCluster(ctx, clusterID)
}

// UnsubscribeFromCluster is the resolver for the unsubscribeFromCluster field.
func (r *mutationResolver) UnsubscribeFromCluster(ctx context.Context, clusterID string) (bool, error) {
	return r.Resolver.DoUnsubscribeFromCluster(ctx, clusterID)
}

// CreatePrivateCluster is the resolver for the createPrivateCluster field.
func (r *mutationResolver) CreatePrivateCluster(ctx context.Context, input model.CreatePrivateClusterInput) (model.CreatePrivateClusterResult, error) {
	return r.DoCreatePrivateCluster(ctx, input)
}

// UpdateClusterMarketplace is the resolver for the updateClusterMarketplace field.
func (r *mutationResolver) UpdateClusterMarketplace(ctx context.Context, clusterID string, input model.UpdateClusterMarketplaceInput) (model.UpdateClusterResult, error) {
	return r.DoUpdateClusterMarketplace(ctx, clusterID, input)
}

// CreateClusterInvite is the resolver for the createClusterInvite field.
func (r *mutationResolver) CreateClusterInvite(ctx context.Context, input model.CreateClusterInviteInput) (model.CreateClusterInviteResult, error) {
	return r.DoCreateClusterInvite(ctx, input)
}

// RevokeClusterInvite is the resolver for the revokeClusterInvite field.
func (r *mutationResolver) RevokeClusterInvite(ctx context.Context, inviteID string) (model.RevokeClusterInviteResult, error) {
	return r.DoRevokeClusterInvite(ctx, inviteID)
}

// RequestClusterSubscription is the resolver for the requestClusterSubscription field.
func (r *mutationResolver) RequestClusterSubscription(ctx context.Context, clusterID string, inviteToken *string) (model.ClusterSubscriptionResult, error) {
	return r.DoRequestClusterSubscription(ctx, clusterID, inviteToken)
}

// AcceptClusterInvite is the resolver for the acceptClusterInvite field.
func (r *mutationResolver) AcceptClusterInvite(ctx context.Context, inviteToken string) (model.ClusterSubscriptionResult, error) {
	return r.DoAcceptClusterInvite(ctx, inviteToken)
}

// ApproveClusterSubscription is the resolver for the approveClusterSubscription field.
func (r *mutationResolver) ApproveClusterSubscription(ctx context.Context, subscriptionID string) (model.ClusterSubscriptionResult, error) {
	return r.DoApproveClusterSubscription(ctx, subscriptionID)
}

// RejectClusterSubscription is the resolver for the rejectClusterSubscription field.
func (r *mutationResolver) RejectClusterSubscription(ctx context.Context, subscriptionID string, reason *string) (model.ClusterSubscriptionResult, error) {
	return r.DoRejectClusterSubscription(ctx, subscriptionID, reason)
}

// CreateDeveloperToken is the resolver for the createDeveloperToken field.
func (r *mutationResolver) CreateDeveloperToken(ctx context.Context, input model.CreateDeveloperTokenInput) (model.CreateDeveloperTokenResult, error) {
	return r.DoCreateDeveloperToken(ctx, input)
}

// RevokeDeveloperToken is the resolver for the revokeDeveloperToken field.
func (r *mutationResolver) RevokeDeveloperToken(ctx context.Context, id string) (model.RevokeDeveloperTokenResult, error) {
	return r.DoRevokeDeveloperToken(ctx, id)
}

// CreateBootstrapToken is the resolver for the createBootstrapToken field.
func (r *mutationResolver) CreateBootstrapToken(ctx context.Context, input model.CreateBootstrapTokenInput) (model.CreateBootstrapTokenResult, error) {
	return r.DoCreateBootstrapToken(ctx, input)
}

// RevokeBootstrapToken is the resolver for the revokeBootstrapToken field.
func (r *mutationResolver) RevokeBootstrapToken(ctx context.Context, id string) (model.RevokeBootstrapTokenResult, error) {
	return r.DoRevokeBootstrapToken(ctx, id)
}

// CreateStreamKey is the resolver for the createStreamKey field.
func (r *mutationResolver) CreateStreamKey(ctx context.Context, streamID string, input model.CreateStreamKeyInput) (model.CreateStreamKeyResult, error) {
	return r.Resolver.DoCreateStreamKey(ctx, streamID, input)
}

// DeleteStreamKey is the resolver for the deleteStreamKey field.
func (r *mutationResolver) DeleteStreamKey(ctx context.Context, streamID string, keyID string) (model.DeleteStreamKeyResult, error) {
	return r.Resolver.DoDeleteStreamKey(ctx, streamID, keyID)
}

// LastHeartbeat is the resolver for the lastHeartbeat field.
func (r *nodeResolver) LastHeartbeat(ctx context.Context, obj *proto.InfrastructureNode) (*time.Time, error) {
	if obj.LastHeartbeat == nil {
		return nil, nil
	}
	t := obj.LastHeartbeat.AsTime()
	return &t, nil
}

// Tags is the resolver for the tags field.
func (r *nodeResolver) Tags(ctx context.Context, obj *proto.InfrastructureNode) (*string, error) {
	if obj.Tags == nil {
		return nil, nil
	}
	b, err := json.Marshal(obj.Tags.AsMap())
	if err != nil {
		return nil, err
	}
	s := string(b)
	return &s, nil
}

// Metadata is the resolver for the metadata field.
func (r *nodeResolver) Metadata(ctx context.Context, obj *proto.InfrastructureNode) (*string, error) {
	if obj.Metadata == nil {
		return nil, nil
	}
	b, err := json.Marshal(obj.Metadata.AsMap())
	if err != nil {
		return nil, err
	}
	s := string(b)
	return &s, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *nodeResolver) CreatedAt(ctx context.Context, obj *proto.InfrastructureNode) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *nodeResolver) UpdatedAt(ctx context.Context, obj *proto.InfrastructureNode) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// MetricsConnection is the resolver for the metricsConnection field.
func (r *nodeResolver) MetricsConnection(ctx context.Context, obj *proto.InfrastructureNode, timeRange *model.TimeRangeInput, first *int, after *string) (*model.NodeMetricsConnection, error) {
	return r.Resolver.DoGetNodeMetricsConnectionForNode(ctx, obj, timeRange, first, after)
}

// Metrics1hConnection is the resolver for the metrics1hConnection field.
func (r *nodeResolver) Metrics1hConnection(ctx context.Context, obj *proto.InfrastructureNode, timeRange *model.TimeRangeInput, first *int, after *string) (*model.NodeMetrics1hConnection, error) {
	return r.Resolver.DoGetNodeMetrics1hConnectionForNode(ctx, obj, timeRange, first, after)
}

// LiveState is the resolver for the liveState field.
func (r *nodeResolver) LiveState(ctx context.Context, obj *proto.InfrastructureNode) (*proto.LiveNode, error) {
	// In demo mode, return synthetic live state
	if middleware.IsDemoMode(ctx) {
		// Demo tenant ID - nodes belong to clusters which have owner_tenant_id
		demoTenantID := "00000000-0000-0000-0000-000000000001"
		var lat, lon float64
		if obj.Latitude != nil {
			lat = *obj.Latitude
		}
		if obj.Longitude != nil {
			lon = *obj.Longitude
		}
		return &proto.LiveNode{
			NodeId:         obj.NodeId,
			TenantId:       demoTenantID, // Infra owner tenant (cluster operator)
			CpuPercent:     35.5,
			RamUsedBytes:   4 * 1024 * 1024 * 1024,   // 4GB
			RamTotalBytes:  16 * 1024 * 1024 * 1024,  // 16GB
			DiskUsedBytes:  50 * 1024 * 1024 * 1024,  // 50GB
			DiskTotalBytes: 500 * 1024 * 1024 * 1024, // 500GB
			UpSpeed:        125 * 1024 * 1024,        // 125MB/s
			DownSpeed:      250 * 1024 * 1024,        // 250MB/s
			ActiveStreams:  3,
			IsHealthy:      true,
			Latitude:       lat,
			Longitude:      lon,
			Location:       obj.GetRegion(),
		}, nil
	}

	return r.Resolver.DoGetLiveNodeState(ctx, obj.NodeId)
}

// Timestamp is the resolver for the timestamp field.
func (r *nodeMetricResolver) Timestamp(ctx context.Context, obj *proto.NodeMetric) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// CPUUsage is the resolver for the cpuUsage field.
func (r *nodeMetricResolver) CPUUsage(ctx context.Context, obj *proto.NodeMetric) (float64, error) {
	return float64(obj.CpuUsage), nil
}

// MemoryTotal is the resolver for the memoryTotal field.
func (r *nodeMetricResolver) MemoryTotal(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.RamMax)
	return &v, nil
}

// MemoryUsed is the resolver for the memoryUsed field.
func (r *nodeMetricResolver) MemoryUsed(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.RamCurrent)
	return &v, nil
}

// DiskTotal is the resolver for the diskTotal field.
func (r *nodeMetricResolver) DiskTotal(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.DiskTotalBytes)
	return &v, nil
}

// DiskUsed is the resolver for the diskUsed field.
func (r *nodeMetricResolver) DiskUsed(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.DiskUsedBytes)
	return &v, nil
}

// ShmTotal is the resolver for the shmTotal field.
func (r *nodeMetricResolver) ShmTotal(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.ShmTotalBytes)
	return &v, nil
}

// ShmUsed is the resolver for the shmUsed field.
func (r *nodeMetricResolver) ShmUsed(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.ShmUsedBytes)
	return &v, nil
}

// NetworkRx is the resolver for the networkRx field.
func (r *nodeMetricResolver) NetworkRx(ctx context.Context, obj *proto.NodeMetric) (int, error) {
	return int(obj.BandwidthIn), nil
}

// NetworkTx is the resolver for the networkTx field.
func (r *nodeMetricResolver) NetworkTx(ctx context.Context, obj *proto.NodeMetric) (int, error) {
	return int(obj.BandwidthOut), nil
}

// UpSpeed is the resolver for the upSpeed field.
func (r *nodeMetricResolver) UpSpeed(ctx context.Context, obj *proto.NodeMetric) (*int, error) {
	v := int(obj.UpSpeed)
	return &v, nil
}

// DownSpeed is the resolver for the downSpeed field.
func (r *nodeMetricResolver) DownSpeed(ctx context.Context, obj *proto.NodeMetric) (*int, error) {
	v := int(obj.DownSpeed)
	return &v, nil
}

// Status is the resolver for the status field.
func (r *nodeMetricResolver) Status(ctx context.Context, obj *proto.NodeMetric) (string, error) {
	if obj.IsHealthy {
		return "HEALTHY", nil
	}
	return "DEGRADED", nil
}

// Metadata is the resolver for the metadata field.
func (r *nodeMetricResolver) Metadata(ctx context.Context, obj *proto.NodeMetric) (*string, error) {
	if obj == nil || obj.Metadata == nil {
		return nil, nil
	}

	payload, err := json.Marshal(obj.Metadata.AsMap())
	if err != nil {
		return nil, fmt.Errorf("failed to marshal node metadata: %w", err)
	}

	result := string(payload)
	return &result, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *nodeMetricHourlyResolver) Timestamp(ctx context.Context, obj *proto.NodeMetricHourly) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// AvgCPU is the resolver for the avgCpu field.
func (r *nodeMetricHourlyResolver) AvgCPU(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.AvgCpu), nil
}

// PeakCPU is the resolver for the peakCpu field.
func (r *nodeMetricHourlyResolver) PeakCPU(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.PeakCpu), nil
}

// AvgMemory is the resolver for the avgMemory field.
func (r *nodeMetricHourlyResolver) AvgMemory(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.AvgMemory), nil
}

// PeakMemory is the resolver for the peakMemory field.
func (r *nodeMetricHourlyResolver) PeakMemory(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.PeakMemory), nil
}

// AvgDisk is the resolver for the avgDisk field.
func (r *nodeMetricHourlyResolver) AvgDisk(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.GetAvgDisk()), nil
}

// PeakDisk is the resolver for the peakDisk field.
func (r *nodeMetricHourlyResolver) PeakDisk(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.GetPeakDisk()), nil
}

// AvgShm is the resolver for the avgShm field.
func (r *nodeMetricHourlyResolver) AvgShm(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.AvgShm), nil
}

// PeakShm is the resolver for the peakShm field.
func (r *nodeMetricHourlyResolver) PeakShm(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.PeakShm), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *nodePerformance5mResolver) Timestamp(ctx context.Context, obj *proto.NodePerformance5M) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// AvgCPU is the resolver for the avgCpu field.
func (r *nodePerformance5mResolver) AvgCPU(ctx context.Context, obj *proto.NodePerformance5M) (float64, error) {
	return float64(obj.AvgCpu), nil
}

// MaxCPU is the resolver for the maxCpu field.
func (r *nodePerformance5mResolver) MaxCPU(ctx context.Context, obj *proto.NodePerformance5M) (float64, error) {
	return float64(obj.MaxCpu), nil
}

// AvgMemory is the resolver for the avgMemory field.
func (r *nodePerformance5mResolver) AvgMemory(ctx context.Context, obj *proto.NodePerformance5M) (float64, error) {
	return float64(obj.AvgMemory), nil
}

// MaxMemory is the resolver for the maxMemory field.
func (r *nodePerformance5mResolver) MaxMemory(ctx context.Context, obj *proto.NodePerformance5M) (float64, error) {
	return float64(obj.MaxMemory), nil
}

// Method is the resolver for the method field.
func (r *paymentResolver) Method(ctx context.Context, obj *proto.PaymentResponse) (model.PaymentMethod, error) {
	// Convert payment method string to GraphQL enum
	switch strings.ToLower(obj.Method) {
	case "card", "mollie":
		return model.PaymentMethodCard, nil
	case "crypto", "crypto_btc", "crypto_eth":
		return model.PaymentMethodCrypto, nil
	case "bank_transfer":
		return model.PaymentMethodBankTransfer, nil
	default:
		// Default to card if method not specified
		return model.PaymentMethodCard, nil
	}
}

// Status is the resolver for the status field.
func (r *paymentResolver) Status(ctx context.Context, obj *proto.PaymentResponse) (model.PaymentStatus, error) {
	s := strings.ToLower(obj.Status)
	switch s {
	case "pending":
		return model.PaymentStatusPending, nil
	case "confirmed":
		return model.PaymentStatusConfirmed, nil
	case "failed":
		return model.PaymentStatusFailed, nil
	default:
		return model.PaymentStatusPending, fmt.Errorf("unknown payment status: %s", obj.Status)
	}
}

// CreatedAt is the resolver for the createdAt field.
func (r *paymentResolver) CreatedAt(ctx context.Context, obj *proto.PaymentResponse) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// TotalBandwidth is the resolver for the totalBandwidth field.
func (r *platformOverviewResolver) TotalBandwidth(ctx context.Context, obj *proto.GetPlatformOverviewResponse) (float64, error) {
	return obj.PeakBandwidth, nil
}

// TimeRange is the resolver for the timeRange field.
func (r *platformOverviewResolver) TimeRange(ctx context.Context, obj *proto.GetPlatformOverviewResponse) (*proto.TimeRange, error) {
	if obj.GeneratedAt == nil {
		return nil, nil
	}
	end := obj.GeneratedAt
	start := timestamppb.New(end.AsTime().Add(-24 * time.Hour))
	return &proto.TimeRange{Start: start, End: end}, nil
}

// TotalUploadBytes is the resolver for the totalUploadBytes field.
func (r *platformOverviewResolver) TotalUploadBytes(ctx context.Context, obj *proto.GetPlatformOverviewResponse) (float64, error) {
	return float64(obj.TotalUploadBytes), nil
}

// TotalDownloadBytes is the resolver for the totalDownloadBytes field.
func (r *platformOverviewResolver) TotalDownloadBytes(ctx context.Context, obj *proto.GetPlatformOverviewResponse) (float64, error) {
	return float64(obj.TotalDownloadBytes), nil
}

// DailyStats is the resolver for the dailyStats field.
func (r *platformOverviewResolver) DailyStats(ctx context.Context, obj *proto.GetPlatformOverviewResponse, days *int) ([]*proto.TenantDailyStat, error) {
	return r.Resolver.DoGetTenantDailyStats(ctx, days)
}

// BytesUp is the resolver for the bytesUp field.
func (r *playbackInstanceResolver) BytesUp(ctx context.Context, obj *proto.PlaybackInstance) (*float64, error) {
	if obj.BytesUp == 0 {
		return nil, nil
	}
	v := float64(obj.BytesUp)
	return &v, nil
}

// BytesDown is the resolver for the bytesDown field.
func (r *playbackInstanceResolver) BytesDown(ctx context.Context, obj *proto.PlaybackInstance) (*float64, error) {
	if obj.BytesDown == 0 {
		return nil, nil
	}
	v := float64(obj.BytesDown)
	return &v, nil
}

// LastUpdate is the resolver for the lastUpdate field.
func (r *playbackInstanceResolver) LastUpdate(ctx context.Context, obj *proto.PlaybackInstance) (*time.Time, error) {
	if obj.LastUpdate == nil {
		return nil, nil
	}
	t := obj.LastUpdate.AsTime()
	return &t, nil
}

// RecordingSizeBytes is the resolver for the recordingSizeBytes field.
func (r *playbackMetadataResolver) RecordingSizeBytes(ctx context.Context, obj *proto.PlaybackMetadata) (*float64, error) {
	if obj.RecordingSizeBytes == nil {
		return nil, nil
	}
	v := float64(*obj.RecordingSizeBytes)
	return &v, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *playbackMetadataResolver) CreatedAt(ctx context.Context, obj *proto.PlaybackMetadata) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *processingUsageRecordResolver) Timestamp(ctx context.Context, obj *proto.ProcessingUsageRecord) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: Timestamp - timestamp"))
}

// InputBytes is the resolver for the inputBytes field.
func (r *processingUsageRecordResolver) InputBytes(ctx context.Context, obj *proto.ProcessingUsageRecord) (*float64, error) {
	panic(fmt.Errorf("not implemented: InputBytes - inputBytes"))
}

// OutputBytesTotal is the resolver for the outputBytesTotal field.
func (r *processingUsageRecordResolver) OutputBytesTotal(ctx context.Context, obj *proto.ProcessingUsageRecord) (*float64, error) {
	panic(fmt.Errorf("not implemented: OutputBytesTotal - outputBytesTotal"))
}

// InputBytesDelta is the resolver for the inputBytesDelta field.
func (r *processingUsageRecordResolver) InputBytesDelta(ctx context.Context, obj *proto.ProcessingUsageRecord) (*float64, error) {
	panic(fmt.Errorf("not implemented: InputBytesDelta - inputBytesDelta"))
}

// OutputBytesDelta is the resolver for the outputBytesDelta field.
func (r *processingUsageRecordResolver) OutputBytesDelta(ctx context.Context, obj *proto.ProcessingUsageRecord) (*float64, error) {
	panic(fmt.Errorf("not implemented: OutputBytesDelta - outputBytesDelta"))
}

// Date is the resolver for the date field.
func (r *processingUsageSummaryResolver) Date(ctx context.Context, obj *proto.ProcessingUsageSummary) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: Date - date"))
}

// LivepeerSegmentCount is the resolver for the livepeerSegmentCount field.
func (r *processingUsageSummaryResolver) LivepeerSegmentCount(ctx context.Context, obj *proto.ProcessingUsageSummary) (int, error) {
	panic(fmt.Errorf("not implemented: LivepeerSegmentCount - livepeerSegmentCount"))
}

// LivepeerUniqueStreams is the resolver for the livepeerUniqueStreams field.
func (r *processingUsageSummaryResolver) LivepeerUniqueStreams(ctx context.Context, obj *proto.ProcessingUsageSummary) (int, error) {
	panic(fmt.Errorf("not implemented: LivepeerUniqueStreams - livepeerUniqueStreams"))
}

// NativeAvSegmentCount is the resolver for the nativeAvSegmentCount field.
func (r *processingUsageSummaryResolver) NativeAvSegmentCount(ctx context.Context, obj *proto.ProcessingUsageSummary) (int, error) {
	panic(fmt.Errorf("not implemented: NativeAvSegmentCount - nativeAvSegmentCount"))
}

// NativeAvUniqueStreams is the resolver for the nativeAvUniqueStreams field.
func (r *processingUsageSummaryResolver) NativeAvUniqueStreams(ctx context.Context, obj *proto.ProcessingUsageSummary) (int, error) {
	panic(fmt.Errorf("not implemented: NativeAvUniqueStreams - nativeAvUniqueStreams"))
}

// Day is the resolver for the day field.
func (r *qualityTierDailyResolver) Day(ctx context.Context, obj *proto.QualityTierDaily) (*time.Time, error) {
	if obj.Day == nil {
		return nil, nil
	}
	t := obj.Day.AsTime()
	return &t, nil
}

// Tier1080pMinutes is the resolver for the tier1080pMinutes field.
func (r *qualityTierDailyResolver) Tier1080pMinutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.Tier_1080PMinutes), nil
}

// Tier720pMinutes is the resolver for the tier720pMinutes field.
func (r *qualityTierDailyResolver) Tier720pMinutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.Tier_720PMinutes), nil
}

// Tier480pMinutes is the resolver for the tier480pMinutes field.
func (r *qualityTierDailyResolver) Tier480pMinutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.Tier_480PMinutes), nil
}

// TierSdMinutes is the resolver for the tierSdMinutes field.
func (r *qualityTierDailyResolver) TierSdMinutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.TierSdMinutes), nil
}

// CodecH264Minutes is the resolver for the codecH264Minutes field.
func (r *qualityTierDailyResolver) CodecH264Minutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.CodecH264Minutes), nil
}

// CodecH265Minutes is the resolver for the codecH265Minutes field.
func (r *qualityTierDailyResolver) CodecH265Minutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.CodecH265Minutes), nil
}

// AvgBitrate is the resolver for the avgBitrate field.
func (r *qualityTierDailyResolver) AvgBitrate(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.AvgBitrate), nil
}

// AvgFps is the resolver for the avgFps field.
func (r *qualityTierDailyResolver) AvgFps(ctx context.Context, obj *proto.QualityTierDaily) (float64, error) {
	return float64(obj.AvgFps), nil
}

// StreamsConnection is the resolver for the streamsConnection field.
func (r *queryResolver) StreamsConnection(ctx context.Context, first *int, after *string, last *int, before *string) (*model.StreamsConnection, error) {
	return r.DoGetStreamsConnection(ctx, first, after, last, before)
}

// Stream is the resolver for the stream field.
func (r *queryResolver) Stream(ctx context.Context, id string) (*proto.Stream, error) {
	return r.DoGetStream(ctx, id)
}

// ValidateStreamKey is the resolver for the validateStreamKey field.
func (r *queryResolver) ValidateStreamKey(ctx context.Context, streamKey string) (*model.StreamValidation, error) {
	return r.DoValidateStreamKey(ctx, streamKey)
}

// PlatformOverview is the resolver for the platformOverview field.
func (r *queryResolver) PlatformOverview(ctx context.Context, timeRange *model.TimeRangeInput) (*proto.GetPlatformOverviewResponse, error) {
	return r.DoGetPlatformOverview(ctx, timeRange)
}

// ViewerGeographicsConnection is the resolver for the viewerGeographicsConnection field.
func (r *queryResolver) ViewerGeographicsConnection(ctx context.Context, stream *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string) (*model.ViewerGeographicsConnection, error) {
	return r.Resolver.DoGetViewerGeographicsConnection(ctx, stream, timeRange, first, after, last, before)
}

// GeographicDistribution is the resolver for the geographicDistribution field.
func (r *queryResolver) GeographicDistribution(ctx context.Context, stream *string, timeRange *model.TimeRangeInput, topN *int) (*model.GeographicDistribution, error) {
	return r.DoGetGeographicDistribution(ctx, stream, timeRange, topN)
}

// RoutingEventsConnection is the resolver for the routingEventsConnection field.
func (r *queryResolver) RoutingEventsConnection(ctx context.Context, stream *string, timeRange *model.TimeRangeInput, subjectTenantID *string, clusterID *string, first *int, after *string, last *int, before *string, noCache *bool) (*model.RoutingEventsConnection, error) {
	return r.Resolver.DoGetRoutingEventsConnection(ctx, stream, timeRange, subjectTenantID, clusterID, first, after, last, before, noCache)
}

// ConnectionEventsConnection is the resolver for the connectionEventsConnection field.
func (r *queryResolver) ConnectionEventsConnection(ctx context.Context, stream *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.ConnectionEventsConnection, error) {
	return r.Resolver.DoGetConnectionEventsConnection(ctx, stream, timeRange, first, after, last, before, noCache)
}

// ViewerSessionsConnection is the resolver for the viewerSessionsConnection field.
func (r *queryResolver) ViewerSessionsConnection(ctx context.Context, stream *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.ViewerSessionsConnection, error) {
	return r.Resolver.DoGetViewerSessionsConnection(ctx, stream, timeRange, first, after, last, before, noCache)
}

// ArtifactState is the resolver for the artifactState field.
func (r *queryResolver) ArtifactState(ctx context.Context, requestID string) (*proto.ArtifactState, error) {
	return r.Resolver.DoGetArtifactState(ctx, requestID)
}

// ArtifactStatesConnection is the resolver for the artifactStatesConnection field.
func (r *queryResolver) ArtifactStatesConnection(ctx context.Context, internalName *string, contentType *string, stage *string, first *int, after *string, last *int, before *string) (*model.ArtifactStatesConnection, error) {
	return r.Resolver.DoGetArtifactStatesConnection(ctx, internalName, contentType, stage, first, after, last, before)
}

// NodeMetricsConnection is the resolver for the nodeMetricsConnection field.
func (r *queryResolver) NodeMetricsConnection(ctx context.Context, nodeID *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.NodeMetricsConnection, error) {
	return r.Resolver.DoGetNodeMetricsConnection(ctx, nodeID, timeRange, first, after, last, before, noCache)
}

// NodeMetrics1hConnection is the resolver for the nodeMetrics1hConnection field.
func (r *queryResolver) NodeMetrics1hConnection(ctx context.Context, timeRange *model.TimeRangeInput, nodeID *string, first *int, after *string, last *int, before *string, noCache *bool) (*model.NodeMetrics1hConnection, error) {
	return r.Resolver.DoGetNodeMetrics1hConnection(ctx, timeRange, nodeID, first, after, last, before, noCache)
}

// StorageUsageConnection is the resolver for the storageUsageConnection field.
func (r *queryResolver) StorageUsageConnection(ctx context.Context, nodeID *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.StorageUsageConnection, error) {
	return r.Resolver.DoGetStorageUsageConnection(ctx, nodeID, timeRange, first, after, last, before, noCache)
}

// NodePerformance5mConnection is the resolver for the nodePerformance5mConnection field.
func (r *queryResolver) NodePerformance5mConnection(ctx context.Context, nodeID *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.NodePerformance5mConnection, error) {
	return r.Resolver.DoGetNodePerformance5mConnection(ctx, nodeID, timeRange, first, after, last, before, noCache)
}

// ViewerHoursHourlyConnection is the resolver for the viewerHoursHourlyConnection field.
func (r *queryResolver) ViewerHoursHourlyConnection(ctx context.Context, stream *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.ViewerHoursHourlyConnection, error) {
	return r.Resolver.DoGetViewerHoursHourlyConnection(ctx, stream, timeRange, first, after, last, before, noCache)
}

// ViewerGeoHourlyConnection is the resolver for the viewerGeoHourlyConnection field.
func (r *queryResolver) ViewerGeoHourlyConnection(ctx context.Context, stream *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.ViewerGeoHourlyConnection, error) {
	return r.Resolver.DoGetViewerGeoHourlyConnection(ctx, stream, timeRange, first, after, last, before, noCache)
}

// ProcessingUsageConnection is the resolver for the processingUsageConnection field.
func (r *queryResolver) ProcessingUsageConnection(ctx context.Context, streamName *string, processType *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.ProcessingUsageConnection, error) {
	return r.Resolver.DoGetProcessingUsageConnection(ctx, streamName, processType, timeRange, first, after, last, before, noCache)
}

// RebufferingEventsConnection is the resolver for the rebufferingEventsConnection field.
func (r *queryResolver) RebufferingEventsConnection(ctx context.Context, internalName *string, nodeID *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.RebufferingEventsConnection, error) {
	return r.Resolver.DoGetRebufferingEventsConnection(ctx, internalName, nodeID, timeRange, first, after, last, before, noCache)
}

// TenantAnalyticsDailyConnection is the resolver for the tenantAnalyticsDailyConnection field.
func (r *queryResolver) TenantAnalyticsDailyConnection(ctx context.Context, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.TenantAnalyticsDailyConnection, error) {
	return r.Resolver.DoGetTenantAnalyticsDailyConnection(ctx, timeRange, first, after, last, before, noCache)
}

// StreamAnalyticsDailyConnection is the resolver for the streamAnalyticsDailyConnection field.
func (r *queryResolver) StreamAnalyticsDailyConnection(ctx context.Context, internalName *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.StreamAnalyticsDailyConnection, error) {
	return r.Resolver.DoGetStreamAnalyticsDailyConnection(ctx, internalName, timeRange, first, after, last, before, noCache)
}

// ServiceInstancesConnection is the resolver for the serviceInstancesConnection field.
func (r *queryResolver) ServiceInstancesConnection(ctx context.Context, clusterID *string, nodeID *string, status *model.InstanceStatus, first *int, after *string, last *int, before *string) (*model.ServiceInstancesConnection, error) {
	return r.Resolver.DoGetServiceInstancesConnection(ctx, clusterID, nodeID, status, first, after, last, before)
}

// StreamKeysConnection is the resolver for the streamKeysConnection field.
func (r *queryResolver) StreamKeysConnection(ctx context.Context, streamID string, first *int, after *string, last *int, before *string) (*model.StreamKeysConnection, error) {
	return r.Resolver.DoGetStreamKeysConnection(ctx, streamID, first, after, last, before)
}

// ClipsConnection is the resolver for the clipsConnection field.
func (r *queryResolver) ClipsConnection(ctx context.Context, streamID *string, first *int, after *string, last *int, before *string) (*model.ClipsConnection, error) {
	return r.DoGetClipsConnection(ctx, streamID, first, after, last, before)
}

// Clip is the resolver for the clip field.
func (r *queryResolver) Clip(ctx context.Context, id string) (*proto.ClipInfo, error) {
	return r.DoGetClip(ctx, id)
}

// ClipViewingUrls is the resolver for the clipViewingUrls field.
func (r *queryResolver) ClipViewingUrls(ctx context.Context, clipID string) (*proto.ClipViewingURLs, error) {
	return r.DoGetClipViewingUrls(ctx, clipID)
}

// BillingTiers is the resolver for the billingTiers field.
func (r *queryResolver) BillingTiers(ctx context.Context) ([]*proto.BillingTier, error) {
	return r.DoGetBillingTiers(ctx)
}

// InvoicesConnection is the resolver for the invoicesConnection field.
func (r *queryResolver) InvoicesConnection(ctx context.Context, first *int, after *string, last *int, before *string) (*model.InvoicesConnection, error) {
	return r.Resolver.DoGetInvoicesConnection(ctx, first, after, last, before)
}

// Invoice is the resolver for the invoice field.
func (r *queryResolver) Invoice(ctx context.Context, id string) (*proto.Invoice, error) {
	return r.DoGetInvoice(ctx, id)
}

// BillingStatus is the resolver for the billingStatus field.
func (r *queryResolver) BillingStatus(ctx context.Context) (*proto.BillingStatusResponse, error) {
	return r.DoGetBillingStatus(ctx)
}

// TenantUsage is the resolver for the tenantUsage field.
func (r *queryResolver) TenantUsage(ctx context.Context, timeRange *model.TimeRangeInput) (*model.TenantUsage, error) {
	return r.DoGetTenantUsage(ctx, timeRange)
}

// UsageRecordsConnection is the resolver for the usageRecordsConnection field.
func (r *queryResolver) UsageRecordsConnection(ctx context.Context, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string) (*model.UsageRecordsConnection, error) {
	return r.Resolver.DoGetUsageRecordsConnection(ctx, timeRange, first, after, last, before)
}

// Tenant is the resolver for the tenant field.
func (r *queryResolver) Tenant(ctx context.Context) (*proto.Tenant, error) {
	return r.DoGetTenant(ctx)
}

// ClustersConnection is the resolver for the clustersConnection field.
func (r *queryResolver) ClustersConnection(ctx context.Context, first *int, after *string, last *int, before *string) (*model.ClustersConnection, error) {
	return r.Resolver.DoGetClustersConnection(ctx, first, after, last, before)
}

// Cluster is the resolver for the cluster field.
func (r *queryResolver) Cluster(ctx context.Context, id string) (*proto.InfrastructureCluster, error) {
	return r.DoGetCluster(ctx, id)
}

// NodesConnection is the resolver for the nodesConnection field.
func (r *queryResolver) NodesConnection(ctx context.Context, clusterID *string, status *model.NodeStatus, typeArg *string, first *int, after *string, last *int, before *string) (*model.NodesConnection, error) {
	return r.Resolver.DoGetNodesConnection(ctx, clusterID, status, typeArg, first, after, last, before)
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (*proto.InfrastructureNode, error) {
	return r.DoGetNode(ctx, id)
}

// DiscoverServicesConnection is the resolver for the discoverServicesConnection field.
func (r *queryResolver) DiscoverServicesConnection(ctx context.Context, typeArg string, clusterID *string, first *int, after *string, last *int, before *string) (*model.ServiceInstancesConnection, error) {
	return r.Resolver.DoGetDiscoverServicesConnection(ctx, typeArg, clusterID, first, after, last, before)
}

// ClustersAccess is the resolver for the clustersAccess field.
func (r *queryResolver) ClustersAccess(ctx context.Context, first *int, after *string) ([]*model.ClusterAccess, error) {
	return r.Resolver.DoGetClustersAccess(ctx, first, after)
}

// ClustersAccessConnection is the resolver for the clustersAccessConnection field.
func (r *queryResolver) ClustersAccessConnection(ctx context.Context, first *int, after *string, last *int, before *string) (*model.ClusterAccessConnection, error) {
	return r.Resolver.DoGetClustersAccessConnection(ctx, first, after, last, before)
}

// ClustersAvailable is the resolver for the clustersAvailable field.
func (r *queryResolver) ClustersAvailable(ctx context.Context, first *int, after *string) ([]*model.AvailableCluster, error) {
	return r.Resolver.DoGetClustersAvailable(ctx, first, after)
}

// ClustersAvailableConnection is the resolver for the clustersAvailableConnection field.
func (r *queryResolver) ClustersAvailableConnection(ctx context.Context, first *int, after *string, last *int, before *string) (*model.AvailableClusterConnection, error) {
	return r.Resolver.DoGetClustersAvailableConnection(ctx, first, after, last, before)
}

// MySubscriptions is the resolver for the mySubscriptions field.
func (r *queryResolver) MySubscriptions(ctx context.Context, first *int, after *string) ([]*proto.InfrastructureCluster, error) {
	return r.Resolver.DoListMySubscriptions(ctx, first, after)
}

// MySubscriptionsConnection is the resolver for the mySubscriptionsConnection field.
func (r *queryResolver) MySubscriptionsConnection(ctx context.Context, first *int, after *string, last *int, before *string) (*model.MySubscriptionsConnection, error) {
	return r.Resolver.DoGetMySubscriptionsConnection(ctx, first, after, last, before)
}

// ServiceInstancesHealth is the resolver for the serviceInstancesHealth field.
func (r *queryResolver) ServiceInstancesHealth(ctx context.Context, serviceID *string) ([]*proto.ServiceInstanceHealth, error) {
	var resp *proto.ListServicesHealthResponse
	var err error
	if serviceID != nil && *serviceID != "" {
		resp, err = r.Clients.Quartermaster.GetServiceHealth(ctx, *serviceID)
	} else {
		resp, err = r.Clients.Quartermaster.ListServicesHealth(ctx, nil)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get service health: %w", err)
	}
	return resp.Instances, nil
}

// MarketplaceClusters is the resolver for the marketplaceClusters field.
func (r *queryResolver) MarketplaceClusters(ctx context.Context, pricingModel *proto.ClusterPricingModel, first *int, after *string) ([]*proto.MarketplaceClusterEntry, error) {
	return r.DoListMarketplaceClusters(ctx, pricingModel, first, after)
}

// MarketplaceClustersConnection is the resolver for the marketplaceClustersConnection field.
func (r *queryResolver) MarketplaceClustersConnection(ctx context.Context, pricingModel *proto.ClusterPricingModel, first *int, after *string, last *int, before *string) (*model.MarketplaceClusterConnection, error) {
	return r.Resolver.DoGetMarketplaceClustersConnection(ctx, pricingModel, first, after, last, before)
}

// MarketplaceCluster is the resolver for the marketplaceCluster field.
func (r *queryResolver) MarketplaceCluster(ctx context.Context, clusterID string) (*proto.MarketplaceClusterEntry, error) {
	return r.DoGetMarketplaceCluster(ctx, clusterID, nil)
}

// PendingSubscriptions is the resolver for the pendingSubscriptions field.
func (r *queryResolver) PendingSubscriptions(ctx context.Context, clusterID string) ([]*proto.ClusterSubscription, error) {
	return r.DoListPendingSubscriptions(ctx, clusterID)
}

// PendingSubscriptionsConnection is the resolver for the pendingSubscriptionsConnection field.
func (r *queryResolver) PendingSubscriptionsConnection(ctx context.Context, clusterID string, first *int, after *string, last *int, before *string) (*model.ClusterSubscriptionConnection, error) {
	return r.Resolver.DoGetPendingSubscriptionsConnection(ctx, clusterID, first, after, last, before)
}

// ClusterInvites is the resolver for the clusterInvites field.
func (r *queryResolver) ClusterInvites(ctx context.Context, clusterID string) ([]*proto.ClusterInvite, error) {
	return r.DoListClusterInvites(ctx, clusterID)
}

// ClusterInvitesConnection is the resolver for the clusterInvitesConnection field.
func (r *queryResolver) ClusterInvitesConnection(ctx context.Context, clusterID string, first *int, after *string, last *int, before *string) (*model.ClusterInviteConnection, error) {
	return r.Resolver.DoGetClusterInvitesConnection(ctx, clusterID, first, after, last, before)
}

// MyClusterInvites is the resolver for the myClusterInvites field.
func (r *queryResolver) MyClusterInvites(ctx context.Context) ([]*proto.ClusterInvite, error) {
	return r.DoListMyClusterInvites(ctx)
}

// MyClusterInvitesConnection is the resolver for the myClusterInvitesConnection field.
func (r *queryResolver) MyClusterInvitesConnection(ctx context.Context, first *int, after *string, last *int, before *string) (*model.ClusterInviteConnection, error) {
	return r.Resolver.DoGetMyClusterInvitesConnection(ctx, first, after, last, before)
}

// DeveloperTokensConnection is the resolver for the developerTokensConnection field.
func (r *queryResolver) DeveloperTokensConnection(ctx context.Context, first *int, after *string, last *int, before *string) (*model.DeveloperTokensConnection, error) {
	return r.Resolver.DoGetDeveloperTokensConnection(ctx, first, after, last, before)
}

// BootstrapTokensConnection is the resolver for the bootstrapTokensConnection field.
func (r *queryResolver) BootstrapTokensConnection(ctx context.Context, kind *string, first *int, after *string, last *int, before *string) (*model.BootstrapTokenConnection, error) {
	return r.Resolver.DoGetBootstrapTokensConnection(ctx, kind, first, after, last, before)
}

// DvrRecordingsConnection is the resolver for the dvrRecordingsConnection field.
func (r *queryResolver) DvrRecordingsConnection(ctx context.Context, internalName *string, first *int, after *string, last *int, before *string) (*model.DVRRecordingsConnection, error) {
	return r.Resolver.DoGetDVRRecordingsConnection(ctx, internalName, first, after, last, before)
}

// VodAsset is the resolver for the vodAsset field.
func (r *queryResolver) VodAsset(ctx context.Context, id string) (*model.VodAsset, error) {
	return r.Resolver.DoGetVodAsset(ctx, id)
}

// VodAssetsConnection is the resolver for the vodAssetsConnection field.
func (r *queryResolver) VodAssetsConnection(ctx context.Context, first *int, after *string, last *int, before *string) (*model.VodAssetsConnection, error) {
	return r.Resolver.DoGetVodAssetsConnection(ctx, first, after, last, before)
}

// ResolveViewerEndpoint is the resolver for the resolveViewerEndpoint field.
// Returns proto.ViewerEndpointResponse directly via autobind.
func (r *queryResolver) ResolveViewerEndpoint(ctx context.Context, contentType string, contentID string) (*proto.ViewerEndpointResponse, error) {
	// Extract viewer IP from request context
	var viewerIP *string

	// Extract IP from GraphQL request context
	if ginCtx := ctx.Value("GinContext"); ginCtx != nil {
		if c, ok := ginCtx.(*gin.Context); ok {
			clientIP := c.ClientIP() // Gin's built-in method handles X-Forwarded-For, etc.
			viewerIP = &clientIP
		}
	}

	// Fallback: try to get from raw HTTP request
	if viewerIP == nil {
		if req := ctx.Value("http_request"); req != nil {
			if httpReq, ok := req.(*http.Request); ok && httpReq != nil {
				clientIP := httpReq.Header.Get("X-Forwarded-For")
				if clientIP == "" {
					clientIP = httpReq.Header.Get("X-Real-IP")
				}
				if clientIP == "" {
					clientIP = httpReq.RemoteAddr
				}
				// Extract IP from potential "ip:port" format
				if idx := strings.LastIndex(clientIP, ":"); idx != -1 {
					clientIP = clientIP[:idx]
				}
				// Use first IP if comma-separated list
				if strings.Contains(clientIP, ",") {
					clientIP = strings.TrimSpace(strings.Split(clientIP, ",")[0])
				}
				viewerIP = &clientIP
			}
		}
	}

	// If we still don't have an IP, this is an error
	if viewerIP == nil {
		return nil, fmt.Errorf("unable to determine viewer IP address for GeoIP routing")
	}

	// Call Commodore's viewer endpoint resolution (which then calls Foghorn)
	// proto.ViewerEndpointResponse is autobound to GraphQL ViewerEndpointResponse
	return r.Resolver.DoResolveViewerEndpoint(ctx, contentType, contentID, viewerIP)
}

// ResolveIngestEndpoint is the resolver for the resolveIngestEndpoint field.
func (r *queryResolver) ResolveIngestEndpoint(ctx context.Context, streamKey string) (*proto.IngestEndpointResponse, error) {
	// Extract client IP from request context for geo-routing
	var viewerIP *string

	if ginCtx := ctx.Value("GinContext"); ginCtx != nil {
		if c, ok := ginCtx.(*gin.Context); ok {
			clientIP := c.ClientIP()
			viewerIP = &clientIP
		}
	}

	// Fallback: try to get from raw HTTP request
	if viewerIP == nil {
		if req := ctx.Value("http_request"); req != nil {
			if httpReq, ok := req.(*http.Request); ok && httpReq != nil {
				clientIP := httpReq.Header.Get("X-Forwarded-For")
				if clientIP == "" {
					clientIP = httpReq.Header.Get("X-Real-IP")
				}
				if clientIP == "" {
					clientIP = httpReq.RemoteAddr
				}
				if idx := strings.LastIndex(clientIP, ":"); idx != -1 {
					clientIP = clientIP[:idx]
				}
				if strings.Contains(clientIP, ",") {
					clientIP = strings.TrimSpace(strings.Split(clientIP, ",")[0])
				}
				viewerIP = &clientIP
			}
		}
	}

	return r.Resolver.DoResolveIngestEndpoint(ctx, streamKey, viewerIP)
}

// StreamMeta is the resolver for the streamMeta field.
// Returns proto.StreamMetaResponse directly via autobind.
func (r *queryResolver) StreamMeta(ctx context.Context, streamKey string, targetBaseURL *string, targetNodeID *string, includeRaw *bool) (*proto.StreamMetaResponse, error) {
	return r.Resolver.DoGetStreamMeta(ctx, streamKey, targetBaseURL, targetNodeID, includeRaw)
}

// Timestamp is the resolver for the timestamp field.
func (r *rebufferingEventResolver) Timestamp(ctx context.Context, obj *proto.RebufferingEvent) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: Timestamp - timestamp"))
}

// Stream is the resolver for the stream field.
func (r *rebufferingEventResolver) Stream(ctx context.Context, obj *proto.RebufferingEvent) (string, error) {
	panic(fmt.Errorf("not implemented: Stream - stream"))
}

// BufferState is the resolver for the bufferState field.
func (r *rebufferingEventResolver) BufferState(ctx context.Context, obj *proto.RebufferingEvent) (model.BufferState, error) {
	panic(fmt.Errorf("not implemented: BufferState - bufferState"))
}

// PreviousState is the resolver for the previousState field.
func (r *rebufferingEventResolver) PreviousState(ctx context.Context, obj *proto.RebufferingEvent) (model.BufferState, error) {
	panic(fmt.Errorf("not implemented: PreviousState - previousState"))
}

// RebufferStart is the resolver for the rebufferStart field.
func (r *rebufferingEventResolver) RebufferStart(ctx context.Context, obj *proto.RebufferingEvent) (bool, error) {
	panic(fmt.Errorf("not implemented: RebufferStart - rebufferStart"))
}

// RebufferEnd is the resolver for the rebufferEnd field.
func (r *rebufferingEventResolver) RebufferEnd(ctx context.Context, obj *proto.RebufferingEvent) (bool, error) {
	panic(fmt.Errorf("not implemented: RebufferEnd - rebufferEnd"))
}

// Timestamp is the resolver for the timestamp field.
func (r *routingEventResolver) Timestamp(ctx context.Context, obj *proto.RoutingEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamName is the resolver for the streamName field.
func (r *routingEventResolver) StreamName(ctx context.Context, obj *proto.RoutingEvent) (string, error) {
	return obj.Stream, nil
}

// LatencyMs is the resolver for the latencyMs field.
func (r *routingEventResolver) LatencyMs(ctx context.Context, obj *proto.RoutingEvent) (*float64, error) {
	v := float64(obj.LatencyMs)
	return &v, nil
}

// Status is the resolver for the status field.
func (r *serviceInstanceResolver) Status(ctx context.Context, obj *proto.ServiceInstance) (model.InstanceStatus, error) {
	s := strings.ToLower(obj.Status)
	switch s {
	case "running", "active":
		return model.InstanceStatusRunning, nil
	case "starting", "booting":
		return model.InstanceStatusStarting, nil
	case "stopping", "terminating":
		return model.InstanceStatusStopping, nil
	case "stopped", "inactive":
		return model.InstanceStatusStopped, nil
	case "error", "failed", "crashed":
		return model.InstanceStatusError, nil
	default:
		return model.InstanceStatusUnknown, nil
	}
}

// HealthStatus is the resolver for the healthStatus field.
func (r *serviceInstanceResolver) HealthStatus(ctx context.Context, obj *proto.ServiceInstance) (model.NodeStatus, error) {
	hs := strings.ToLower(obj.HealthStatus)
	switch hs {
	case "healthy", "ok", "passing":
		return model.NodeStatusHealthy, nil
	case "degraded", "warning":
		return model.NodeStatusDegraded, nil
	case "unhealthy", "failing", "error":
		return model.NodeStatusUnhealthy, nil
	default:
		return model.NodeStatusUnhealthy, nil
	}
}

// StartedAt is the resolver for the startedAt field.
func (r *serviceInstanceResolver) StartedAt(ctx context.Context, obj *proto.ServiceInstance) (*time.Time, error) {
	if obj.StartedAt == nil {
		return nil, nil
	}
	t := obj.StartedAt.AsTime()
	return &t, nil
}

// StoppedAt is the resolver for the stoppedAt field.
func (r *serviceInstanceResolver) StoppedAt(ctx context.Context, obj *proto.ServiceInstance) (*time.Time, error) {
	if obj.StoppedAt == nil {
		return nil, nil
	}
	t := obj.StoppedAt.AsTime()
	return &t, nil
}

// LastHealthCheck is the resolver for the lastHealthCheck field.
func (r *serviceInstanceResolver) LastHealthCheck(ctx context.Context, obj *proto.ServiceInstance) (*time.Time, error) {
	if obj.LastHealthCheck == nil {
		return nil, nil
	}
	t := obj.LastHealthCheck.AsTime()
	return &t, nil
}

// LastHealthCheck is the resolver for the lastHealthCheck field.
func (r *serviceInstanceHealthResolver) LastHealthCheck(ctx context.Context, obj *proto.ServiceInstanceHealth) (*time.Time, error) {
	if obj.LastHealthCheck == nil {
		return nil, nil
	}
	t := obj.LastHealthCheck.AsTime()
	return &t, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *storageEventResolver) Timestamp(ctx context.Context, obj *proto.StorageEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *storageEventResolver) SizeBytes(ctx context.Context, obj *proto.StorageEvent) (float64, error) {
	return float64(obj.SizeBytes), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *storageUsageRecordResolver) Timestamp(ctx context.Context, obj *proto.StorageUsageRecord) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// TotalBytes is the resolver for the totalBytes field.
func (r *storageUsageRecordResolver) TotalBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.TotalBytes), nil
}

// FileCount is the resolver for the fileCount field.
func (r *storageUsageRecordResolver) FileCount(ctx context.Context, obj *proto.StorageUsageRecord) (int, error) {
	return int(obj.FileCount), nil
}

// DvrBytes is the resolver for the dvrBytes field.
func (r *storageUsageRecordResolver) DvrBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.DvrBytes), nil
}

// ClipBytes is the resolver for the clipBytes field.
func (r *storageUsageRecordResolver) ClipBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.ClipBytes), nil
}

// VodBytes is the resolver for the vodBytes field.
func (r *storageUsageRecordResolver) VodBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.VodBytes), nil
}

// FrozenDvrBytes is the resolver for the frozenDvrBytes field.
func (r *storageUsageRecordResolver) FrozenDvrBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.FrozenDvrBytes), nil
}

// FrozenClipBytes is the resolver for the frozenClipBytes field.
func (r *storageUsageRecordResolver) FrozenClipBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.FrozenClipBytes), nil
}

// FrozenVodBytes is the resolver for the frozenVodBytes field.
func (r *storageUsageRecordResolver) FrozenVodBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.FrozenVodBytes), nil
}

// ID is the resolver for the id field.
func (r *streamResolver) ID(ctx context.Context, obj *proto.Stream) (string, error) {
	return obj.InternalName, nil
}

// Name is the resolver for the name field.
func (r *streamResolver) Name(ctx context.Context, obj *proto.Stream) (string, error) {
	return obj.Title, nil
}

// Record is the resolver for the record field.
func (r *streamResolver) Record(ctx context.Context, obj *proto.Stream) (bool, error) {
	return obj.IsRecording, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *streamResolver) CreatedAt(ctx context.Context, obj *proto.Stream) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *streamResolver) UpdatedAt(ctx context.Context, obj *proto.Stream) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// Metrics is the resolver for the metrics field.
func (r *streamResolver) Metrics(ctx context.Context, obj *proto.Stream) (*proto.StreamStatusResponse, error) {
	// In demo mode, return metrics from the stream object itself (set by demo.GenerateStreams)
	if middleware.IsDemoMode(ctx) {
		resp := &proto.StreamStatusResponse{
			Status:          obj.Status,
			CurrentViewers:  int64(obj.CurrentViewers),
			PeakViewers:     int64(obj.PeakViewers),
			TotalViews:      int64(obj.TotalViews),
			DurationSeconds: int64(obj.Duration),
			StartedAt:       obj.StartedAt,
			EndedAt:         obj.EndedAt,
		}
		// Add quality metrics for live/recording streams
		if obj.Status == "live" || obj.Status == "recording" {
			bufferState := "FULL"
			qualityTier := "1080p30"
			primaryWidth := int32(1920)
			primaryHeight := int32(1080)
			primaryFps := float32(30.0)
			primaryCodec := "H264"
			primaryBitrate := int32(4500)
			hasIssues := false
			resp.BufferState = &bufferState
			resp.QualityTier = &qualityTier
			resp.PrimaryWidth = &primaryWidth
			resp.PrimaryHeight = &primaryHeight
			resp.PrimaryFps = &primaryFps
			resp.PrimaryCodec = &primaryCodec
			resp.PrimaryBitrate = &primaryBitrate
			resp.HasIssues = &hasIssues
			resp.LastEventType = "stream-buffer"
			resp.LastEventAt = obj.UpdatedAt
		} else if obj.Status == "ended" {
			// Ended streams have last event info
			resp.LastEventType = "stream-end"
			resp.LastEventAt = obj.EndedAt
		}
		return resp, nil
	}

	tenantID, _ := ctx.Value("tenant_id").(string)
	if tenantID == "" {
		return nil, nil
	}

	// Use loader for request-scoped caching
	loaders := loaders.FromContext(ctx)
	if loaders == nil || loaders.StreamMetrics == nil {
		// Fallback: direct call
		return r.Clients.Periscope.GetStreamStatus(ctx, tenantID, obj.InternalName)
	}

	return loaders.StreamMetrics.Load(ctx, tenantID, obj.InternalName)
}

// Analytics is the resolver for the analytics field.
func (r *streamResolver) Analytics(ctx context.Context, obj *proto.Stream, timeRange *model.TimeRangeInput) (*proto.StreamAnalytics, error) {
	return r.Resolver.DoGetStreamAnalytics(ctx, obj.InternalName, timeRange)
}

// ViewerTimeSeriesConnection is the resolver for the viewerTimeSeriesConnection field.
func (r *streamResolver) ViewerTimeSeriesConnection(ctx context.Context, obj *proto.Stream, timeRange *model.TimeRangeInput, interval *string, first *int, after *string, last *int, before *string) (*model.ViewerTimeSeriesConnection, error) {
	return r.Resolver.DoGetViewerTimeSeriesConnection(ctx, obj.InternalName, timeRange, interval, first, after, last, before)
}

// CurrentHealth is the resolver for the currentHealth field.
func (r *streamResolver) CurrentHealth(ctx context.Context, obj *proto.Stream) (*proto.StreamHealthMetric, error) {
	return r.Resolver.DoGetCurrentStreamHealth(ctx, obj.InternalName)
}

// HealthConnection is the resolver for the healthConnection field.
func (r *streamResolver) HealthConnection(ctx context.Context, obj *proto.Stream, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.StreamHealthMetricsConnection, error) {
	return r.Resolver.DoGetStreamHealthConnection(ctx, obj, timeRange, first, after)
}

// RebufferingEventsConnection is the resolver for the rebufferingEventsConnection field.
func (r *streamResolver) RebufferingEventsConnection(ctx context.Context, obj *proto.Stream, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string) (*model.RebufferingEventsConnection, error) {
	return r.Resolver.DoGetRebufferingEventsConnection(ctx, &obj.InternalName, nil, timeRange, first, after, last, before, nil)
}

// TrackListConnection is the resolver for the trackListConnection field.
func (r *streamResolver) TrackListConnection(ctx context.Context, obj *proto.Stream, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.TrackListEventsConnection, error) {
	return r.Resolver.DoGetTrackListEventsConnection(ctx, obj.InternalName, timeRange, first, after, last, before, noCache)
}

// ClientMetricsConnection is the resolver for the clientMetricsConnection field.
func (r *streamResolver) ClientMetricsConnection(ctx context.Context, obj *proto.Stream, timeRange *model.TimeRangeInput, nodeID *string, first *int, after *string, last *int, before *string, noCache *bool) (*model.ClientMetrics5mConnection, error) {
	return r.Resolver.DoGetClientMetrics5mConnection(ctx, &obj.InternalName, nodeID, timeRange, first, after, last, before, noCache)
}

// ConnectionHourlyConnection is the resolver for the connectionHourlyConnection field.
func (r *streamResolver) ConnectionHourlyConnection(ctx context.Context, obj *proto.Stream, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.StreamConnectionHourlyConnection, error) {
	return r.Resolver.DoGetStreamConnectionHourlyConnection(ctx, &obj.InternalName, timeRange, first, after, last, before, noCache)
}

// QualityDailyConnection is the resolver for the qualityDailyConnection field.
func (r *streamResolver) QualityDailyConnection(ctx context.Context, obj *proto.Stream, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.QualityTierDailyConnection, error) {
	return r.Resolver.DoGetQualityTierDailyConnection(ctx, &obj.InternalName, timeRange, first, after, last, before, noCache)
}

// ClipEventsConnection is the resolver for the clipEventsConnection field.
func (r *streamResolver) ClipEventsConnection(ctx context.Context, obj *proto.Stream, stage *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.ClipEventsConnection, error) {
	return r.Resolver.DoGetClipEventsConnection(ctx, &obj.InternalName, stage, timeRange, first, after, last, before, noCache)
}

// StorageEventsConnection is the resolver for the storageEventsConnection field.
func (r *streamResolver) StorageEventsConnection(ctx context.Context, obj *proto.Stream, assetType *string, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.StorageEventsConnection, error) {
	return r.Resolver.DoGetStorageEventsConnection(ctx, &obj.InternalName, assetType, timeRange, first, after, last, before, noCache)
}

// EventsConnection is the resolver for the eventsConnection field.
func (r *streamResolver) EventsConnection(ctx context.Context, obj *proto.Stream, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.StreamEventsConnection, error) {
	return r.Resolver.DoGetStreamEventsConnection(ctx, obj, timeRange, first, after)
}

// ViewerSessionsConnection is the resolver for the viewerSessionsConnection field.
func (r *streamResolver) ViewerSessionsConnection(ctx context.Context, obj *proto.Stream, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.ViewerSessionsConnection, error) {
	// Use stream's playbackId (internal_name) as the filter
	return r.Resolver.DoGetViewerSessionsConnection(ctx, &obj.PlaybackId, timeRange, first, after, last, before, noCache)
}

// Health5mConnection is the resolver for the health5mConnection field.
func (r *streamResolver) Health5mConnection(ctx context.Context, obj *proto.Stream, timeRange *model.TimeRangeInput, first *int, after *string, last *int, before *string, noCache *bool) (*model.StreamHealth5mConnection, error) {
	return r.Resolver.DoGetStreamHealth5mConnection(ctx, obj, timeRange, first, after, last, before, noCache)
}

// SessionStartTime is the resolver for the sessionStartTime field.
func (r *streamAnalyticsResolver) SessionStartTime(ctx context.Context, obj *proto.StreamAnalytics) (*time.Time, error) {
	if obj.SessionStartTime == nil {
		return nil, nil
	}
	t := obj.SessionStartTime.AsTime()
	return &t, nil
}

// SessionEndTime is the resolver for the sessionEndTime field.
func (r *streamAnalyticsResolver) SessionEndTime(ctx context.Context, obj *proto.StreamAnalytics) (*time.Time, error) {
	if obj.SessionEndTime == nil {
		return nil, nil
	}
	t := obj.SessionEndTime.AsTime()
	return &t, nil
}

// BandwidthIn is the resolver for the bandwidthIn field.
func (r *streamAnalyticsResolver) BandwidthIn(ctx context.Context, obj *proto.StreamAnalytics) (float64, error) {
	return float64(obj.BandwidthIn), nil
}

// BandwidthOut is the resolver for the bandwidthOut field.
func (r *streamAnalyticsResolver) BandwidthOut(ctx context.Context, obj *proto.StreamAnalytics) (float64, error) {
	return float64(obj.BandwidthOut), nil
}

// Upbytes is the resolver for the upbytes field.
func (r *streamAnalyticsResolver) Upbytes(ctx context.Context, obj *proto.StreamAnalytics) (float64, error) {
	return float64(obj.Upbytes), nil
}

// Downbytes is the resolver for the downbytes field.
func (r *streamAnalyticsResolver) Downbytes(ctx context.Context, obj *proto.StreamAnalytics) (float64, error) {
	return float64(obj.Downbytes), nil
}

// PacketsSent is the resolver for the packetsSent field.
func (r *streamAnalyticsResolver) PacketsSent(ctx context.Context, obj *proto.StreamAnalytics) (float64, error) {
	return float64(obj.PacketsSent), nil
}

// PacketsLost is the resolver for the packetsLost field.
func (r *streamAnalyticsResolver) PacketsLost(ctx context.Context, obj *proto.StreamAnalytics) (float64, error) {
	return float64(obj.PacketsLost), nil
}

// PacketsRetrans is the resolver for the packetsRetrans field.
func (r *streamAnalyticsResolver) PacketsRetrans(ctx context.Context, obj *proto.StreamAnalytics) (float64, error) {
	return float64(obj.PacketsRetrans), nil
}

// LastUpdated is the resolver for the lastUpdated field.
func (r *streamAnalyticsResolver) LastUpdated(ctx context.Context, obj *proto.StreamAnalytics) (*time.Time, error) {
	if obj.LastUpdated == nil {
		return nil, nil
	}
	t := obj.LastUpdated.AsTime()
	return &t, nil
}

// CurrentFps is the resolver for the currentFps field.
func (r *streamAnalyticsResolver) CurrentFps(ctx context.Context, obj *proto.StreamAnalytics) (*float64, error) {
	if obj.CurrentFps == nil {
		return nil, nil
	}
	v := float64(*obj.CurrentFps)
	return &v, nil
}

// AvgBufferHealth is the resolver for the avgBufferHealth field.
func (r *streamAnalyticsResolver) AvgBufferHealth(ctx context.Context, obj *proto.StreamAnalytics) (*float64, error) {
	value := float64(obj.AvgBufferHealth)
	return &value, nil
}

// PacketLossRate is the resolver for the packetLossRate field.
func (r *streamAnalyticsResolver) PacketLossRate(ctx context.Context, obj *proto.StreamAnalytics) (*float64, error) {
	value := float64(obj.PacketLossRate)
	return &value, nil
}

// Day is the resolver for the day field.
func (r *streamAnalyticsDailyResolver) Day(ctx context.Context, obj *proto.StreamAnalyticsDaily) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: Day - day"))
}

// MaxKeepawaMs is the resolver for the maxKeepawaMs field.
func (r *streamBufferEventResolver) MaxKeepawaMs(ctx context.Context, obj *proto.StreamBufferTrigger) (*int, error) {
	if obj.MaxKeepawayMs == nil {
		return nil, nil
	}
	v := int(*obj.MaxKeepawayMs)
	return &v, nil
}

// Hour is the resolver for the hour field.
func (r *streamConnectionHourlyResolver) Hour(ctx context.Context, obj *proto.StreamConnectionHourly) (*time.Time, error) {
	if obj.Hour == nil {
		return nil, nil
	}
	t := obj.Hour.AsTime()
	return &t, nil
}

// TotalBytes is the resolver for the totalBytes field.
func (r *streamConnectionHourlyResolver) TotalBytes(ctx context.Context, obj *proto.StreamConnectionHourly) (float64, error) {
	return float64(obj.TotalBytes), nil
}

// UniqueViewers is the resolver for the uniqueViewers field.
func (r *streamConnectionHourlyResolver) UniqueViewers(ctx context.Context, obj *proto.StreamConnectionHourly) (int, error) {
	return int(obj.UniqueViewers), nil
}

// TotalSessions is the resolver for the totalSessions field.
func (r *streamConnectionHourlyResolver) TotalSessions(ctx context.Context, obj *proto.StreamConnectionHourly) (int, error) {
	return int(obj.TotalSessions), nil
}

// DownloadedBytes is the resolver for the downloadedBytes field.
func (r *streamEndEventResolver) DownloadedBytes(ctx context.Context, obj *proto.StreamEndTrigger) (*float64, error) {
	if obj.DownloadedBytes == nil {
		return nil, nil
	}
	v := float64(*obj.DownloadedBytes)
	return &v, nil
}

// UploadedBytes is the resolver for the uploadedBytes field.
func (r *streamEndEventResolver) UploadedBytes(ctx context.Context, obj *proto.StreamEndTrigger) (*float64, error) {
	if obj.UploadedBytes == nil {
		return nil, nil
	}
	v := float64(*obj.UploadedBytes)
	return &v, nil
}

// TotalViewers is the resolver for the totalViewers field.
func (r *streamEndEventResolver) TotalViewers(ctx context.Context, obj *proto.StreamEndTrigger) (*float64, error) {
	if obj.TotalViewers == nil {
		return nil, nil
	}
	v := float64(*obj.TotalViewers)
	return &v, nil
}

// TotalInputs is the resolver for the totalInputs field.
func (r *streamEndEventResolver) TotalInputs(ctx context.Context, obj *proto.StreamEndTrigger) (*float64, error) {
	if obj.TotalInputs == nil {
		return nil, nil
	}
	v := float64(*obj.TotalInputs)
	return &v, nil
}

// TotalOutputs is the resolver for the totalOutputs field.
func (r *streamEndEventResolver) TotalOutputs(ctx context.Context, obj *proto.StreamEndTrigger) (*float64, error) {
	if obj.TotalOutputs == nil {
		return nil, nil
	}
	v := float64(*obj.TotalOutputs)
	return &v, nil
}

// ViewerSeconds is the resolver for the viewerSeconds field.
func (r *streamEndEventResolver) ViewerSeconds(ctx context.Context, obj *proto.StreamEndTrigger) (*float64, error) {
	if obj.ViewerSeconds == nil {
		return nil, nil
	}
	v := float64(*obj.ViewerSeconds)
	return &v, nil
}

// Type is the resolver for the type field.
func (r *streamEventResolver) Type(ctx context.Context, obj *proto.StreamEvent) (model.StreamEventType, error) {
	switch obj.EventType {
	case "STREAM_START":
		return model.StreamEventTypeStreamStart, nil
	case "STREAM_END":
		return model.StreamEventTypeStreamEnd, nil
	case "STREAM_ERROR":
		return model.StreamEventTypeStreamError, nil
	case "BUFFER_UPDATE":
		return model.StreamEventTypeBufferUpdate, nil
	case "TRACK_LIST_UPDATE":
		return model.StreamEventTypeTrackListUpdate, nil
	default:
		return model.StreamEventTypeStreamStart, fmt.Errorf("unknown stream event type: %s", obj.EventType)
	}
}

// Stream is the resolver for the stream field.
func (r *streamEventResolver) Stream(ctx context.Context, obj *proto.StreamEvent) (string, error) {
	return obj.InternalName, nil
}

// Status is the resolver for the status field.
func (r *streamEventResolver) Status(ctx context.Context, obj *proto.StreamEvent) (model.StreamStatus, error) {
	switch obj.Status {
	case "LIVE":
		return model.StreamStatusLive, nil
	case "RECORDING":
		return model.StreamStatusRecording, nil
	case "ENDED":
		return model.StreamStatusEnded, nil
	case "OFFLINE":
		return model.StreamStatusOffline, nil
	default:
		return model.StreamStatusOffline, fmt.Errorf("unknown stream status: %s", obj.Status)
	}
}

// Timestamp is the resolver for the timestamp field.
func (r *streamEventResolver) Timestamp(ctx context.Context, obj *proto.StreamEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// Details is the resolver for the details field.
func (r *streamEventResolver) Details(ctx context.Context, obj *proto.StreamEvent) (*string, error) {
	if obj.EventData == "" {
		return nil, nil
	}
	return &obj.EventData, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *streamHealth5mResolver) Timestamp(ctx context.Context, obj *proto.StreamHealth5M) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// AvgFps is the resolver for the avgFps field.
func (r *streamHealth5mResolver) AvgFps(ctx context.Context, obj *proto.StreamHealth5M) (float64, error) {
	return float64(obj.AvgFps), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *streamHealthMetricResolver) Timestamp(ctx context.Context, obj *proto.StreamHealthMetric) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// Stream is the resolver for the stream field.
func (r *streamHealthMetricResolver) Stream(ctx context.Context, obj *proto.StreamHealthMetric) (string, error) {
	return obj.InternalName, nil
}

// Fps is the resolver for the fps field.
func (r *streamHealthMetricResolver) Fps(ctx context.Context, obj *proto.StreamHealthMetric) (*float64, error) {
	if obj.Fps == 0 {
		return nil, nil
	}
	v := float64(obj.Fps)
	return &v, nil
}

// BufferState is the resolver for the bufferState field.
func (r *streamHealthMetricResolver) BufferState(ctx context.Context, obj *proto.StreamHealthMetric) (model.BufferState, error) {
	s := strings.ToUpper(obj.BufferState)
	switch s {
	case "FULL":
		return model.BufferStateFull, nil
	case "EMPTY":
		return model.BufferStateEmpty, nil
	case "DRY":
		return model.BufferStateDry, nil
	case "RECOVER":
		return model.BufferStateRecover, nil
	default:
		return model.BufferStateRecover, nil
	}
}

// BufferHealth is the resolver for the bufferHealth field.
func (r *streamHealthMetricResolver) BufferHealth(ctx context.Context, obj *proto.StreamHealthMetric) (*float64, error) {
	v := float64(obj.BufferHealth)
	return &v, nil
}

// AudioChannels is the resolver for the audioChannels field.
func (r *streamHealthMetricResolver) AudioChannels(ctx context.Context, obj *proto.StreamHealthMetric) (*int, error) {
	if obj.PrimaryAudioChannels == nil {
		return nil, nil
	}
	v := int(*obj.PrimaryAudioChannels)
	return &v, nil
}

// AudioSampleRate is the resolver for the audioSampleRate field.
func (r *streamHealthMetricResolver) AudioSampleRate(ctx context.Context, obj *proto.StreamHealthMetric) (*int, error) {
	if obj.PrimaryAudioSampleRate == nil {
		return nil, nil
	}
	v := int(*obj.PrimaryAudioSampleRate)
	return &v, nil
}

// AudioCodec is the resolver for the audioCodec field.
func (r *streamHealthMetricResolver) AudioCodec(ctx context.Context, obj *proto.StreamHealthMetric) (*string, error) {
	if obj.PrimaryAudioCodec != nil {
		return obj.PrimaryAudioCodec, nil
	}
	// Fallback to generic codec field if no audio-specific codec
	if obj.Codec == "" {
		return nil, nil
	}
	return &obj.Codec, nil
}

// AudioBitrate is the resolver for the audioBitrate field.
func (r *streamHealthMetricResolver) AudioBitrate(ctx context.Context, obj *proto.StreamHealthMetric) (*int, error) {
	if obj.PrimaryAudioBitrate == nil {
		return nil, nil
	}
	v := int(*obj.PrimaryAudioBitrate)
	return &v, nil
}

// LastUsedAt is the resolver for the lastUsedAt field.
func (r *streamKeyResolver) LastUsedAt(ctx context.Context, obj *proto.StreamKey) (*time.Time, error) {
	if obj.LastUsedAt == nil {
		return nil, nil
	}
	t := obj.LastUsedAt.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *streamKeyResolver) CreatedAt(ctx context.Context, obj *proto.StreamKey) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UploadedBytes is the resolver for the uploadedBytes field.
func (r *streamLifecycleUpdateResolver) UploadedBytes(ctx context.Context, obj *proto.StreamLifecycleUpdate) (*float64, error) {
	if obj.UploadedBytes == nil {
		return nil, nil
	}
	v := float64(*obj.UploadedBytes)
	return &v, nil
}

// DownloadedBytes is the resolver for the downloadedBytes field.
func (r *streamLifecycleUpdateResolver) DownloadedBytes(ctx context.Context, obj *proto.StreamLifecycleUpdate) (*float64, error) {
	if obj.DownloadedBytes == nil {
		return nil, nil
	}
	v := float64(*obj.DownloadedBytes)
	return &v, nil
}

// TotalViewers is the resolver for the totalViewers field.
func (r *streamLifecycleUpdateResolver) TotalViewers(ctx context.Context, obj *proto.StreamLifecycleUpdate) (*int, error) {
	if obj.TotalViewers == nil {
		return nil, nil
	}
	v := int(*obj.TotalViewers)
	return &v, nil
}

// TotalInputs is the resolver for the totalInputs field.
func (r *streamLifecycleUpdateResolver) TotalInputs(ctx context.Context, obj *proto.StreamLifecycleUpdate) (*int, error) {
	if obj.TotalInputs == nil {
		return nil, nil
	}
	v := int(*obj.TotalInputs)
	return &v, nil
}

// ViewerSeconds is the resolver for the viewerSeconds field.
func (r *streamLifecycleUpdateResolver) ViewerSeconds(ctx context.Context, obj *proto.StreamLifecycleUpdate) (*float64, error) {
	if obj.ViewerSeconds == nil {
		return nil, nil
	}
	v := float64(*obj.ViewerSeconds)
	return &v, nil
}

// Raw is the resolver for the raw field.
func (r *streamMetaResponseResolver) Raw(ctx context.Context, obj *proto.StreamMetaResponse) (*string, error) {
	if len(obj.Raw) == 0 {
		return nil, nil
	}
	s := string(obj.Raw)
	return &s, nil
}

// Status is the resolver for the status field.
func (r *streamMetricsResolver) Status(ctx context.Context, obj *proto.StreamStatusResponse) (model.StreamStatus, error) {
	switch obj.Status {
	case "live":
		return model.StreamStatusLive, nil
	case "offline":
		return model.StreamStatusOffline, nil
	case "recording":
		return model.StreamStatusRecording, nil
	case "ended":
		return model.StreamStatusEnded, nil
	default:
		return model.StreamStatusOffline, nil
	}
}

// IsLive is the resolver for the isLive field.
func (r *streamMetricsResolver) IsLive(ctx context.Context, obj *proto.StreamStatusResponse) (bool, error) {
	return obj.Status == "live", nil
}

// StartedAt is the resolver for the startedAt field.
func (r *streamMetricsResolver) StartedAt(ctx context.Context, obj *proto.StreamStatusResponse) (*time.Time, error) {
	if obj.StartedAt == nil {
		return nil, nil
	}
	t := obj.StartedAt.AsTime()
	return &t, nil
}

// EndedAt is the resolver for the endedAt field.
func (r *streamMetricsResolver) EndedAt(ctx context.Context, obj *proto.StreamStatusResponse) (*time.Time, error) {
	if obj.EndedAt == nil {
		return nil, nil
	}
	t := obj.EndedAt.AsTime()
	return &t, nil
}

// Duration is the resolver for the duration field.
func (r *streamMetricsResolver) Duration(ctx context.Context, obj *proto.StreamStatusResponse) (int, error) {
	return int(obj.DurationSeconds), nil
}

// LastEventAt is the resolver for the lastEventAt field.
func (r *streamMetricsResolver) LastEventAt(ctx context.Context, obj *proto.StreamStatusResponse) (*time.Time, error) {
	if obj.LastEventAt == nil {
		return nil, nil
	}
	t := obj.LastEventAt.AsTime()
	return &t, nil
}

// PrimaryFps is the resolver for the primaryFps field.
func (r *streamMetricsResolver) PrimaryFps(ctx context.Context, obj *proto.StreamStatusResponse) (*float64, error) {
	if obj.PrimaryFps == nil {
		return nil, nil
	}
	v := float64(*obj.PrimaryFps)
	return &v, nil
}

// StreamEvents is the resolver for the streamEvents field.
func (r *subscriptionResolver) StreamEvents(ctx context.Context, stream *string) (<-chan *model.StreamSubscriptionEvent, error) {
	return r.Resolver.DoStreamUpdates(ctx, stream)
}

// ViewerMetrics is the resolver for the viewerMetrics field.
func (r *subscriptionResolver) ViewerMetrics(ctx context.Context, stream string) (<-chan *proto.ClientLifecycleUpdate, error) {
	return r.Resolver.DoAnalyticsUpdates(ctx, stream)
}

// TrackListUpdates is the resolver for the trackListUpdates field.
func (r *subscriptionResolver) TrackListUpdates(ctx context.Context, stream string) (<-chan *proto.StreamTrackListTrigger, error) {
	return r.Resolver.DoTrackListUpdates(ctx, stream)
}

// ClipLifecycle is the resolver for the clipLifecycle field.
func (r *subscriptionResolver) ClipLifecycle(ctx context.Context, stream string) (<-chan *proto.ClipLifecycleData, error) {
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required for subscriptions: %w", err)
	}
	jwtToken := ""
	if token := ctx.Value("jwt_token"); token != nil {
		if s, ok := token.(string); ok {
			jwtToken = s
		}
	}
	cfg := resolvers.ConnectionConfig{UserID: user.UserID, TenantID: user.TenantID, JWT: jwtToken}
	return r.Resolver.SubManager.SubscribeToLifecycle(ctx, cfg, stream)
}

// DvrLifecycle is the resolver for the dvrLifecycle field.
func (r *subscriptionResolver) DvrLifecycle(ctx context.Context, stream string) (<-chan *proto.DVRLifecycleData, error) {
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required for subscriptions: %w", err)
	}
	jwtToken := ""
	if token := ctx.Value("jwt_token"); token != nil {
		if s, ok := token.(string); ok {
			jwtToken = s
		}
	}
	cfg := resolvers.ConnectionConfig{UserID: user.UserID, TenantID: user.TenantID, JWT: jwtToken}
	return r.Resolver.SubManager.SubscribeToDVRLifecycle(ctx, cfg, stream)
}

// VodLifecycle is the resolver for the vodLifecycle field.
func (r *subscriptionResolver) VodLifecycle(ctx context.Context) (<-chan *proto.VodLifecycleData, error) {
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required for subscriptions: %w", err)
	}
	jwtToken := ""
	if token := ctx.Value("jwt_token"); token != nil {
		if s, ok := token.(string); ok {
			jwtToken = s
		}
	}
	cfg := resolvers.ConnectionConfig{UserID: user.UserID, TenantID: user.TenantID, JWT: jwtToken}
	return r.Resolver.SubManager.SubscribeToVodLifecycle(ctx, cfg)
}

// SystemHealth is the resolver for the systemHealth field.
func (r *subscriptionResolver) SystemHealth(ctx context.Context) (<-chan *proto.NodeLifecycleUpdate, error) {
	return r.Resolver.DoSystemUpdates(ctx)
}

// Firehose is the resolver for the firehose field.
func (r *subscriptionResolver) Firehose(ctx context.Context) (<-chan *model.TenantEvent, error) {
	if r.Resolver.Metrics != nil {
		r.Resolver.Metrics.Operations.WithLabelValues("subscription_firehose", "requested").Inc()
	}

	// Demo mode returns mock events
	if middleware.IsDemoMode(ctx) {
		r.Resolver.Logger.Debug("Returning demo firehose subscription")
		if r.Resolver.Metrics != nil {
			r.Resolver.Metrics.Operations.WithLabelValues("subscription_firehose", "demo").Inc()
		}
		ch := make(chan *model.TenantEvent, 10)
		go func() {
			defer close(ch)
			// Send demo events periodically
			ticker := time.NewTicker(2 * time.Second)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					// Send a random demo event
					ch <- &model.TenantEvent{
						Type:      "demo_event",
						Channel:   "STREAMS",
						Timestamp: time.Now(),
					}
				}
			}
		}()
		return ch, nil
	}

	r.Resolver.Logger.Info("Setting up firehose subscription")
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		if r.Resolver.Metrics != nil {
			r.Resolver.Metrics.Operations.WithLabelValues("subscription_firehose", "auth_error").Inc()
		}
		return nil, fmt.Errorf("authentication required for firehose subscription: %w", err)
	}

	jwtToken := ""
	if token := ctx.Value("jwt_token"); token != nil {
		if tokenStr, ok := token.(string); ok {
			jwtToken = tokenStr
		}
	}

	config := resolvers.ConnectionConfig{UserID: user.UserID, TenantID: user.TenantID, JWT: jwtToken}
	ch, err := r.Resolver.SubManager.SubscribeToFirehose(ctx, config)
	if err != nil {
		if r.Resolver.Metrics != nil {
			r.Resolver.Metrics.Operations.WithLabelValues("subscription_firehose", "error").Inc()
		}
		r.Resolver.Logger.WithError(err).WithFields(logging.Fields{
			"user_id":   user.UserID,
			"tenant_id": user.TenantID,
		}).Error("Failed to setup firehose subscription")
		return nil, fmt.Errorf("failed to setup firehose subscription: %w", err)
	}

	r.Resolver.Logger.WithFields(logging.Fields{
		"user_id":   user.UserID,
		"tenant_id": user.TenantID,
	}).Info("Successfully setup firehose subscription")

	if r.Resolver.Metrics != nil {
		r.Resolver.Metrics.Operations.WithLabelValues("subscription_firehose", "success").Inc()
	}
	return ch, nil
}

// NodeID is the resolver for the nodeId field.
// Returns the database UUID (node_uuid) for reliable frontend lookups, not the logical name (node_id).
func (r *systemHealthEventResolver) NodeID(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*string, error) {
	// NodeUuid is enriched by Foghorn from Quartermaster lookup
	return obj.NodeUuid, nil
}

// Node is the resolver for the node field.
func (r *systemHealthEventResolver) Node(ctx context.Context, obj *proto.NodeLifecycleUpdate) (string, error) {
	return obj.NodeId, nil
}

// Status is the resolver for the status field.
func (r *systemHealthEventResolver) Status(ctx context.Context, obj *proto.NodeLifecycleUpdate) (model.NodeStatus, error) {
	if obj.IsHealthy {
		return model.NodeStatusHealthy, nil
	}
	return model.NodeStatusUnhealthy, nil
}

// CPUTenths is the resolver for the cpuTenths field.
func (r *systemHealthEventResolver) CPUTenths(ctx context.Context, obj *proto.NodeLifecycleUpdate) (int, error) {
	return int(obj.CpuTenths), nil
}

// RAMMax is the resolver for the ramMax field.
func (r *systemHealthEventResolver) RAMMax(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*float64, error) {
	v := float64(obj.RamMax)
	return &v, nil
}

// RAMCurrent is the resolver for the ramCurrent field.
func (r *systemHealthEventResolver) RAMCurrent(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*float64, error) {
	v := float64(obj.RamCurrent)
	return &v, nil
}

// DiskTotalBytes is the resolver for the diskTotalBytes field.
func (r *systemHealthEventResolver) DiskTotalBytes(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*float64, error) {
	v := float64(obj.DiskTotalBytes)
	return &v, nil
}

// DiskUsedBytes is the resolver for the diskUsedBytes field.
func (r *systemHealthEventResolver) DiskUsedBytes(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*float64, error) {
	v := float64(obj.DiskUsedBytes)
	return &v, nil
}

// ShmTotalBytes is the resolver for the shmTotalBytes field.
func (r *systemHealthEventResolver) ShmTotalBytes(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*float64, error) {
	v := float64(obj.ShmTotalBytes)
	return &v, nil
}

// ShmUsedBytes is the resolver for the shmUsedBytes field.
func (r *systemHealthEventResolver) ShmUsedBytes(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*float64, error) {
	v := float64(obj.ShmUsedBytes)
	return &v, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *systemHealthEventResolver) Timestamp(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*time.Time, error) {
	if obj.Timestamp == 0 {
		return nil, nil
	}
	t := time.Unix(obj.Timestamp, 0)
	return &t, nil
}

// Cluster is the resolver for the cluster field.
func (r *tenantResolver) Cluster(ctx context.Context, obj *proto.Tenant) (*string, error) {
	return obj.PrimaryClusterId, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *tenantResolver) CreatedAt(ctx context.Context, obj *proto.Tenant) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// Day is the resolver for the day field.
func (r *tenantAnalyticsDailyResolver) Day(ctx context.Context, obj *proto.TenantAnalyticsDaily) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: Day - day"))
}

// Date is the resolver for the date field.
func (r *tenantDailyStatResolver) Date(ctx context.Context, obj *proto.TenantDailyStat) (*time.Time, error) {
	if obj.Date == nil {
		return nil, nil
	}
	t := obj.Date.AsTime()
	return &t, nil
}

// StartedAt is the resolver for the startedAt field.
func (r *tenantSubscriptionResolver) StartedAt(ctx context.Context, obj *proto.TenantSubscription) (*time.Time, error) {
	if obj.StartedAt == nil || !obj.StartedAt.IsValid() {
		return nil, nil
	}
	t := obj.StartedAt.AsTime()
	return &t, nil
}

// TrialEndsAt is the resolver for the trialEndsAt field.
func (r *tenantSubscriptionResolver) TrialEndsAt(ctx context.Context, obj *proto.TenantSubscription) (*time.Time, error) {
	if obj.TrialEndsAt == nil || !obj.TrialEndsAt.IsValid() {
		return nil, nil
	}
	t := obj.TrialEndsAt.AsTime()
	return &t, nil
}

// NextBillingDate is the resolver for the nextBillingDate field.
func (r *tenantSubscriptionResolver) NextBillingDate(ctx context.Context, obj *proto.TenantSubscription) (*time.Time, error) {
	if obj.NextBillingDate == nil || !obj.NextBillingDate.IsValid() {
		return nil, nil
	}
	t := obj.NextBillingDate.AsTime()
	return &t, nil
}

// CancelledAt is the resolver for the cancelledAt field.
func (r *tenantSubscriptionResolver) CancelledAt(ctx context.Context, obj *proto.TenantSubscription) (*time.Time, error) {
	if obj.CancelledAt == nil || !obj.CancelledAt.IsValid() {
		return nil, nil
	}
	t := obj.CancelledAt.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *tenantSubscriptionResolver) CreatedAt(ctx context.Context, obj *proto.TenantSubscription) (*time.Time, error) {
	if obj.CreatedAt == nil || !obj.CreatedAt.IsValid() {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *tenantSubscriptionResolver) UpdatedAt(ctx context.Context, obj *proto.TenantSubscription) (*time.Time, error) {
	if obj.UpdatedAt == nil || !obj.UpdatedAt.IsValid() {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// Start is the resolver for the start field.
func (r *timeRangeResolver) Start(ctx context.Context, obj *proto.TimeRange) (*time.Time, error) {
	if obj.Start == nil {
		return nil, nil
	}
	t := obj.Start.AsTime()
	return &t, nil
}

// End is the resolver for the end field.
func (r *timeRangeResolver) End(ctx context.Context, obj *proto.TimeRange) (*time.Time, error) {
	if obj.End == nil {
		return nil, nil
	}
	t := obj.End.AsTime()
	return &t, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *trackListEventResolver) Timestamp(ctx context.Context, obj *proto.TrackListEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *usageRecordResolver) CreatedAt(ctx context.Context, obj *proto.UsageRecord) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *usageSummaryResolver) Timestamp(ctx context.Context, obj *proto.UsageSummary) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// Name is the resolver for the name field.
func (r *userResolver) Name(ctx context.Context, obj *proto.User) (*string, error) {
	if obj.FirstName != "" || obj.LastName != "" {
		fullName := obj.FirstName + " " + obj.LastName
		fullName = strings.TrimSpace(fullName)
		return &fullName, nil
	}
	return nil, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *userResolver) CreatedAt(ctx context.Context, obj *proto.User) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *viewerCountBucketResolver) Timestamp(ctx context.Context, obj *proto.ViewerCountBucket) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// Stream is the resolver for the stream field.
func (r *viewerCountBucketResolver) Stream(ctx context.Context, obj *proto.ViewerCountBucket) (*string, error) {
	if obj.InternalName == "" {
		return nil, nil
	}
	return &obj.InternalName, nil
}

// Outputs is the resolver for the outputs field.
func (r *viewerEndpointResolver) Outputs(ctx context.Context, obj *proto.ViewerEndpoint) (*string, error) {
	if obj.Outputs == nil || len(obj.Outputs) == 0 {
		return nil, nil
	}
	b, err := json.Marshal(obj.Outputs)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal outputs: %w", err)
	}
	s := string(b)
	return &s, nil
}

// Hour is the resolver for the hour field.
func (r *viewerGeoHourlyResolver) Hour(ctx context.Context, obj *proto.ViewerGeoHourly) (*time.Time, error) {
	if obj.Hour == nil {
		return nil, nil
	}
	t := obj.Hour.AsTime()
	return &t, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *viewerGeographicResolver) Timestamp(ctx context.Context, obj *proto.ConnectionEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// Stream is the resolver for the stream field.
func (r *viewerGeographicResolver) Stream(ctx context.Context, obj *proto.ConnectionEvent) (*string, error) {
	s := obj.InternalName
	return &s, nil
}

// ViewerCount is the resolver for the viewerCount field.
func (r *viewerGeographicResolver) ViewerCount(ctx context.Context, obj *proto.ConnectionEvent) (*int, error) {
	v := 0
	if obj.EventType == "connect" {
		v = 1
	}
	return &v, nil
}

// ConnectionAddr is the resolver for the connectionAddr field.
func (r *viewerGeographicResolver) ConnectionAddr(ctx context.Context, obj *proto.ConnectionEvent) (*string, error) {
	// Redacted for privacy - client IPs are not exposed via API
	return nil, nil
}

// Source is the resolver for the source field.
func (r *viewerGeographicResolver) Source(ctx context.Context, obj *proto.ConnectionEvent) (*string, error) {
	if obj.Connector != "" {
		v := obj.Connector
		return &v, nil
	}
	return nil, nil
}

// SessionDurationSeconds is the resolver for the sessionDurationSeconds field.
func (r *viewerGeographicResolver) SessionDurationSeconds(ctx context.Context, obj *proto.ConnectionEvent) (*int, error) {
	if obj.SessionDurationSeconds == 0 {
		return nil, nil
	}
	v := int(obj.SessionDurationSeconds)
	return &v, nil
}

// BytesTransferred is the resolver for the bytesTransferred field.
func (r *viewerGeographicResolver) BytesTransferred(ctx context.Context, obj *proto.ConnectionEvent) (*int, error) {
	if obj.BytesTransferred == 0 {
		return nil, nil
	}
	v := int(obj.BytesTransferred)
	return &v, nil
}

// Hour is the resolver for the hour field.
func (r *viewerHoursHourlyResolver) Hour(ctx context.Context, obj *proto.ViewerHoursHourly) (*time.Time, error) {
	if obj.Hour == nil {
		return nil, nil
	}
	t := obj.Hour.AsTime()
	return &t, nil
}

// TotalBytes is the resolver for the totalBytes field.
func (r *viewerHoursHourlyResolver) TotalBytes(ctx context.Context, obj *proto.ViewerHoursHourly) (float64, error) {
	return float64(obj.TotalBytes), nil
}

// ViewerHours is the resolver for the viewerHours field.
func (r *viewerHoursHourlyResolver) ViewerHours(ctx context.Context, obj *proto.ViewerHoursHourly) (float64, error) {
	// Computed: totalSessionSeconds / 3600
	return float64(obj.TotalSessionSeconds) / 3600.0, nil
}

// EgressGb is the resolver for the egressGb field.
func (r *viewerHoursHourlyResolver) EgressGb(ctx context.Context, obj *proto.ViewerHoursHourly) (float64, error) {
	// Computed: totalBytes / 1e9
	return float64(obj.TotalBytes) / 1e9, nil
}

// Host is the resolver for the host field.
func (r *viewerMetricsResolver) Host(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*string, error) {
	// Redacted for privacy - client IPs are not exposed via API
	return nil, nil
}

// ConnectionTime is the resolver for the connectionTime field.
func (r *viewerMetricsResolver) ConnectionTime(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*float64, error) {
	if obj.ConnectionTime == nil {
		return nil, nil
	}
	v := float64(*obj.ConnectionTime)
	return &v, nil
}

// Position is the resolver for the position field.
func (r *viewerMetricsResolver) Position(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*float64, error) {
	if obj.Position == nil {
		return nil, nil
	}
	v := float64(*obj.Position)
	return &v, nil
}

// BandwidthInBps is the resolver for the bandwidthInBps field.
func (r *viewerMetricsResolver) BandwidthInBps(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*int, error) {
	if obj.BandwidthInBps == nil {
		return nil, nil
	}
	v := int(*obj.BandwidthInBps)
	return &v, nil
}

// BandwidthOutBps is the resolver for the bandwidthOutBps field.
func (r *viewerMetricsResolver) BandwidthOutBps(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*int, error) {
	if obj.BandwidthOutBps == nil {
		return nil, nil
	}
	v := int(*obj.BandwidthOutBps)
	return &v, nil
}

// BytesDownloaded is the resolver for the bytesDownloaded field.
func (r *viewerMetricsResolver) BytesDownloaded(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*float64, error) {
	if obj.BytesDownloaded == nil {
		return nil, nil
	}
	v := float64(*obj.BytesDownloaded)
	return &v, nil
}

// BytesUploaded is the resolver for the bytesUploaded field.
func (r *viewerMetricsResolver) BytesUploaded(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*float64, error) {
	if obj.BytesUploaded == nil {
		return nil, nil
	}
	v := float64(*obj.BytesUploaded)
	return &v, nil
}

// PacketsSent is the resolver for the packetsSent field.
func (r *viewerMetricsResolver) PacketsSent(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*int, error) {
	if obj.PacketsSent == nil {
		return nil, nil
	}
	v := int(*obj.PacketsSent)
	return &v, nil
}

// PacketsLost is the resolver for the packetsLost field.
func (r *viewerMetricsResolver) PacketsLost(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*int, error) {
	if obj.PacketsLost == nil {
		return nil, nil
	}
	v := int(*obj.PacketsLost)
	return &v, nil
}

// PacketsRetransmitted is the resolver for the packetsRetransmitted field.
func (r *viewerMetricsResolver) PacketsRetransmitted(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*int, error) {
	if obj.PacketsRetransmitted == nil {
		return nil, nil
	}
	v := int(*obj.PacketsRetransmitted)
	return &v, nil
}

// ID is the resolver for the id field.
func (r *viewerSessionResolver) ID(ctx context.Context, obj *proto.ViewerSession) (string, error) {
	return obj.SessionId, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *viewerSessionResolver) Timestamp(ctx context.Context, obj *proto.ViewerSession) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// ConnectionQuality is the resolver for the connectionQuality field.
func (r *viewerSessionResolver) ConnectionQuality(ctx context.Context, obj *proto.ViewerSession) (*float64, error) {
	v := float64(obj.ConnectionQuality)
	return &v, nil
}

// BufferHealth is the resolver for the bufferHealth field.
func (r *viewerSessionResolver) BufferHealth(ctx context.Context, obj *proto.ViewerSession) (*float64, error) {
	v := float64(obj.BufferHealth)
	return &v, nil
}

// Status is the resolver for the status field.
func (r *vodLifecycleResolver) Status(ctx context.Context, obj *proto.VodLifecycleData) (int, error) {
	return int(obj.Status), nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *vodLifecycleResolver) SizeBytes(ctx context.Context, obj *proto.VodLifecycleData) (*float64, error) {
	if obj.SizeBytes == nil {
		return nil, nil
	}
	v := float64(*obj.SizeBytes)
	return &v, nil
}

// ArtifactState returns generated.ArtifactStateResolver implementation.
func (r *Resolver) ArtifactState() generated.ArtifactStateResolver { return &artifactStateResolver{r} }

// BillingStatus returns generated.BillingStatusResolver implementation.
func (r *Resolver) BillingStatus() generated.BillingStatusResolver { return &billingStatusResolver{r} }

// BillingTier returns generated.BillingTierResolver implementation.
func (r *Resolver) BillingTier() generated.BillingTierResolver { return &billingTierResolver{r} }

// BootstrapToken returns generated.BootstrapTokenResolver implementation.
func (r *Resolver) BootstrapToken() generated.BootstrapTokenResolver {
	return &bootstrapTokenResolver{r}
}

// CityMetric returns generated.CityMetricResolver implementation.
func (r *Resolver) CityMetric() generated.CityMetricResolver { return &cityMetricResolver{r} }

// ClientMetrics5m returns generated.ClientMetrics5mResolver implementation.
func (r *Resolver) ClientMetrics5m() generated.ClientMetrics5mResolver {
	return &clientMetrics5mResolver{r}
}

// Clip returns generated.ClipResolver implementation.
func (r *Resolver) Clip() generated.ClipResolver { return &clipResolver{r} }

// ClipEvent returns generated.ClipEventResolver implementation.
func (r *Resolver) ClipEvent() generated.ClipEventResolver { return &clipEventResolver{r} }

// ClipLifecycle returns generated.ClipLifecycleResolver implementation.
func (r *Resolver) ClipLifecycle() generated.ClipLifecycleResolver { return &clipLifecycleResolver{r} }

// ClipViewingUrls returns generated.ClipViewingUrlsResolver implementation.
func (r *Resolver) ClipViewingUrls() generated.ClipViewingUrlsResolver {
	return &clipViewingUrlsResolver{r}
}

// Cluster returns generated.ClusterResolver implementation.
func (r *Resolver) Cluster() generated.ClusterResolver { return &clusterResolver{r} }

// ClusterInvite returns generated.ClusterInviteResolver implementation.
func (r *Resolver) ClusterInvite() generated.ClusterInviteResolver { return &clusterInviteResolver{r} }

// ClusterSubscription returns generated.ClusterSubscriptionResolver implementation.
func (r *Resolver) ClusterSubscription() generated.ClusterSubscriptionResolver {
	return &clusterSubscriptionResolver{r}
}

// ConnectionEvent returns generated.ConnectionEventResolver implementation.
func (r *Resolver) ConnectionEvent() generated.ConnectionEventResolver {
	return &connectionEventResolver{r}
}

// CountryMetric returns generated.CountryMetricResolver implementation.
func (r *Resolver) CountryMetric() generated.CountryMetricResolver { return &countryMetricResolver{r} }

// DVREvent returns generated.DVREventResolver implementation.
func (r *Resolver) DVREvent() generated.DVREventResolver { return &dVREventResolver{r} }

// DVRRequest returns generated.DVRRequestResolver implementation.
func (r *Resolver) DVRRequest() generated.DVRRequestResolver { return &dVRRequestResolver{r} }

// DeveloperToken returns generated.DeveloperTokenResolver implementation.
func (r *Resolver) DeveloperToken() generated.DeveloperTokenResolver {
	return &developerTokenResolver{r}
}

// GeoBucket returns generated.GeoBucketResolver implementation.
func (r *Resolver) GeoBucket() generated.GeoBucketResolver { return &geoBucketResolver{r} }

// Invoice returns generated.InvoiceResolver implementation.
func (r *Resolver) Invoice() generated.InvoiceResolver { return &invoiceResolver{r} }

// LiveNode returns generated.LiveNodeResolver implementation.
func (r *Resolver) LiveNode() generated.LiveNodeResolver { return &liveNodeResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Node returns generated.NodeResolver implementation.
func (r *Resolver) Node() generated.NodeResolver { return &nodeResolver{r} }

// NodeMetric returns generated.NodeMetricResolver implementation.
func (r *Resolver) NodeMetric() generated.NodeMetricResolver { return &nodeMetricResolver{r} }

// NodeMetricHourly returns generated.NodeMetricHourlyResolver implementation.
func (r *Resolver) NodeMetricHourly() generated.NodeMetricHourlyResolver {
	return &nodeMetricHourlyResolver{r}
}

// NodePerformance5m returns generated.NodePerformance5mResolver implementation.
func (r *Resolver) NodePerformance5m() generated.NodePerformance5mResolver {
	return &nodePerformance5mResolver{r}
}

// Payment returns generated.PaymentResolver implementation.
func (r *Resolver) Payment() generated.PaymentResolver { return &paymentResolver{r} }

// PlatformOverview returns generated.PlatformOverviewResolver implementation.
func (r *Resolver) PlatformOverview() generated.PlatformOverviewResolver {
	return &platformOverviewResolver{r}
}

// PlaybackInstance returns generated.PlaybackInstanceResolver implementation.
func (r *Resolver) PlaybackInstance() generated.PlaybackInstanceResolver {
	return &playbackInstanceResolver{r}
}

// PlaybackMetadata returns generated.PlaybackMetadataResolver implementation.
func (r *Resolver) PlaybackMetadata() generated.PlaybackMetadataResolver {
	return &playbackMetadataResolver{r}
}

// ProcessingUsageRecord returns generated.ProcessingUsageRecordResolver implementation.
func (r *Resolver) ProcessingUsageRecord() generated.ProcessingUsageRecordResolver {
	return &processingUsageRecordResolver{r}
}

// ProcessingUsageSummary returns generated.ProcessingUsageSummaryResolver implementation.
func (r *Resolver) ProcessingUsageSummary() generated.ProcessingUsageSummaryResolver {
	return &processingUsageSummaryResolver{r}
}

// QualityTierDaily returns generated.QualityTierDailyResolver implementation.
func (r *Resolver) QualityTierDaily() generated.QualityTierDailyResolver {
	return &qualityTierDailyResolver{r}
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// RebufferingEvent returns generated.RebufferingEventResolver implementation.
func (r *Resolver) RebufferingEvent() generated.RebufferingEventResolver {
	return &rebufferingEventResolver{r}
}

// RoutingEvent returns generated.RoutingEventResolver implementation.
func (r *Resolver) RoutingEvent() generated.RoutingEventResolver { return &routingEventResolver{r} }

// ServiceInstance returns generated.ServiceInstanceResolver implementation.
func (r *Resolver) ServiceInstance() generated.ServiceInstanceResolver {
	return &serviceInstanceResolver{r}
}

// ServiceInstanceHealth returns generated.ServiceInstanceHealthResolver implementation.
func (r *Resolver) ServiceInstanceHealth() generated.ServiceInstanceHealthResolver {
	return &serviceInstanceHealthResolver{r}
}

// StorageEvent returns generated.StorageEventResolver implementation.
func (r *Resolver) StorageEvent() generated.StorageEventResolver { return &storageEventResolver{r} }

// StorageUsageRecord returns generated.StorageUsageRecordResolver implementation.
func (r *Resolver) StorageUsageRecord() generated.StorageUsageRecordResolver {
	return &storageUsageRecordResolver{r}
}

// Stream returns generated.StreamResolver implementation.
func (r *Resolver) Stream() generated.StreamResolver { return &streamResolver{r} }

// StreamAnalytics returns generated.StreamAnalyticsResolver implementation.
func (r *Resolver) StreamAnalytics() generated.StreamAnalyticsResolver {
	return &streamAnalyticsResolver{r}
}

// StreamAnalyticsDaily returns generated.StreamAnalyticsDailyResolver implementation.
func (r *Resolver) StreamAnalyticsDaily() generated.StreamAnalyticsDailyResolver {
	return &streamAnalyticsDailyResolver{r}
}

// StreamBufferEvent returns generated.StreamBufferEventResolver implementation.
func (r *Resolver) StreamBufferEvent() generated.StreamBufferEventResolver {
	return &streamBufferEventResolver{r}
}

// StreamConnectionHourly returns generated.StreamConnectionHourlyResolver implementation.
func (r *Resolver) StreamConnectionHourly() generated.StreamConnectionHourlyResolver {
	return &streamConnectionHourlyResolver{r}
}

// StreamEndEvent returns generated.StreamEndEventResolver implementation.
func (r *Resolver) StreamEndEvent() generated.StreamEndEventResolver {
	return &streamEndEventResolver{r}
}

// StreamEvent returns generated.StreamEventResolver implementation.
func (r *Resolver) StreamEvent() generated.StreamEventResolver { return &streamEventResolver{r} }

// StreamHealth5m returns generated.StreamHealth5mResolver implementation.
func (r *Resolver) StreamHealth5m() generated.StreamHealth5mResolver {
	return &streamHealth5mResolver{r}
}

// StreamHealthMetric returns generated.StreamHealthMetricResolver implementation.
func (r *Resolver) StreamHealthMetric() generated.StreamHealthMetricResolver {
	return &streamHealthMetricResolver{r}
}

// StreamKey returns generated.StreamKeyResolver implementation.
func (r *Resolver) StreamKey() generated.StreamKeyResolver { return &streamKeyResolver{r} }

// StreamLifecycleUpdate returns generated.StreamLifecycleUpdateResolver implementation.
func (r *Resolver) StreamLifecycleUpdate() generated.StreamLifecycleUpdateResolver {
	return &streamLifecycleUpdateResolver{r}
}

// StreamMetaResponse returns generated.StreamMetaResponseResolver implementation.
func (r *Resolver) StreamMetaResponse() generated.StreamMetaResponseResolver {
	return &streamMetaResponseResolver{r}
}

// StreamMetrics returns generated.StreamMetricsResolver implementation.
func (r *Resolver) StreamMetrics() generated.StreamMetricsResolver { return &streamMetricsResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// SystemHealthEvent returns generated.SystemHealthEventResolver implementation.
func (r *Resolver) SystemHealthEvent() generated.SystemHealthEventResolver {
	return &systemHealthEventResolver{r}
}

// Tenant returns generated.TenantResolver implementation.
func (r *Resolver) Tenant() generated.TenantResolver { return &tenantResolver{r} }

// TenantAnalyticsDaily returns generated.TenantAnalyticsDailyResolver implementation.
func (r *Resolver) TenantAnalyticsDaily() generated.TenantAnalyticsDailyResolver {
	return &tenantAnalyticsDailyResolver{r}
}

// TenantDailyStat returns generated.TenantDailyStatResolver implementation.
func (r *Resolver) TenantDailyStat() generated.TenantDailyStatResolver {
	return &tenantDailyStatResolver{r}
}

// TenantSubscription returns generated.TenantSubscriptionResolver implementation.
func (r *Resolver) TenantSubscription() generated.TenantSubscriptionResolver {
	return &tenantSubscriptionResolver{r}
}

// TimeRange returns generated.TimeRangeResolver implementation.
func (r *Resolver) TimeRange() generated.TimeRangeResolver { return &timeRangeResolver{r} }

// TrackListEvent returns generated.TrackListEventResolver implementation.
func (r *Resolver) TrackListEvent() generated.TrackListEventResolver {
	return &trackListEventResolver{r}
}

// UsageRecord returns generated.UsageRecordResolver implementation.
func (r *Resolver) UsageRecord() generated.UsageRecordResolver { return &usageRecordResolver{r} }

// UsageSummary returns generated.UsageSummaryResolver implementation.
func (r *Resolver) UsageSummary() generated.UsageSummaryResolver { return &usageSummaryResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

// ViewerCountBucket returns generated.ViewerCountBucketResolver implementation.
func (r *Resolver) ViewerCountBucket() generated.ViewerCountBucketResolver {
	return &viewerCountBucketResolver{r}
}

// ViewerEndpoint returns generated.ViewerEndpointResolver implementation.
func (r *Resolver) ViewerEndpoint() generated.ViewerEndpointResolver {
	return &viewerEndpointResolver{r}
}

// ViewerGeoHourly returns generated.ViewerGeoHourlyResolver implementation.
func (r *Resolver) ViewerGeoHourly() generated.ViewerGeoHourlyResolver {
	return &viewerGeoHourlyResolver{r}
}

// ViewerGeographic returns generated.ViewerGeographicResolver implementation.
func (r *Resolver) ViewerGeographic() generated.ViewerGeographicResolver {
	return &viewerGeographicResolver{r}
}

// ViewerHoursHourly returns generated.ViewerHoursHourlyResolver implementation.
func (r *Resolver) ViewerHoursHourly() generated.ViewerHoursHourlyResolver {
	return &viewerHoursHourlyResolver{r}
}

// ViewerMetrics returns generated.ViewerMetricsResolver implementation.
func (r *Resolver) ViewerMetrics() generated.ViewerMetricsResolver { return &viewerMetricsResolver{r} }

// ViewerSession returns generated.ViewerSessionResolver implementation.
func (r *Resolver) ViewerSession() generated.ViewerSessionResolver { return &viewerSessionResolver{r} }

// VodLifecycle returns generated.VodLifecycleResolver implementation.
func (r *Resolver) VodLifecycle() generated.VodLifecycleResolver { return &vodLifecycleResolver{r} }

type artifactStateResolver struct{ *Resolver }
type billingStatusResolver struct{ *Resolver }
type billingTierResolver struct{ *Resolver }
type bootstrapTokenResolver struct{ *Resolver }
type cityMetricResolver struct{ *Resolver }
type clientMetrics5mResolver struct{ *Resolver }
type clipResolver struct{ *Resolver }
type clipEventResolver struct{ *Resolver }
type clipLifecycleResolver struct{ *Resolver }
type clipViewingUrlsResolver struct{ *Resolver }
type clusterResolver struct{ *Resolver }
type clusterInviteResolver struct{ *Resolver }
type clusterSubscriptionResolver struct{ *Resolver }
type connectionEventResolver struct{ *Resolver }
type countryMetricResolver struct{ *Resolver }
type dVREventResolver struct{ *Resolver }
type dVRRequestResolver struct{ *Resolver }
type developerTokenResolver struct{ *Resolver }
type geoBucketResolver struct{ *Resolver }
type invoiceResolver struct{ *Resolver }
type liveNodeResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type nodeResolver struct{ *Resolver }
type nodeMetricResolver struct{ *Resolver }
type nodeMetricHourlyResolver struct{ *Resolver }
type nodePerformance5mResolver struct{ *Resolver }
type paymentResolver struct{ *Resolver }
type platformOverviewResolver struct{ *Resolver }
type playbackInstanceResolver struct{ *Resolver }
type playbackMetadataResolver struct{ *Resolver }
type processingUsageRecordResolver struct{ *Resolver }
type processingUsageSummaryResolver struct{ *Resolver }
type qualityTierDailyResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type rebufferingEventResolver struct{ *Resolver }
type routingEventResolver struct{ *Resolver }
type serviceInstanceResolver struct{ *Resolver }
type serviceInstanceHealthResolver struct{ *Resolver }
type storageEventResolver struct{ *Resolver }
type storageUsageRecordResolver struct{ *Resolver }
type streamResolver struct{ *Resolver }
type streamAnalyticsResolver struct{ *Resolver }
type streamAnalyticsDailyResolver struct{ *Resolver }
type streamBufferEventResolver struct{ *Resolver }
type streamConnectionHourlyResolver struct{ *Resolver }
type streamEndEventResolver struct{ *Resolver }
type streamEventResolver struct{ *Resolver }
type streamHealth5mResolver struct{ *Resolver }
type streamHealthMetricResolver struct{ *Resolver }
type streamKeyResolver struct{ *Resolver }
type streamLifecycleUpdateResolver struct{ *Resolver }
type streamMetaResponseResolver struct{ *Resolver }
type streamMetricsResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type systemHealthEventResolver struct{ *Resolver }
type tenantResolver struct{ *Resolver }
type tenantAnalyticsDailyResolver struct{ *Resolver }
type tenantDailyStatResolver struct{ *Resolver }
type tenantSubscriptionResolver struct{ *Resolver }
type timeRangeResolver struct{ *Resolver }
type trackListEventResolver struct{ *Resolver }
type usageRecordResolver struct{ *Resolver }
type usageSummaryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type viewerCountBucketResolver struct{ *Resolver }
type viewerEndpointResolver struct{ *Resolver }
type viewerGeoHourlyResolver struct{ *Resolver }
type viewerGeographicResolver struct{ *Resolver }
type viewerHoursHourlyResolver struct{ *Resolver }
type viewerMetricsResolver struct{ *Resolver }
type viewerSessionResolver struct{ *Resolver }
type vodLifecycleResolver struct{ *Resolver }
