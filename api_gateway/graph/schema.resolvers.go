package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"frameworks/api_gateway/graph/generated"
	"frameworks/api_gateway/graph/model"
	"frameworks/pkg/models"
	"strings"
	"time"
)

// CurrentTier is the resolver for the currentTier field.
func (r *billingStatusResolver) CurrentTier(ctx context.Context, obj *models.BillingStatus) (*models.BillingTier, error) {
	return &obj.Tier, nil
}

// OutstandingAmount is the resolver for the outstandingAmount field.
func (r *billingStatusResolver) OutstandingAmount(ctx context.Context, obj *models.BillingStatus) (float64, error) {
	// Calculate total outstanding amount from pending invoices
	var total float64
	for _, invoice := range obj.PendingInvoices {
		total += invoice.Amount
	}
	return total, nil
}

// Name is the resolver for the name field.
func (r *billingTierResolver) Name(ctx context.Context, obj *models.BillingTier) (string, error) {
	return obj.DisplayName, nil
}

// Price is the resolver for the price field.
func (r *billingTierResolver) Price(ctx context.Context, obj *models.BillingTier) (float64, error) {
	return obj.BasePrice, nil
}

// Features is the resolver for the features field.
func (r *billingTierResolver) Features(ctx context.Context, obj *models.BillingTier) ([]string, error) {
	// Convert JSONB features to string slice
	var features []string
	if obj.Features != nil {
		for key, value := range obj.Features {
			if enabled, ok := value.(bool); ok && enabled {
				features = append(features, key)
			}
		}
	}
	return features, nil
}

// LineItems is the resolver for the lineItems field.
func (r *invoiceResolver) LineItems(ctx context.Context, obj *models.Invoice) ([]*model.LineItem, error) {
	// Convert usage details JSONB to line items
	var lineItems []*model.LineItem
	if obj.UsageDetails != nil {
		for description, details := range obj.UsageDetails {
			if detailMap, ok := details.(map[string]interface{}); ok {
				quantity := 1
				unitPrice := obj.Amount
				if q, exists := detailMap["quantity"]; exists {
					if qInt, ok := q.(float64); ok {
						quantity = int(qInt)
					}
				}
				if up, exists := detailMap["unit_price"]; exists {
					if upFloat, ok := up.(float64); ok {
						unitPrice = upFloat
					}
				}
				lineItems = append(lineItems, &model.LineItem{
					Description: description,
					Quantity:    quantity,
					UnitPrice:   unitPrice,
					Total:       unitPrice * float64(quantity),
				})
			}
		}
	}
	// If no line items from usage details, create a default one
	if len(lineItems) == 0 {
		lineItems = append(lineItems, &model.LineItem{
			Description: "Service usage",
			Quantity:    1,
			UnitPrice:   obj.Amount,
			Total:       obj.Amount,
		})
	}
	return lineItems, nil
}

// CreateStream is the resolver for the createStream field.
func (r *mutationResolver) CreateStream(ctx context.Context, input model.CreateStreamInput) (*models.Stream, error) {
	return r.DoCreateStream(ctx, input)
}

// UpdateStream is the resolver for the updateStream field.
func (r *mutationResolver) UpdateStream(ctx context.Context, id string, input model.UpdateStreamInput) (*models.Stream, error) {
	return r.DoUpdateStream(ctx, id, input)
}

// DeleteStream is the resolver for the deleteStream field.
func (r *mutationResolver) DeleteStream(ctx context.Context, id string) (bool, error) {
	return r.DoDeleteStream(ctx, id)
}

// RefreshStreamKey is the resolver for the refreshStreamKey field.
func (r *mutationResolver) RefreshStreamKey(ctx context.Context, id string) (*models.Stream, error) {
	return r.Resolver.DoRefreshStreamKey(ctx, id)
}

// CreateClip is the resolver for the createClip field.
func (r *mutationResolver) CreateClip(ctx context.Context, input model.CreateClipInput) (*model.Clip, error) {
	return r.DoCreateClip(ctx, input)
}

// CreatePayment is the resolver for the createPayment field.
func (r *mutationResolver) CreatePayment(ctx context.Context, input model.CreatePaymentInput) (*models.Payment, error) {
	return r.DoCreatePayment(ctx, input)
}

// UpdateBillingTier is the resolver for the updateBillingTier field.
func (r *mutationResolver) UpdateBillingTier(ctx context.Context, tierID string) (*models.BillingStatus, error) {
	return r.DoUpdateBillingTier(ctx, tierID)
}

// UpdateTenant is the resolver for the updateTenant field.
func (r *mutationResolver) UpdateTenant(ctx context.Context, input model.UpdateTenantInput) (*models.Tenant, error) {
	return r.DoUpdateTenant(ctx, input)
}

// CreateDeveloperToken is the resolver for the createDeveloperToken field.
func (r *mutationResolver) CreateDeveloperToken(ctx context.Context, input model.CreateDeveloperTokenInput) (*model.DeveloperToken, error) {
	return r.DoCreateDeveloperToken(ctx, input)
}

// RevokeDeveloperToken is the resolver for the revokeDeveloperToken field.
func (r *mutationResolver) RevokeDeveloperToken(ctx context.Context, id string) (bool, error) {
	return r.DoRevokeDeveloperToken(ctx, id)
}

// Method is the resolver for the method field.
func (r *paymentResolver) Method(ctx context.Context, obj *models.Payment) (model.PaymentMethod, error) {
	// Convert payment method string to GraphQL enum
	switch obj.Method {
	case "card", "mollie":
		return model.PaymentMethodCard, nil
	case "crypto", "crypto_btc", "crypto_eth":
		return model.PaymentMethodCrypto, nil
	case "bank_transfer":
		return model.PaymentMethodBankTransfer, nil
	default:
		return model.PaymentMethodCard, nil
	}
}

// Streams is the resolver for the streams field.
func (r *queryResolver) Streams(ctx context.Context) ([]*models.Stream, error) {
	return r.DoGetStreams(ctx)
}

// Stream is the resolver for the stream field.
func (r *queryResolver) Stream(ctx context.Context, id string) (*models.Stream, error) {
	return r.DoGetStream(ctx, id)
}

// ValidateStreamKey is the resolver for the validateStreamKey field.
func (r *queryResolver) ValidateStreamKey(ctx context.Context, streamKey string) (*model.StreamValidation, error) {
	return r.DoValidateStreamKey(ctx, streamKey)
}

// StreamEmbed is the resolver for the streamEmbed field.
func (r *queryResolver) StreamEmbed(ctx context.Context, id string) (*model.StreamEmbed, error) {
	panic(fmt.Errorf("not implemented: StreamEmbed - streamEmbed"))
}

// StreamAnalytics is the resolver for the streamAnalytics field.
func (r *queryResolver) StreamAnalytics(ctx context.Context, stream string, timeRange *model.TimeRangeInput) (*models.StreamAnalytics, error) {
	return r.DoGetStreamAnalytics(ctx, stream, timeRange)
}

// ViewerMetrics is the resolver for the viewerMetrics field.
func (r *queryResolver) ViewerMetrics(ctx context.Context, stream *string, timeRange *model.TimeRangeInput) ([]*model.ViewerMetric, error) {
	return r.DoGetViewerMetrics(ctx, stream, timeRange)
}

// PlatformOverview is the resolver for the platformOverview field.
func (r *queryResolver) PlatformOverview(ctx context.Context, timeRange *model.TimeRangeInput) (*model.PlatformOverview, error) {
	return r.DoGetPlatformOverview(ctx, timeRange)
}

// StreamHealthMetrics is the resolver for the streamHealthMetrics field.
func (r *queryResolver) StreamHealthMetrics(ctx context.Context, stream string, timeRange *model.TimeRangeInput) ([]*model.StreamHealthMetric, error) {
	return r.DoGetStreamHealthMetrics(ctx, stream, timeRange)
}

// StreamQualityChanges is the resolver for the streamQualityChanges field.
func (r *queryResolver) StreamQualityChanges(ctx context.Context, stream string, timeRange *model.TimeRangeInput) ([]*model.StreamQualityChange, error) {
	return r.DoGetStreamQualityChanges(ctx, stream, timeRange)
}

// StreamHealthAlerts is the resolver for the streamHealthAlerts field.
func (r *queryResolver) StreamHealthAlerts(ctx context.Context, stream *string, timeRange *model.TimeRangeInput) ([]*model.StreamHealthAlert, error) {
	return r.DoGetStreamHealthAlerts(ctx, stream, timeRange)
}

// CurrentStreamHealth is the resolver for the currentStreamHealth field.
func (r *queryResolver) CurrentStreamHealth(ctx context.Context, stream string) (*model.StreamHealthMetric, error) {
	return r.DoGetCurrentStreamHealth(ctx, stream)
}

// RebufferingEvents is the resolver for the rebufferingEvents field.
func (r *queryResolver) RebufferingEvents(ctx context.Context, stream string, timeRange *model.TimeRangeInput) ([]*model.RebufferingEvent, error) {
	return r.DoGetRebufferingEvents(ctx, stream, timeRange)
}

// BillingTiers is the resolver for the billingTiers field.
func (r *queryResolver) BillingTiers(ctx context.Context) ([]*models.BillingTier, error) {
	return r.DoGetBillingTiers(ctx)
}

// Invoices is the resolver for the invoices field.
func (r *queryResolver) Invoices(ctx context.Context) ([]*models.Invoice, error) {
	return r.DoGetInvoices(ctx)
}

// Invoice is the resolver for the invoice field.
func (r *queryResolver) Invoice(ctx context.Context, id string) (*models.Invoice, error) {
	return r.DoGetInvoice(ctx, id)
}

// BillingStatus is the resolver for the billingStatus field.
func (r *queryResolver) BillingStatus(ctx context.Context) (*models.BillingStatus, error) {
	return r.DoGetBillingStatus(ctx)
}

// UsageRecords is the resolver for the usageRecords field.
func (r *queryResolver) UsageRecords(ctx context.Context, timeRange *model.TimeRangeInput) ([]*models.UsageRecord, error) {
	return r.DoGetUsageRecords(ctx, timeRange)
}

// Tenant is the resolver for the tenant field.
func (r *queryResolver) Tenant(ctx context.Context) (*models.Tenant, error) {
	return r.DoGetTenant(ctx)
}

// Clusters is the resolver for the clusters field.
func (r *queryResolver) Clusters(ctx context.Context) ([]*model.Cluster, error) {
	return r.DoGetClusters(ctx)
}

// Cluster is the resolver for the cluster field.
func (r *queryResolver) Cluster(ctx context.Context, id string) (*model.Cluster, error) {
	return r.DoGetCluster(ctx, id)
}

// Nodes is the resolver for the nodes field.
func (r *queryResolver) Nodes(ctx context.Context) ([]*model.Node, error) {
	return r.DoGetNodes(ctx)
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (*model.Node, error) {
	return r.DoGetNode(ctx, id)
}

// DeveloperTokens is the resolver for the developerTokens field.
func (r *queryResolver) DeveloperTokens(ctx context.Context) ([]*model.DeveloperToken, error) {
	return r.DoGetDeveloperTokens(ctx)
}

// Name is the resolver for the name field.
func (r *streamResolver) Name(ctx context.Context, obj *models.Stream) (string, error) {
	return obj.Title, nil
}

// Status is the resolver for the status field.
func (r *streamResolver) Status(ctx context.Context, obj *models.Stream) (model.StreamStatus, error) {
	// Convert status string to GraphQL enum
	switch obj.Status {
	case "offline":
		return model.StreamStatusOffline, nil
	case "live":
		return model.StreamStatusLive, nil
	case "recording":
		return model.StreamStatusRecording, nil
	case "ended":
		return model.StreamStatusEnded, nil
	default:
		return model.StreamStatusOffline, nil
	}
}

// Record is the resolver for the record field.
func (r *streamResolver) Record(ctx context.Context, obj *models.Stream) (bool, error) {
	return obj.IsRecording, nil
}

// Stream is the resolver for the stream field.
func (r *streamAnalyticsResolver) Stream(ctx context.Context, obj *models.StreamAnalytics) (string, error) {
	panic(fmt.Errorf("not implemented: Stream - stream"))
}

// TotalViews is the resolver for the totalViews field.
func (r *streamAnalyticsResolver) TotalViews(ctx context.Context, obj *models.StreamAnalytics) (int, error) {
	return obj.TotalConnections, nil
}

// TotalViewTime is the resolver for the totalViewTime field.
func (r *streamAnalyticsResolver) TotalViewTime(ctx context.Context, obj *models.StreamAnalytics) (float64, error) {
	return float64(obj.TotalSessionDuration), nil
}

// AverageViewers is the resolver for the averageViewers field.
func (r *streamAnalyticsResolver) AverageViewers(ctx context.Context, obj *models.StreamAnalytics) (float64, error) {
	return obj.AvgViewers, nil
}

// UniqueViewers is the resolver for the uniqueViewers field.
func (r *streamAnalyticsResolver) UniqueViewers(ctx context.Context, obj *models.StreamAnalytics) (int, error) {
	// Calculate from unique countries/cities as proxy for unique viewers
	return obj.UniqueCountries + obj.UniqueCities, nil
}

// TimeRange is the resolver for the timeRange field.
func (r *streamAnalyticsResolver) TimeRange(ctx context.Context, obj *models.StreamAnalytics) (*model.TimeRange, error) {
	return &model.TimeRange{
		Start: obj.SessionStartTime,
		End:   obj.SessionEndTime,
	}, nil
}

// CurrentHealthScore is the resolver for the currentHealthScore field.
func (r *streamAnalyticsResolver) CurrentHealthScore(ctx context.Context, obj *models.StreamAnalytics) (*float64, error) {
	panic(fmt.Errorf("not implemented: CurrentHealthScore - currentHealthScore"))
}

// AverageHealthScore is the resolver for the averageHealthScore field.
func (r *streamAnalyticsResolver) AverageHealthScore(ctx context.Context, obj *models.StreamAnalytics) (*float64, error) {
	panic(fmt.Errorf("not implemented: AverageHealthScore - averageHealthScore"))
}

// FrameJitterMs is the resolver for the frameJitterMs field.
func (r *streamAnalyticsResolver) FrameJitterMs(ctx context.Context, obj *models.StreamAnalytics) (*float64, error) {
	panic(fmt.Errorf("not implemented: FrameJitterMs - frameJitterMs"))
}

// KeyframeStabilityMs is the resolver for the keyframeStabilityMs field.
func (r *streamAnalyticsResolver) KeyframeStabilityMs(ctx context.Context, obj *models.StreamAnalytics) (*float64, error) {
	panic(fmt.Errorf("not implemented: KeyframeStabilityMs - keyframeStabilityMs"))
}

// CurrentIssues is the resolver for the currentIssues field.
func (r *streamAnalyticsResolver) CurrentIssues(ctx context.Context, obj *models.StreamAnalytics) (*string, error) {
	panic(fmt.Errorf("not implemented: CurrentIssues - currentIssues"))
}

// BufferState is the resolver for the bufferState field.
func (r *streamAnalyticsResolver) BufferState(ctx context.Context, obj *models.StreamAnalytics) (*model.BufferState, error) {
	panic(fmt.Errorf("not implemented: BufferState - bufferState"))
}

// PacketLossPercentage is the resolver for the packetLossPercentage field.
func (r *streamAnalyticsResolver) PacketLossPercentage(ctx context.Context, obj *models.StreamAnalytics) (*float64, error) {
	panic(fmt.Errorf("not implemented: PacketLossPercentage - packetLossPercentage"))
}

// QualityTier is the resolver for the qualityTier field.
func (r *streamAnalyticsResolver) QualityTier(ctx context.Context, obj *models.StreamAnalytics) (*string, error) {
	panic(fmt.Errorf("not implemented: QualityTier - qualityTier"))
}

// CurrentCodec is the resolver for the currentCodec field.
func (r *streamAnalyticsResolver) CurrentCodec(ctx context.Context, obj *models.StreamAnalytics) (*string, error) {
	panic(fmt.Errorf("not implemented: CurrentCodec - currentCodec"))
}

// CurrentResolution is the resolver for the currentResolution field.
func (r *streamAnalyticsResolver) CurrentResolution(ctx context.Context, obj *models.StreamAnalytics) (*string, error) {
	panic(fmt.Errorf("not implemented: CurrentResolution - currentResolution"))
}

// CurrentBitrate is the resolver for the currentBitrate field.
func (r *streamAnalyticsResolver) CurrentBitrate(ctx context.Context, obj *models.StreamAnalytics) (*int, error) {
	panic(fmt.Errorf("not implemented: CurrentBitrate - currentBitrate"))
}

// CurrentFps is the resolver for the currentFps field.
func (r *streamAnalyticsResolver) CurrentFps(ctx context.Context, obj *models.StreamAnalytics) (*float64, error) {
	panic(fmt.Errorf("not implemented: CurrentFps - currentFps"))
}

// RebufferCount is the resolver for the rebufferCount field.
func (r *streamAnalyticsResolver) RebufferCount(ctx context.Context, obj *models.StreamAnalytics) (*int, error) {
	panic(fmt.Errorf("not implemented: RebufferCount - rebufferCount"))
}

// AlertCount is the resolver for the alertCount field.
func (r *streamAnalyticsResolver) AlertCount(ctx context.Context, obj *models.StreamAnalytics) (*int, error) {
	panic(fmt.Errorf("not implemented: AlertCount - alertCount"))
}

// StreamEvents is the resolver for the streamEvents field.
func (r *subscriptionResolver) StreamEvents(ctx context.Context, stream *string) (<-chan *model.StreamEvent, error) {
	return r.Resolver.DoStreamUpdates(ctx, stream)
}

// ViewerMetrics is the resolver for the viewerMetrics field.
func (r *subscriptionResolver) ViewerMetrics(ctx context.Context, stream string) (<-chan *model.ViewerMetrics, error) {
	return r.Resolver.DoAnalyticsUpdates(ctx)
}

// TrackListUpdates is the resolver for the trackListUpdates field.
func (r *subscriptionResolver) TrackListUpdates(ctx context.Context, stream string) (<-chan *model.TrackListEvent, error) {
	return r.Resolver.DoTrackListUpdates(ctx, stream)
}

// SystemHealth is the resolver for the systemHealth field.
func (r *subscriptionResolver) SystemHealth(ctx context.Context) (<-chan *model.SystemHealthEvent, error) {
	return r.Resolver.DoSystemUpdates(ctx)
}

// UserEvents is the resolver for the userEvents field.
func (r *subscriptionResolver) UserEvents(ctx context.Context) (<-chan model.TenantEvent, error) {
	return r.Resolver.DoUserEvents(ctx)
}

// Settings is the resolver for the settings field.
func (r *tenantResolver) Settings(ctx context.Context, obj *models.Tenant) (*string, error) {
	// Convert tenant settings to JSON string if needed
	// For now, return nil as settings might be handled differently
	return nil, nil
}

// Cluster is the resolver for the cluster field.
func (r *tenantResolver) Cluster(ctx context.Context, obj *models.Tenant) (*string, error) {
	panic(fmt.Errorf("not implemented: Cluster - cluster"))
}

// ResourceType is the resolver for the resourceType field.
func (r *usageRecordResolver) ResourceType(ctx context.Context, obj *models.UsageRecord) (string, error) {
	return obj.UsageType, nil
}

// Quantity is the resolver for the quantity field.
func (r *usageRecordResolver) Quantity(ctx context.Context, obj *models.UsageRecord) (float64, error) {
	return obj.UsageValue, nil
}

// Unit is the resolver for the unit field.
func (r *usageRecordResolver) Unit(ctx context.Context, obj *models.UsageRecord) (string, error) {
	// Determine unit based on usage type
	switch obj.UsageType {
	case "bandwidth", "egress":
		return "GB", nil
	case "storage", "recording":
		return "GB", nil
	case "streaming":
		return "hours", nil
	case "transcoding":
		return "minutes", nil
	default:
		return "units", nil
	}
}

// Cost is the resolver for the cost field.
func (r *usageRecordResolver) Cost(ctx context.Context, obj *models.UsageRecord) (float64, error) {
	// Extract cost from usage details if available
	if obj.UsageDetails != nil {
		if cost, exists := obj.UsageDetails["cost"]; exists {
			if costFloat, ok := cost.(float64); ok {
				return costFloat, nil
			}
		}
	}
	// Default to 0.0 if no cost information
	return 0.0, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *usageRecordResolver) Timestamp(ctx context.Context, obj *models.UsageRecord) (*time.Time, error) {
	return &obj.CreatedAt, nil
}

// Name is the resolver for the name field.
func (r *userResolver) Name(ctx context.Context, obj *models.User) (*string, error) {
	if obj.FirstName != "" || obj.LastName != "" {
		fullName := obj.FirstName + " " + obj.LastName
		fullName = strings.TrimSpace(fullName)
		return &fullName, nil
	}
	return nil, nil
}

// BillingStatus returns generated.BillingStatusResolver implementation.
func (r *Resolver) BillingStatus() generated.BillingStatusResolver { return &billingStatusResolver{r} }

// BillingTier returns generated.BillingTierResolver implementation.
func (r *Resolver) BillingTier() generated.BillingTierResolver { return &billingTierResolver{r} }

// Invoice returns generated.InvoiceResolver implementation.
func (r *Resolver) Invoice() generated.InvoiceResolver { return &invoiceResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Payment returns generated.PaymentResolver implementation.
func (r *Resolver) Payment() generated.PaymentResolver { return &paymentResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Stream returns generated.StreamResolver implementation.
func (r *Resolver) Stream() generated.StreamResolver { return &streamResolver{r} }

// StreamAnalytics returns generated.StreamAnalyticsResolver implementation.
func (r *Resolver) StreamAnalytics() generated.StreamAnalyticsResolver {
	return &streamAnalyticsResolver{r}
}

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// Tenant returns generated.TenantResolver implementation.
func (r *Resolver) Tenant() generated.TenantResolver { return &tenantResolver{r} }

// UsageRecord returns generated.UsageRecordResolver implementation.
func (r *Resolver) UsageRecord() generated.UsageRecordResolver { return &usageRecordResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type billingStatusResolver struct{ *Resolver }
type billingTierResolver struct{ *Resolver }
type invoiceResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type paymentResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type streamResolver struct{ *Resolver }
type streamAnalyticsResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type tenantResolver struct{ *Resolver }
type usageRecordResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
