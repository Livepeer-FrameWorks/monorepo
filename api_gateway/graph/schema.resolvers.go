package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"encoding/json"
	"fmt"
	"frameworks/api_gateway/graph/generated"
	"frameworks/api_gateway/graph/markers"
	"frameworks/api_gateway/graph/model"
	"frameworks/api_gateway/internal/loaders"
	"frameworks/api_gateway/internal/middleware"
	"frameworks/api_gateway/internal/resolvers"
	"frameworks/pkg/ctxkeys"
	"frameworks/pkg/globalid"
	"frameworks/pkg/logging"
	"frameworks/pkg/proto"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// APIUsageConnection is the resolver for the apiUsageConnection field.
func (r *aPIUsageResolver) APIUsageConnection(ctx context.Context, obj *markers.APIUsage, page *model.ConnectionInput, authType *string, operationType *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.APIUsageConnection, error) {
	var first, last *int
	var after, before *string
	if page != nil {
		first = page.First
		last = page.Last
		after = page.After
		before = page.Before
	}
	return r.DoGetAPIUsageConnection(ctx, authType, operationType, nil, timeRange, first, after, last, before, noCache)
}

// TotalRequests is the resolver for the totalRequests field.
func (r *aPIUsageOperationSummaryResolver) TotalRequests(ctx context.Context, obj *proto.APIUsageOperationSummary) (int, error) {
	return int(obj.TotalRequests), nil
}

// TotalErrors is the resolver for the totalErrors field.
func (r *aPIUsageOperationSummaryResolver) TotalErrors(ctx context.Context, obj *proto.APIUsageOperationSummary) (int, error) {
	return int(obj.TotalErrors), nil
}

// UniqueOperations is the resolver for the uniqueOperations field.
func (r *aPIUsageOperationSummaryResolver) UniqueOperations(ctx context.Context, obj *proto.APIUsageOperationSummary) (int, error) {
	return int(obj.UniqueOperations), nil
}

// TotalComplexity is the resolver for the totalComplexity field.
func (r *aPIUsageOperationSummaryResolver) TotalComplexity(ctx context.Context, obj *proto.APIUsageOperationSummary) (int, error) {
	return int(obj.TotalComplexity), nil
}

// ID is the resolver for the id field.
func (r *aPIUsageRecordResolver) ID(ctx context.Context, obj *proto.APIUsageRecord) (string, error) {
	hourPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeAPIUsageRecord, hourPart, obj.AuthType, obj.OperationType, obj.OperationName), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *aPIUsageRecordResolver) Timestamp(ctx context.Context, obj *proto.APIUsageRecord) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// RequestCount is the resolver for the requestCount field.
func (r *aPIUsageRecordResolver) RequestCount(ctx context.Context, obj *proto.APIUsageRecord) (int, error) {
	return int(obj.RequestCount), nil
}

// ErrorCount is the resolver for the errorCount field.
func (r *aPIUsageRecordResolver) ErrorCount(ctx context.Context, obj *proto.APIUsageRecord) (int, error) {
	return int(obj.ErrorCount), nil
}

// TotalDurationMs is the resolver for the totalDurationMs field.
func (r *aPIUsageRecordResolver) TotalDurationMs(ctx context.Context, obj *proto.APIUsageRecord) (float64, error) {
	return float64(obj.TotalDurationMs), nil
}

// TotalComplexity is the resolver for the totalComplexity field.
func (r *aPIUsageRecordResolver) TotalComplexity(ctx context.Context, obj *proto.APIUsageRecord) (int, error) {
	return int(obj.TotalComplexity), nil
}

// UniqueUsers is the resolver for the uniqueUsers field.
func (r *aPIUsageRecordResolver) UniqueUsers(ctx context.Context, obj *proto.APIUsageRecord) (int, error) {
	return int(obj.UniqueUsers), nil
}

// UniqueTokens is the resolver for the uniqueTokens field.
func (r *aPIUsageRecordResolver) UniqueTokens(ctx context.Context, obj *proto.APIUsageRecord) (int, error) {
	return int(obj.UniqueTokens), nil
}

// Date is the resolver for the date field.
func (r *aPIUsageSummaryResolver) Date(ctx context.Context, obj *proto.APIUsageSummary) (*time.Time, error) {
	if obj.Date == nil {
		return nil, nil
	}
	t := obj.Date.AsTime()
	return &t, nil
}

// TotalRequests is the resolver for the totalRequests field.
func (r *aPIUsageSummaryResolver) TotalRequests(ctx context.Context, obj *proto.APIUsageSummary) (int, error) {
	return int(obj.TotalRequests), nil
}

// TotalErrors is the resolver for the totalErrors field.
func (r *aPIUsageSummaryResolver) TotalErrors(ctx context.Context, obj *proto.APIUsageSummary) (int, error) {
	return int(obj.TotalErrors), nil
}

// TotalComplexity is the resolver for the totalComplexity field.
func (r *aPIUsageSummaryResolver) TotalComplexity(ctx context.Context, obj *proto.APIUsageSummary) (int, error) {
	return int(obj.TotalComplexity), nil
}

// UniqueUsers is the resolver for the uniqueUsers field.
func (r *aPIUsageSummaryResolver) UniqueUsers(ctx context.Context, obj *proto.APIUsageSummary) (int, error) {
	return int(obj.UniqueUsers), nil
}

// UniqueTokens is the resolver for the uniqueTokens field.
func (r *aPIUsageSummaryResolver) UniqueTokens(ctx context.Context, obj *proto.APIUsageSummary) (int, error) {
	return int(obj.UniqueTokens), nil
}

// Overview is the resolver for the overview field.
func (r *analyticsResolver) Overview(ctx context.Context, obj *markers.Analytics, timeRange *model.TimeRangeInput) (*proto.GetPlatformOverviewResponse, error) {
	return r.DoGetPlatformOverview(ctx, timeRange)
}

// Usage is the resolver for the usage field.
func (r *analyticsResolver) Usage(ctx context.Context, obj *markers.Analytics) (*markers.AnalyticsUsage, error) {
	return &markers.AnalyticsUsage{}, nil
}

// Health is the resolver for the health field.
func (r *analyticsResolver) Health(ctx context.Context, obj *markers.Analytics) (*markers.AnalyticsHealth, error) {
	return &markers.AnalyticsHealth{}, nil
}

// Lifecycle is the resolver for the lifecycle field.
func (r *analyticsResolver) Lifecycle(ctx context.Context, obj *markers.Analytics) (*markers.AnalyticsLifecycle, error) {
	return &markers.AnalyticsLifecycle{}, nil
}

// Infra is the resolver for the infra field.
func (r *analyticsResolver) Infra(ctx context.Context, obj *markers.Analytics) (*markers.AnalyticsInfra, error) {
	return &markers.AnalyticsInfra{}, nil
}

// StreamHealthConnection is the resolver for the streamHealthConnection field.
func (r *analyticsHealthResolver) StreamHealthConnection(ctx context.Context, obj *markers.AnalyticsHealth, page *model.ConnectionInput, streamID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.StreamHealthMetricsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	streamName := ""
	if streamID != nil {
		streamName = *streamID
	}
	return r.DoGetStreamHealthMetricsConnection(ctx, streamName, timeRange, first, after, last, before, noCache)
}

// StreamHealth5mConnection is the resolver for the streamHealth5mConnection field.
func (r *analyticsHealthResolver) StreamHealth5mConnection(ctx context.Context, obj *markers.AnalyticsHealth, page *model.ConnectionInput, streamID string, timeRange *model.TimeRangeInput, noCache *bool) (*model.StreamHealth5mConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetStreamHealth5mConnection(ctx, streamID, timeRange, first, after, last, before, noCache)
}

// RebufferingEventsConnection is the resolver for the rebufferingEventsConnection field.
func (r *analyticsHealthResolver) RebufferingEventsConnection(ctx context.Context, obj *markers.AnalyticsHealth, page *model.ConnectionInput, streamID *string, nodeID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.RebufferingEventsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetRebufferingEventsConnection(ctx, streamID, nodeID, timeRange, first, after, last, before, noCache)
}

// ClientQoeConnection is the resolver for the clientQoeConnection field.
func (r *analyticsHealthResolver) ClientQoeConnection(ctx context.Context, obj *markers.AnalyticsHealth, page *model.ConnectionInput, streamID *string, nodeID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.ClientMetrics5mConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetClientMetrics5mConnection(ctx, streamID, nodeID, timeRange, first, after, last, before, noCache)
}

// StreamHealthSummary is the resolver for the streamHealthSummary field.
func (r *analyticsHealthResolver) StreamHealthSummary(ctx context.Context, obj *markers.AnalyticsHealth, streamID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.StreamHealthSummary, error) {
	return r.DoGetStreamHealthSummary(ctx, streamID, timeRange, noCache)
}

// ClientQoeSummary is the resolver for the clientQoeSummary field.
func (r *analyticsHealthResolver) ClientQoeSummary(ctx context.Context, obj *markers.AnalyticsHealth, streamID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.ClientQoeSummary, error) {
	return r.DoGetClientQoeSummary(ctx, streamID, timeRange, noCache)
}

// RoutingEventsConnection is the resolver for the routingEventsConnection field.
func (r *analyticsInfraResolver) RoutingEventsConnection(ctx context.Context, obj *markers.AnalyticsInfra, page *model.ConnectionInput, streamID *string, timeRange *model.TimeRangeInput, subjectTenantID *string, clusterID *string, noCache *bool) (*model.RoutingEventsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetRoutingEventsConnection(ctx, streamID, timeRange, subjectTenantID, clusterID, first, after, last, before, noCache)
}

// NodeMetricsConnection is the resolver for the nodeMetricsConnection field.
func (r *analyticsInfraResolver) NodeMetricsConnection(ctx context.Context, obj *markers.AnalyticsInfra, page *model.ConnectionInput, nodeID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.NodeMetricsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetNodeMetricsConnection(ctx, nodeID, timeRange, first, after, last, before, noCache)
}

// NodeMetrics1hConnection is the resolver for the nodeMetrics1hConnection field.
func (r *analyticsInfraResolver) NodeMetrics1hConnection(ctx context.Context, obj *markers.AnalyticsInfra, page *model.ConnectionInput, timeRange *model.TimeRangeInput, nodeID *string, noCache *bool) (*model.NodeMetrics1hConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetNodeMetrics1hConnection(ctx, timeRange, nodeID, first, after, last, before, noCache)
}

// NodeMetricsAggregated is the resolver for the nodeMetricsAggregated field.
func (r *analyticsInfraResolver) NodeMetricsAggregated(ctx context.Context, obj *markers.AnalyticsInfra, timeRange *model.TimeRangeInput, nodeID *string, noCache *bool) ([]*proto.NodeMetricsAggregated, error) {
	return r.DoGetNodeMetricsAggregated(ctx, timeRange, nodeID, noCache)
}

// NodePerformance5mConnection is the resolver for the nodePerformance5mConnection field.
func (r *analyticsInfraResolver) NodePerformance5mConnection(ctx context.Context, obj *markers.AnalyticsInfra, page *model.ConnectionInput, nodeID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.NodePerformance5mConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetNodePerformance5mConnection(ctx, nodeID, timeRange, first, after, last, before, noCache)
}

// ServiceInstancesConnection is the resolver for the serviceInstancesConnection field.
func (r *analyticsInfraResolver) ServiceInstancesConnection(ctx context.Context, obj *markers.AnalyticsInfra, page *model.ConnectionInput, clusterID *string, nodeID *string, status *model.InstanceStatus) (*model.ServiceInstancesConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetServiceInstancesConnection(ctx, clusterID, nodeID, status, first, after, last, before)
}

// ServiceInstancesHealth is the resolver for the serviceInstancesHealth field.
func (r *analyticsInfraResolver) ServiceInstancesHealth(ctx context.Context, obj *markers.AnalyticsInfra, serviceID *string) ([]*proto.ServiceInstanceHealth, error) {
	var resp *proto.ListServicesHealthResponse
	var err error
	if serviceID != nil && *serviceID != "" {
		resp, err = r.Clients.Quartermaster.GetServiceHealth(ctx, *serviceID)
	} else {
		resp, err = r.Clients.Quartermaster.ListServicesHealth(ctx, nil)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get service health: %w", err)
	}
	return resp.Instances, nil
}

// RoutingEfficiency is the resolver for the routingEfficiency field.
func (r *analyticsInfraResolver) RoutingEfficiency(ctx context.Context, obj *markers.AnalyticsInfra, streamID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.RoutingEfficiency, error) {
	return r.DoGetRoutingEfficiency(ctx, streamID, timeRange, noCache)
}

// StreamEventsConnection is the resolver for the streamEventsConnection field.
func (r *analyticsLifecycleResolver) StreamEventsConnection(ctx context.Context, obj *markers.AnalyticsLifecycle, page *model.ConnectionInput, streamID string, timeRange *model.TimeRangeInput, noCache *bool) (*model.StreamEventsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetStreamEventsConnection(ctx, streamID, timeRange, first, after, last, before, noCache)
}

// BufferEventsConnection is the resolver for the bufferEventsConnection field.
func (r *analyticsLifecycleResolver) BufferEventsConnection(ctx context.Context, obj *markers.AnalyticsLifecycle, page *model.ConnectionInput, streamID string, timeRange *model.TimeRangeInput, noCache *bool) (*model.BufferEventsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetBufferEventsConnection(ctx, streamID, timeRange, first, after, last, before, noCache)
}

// ArtifactEventsConnection is the resolver for the artifactEventsConnection field.
func (r *analyticsLifecycleResolver) ArtifactEventsConnection(ctx context.Context, obj *markers.AnalyticsLifecycle, page *model.ConnectionInput, streamID *string, stage *string, contentType *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.ArtifactEventsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetArtifactEventsConnection(ctx, streamID, stage, contentType, timeRange, first, after, last, before, noCache)
}

// StorageEventsConnection is the resolver for the storageEventsConnection field.
func (r *analyticsLifecycleResolver) StorageEventsConnection(ctx context.Context, obj *markers.AnalyticsLifecycle, page *model.ConnectionInput, assetType *string, streamID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.StorageEventsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetStorageEventsConnection(ctx, streamID, assetType, timeRange, first, after, last, before, noCache)
}

// ConnectionEventsConnection is the resolver for the connectionEventsConnection field.
func (r *analyticsLifecycleResolver) ConnectionEventsConnection(ctx context.Context, obj *markers.AnalyticsLifecycle, page *model.ConnectionInput, streamID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.ConnectionEventsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetConnectionEventsConnection(ctx, streamID, timeRange, first, after, last, before, noCache)
}

// ViewerSessionsConnection is the resolver for the viewerSessionsConnection field.
func (r *analyticsLifecycleResolver) ViewerSessionsConnection(ctx context.Context, obj *markers.AnalyticsLifecycle, page *model.ConnectionInput, streamID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.ViewerSessionsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetViewerSessionsConnection(ctx, streamID, timeRange, first, after, last, before, noCache)
}

// TrackListConnection is the resolver for the trackListConnection field.
func (r *analyticsLifecycleResolver) TrackListConnection(ctx context.Context, obj *markers.AnalyticsLifecycle, page *model.ConnectionInput, streamID string, timeRange *model.TimeRangeInput, noCache *bool) (*model.TrackListEventsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetTrackListEventsConnection(ctx, streamID, timeRange, first, after, last, before, noCache)
}

// ArtifactStatesConnection is the resolver for the artifactStatesConnection field.
func (r *analyticsLifecycleResolver) ArtifactStatesConnection(ctx context.Context, obj *markers.AnalyticsLifecycle, page *model.ConnectionInput, streamID *string, contentType *string, stage *string) (*model.ArtifactStatesConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetArtifactStatesConnection(ctx, streamID, contentType, stage, first, after, last, before)
}

// Streaming is the resolver for the streaming field.
func (r *analyticsUsageResolver) Streaming(ctx context.Context, obj *markers.AnalyticsUsage) (*markers.StreamingUsage, error) {
	return &markers.StreamingUsage{}, nil
}

// Storage is the resolver for the storage field.
func (r *analyticsUsageResolver) Storage(ctx context.Context, obj *markers.AnalyticsUsage) (*markers.StorageUsage, error) {
	return &markers.StorageUsage{}, nil
}

// Processing is the resolver for the processing field.
func (r *analyticsUsageResolver) Processing(ctx context.Context, obj *markers.AnalyticsUsage) (*markers.ProcessingUsage, error) {
	return &markers.ProcessingUsage{}, nil
}

// API is the resolver for the api field.
func (r *analyticsUsageResolver) API(ctx context.Context, obj *markers.AnalyticsUsage) (*markers.APIUsage, error) {
	return &markers.APIUsage{}, nil
}

// ID is the resolver for the id field.
func (r *artifactEventResolver) ID(ctx context.Context, obj *proto.ClipEvent) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeArtifactEvent, obj.StreamId, obj.RequestId, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *artifactEventResolver) Timestamp(ctx context.Context, obj *proto.ClipEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamID resolvers normalize stream references to Relay global IDs.
func (r *artifactEventResolver) StreamID(ctx context.Context, obj *proto.ClipEvent) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *artifactEventResolver) Stream(ctx context.Context, obj *proto.ClipEvent) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// PlaybackID is the resolver for the playbackId field.
func (r *artifactEventResolver) PlaybackID(ctx context.Context, obj *proto.ClipEvent) (*string, error) {
	return r.resolveArtifactPlaybackID(ctx, obj.GetContentType(), obj.GetRequestId()), nil
}

// Percent is the resolver for the percent field.
func (r *artifactEventResolver) Percent(ctx context.Context, obj *proto.ClipEvent) (*int, error) {
	if obj.Percent == nil {
		return nil, nil
	}
	v := int(*obj.Percent)
	return &v, nil
}

// FilePath is the resolver for the filePath field.
func (r *artifactEventResolver) FilePath(ctx context.Context, obj *proto.ClipEvent) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if obj.FilePath == nil || *obj.FilePath == "" {
		return nil, nil
	}
	return obj.FilePath, nil
}

// S3Url is the resolver for the s3Url field.
func (r *artifactEventResolver) S3Url(ctx context.Context, obj *proto.ClipEvent) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if obj.S3Url == nil || *obj.S3Url == "" {
		return nil, nil
	}
	return obj.S3Url, nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *artifactEventResolver) SizeBytes(ctx context.Context, obj *proto.ClipEvent) (*float64, error) {
	if obj.SizeBytes == nil {
		return nil, nil
	}
	v := float64(*obj.SizeBytes)
	return &v, nil
}

// StreamID is the resolver for the streamId field.
func (r *artifactStateResolver) StreamID(ctx context.Context, obj *proto.ArtifactState) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *artifactStateResolver) Stream(ctx context.Context, obj *proto.ArtifactState) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// PlaybackID is the resolver for the playbackId field.
func (r *artifactStateResolver) PlaybackID(ctx context.Context, obj *proto.ArtifactState) (*string, error) {
	return r.resolveArtifactPlaybackID(ctx, obj.GetContentType(), obj.GetRequestId()), nil
}

// ProgressPercent is the resolver for the progressPercent field.
func (r *artifactStateResolver) ProgressPercent(ctx context.Context, obj *proto.ArtifactState) (int, error) {
	return int(obj.ProgressPercent), nil
}

// RequestedAt is the resolver for the requestedAt field.
func (r *artifactStateResolver) RequestedAt(ctx context.Context, obj *proto.ArtifactState) (*time.Time, error) {
	if obj.RequestedAt == nil {
		return nil, nil
	}
	t := obj.RequestedAt.AsTime()
	return &t, nil
}

// StartedAt is the resolver for the startedAt field.
func (r *artifactStateResolver) StartedAt(ctx context.Context, obj *proto.ArtifactState) (*time.Time, error) {
	if obj.StartedAt == nil {
		return nil, nil
	}
	t := obj.StartedAt.AsTime()
	return &t, nil
}

// CompletedAt is the resolver for the completedAt field.
func (r *artifactStateResolver) CompletedAt(ctx context.Context, obj *proto.ArtifactState) (*time.Time, error) {
	if obj.CompletedAt == nil {
		return nil, nil
	}
	t := obj.CompletedAt.AsTime()
	return &t, nil
}

// SegmentCount is the resolver for the segmentCount field.
func (r *artifactStateResolver) SegmentCount(ctx context.Context, obj *proto.ArtifactState) (*int, error) {
	if obj.SegmentCount == nil {
		return nil, nil
	}
	v := int(*obj.SegmentCount)
	return &v, nil
}

// ManifestPath is the resolver for the manifestPath field.
func (r *artifactStateResolver) ManifestPath(ctx context.Context, obj *proto.ArtifactState) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if obj.ManifestPath == nil || *obj.ManifestPath == "" {
		return nil, nil
	}
	return obj.ManifestPath, nil
}

// FilePath is the resolver for the filePath field.
func (r *artifactStateResolver) FilePath(ctx context.Context, obj *proto.ArtifactState) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if obj.FilePath == nil || *obj.FilePath == "" {
		return nil, nil
	}
	return obj.FilePath, nil
}

// S3Url is the resolver for the s3Url field.
func (r *artifactStateResolver) S3Url(ctx context.Context, obj *proto.ArtifactState) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if obj.S3Url == nil || *obj.S3Url == "" {
		return nil, nil
	}
	return obj.S3Url, nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *artifactStateResolver) SizeBytes(ctx context.Context, obj *proto.ArtifactState) (*float64, error) {
	if obj.SizeBytes == nil {
		return nil, nil
	}
	v := float64(*obj.SizeBytes)
	return &v, nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *artifactStateResolver) ExpiresAt(ctx context.Context, obj *proto.ArtifactState) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *billingDetailsResolver) UpdatedAt(ctx context.Context, obj *proto.BillingDetails) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// CurrentTier is the resolver for the currentTier field.
func (r *billingStatusResolver) CurrentTier(ctx context.Context, obj *proto.BillingStatusResponse) (*proto.BillingTier, error) {
	return obj.Tier, nil
}

// NextBillingDate is the resolver for the nextBillingDate field.
func (r *billingStatusResolver) NextBillingDate(ctx context.Context, obj *proto.BillingStatusResponse) (*time.Time, error) {
	if obj.NextBillingDate == nil {
		return nil, nil
	}
	t := obj.NextBillingDate.AsTime()
	return &t, nil
}

// TrialEndsAt is the resolver for the trialEndsAt field.
func (r *billingStatusResolver) TrialEndsAt(ctx context.Context, obj *proto.BillingStatusResponse) (*time.Time, error) {
	if obj.Subscription == nil || obj.Subscription.TrialEndsAt == nil || !obj.Subscription.TrialEndsAt.IsValid() {
		return nil, nil
	}
	t := obj.Subscription.TrialEndsAt.AsTime()
	return &t, nil
}

// LiveUsage is the resolver for the liveUsage field.
func (r *billingStatusResolver) LiveUsage(ctx context.Context, obj *proto.BillingStatusResponse) (*proto.LiveUsageSummary, error) {
	preview, _ := r.DoGetInvoicePreview(ctx)
	var startTime, endTime *time.Time
	if preview != nil {
		if preview.PeriodStart != nil {
			start := preview.PeriodStart.AsTime()
			startTime = &start
		}
		if preview.PeriodEnd != nil {
			end := preview.PeriodEnd.AsTime()
			endTime = &end
		}
	}
	return r.DoGetLiveUsageSummary(ctx, startTime, endTime)
}

// InvoicePreview is the resolver for the invoicePreview field.
func (r *billingStatusResolver) InvoicePreview(ctx context.Context, obj *proto.BillingStatusResponse) (*proto.Invoice, error) {
	return r.DoGetInvoicePreview(ctx)
}

// Metadata is the resolver for the metadata field.
func (r *bootstrapTokenResolver) Metadata(ctx context.Context, obj *proto.BootstrapToken) (*string, error) {
	if obj.Metadata == nil {
		return nil, nil
	}
	b, err := json.Marshal(obj.Metadata.AsMap())
	if err != nil {
		return nil, err
	}
	s := string(b)
	return &s, nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *bootstrapTokenResolver) ExpiresAt(ctx context.Context, obj *proto.BootstrapToken) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// UsedAt is the resolver for the usedAt field.
func (r *bootstrapTokenResolver) UsedAt(ctx context.Context, obj *proto.BootstrapToken) (*time.Time, error) {
	if obj.UsedAt == nil {
		return nil, nil
	}
	t := obj.UsedAt.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *bootstrapTokenResolver) CreatedAt(ctx context.Context, obj *proto.BootstrapToken) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// ID is the resolver for the id field.
func (r *bufferEventResolver) ID(ctx context.Context, obj *proto.BufferEvent) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeBufferEvent, obj.StreamId, obj.EventId, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *bufferEventResolver) Timestamp(ctx context.Context, obj *proto.BufferEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// BufferState is the resolver for the bufferState field.
func (r *bufferEventResolver) BufferState(ctx context.Context, obj *proto.BufferEvent) (model.BufferState, error) {
	s := strings.ToUpper(obj.Status)
	switch s {
	case "FULL":
		return model.BufferStateFull, nil
	case "EMPTY":
		return model.BufferStateEmpty, nil
	case "DRY":
		return model.BufferStateDry, nil
	case "RECOVER":
		return model.BufferStateRecover, nil
	case "RECOVERING":
		return model.BufferStateRecover, nil
	default:
		return model.BufferStateRecover, nil
	}
}

// Payload is the resolver for the payload field.
func (r *bufferEventResolver) Payload(ctx context.Context, obj *proto.BufferEvent) (*string, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.EventPayload != nil {
		payload, err := json.Marshal(obj.EventPayload.AsMap())
		if err != nil {
			return nil, fmt.Errorf("failed to marshal buffer event payload: %w", err)
		}
		result := string(payload)
		return &result, nil
	}
	if obj.EventData != "" {
		v := obj.EventData
		return &v, nil
	}
	return nil, nil
}

// Percentage is the resolver for the percentage field.
func (r *cityMetricResolver) Percentage(ctx context.Context, obj *proto.CityMetric) (float64, error) {
	return float64(obj.Percentage), nil
}

// ID is the resolver for the id field.
func (r *clientMetrics5mResolver) ID(ctx context.Context, obj *proto.ClientMetrics5M) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeClientMetrics5m, obj.StreamId, obj.NodeId, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *clientMetrics5mResolver) Timestamp(ctx context.Context, obj *proto.ClientMetrics5M) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *clientMetrics5mResolver) StreamID(ctx context.Context, obj *proto.ClientMetrics5M) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *clientMetrics5mResolver) Stream(ctx context.Context, obj *proto.ClientMetrics5M) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// ActiveSessions is the resolver for the activeSessions field.
func (r *clientMetrics5mResolver) ActiveSessions(ctx context.Context, obj *proto.ClientMetrics5M) (int, error) {
	return int(obj.ActiveSessions), nil
}

// AvgConnectionTime is the resolver for the avgConnectionTime field.
func (r *clientMetrics5mResolver) AvgConnectionTime(ctx context.Context, obj *proto.ClientMetrics5M) (float64, error) {
	return float64(obj.AvgConnectionTime), nil
}

// PacketLossRate is the resolver for the packetLossRate field.
func (r *clientMetrics5mResolver) PacketLossRate(ctx context.Context, obj *proto.ClientMetrics5M) (*float64, error) {
	if obj.PacketLossRate == nil {
		return nil, nil
	}
	value := float64(*obj.PacketLossRate)
	return &value, nil
}

// ID is the resolver for the id field.
func (r *clipResolver) ID(ctx context.Context, obj *proto.ClipInfo) (string, error) {
	if obj.ClipHash != "" {
		return globalid.Encode(globalid.TypeClip, obj.ClipHash), nil
	}
	return globalid.Encode(globalid.TypeClip, obj.Id), nil
}

// StreamID is the resolver for the streamId field.
func (r *clipResolver) StreamID(ctx context.Context, obj *proto.ClipInfo) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *clipResolver) Stream(ctx context.Context, obj *proto.ClipInfo) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// NodeID is the resolver for the nodeId field.
func (r *clipResolver) NodeID(ctx context.Context, obj *proto.ClipInfo) (*string, error) {
	if state := r.getLifecycleData(ctx, obj.ClipHash); state != nil && state.ProcessingNodeId != nil && *state.ProcessingNodeId != "" {
		return state.ProcessingNodeId, nil
	}
	if obj.NodeId != "" {
		return &obj.NodeId, nil
	}
	return nil, nil
}

// StoragePath is the resolver for the storagePath field.
func (r *clipResolver) StoragePath(ctx context.Context, obj *proto.ClipInfo) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if state := r.getLifecycleData(ctx, obj.ClipHash); state != nil && state.FilePath != nil && *state.FilePath != "" {
		return state.FilePath, nil
	}
	if obj.StoragePath != "" {
		return &obj.StoragePath, nil
	}
	return nil, nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *clipResolver) SizeBytes(ctx context.Context, obj *proto.ClipInfo) (*float64, error) {
	if state := r.getLifecycleData(ctx, obj.ClipHash); state != nil && state.SizeBytes != nil {
		size := float64(*state.SizeBytes)
		return &size, nil
	}
	if obj.SizeBytes != nil {
		size := float64(*obj.SizeBytes)
		return &size, nil
	}
	return nil, nil
}

// Status is the resolver for the status field.
// Fetches lifecycle data from Periscope - the source of truth for processing status.
func (r *clipResolver) Status(ctx context.Context, obj *proto.ClipInfo) (string, error) {
	if state := r.getLifecycleData(ctx, obj.ClipHash); state != nil && state.Stage != "" {
		return state.Stage, nil
	}
	if obj.Status != "" {
		return obj.Status, nil
	}
	return "unknown", nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *clipResolver) CreatedAt(ctx context.Context, obj *proto.ClipInfo) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *clipResolver) UpdatedAt(ctx context.Context, obj *proto.ClipInfo) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// StorageLocation is the resolver for the storageLocation field.
func (r *clipResolver) StorageLocation(ctx context.Context, obj *proto.ClipInfo) (*string, error) {
	state := r.getLifecycleData(ctx, obj.ClipHash)
	if state == nil {
		return nil, nil
	}
	if state != nil && state.S3Url != nil && *state.S3Url != "" {
		loc := "s3"
		return &loc, nil
	}
	loc := "local"
	return &loc, nil
}

// IsFrozen is the resolver for the isFrozen field.
func (r *clipResolver) IsFrozen(ctx context.Context, obj *proto.ClipInfo) (*bool, error) {
	// Frozen if stored in S3 (has S3 URL in lifecycle data)
	state := r.getLifecycleData(ctx, obj.ClipHash)
	if state == nil {
		return nil, nil
	}
	frozen := state.S3Url != nil && *state.S3Url != ""
	return &frozen, nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *clipResolver) ExpiresAt(ctx context.Context, obj *proto.ClipInfo) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// IsExpired is the resolver for the isExpired field.
func (r *clipResolver) IsExpired(ctx context.Context, obj *proto.ClipInfo) (bool, error) {
	return obj.ExpiresAt != nil && obj.ExpiresAt.AsTime().Before(time.Now()), nil
}

// Stage is the resolver for the stage field.
func (r *clipLifecycleResolver) Stage(ctx context.Context, obj *proto.ClipLifecycleData) (int, error) {
	return int(obj.Stage), nil
}

// PlaybackID is the resolver for the playbackId field.
func (r *clipLifecycleResolver) PlaybackID(ctx context.Context, obj *proto.ClipLifecycleData) (*string, error) {
	return r.resolveArtifactPlaybackID(ctx, "clip", obj.GetClipHash()), nil
}

// ProgressPercent is the resolver for the progressPercent field.
func (r *clipLifecycleResolver) ProgressPercent(ctx context.Context, obj *proto.ClipLifecycleData) (*int, error) {
	if obj.ProgressPercent == nil {
		return nil, nil
	}
	v := int(*obj.ProgressPercent)
	return &v, nil
}

// FilePath is the resolver for the filePath field.
func (r *clipLifecycleResolver) FilePath(ctx context.Context, obj *proto.ClipLifecycleData) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if obj.FilePath == nil || *obj.FilePath == "" {
		return nil, nil
	}
	return obj.FilePath, nil
}

// S3Url is the resolver for the s3Url field.
func (r *clipLifecycleResolver) S3Url(ctx context.Context, obj *proto.ClipLifecycleData) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if obj.S3Url == nil || *obj.S3Url == "" {
		return nil, nil
	}
	return obj.S3Url, nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *clipLifecycleResolver) SizeBytes(ctx context.Context, obj *proto.ClipLifecycleData) (*float64, error) {
	if obj.SizeBytes == nil {
		return nil, nil
	}
	v := float64(*obj.SizeBytes)
	return &v, nil
}

// StreamID is the resolver for the streamId field.
func (r *clipLifecycleResolver) StreamID(ctx context.Context, obj *proto.ClipLifecycleData) (*string, error) {
	return encodeStreamIDOptional(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *clipLifecycleResolver) Stream(ctx context.Context, obj *proto.ClipLifecycleData) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// ID is the resolver for the id field.
func (r *clusterResolver) ID(ctx context.Context, obj *proto.InfrastructureCluster) (string, error) {
	return globalid.Encode(globalid.TypeCluster, obj.Id), nil
}

// IsSubscribed is the resolver for the isSubscribed field.
func (r *clusterResolver) IsSubscribed(ctx context.Context, obj *proto.InfrastructureCluster) (bool, error) {
	return r.DoCheckIsSubscribed(ctx, obj)
}

// CreatedAt is the resolver for the createdAt field.
func (r *clusterResolver) CreatedAt(ctx context.Context, obj *proto.InfrastructureCluster) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *clusterResolver) UpdatedAt(ctx context.Context, obj *proto.InfrastructureCluster) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// NodesConnection is the resolver for the nodesConnection field.
func (r *clusterResolver) NodesConnection(ctx context.Context, obj *proto.InfrastructureCluster, page *model.ConnectionInput) (*model.NodesConnection, error) {
	// Reuse DoGetNodesConnection with cluster ID filter
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetNodesConnection(ctx, &obj.Id, nil, nil, first, after, last, before)
}

// ResourceLimits is the resolver for the resourceLimits field.
func (r *clusterInviteResolver) ResourceLimits(ctx context.Context, obj *proto.ClusterInvite) (*string, error) {
	if obj.ResourceLimits == nil {
		return nil, nil
	}
	b, err := obj.ResourceLimits.MarshalJSON()
	if err != nil {
		return nil, fmt.Errorf("failed to marshal cluster invite resource limits: %w", err)
	}
	s := string(b)
	return &s, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *clusterInviteResolver) CreatedAt(ctx context.Context, obj *proto.ClusterInvite) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *clusterInviteResolver) ExpiresAt(ctx context.Context, obj *proto.ClusterInvite) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// AcceptedAt is the resolver for the acceptedAt field.
func (r *clusterInviteResolver) AcceptedAt(ctx context.Context, obj *proto.ClusterInvite) (*time.Time, error) {
	if obj.AcceptedAt == nil {
		return nil, nil
	}
	t := obj.AcceptedAt.AsTime()
	return &t, nil
}

// ResourceLimits is the resolver for the resourceLimits field.
func (r *clusterSubscriptionResolver) ResourceLimits(ctx context.Context, obj *proto.ClusterSubscription) (*string, error) {
	if obj.ResourceLimits == nil {
		return nil, nil
	}
	b, err := obj.ResourceLimits.MarshalJSON()
	if err != nil {
		return nil, fmt.Errorf("failed to marshal cluster subscription resource limits: %w", err)
	}
	s := string(b)
	return &s, nil
}

// RequestedAt is the resolver for the requestedAt field.
func (r *clusterSubscriptionResolver) RequestedAt(ctx context.Context, obj *proto.ClusterSubscription) (*time.Time, error) {
	if obj.RequestedAt == nil {
		return nil, nil
	}
	t := obj.RequestedAt.AsTime()
	return &t, nil
}

// ApprovedAt is the resolver for the approvedAt field.
func (r *clusterSubscriptionResolver) ApprovedAt(ctx context.Context, obj *proto.ClusterSubscription) (*time.Time, error) {
	if obj.ApprovedAt == nil {
		return nil, nil
	}
	t := obj.ApprovedAt.AsTime()
	return &t, nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *clusterSubscriptionResolver) ExpiresAt(ctx context.Context, obj *proto.ClusterSubscription) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *clusterSubscriptionResolver) CreatedAt(ctx context.Context, obj *proto.ClusterSubscription) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *clusterSubscriptionResolver) UpdatedAt(ctx context.Context, obj *proto.ClusterSubscription) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// ID is the resolver for the id field.
func (r *connectionEventResolver) ID(ctx context.Context, obj *proto.ConnectionEvent) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeConnectionEvent, obj.StreamId, obj.EventId, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *connectionEventResolver) Timestamp(ctx context.Context, obj *proto.ConnectionEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *connectionEventResolver) StreamID(ctx context.Context, obj *proto.ConnectionEvent) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *connectionEventResolver) Stream(ctx context.Context, obj *proto.ConnectionEvent) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// ConnectionAddr is the resolver for the connectionAddr field.
func (r *connectionEventResolver) ConnectionAddr(ctx context.Context, obj *proto.ConnectionEvent) (*string, error) {
	// Redacted for privacy - client IPs are not exposed via API
	return nil, nil
}

// SessionDurationSeconds is the resolver for the sessionDurationSeconds field.
func (r *connectionEventResolver) SessionDurationSeconds(ctx context.Context, obj *proto.ConnectionEvent) (*int, error) {
	if obj.SessionDurationSeconds == 0 {
		return nil, nil
	}
	v := int(obj.SessionDurationSeconds)
	return &v, nil
}

// BytesTransferred is the resolver for the bytesTransferred field.
func (r *connectionEventResolver) BytesTransferred(ctx context.Context, obj *proto.ConnectionEvent) (*float64, error) {
	if obj.BytesTransferred == 0 {
		return nil, nil
	}
	v := float64(obj.BytesTransferred)
	return &v, nil
}

// Percentage is the resolver for the percentage field.
func (r *countryMetricResolver) Percentage(ctx context.Context, obj *proto.CountryMetric) (float64, error) {
	return float64(obj.GetPercentage()), nil
}

// Status is the resolver for the status field.
func (r *dVREventResolver) Status(ctx context.Context, obj *proto.DVRLifecycleData) (string, error) {
	return obj.Status.String(), nil
}

// PlaybackID is the resolver for the playbackId field.
func (r *dVREventResolver) PlaybackID(ctx context.Context, obj *proto.DVRLifecycleData) (*string, error) {
	return r.resolveArtifactPlaybackID(ctx, "dvr", obj.GetDvrHash()), nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *dVREventResolver) SizeBytes(ctx context.Context, obj *proto.DVRLifecycleData) (*float64, error) {
	if obj.SizeBytes == nil {
		return nil, nil
	}
	v := float64(*obj.SizeBytes)
	return &v, nil
}

// StreamID is the resolver for the streamId field.
func (r *dVREventResolver) StreamID(ctx context.Context, obj *proto.DVRLifecycleData) (*string, error) {
	return encodeStreamIDOptional(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *dVREventResolver) Stream(ctx context.Context, obj *proto.DVRLifecycleData) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// StreamID is the resolver for the streamId field.
func (r *dVRRequestResolver) StreamID(ctx context.Context, obj *proto.DVRInfo) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *dVRRequestResolver) Stream(ctx context.Context, obj *proto.DVRInfo) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// CreatedAt is the resolver for the createdAt field.
// Business metadata - from Commodore registry.
func (r *dVRRequestResolver) CreatedAt(ctx context.Context, obj *proto.DVRInfo) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
// Business metadata - from Commodore registry.
func (r *dVRRequestResolver) UpdatedAt(ctx context.Context, obj *proto.DVRInfo) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// ExpiresAt is the resolver for the expiresAt field.
// Business metadata - from Commodore registry.
func (r *dVRRequestResolver) ExpiresAt(ctx context.Context, obj *proto.DVRInfo) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// IsExpired is the resolver for the isExpired field.
func (r *dVRRequestResolver) IsExpired(ctx context.Context, obj *proto.DVRInfo) (bool, error) {
	return obj.ExpiresAt != nil && obj.ExpiresAt.AsTime().Before(time.Now()), nil
}

// StorageNodeID is the resolver for the storageNodeId field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) StorageNodeID(ctx context.Context, obj *proto.DVRInfo) (*string, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.ProcessingNodeId != nil && *state.ProcessingNodeId != "" {
		return state.ProcessingNodeId, nil
	}
	return nil, nil
}

// Status is the resolver for the status field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) Status(ctx context.Context, obj *proto.DVRInfo) (*string, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.Stage != "" {
		return &state.Stage, nil
	}
	if obj.Status != "" {
		return &obj.Status, nil
	}
	status := "unknown"
	return &status, nil
}

// StartedAt is the resolver for the startedAt field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) StartedAt(ctx context.Context, obj *proto.DVRInfo) (*time.Time, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.StartedAt != nil {
		t := state.StartedAt.AsTime()
		return &t, nil
	}
	if obj.StartedAt != nil {
		t := obj.StartedAt.AsTime()
		return &t, nil
	}
	return nil, nil
}

// EndedAt is the resolver for the endedAt field.
// Lifecycle data - from Periscope (CompletedAt maps to EndedAt).
func (r *dVRRequestResolver) EndedAt(ctx context.Context, obj *proto.DVRInfo) (*time.Time, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.CompletedAt != nil {
		t := state.CompletedAt.AsTime()
		return &t, nil
	}
	if obj.EndedAt != nil {
		t := obj.EndedAt.AsTime()
		return &t, nil
	}
	return nil, nil
}

// DurationSeconds is the resolver for the durationSeconds field.
// Note: Duration may need to be computed from start/end times in lifecycle data.
// For now, we rely on business registry data as duration is often stored there.
func (r *dVRRequestResolver) DurationSeconds(ctx context.Context, obj *proto.DVRInfo) (*int, error) {
	// Try to calculate from lifecycle data timestamps
	state := r.getLifecycleData(ctx, obj.DvrHash)
	if state != nil && state.StartedAt != nil && state.CompletedAt != nil {
		duration := int(state.CompletedAt.AsTime().Sub(state.StartedAt.AsTime()).Seconds())
		if duration > 0 {
			return &duration, nil
		}
	}
	// Fallback to business data
	if obj.DurationSeconds != nil {
		duration := int(*obj.DurationSeconds)
		return &duration, nil
	}
	return nil, nil
}

// SizeBytes is the resolver for the sizeBytes field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) SizeBytes(ctx context.Context, obj *proto.DVRInfo) (*float64, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.SizeBytes != nil {
		size := float64(*state.SizeBytes)
		return &size, nil
	}
	if obj.SizeBytes != nil {
		size := float64(*obj.SizeBytes)
		return &size, nil
	}
	return nil, nil
}

// ManifestPath is the resolver for the manifestPath field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) ManifestPath(ctx context.Context, obj *proto.DVRInfo) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.ManifestPath != nil && *state.ManifestPath != "" {
		return state.ManifestPath, nil
	}
	return nil, nil
}

// ErrorMessage is the resolver for the errorMessage field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) ErrorMessage(ctx context.Context, obj *proto.DVRInfo) (*string, error) {
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.ErrorMessage != nil && *state.ErrorMessage != "" {
		return state.ErrorMessage, nil
	}
	return nil, nil
}

// StorageLocation is the resolver for the storageLocation field.
// Lifecycle data - derived from S3 URL presence.
func (r *dVRRequestResolver) StorageLocation(ctx context.Context, obj *proto.DVRInfo) (*string, error) {
	state := r.getLifecycleData(ctx, obj.DvrHash)
	if state == nil {
		return nil, nil
	}
	if state.S3Url != nil && *state.S3Url != "" {
		loc := "s3"
		return &loc, nil
	}
	loc := "local"
	return &loc, nil
}

// IsFrozen is the resolver for the isFrozen field.
// Lifecycle data - true if stored in S3.
func (r *dVRRequestResolver) IsFrozen(ctx context.Context, obj *proto.DVRInfo) (*bool, error) {
	state := r.getLifecycleData(ctx, obj.DvrHash)
	if state == nil {
		return nil, nil
	}
	frozen := state.S3Url != nil && *state.S3Url != ""
	return &frozen, nil
}

// FrozenAt is the resolver for the frozenAt field.
// Business metadata - from Commodore registry (or could derive from lifecycle updates).
func (r *dVRRequestResolver) FrozenAt(ctx context.Context, obj *proto.DVRInfo) (*time.Time, error) {
	if obj.FrozenAt == nil {
		return nil, nil
	}
	t := obj.FrozenAt.AsTime()
	return &t, nil
}

// S3Url is the resolver for the s3Url field.
// Lifecycle data - from Periscope.
func (r *dVRRequestResolver) S3Url(ctx context.Context, obj *proto.DVRInfo) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if state := r.getLifecycleData(ctx, obj.DvrHash); state != nil && state.S3Url != nil && *state.S3Url != "" {
		return state.S3Url, nil
	}
	return nil, nil
}

// LastUsedAt is the resolver for the lastUsedAt field.
func (r *developerTokenResolver) LastUsedAt(ctx context.Context, obj *proto.APITokenInfo) (*time.Time, error) {
	if obj.LastUsedAt == nil {
		return nil, nil
	}
	t := obj.LastUsedAt.AsTime()
	return &t, nil
}

// ExpiresAt is the resolver for the expiresAt field.
func (r *developerTokenResolver) ExpiresAt(ctx context.Context, obj *proto.APITokenInfo) (*time.Time, error) {
	if obj.ExpiresAt == nil {
		return nil, nil
	}
	t := obj.ExpiresAt.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *developerTokenResolver) CreatedAt(ctx context.Context, obj *proto.APITokenInfo) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// H3Index is the resolver for the h3Index field.
func (r *geoBucketResolver) H3Index(ctx context.Context, obj *proto.GeoBucket) (string, error) {
	if obj == nil {
		return "", nil
	}
	// ClickHouse stores H3 as UInt64; present as hex string for frontend (h3-js expects hex)
	return strings.ToLower(strconv.FormatUint(obj.H3Index, 16)), nil
}

// Resolution is the resolver for the resolution field.
func (r *geoBucketResolver) Resolution(ctx context.Context, obj *proto.GeoBucket) (int, error) {
	if obj == nil {
		return 0, nil
	}
	return int(obj.Resolution), nil
}

// StreamID is the resolver for the streamId field.
func (r *geographicDistributionResolver) StreamID(ctx context.Context, obj *model.GeographicDistribution) (*string, error) {
	return encodeStreamIDOptionalPtr(obj.Stream)
}

// Stream is the resolver for the stream field.
func (r *geographicDistributionResolver) Stream(ctx context.Context, obj *model.GeographicDistribution) (*proto.Stream, error) {
	return r.resolveStreamByIDPtr(ctx, obj.Stream)
}

// ID is the resolver for the id field.
func (r *infrastructureNodeResolver) ID(ctx context.Context, obj *proto.InfrastructureNode) (string, error) {
	return globalid.Encode(globalid.TypeInfrastructureNode, obj.Id), nil
}

// InternalIP is the resolver for the internalIp field.
func (r *infrastructureNodeResolver) InternalIP(ctx context.Context, obj *proto.InfrastructureNode) (*string, error) {
	if !r.CanViewSensitiveInfraData(ctx, obj.ClusterId) {
		return nil, nil
	}
	if obj.InternalIp == nil || *obj.InternalIp == "" {
		return nil, nil
	}
	return obj.InternalIp, nil
}

// ExternalIP is the resolver for the externalIp field.
func (r *infrastructureNodeResolver) ExternalIP(ctx context.Context, obj *proto.InfrastructureNode) (*string, error) {
	if !r.CanViewSensitiveInfraData(ctx, obj.ClusterId) {
		return nil, nil
	}
	if obj.ExternalIp == nil || *obj.ExternalIp == "" {
		return nil, nil
	}
	return obj.ExternalIp, nil
}

// WireguardIP is the resolver for the wireguardIp field.
func (r *infrastructureNodeResolver) WireguardIP(ctx context.Context, obj *proto.InfrastructureNode) (*string, error) {
	if !r.CanViewSensitiveInfraData(ctx, obj.ClusterId) {
		return nil, nil
	}
	if obj.WireguardIp == nil || *obj.WireguardIp == "" {
		return nil, nil
	}
	return obj.WireguardIp, nil
}

// WireguardPublicKey is the resolver for the wireguardPublicKey field.
func (r *infrastructureNodeResolver) WireguardPublicKey(ctx context.Context, obj *proto.InfrastructureNode) (*string, error) {
	if !r.CanViewSensitiveInfraData(ctx, obj.ClusterId) {
		return nil, nil
	}
	if obj.WireguardPublicKey == nil || *obj.WireguardPublicKey == "" {
		return nil, nil
	}
	return obj.WireguardPublicKey, nil
}

// LastHeartbeat is the resolver for the lastHeartbeat field.
func (r *infrastructureNodeResolver) LastHeartbeat(ctx context.Context, obj *proto.InfrastructureNode) (*time.Time, error) {
	if obj.LastHeartbeat == nil {
		return nil, nil
	}
	t := obj.LastHeartbeat.AsTime()
	return &t, nil
}

// Tags is the resolver for the tags field.
func (r *infrastructureNodeResolver) Tags(ctx context.Context, obj *proto.InfrastructureNode) (*string, error) {
	if obj.Tags == nil {
		return nil, nil
	}
	b, err := json.Marshal(obj.Tags.AsMap())
	if err != nil {
		return nil, err
	}
	s := string(b)
	return &s, nil
}

// Metadata is the resolver for the metadata field.
func (r *infrastructureNodeResolver) Metadata(ctx context.Context, obj *proto.InfrastructureNode) (*string, error) {
	if !r.CanViewSensitiveInfraData(ctx, obj.ClusterId) {
		return nil, nil
	}
	if obj.Metadata == nil {
		return nil, nil
	}
	b, err := json.Marshal(obj.Metadata.AsMap())
	if err != nil {
		return nil, err
	}
	s := string(b)
	return &s, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *infrastructureNodeResolver) CreatedAt(ctx context.Context, obj *proto.InfrastructureNode) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *infrastructureNodeResolver) UpdatedAt(ctx context.Context, obj *proto.InfrastructureNode) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// MetricsConnection is the resolver for the metricsConnection field.
func (r *infrastructureNodeResolver) MetricsConnection(ctx context.Context, obj *proto.InfrastructureNode, page *model.ConnectionInput, timeRange *model.TimeRangeInput) (*model.NodeMetricsConnection, error) {
	first, after := mergeForwardConnectionInput(page, nil, nil)
	return r.DoGetNodeMetricsConnectionForNode(ctx, obj, timeRange, first, after)
}

// Metrics1hConnection is the resolver for the metrics1hConnection field.
func (r *infrastructureNodeResolver) Metrics1hConnection(ctx context.Context, obj *proto.InfrastructureNode, page *model.ConnectionInput, timeRange *model.TimeRangeInput) (*model.NodeMetrics1hConnection, error) {
	first, after := mergeForwardConnectionInput(page, nil, nil)
	return r.DoGetNodeMetrics1hConnectionForNode(ctx, obj, timeRange, first, after)
}

// LiveState is the resolver for the liveState field.
func (r *infrastructureNodeResolver) LiveState(ctx context.Context, obj *proto.InfrastructureNode) (*proto.LiveNode, error) {
	// In demo mode, return synthetic live state
	if middleware.IsDemoMode(ctx) {
		// Demo tenant ID - nodes belong to clusters which have owner_tenant_id
		demoTenantID := "5eed517e-ba5e-da7a-517e-ba5eda7a0001"
		var lat, lon float64
		if obj.Latitude != nil {
			lat = *obj.Latitude
		}
		if obj.Longitude != nil {
			lon = *obj.Longitude
		}
		return &proto.LiveNode{
			NodeId:         obj.NodeId,
			TenantId:       demoTenantID, // Infra owner tenant (cluster operator)
			CpuPercent:     35.5,
			RamUsedBytes:   4 * 1024 * 1024 * 1024,   // 4GB
			RamTotalBytes:  16 * 1024 * 1024 * 1024,  // 16GB
			DiskUsedBytes:  50 * 1024 * 1024 * 1024,  // 50GB
			DiskTotalBytes: 500 * 1024 * 1024 * 1024, // 500GB
			UpSpeed:        125 * 1024 * 1024,        // 125MB/s
			DownSpeed:      250 * 1024 * 1024,        // 250MB/s
			ActiveStreams:  3,
			IsHealthy:      true,
			Latitude:       lat,
			Longitude:      lon,
			Location:       obj.GetRegion(),
		}, nil
	}

	lds := loaders.FromContext(ctx)
	if lds != nil && lds.LiveNodeState != nil {
		return lds.LiveNodeState.Load(ctx, obj.NodeId)
	}
	return r.DoGetLiveNodeState(ctx, obj.NodeId)
}

// StreamID is the resolver for the streamId field.
func (r *ingestMetadataResolver) StreamID(ctx context.Context, obj *proto.IngestMetadata) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *ingestMetadataResolver) Stream(ctx context.Context, obj *proto.IngestMetadata) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// Status is the resolver for the status field.
func (r *invoiceResolver) Status(ctx context.Context, obj *proto.Invoice) (model.InvoiceStatus, error) {
	s := strings.ToLower(obj.Status)
	switch s {
	case "draft":
		return model.InvoiceStatusDraft, nil
	case "pending":
		return model.InvoiceStatusPending, nil
	case "paid":
		return model.InvoiceStatusPaid, nil
	case "overdue":
		return model.InvoiceStatusOverdue, nil
	case "failed":
		return model.InvoiceStatusFailed, nil
	case "cancelled":
		return model.InvoiceStatusCancelled, nil
	default:
		return model.InvoiceStatusPending, fmt.Errorf("unknown invoice status: %s", obj.Status)
	}
}

// DueDate is the resolver for the dueDate field.
func (r *invoiceResolver) DueDate(ctx context.Context, obj *proto.Invoice) (*time.Time, error) {
	if obj.DueDate == nil {
		return nil, fmt.Errorf("invoice dueDate is required but missing")
	}
	t := obj.DueDate.AsTime()
	return &t, nil
}

// PaidAt is the resolver for the paidAt field.
func (r *invoiceResolver) PaidAt(ctx context.Context, obj *proto.Invoice) (*time.Time, error) {
	if obj.PaidAt == nil {
		return nil, nil
	}
	t := obj.PaidAt.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *invoiceResolver) CreatedAt(ctx context.Context, obj *proto.Invoice) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, fmt.Errorf("invoice createdAt is required but missing")
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *invoiceResolver) UpdatedAt(ctx context.Context, obj *proto.Invoice) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, fmt.Errorf("invoice updatedAt is required but missing")
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// PeriodStart is the resolver for the periodStart field.
func (r *invoiceResolver) PeriodStart(ctx context.Context, obj *proto.Invoice) (*time.Time, error) {
	if obj.PeriodStart == nil {
		return nil, nil
	}
	t := obj.PeriodStart.AsTime()
	return &t, nil
}

// PeriodEnd is the resolver for the periodEnd field.
func (r *invoiceResolver) PeriodEnd(ctx context.Context, obj *proto.Invoice) (*time.Time, error) {
	if obj.PeriodEnd == nil {
		return nil, nil
	}
	t := obj.PeriodEnd.AsTime()
	return &t, nil
}

// UsageDetails is the resolver for the usageDetails field.
func (r *invoiceResolver) UsageDetails(ctx context.Context, obj *proto.Invoice) (*string, error) {
	if obj.UsageDetails == nil {
		return nil, nil
	}
	payload, err := json.Marshal(obj.UsageDetails.AsMap())
	if err != nil {
		return nil, fmt.Errorf("failed to encode usageDetails: %w", err)
	}
	encoded := string(payload)
	return &encoded, nil
}

// CPUPercent is the resolver for the cpuPercent field.
func (r *liveNodeResolver) CPUPercent(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	return float64(obj.CpuPercent), nil
}

// RAMUsedBytes is the resolver for the ramUsedBytes field.
func (r *liveNodeResolver) RAMUsedBytes(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	return float64(obj.RamUsedBytes), nil
}

// RAMTotalBytes is the resolver for the ramTotalBytes field.
func (r *liveNodeResolver) RAMTotalBytes(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	return float64(obj.RamTotalBytes), nil
}

// DiskUsedBytes is the resolver for the diskUsedBytes field.
func (r *liveNodeResolver) DiskUsedBytes(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	return float64(obj.DiskUsedBytes), nil
}

// DiskTotalBytes is the resolver for the diskTotalBytes field.
func (r *liveNodeResolver) DiskTotalBytes(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	return float64(obj.DiskTotalBytes), nil
}

// UpSpeed is the resolver for the upSpeed field.
func (r *liveNodeResolver) UpSpeed(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	return float64(obj.UpSpeed), nil
}

// DownSpeed is the resolver for the downSpeed field.
func (r *liveNodeResolver) DownSpeed(ctx context.Context, obj *proto.LiveNode) (float64, error) {
	return float64(obj.DownSpeed), nil
}

// ActiveStreams is the resolver for the activeStreams field.
func (r *liveNodeResolver) ActiveStreams(ctx context.Context, obj *proto.LiveNode) (int, error) {
	return int(obj.ActiveStreams), nil
}

// Metadata is the resolver for the metadata field.
func (r *liveNodeResolver) Metadata(ctx context.Context, obj *proto.LiveNode) (*string, error) {
	if obj.Metadata == nil {
		return nil, nil
	}
	b, err := json.Marshal(obj.Metadata.AsMap())
	if err != nil {
		return nil, err
	}
	s := string(b)
	return &s, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *liveNodeResolver) UpdatedAt(ctx context.Context, obj *proto.LiveNode) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// PeriodStart is the resolver for the periodStart field.
func (r *liveUsageSummaryResolver) PeriodStart(ctx context.Context, obj *proto.LiveUsageSummary) (*time.Time, error) {
	if obj.PeriodStart == nil {
		return nil, nil
	}
	t := obj.PeriodStart.AsTime()
	return &t, nil
}

// PeriodEnd is the resolver for the periodEnd field.
func (r *liveUsageSummaryResolver) PeriodEnd(ctx context.Context, obj *proto.LiveUsageSummary) (*time.Time, error) {
	if obj.PeriodEnd == nil {
		return nil, nil
	}
	t := obj.PeriodEnd.AsTime()
	return &t, nil
}

// LivepeerSegmentCount is the resolver for the livepeerSegmentCount field.
func (r *liveUsageSummaryResolver) LivepeerSegmentCount(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetLivepeerSegmentCount()), nil
}

// LivepeerUniqueStreams is the resolver for the livepeerUniqueStreams field.
func (r *liveUsageSummaryResolver) LivepeerUniqueStreams(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetLivepeerUniqueStreams()), nil
}

// NativeAvSegmentCount is the resolver for the nativeAvSegmentCount field.
func (r *liveUsageSummaryResolver) NativeAvSegmentCount(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetNativeAvSegmentCount()), nil
}

// NativeAvUniqueStreams is the resolver for the nativeAvUniqueStreams field.
func (r *liveUsageSummaryResolver) NativeAvUniqueStreams(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetNativeAvUniqueStreams()), nil
}

// GeoBreakdown is the resolver for the geoBreakdown field.
func (r *liveUsageSummaryResolver) GeoBreakdown(ctx context.Context, obj *proto.LiveUsageSummary) ([]*proto.CountryMetrics, error) {
	// Convert periscope.CountryMetric to purser.CountryMetrics
	result := make([]*proto.CountryMetrics, 0, len(obj.GetGeoBreakdown()))
	for _, cm := range obj.GetGeoBreakdown() {
		result = append(result, &proto.CountryMetrics{
			CountryCode: cm.GetCountryCode(),
			ViewerCount: cm.GetViewerCount(),
			ViewerHours: cm.GetViewerHours(),
			EgressGb:    cm.GetEgressGb(),
		})
	}
	return result, nil
}

// ClipsCreated is the resolver for the clipsCreated field.
func (r *liveUsageSummaryResolver) ClipsCreated(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetClipsCreated()), nil
}

// ClipsDeleted is the resolver for the clipsDeleted field.
func (r *liveUsageSummaryResolver) ClipsDeleted(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetClipsDeleted()), nil
}

// DvrCreated is the resolver for the dvrCreated field.
func (r *liveUsageSummaryResolver) DvrCreated(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetDvrCreated()), nil
}

// DvrDeleted is the resolver for the dvrDeleted field.
func (r *liveUsageSummaryResolver) DvrDeleted(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetDvrDeleted()), nil
}

// VodCreated is the resolver for the vodCreated field.
func (r *liveUsageSummaryResolver) VodCreated(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetVodCreated()), nil
}

// VodDeleted is the resolver for the vodDeleted field.
func (r *liveUsageSummaryResolver) VodDeleted(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetVodDeleted()), nil
}

// ClipBytes is the resolver for the clipBytes field.
func (r *liveUsageSummaryResolver) ClipBytes(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetClipBytes()), nil
}

// DvrBytes is the resolver for the dvrBytes field.
func (r *liveUsageSummaryResolver) DvrBytes(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetDvrBytes()), nil
}

// VodBytes is the resolver for the vodBytes field.
func (r *liveUsageSummaryResolver) VodBytes(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetVodBytes()), nil
}

// FrozenClipBytes is the resolver for the frozenClipBytes field.
func (r *liveUsageSummaryResolver) FrozenClipBytes(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetFrozenClipBytes()), nil
}

// FrozenDvrBytes is the resolver for the frozenDvrBytes field.
func (r *liveUsageSummaryResolver) FrozenDvrBytes(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetFrozenDvrBytes()), nil
}

// FrozenVodBytes is the resolver for the frozenVodBytes field.
func (r *liveUsageSummaryResolver) FrozenVodBytes(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetFrozenVodBytes()), nil
}

// FreezeCount is the resolver for the freezeCount field.
func (r *liveUsageSummaryResolver) FreezeCount(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetFreezeCount()), nil
}

// FreezeBytes is the resolver for the freezeBytes field.
func (r *liveUsageSummaryResolver) FreezeBytes(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetFreezeBytes()), nil
}

// DefrostCount is the resolver for the defrostCount field.
func (r *liveUsageSummaryResolver) DefrostCount(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetDefrostCount()), nil
}

// DefrostBytes is the resolver for the defrostBytes field.
func (r *liveUsageSummaryResolver) DefrostBytes(ctx context.Context, obj *proto.LiveUsageSummary) (int, error) {
	return int(obj.GetDefrostBytes()), nil
}

// MandateID is the resolver for the mandateId field.
func (r *mollieMandateResolver) MandateID(ctx context.Context, obj *proto.MollieMandate) (string, error) {
	return obj.MollieMandateId, nil
}

// CustomerID is the resolver for the customerId field.
func (r *mollieMandateResolver) CustomerID(ctx context.Context, obj *proto.MollieMandate) (string, error) {
	return obj.MollieCustomerId, nil
}

// Details is the resolver for the details field.
func (r *mollieMandateResolver) Details(ctx context.Context, obj *proto.MollieMandate) (*string, error) {
	if obj.Details == nil {
		return nil, nil
	}
	b, err := json.Marshal(obj.Details.AsMap())
	if err != nil {
		return nil, err
	}
	s := string(b)
	return &s, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *mollieMandateResolver) CreatedAt(ctx context.Context, obj *proto.MollieMandate) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// CreateStream is the resolver for the createStream field.
func (r *mutationResolver) CreateStream(ctx context.Context, input model.CreateStreamInput) (model.CreateStreamResult, error) {
	return r.DoCreateStream(ctx, input)
}

// UpdateStream is the resolver for the updateStream field.
func (r *mutationResolver) UpdateStream(ctx context.Context, id string, input model.UpdateStreamInput) (model.UpdateStreamResult, error) {
	rawID, err := resolvers.NormalizeStreamID(id)
	if err != nil {
		return nil, err
	}
	return r.DoUpdateStream(ctx, rawID, input)
}

// DeleteStream is the resolver for the deleteStream field.
func (r *mutationResolver) DeleteStream(ctx context.Context, id string) (model.DeleteStreamResult, error) {
	rawID, err := resolvers.NormalizeStreamID(id)
	if err != nil {
		return nil, err
	}
	return r.DoDeleteStream(ctx, rawID)
}

// RefreshStreamKey is the resolver for the refreshStreamKey field.
func (r *mutationResolver) RefreshStreamKey(ctx context.Context, id string) (model.UpdateStreamResult, error) {
	rawID, err := resolvers.NormalizeStreamID(id)
	if err != nil {
		return nil, err
	}
	return r.DoRefreshStreamKey(ctx, rawID)
}

// CreateClip is the resolver for the createClip field.
func (r *mutationResolver) CreateClip(ctx context.Context, input model.CreateClipInput) (model.CreateClipResult, error) {
	return r.DoCreateClip(ctx, input)
}

// DeleteClip is the resolver for the deleteClip field.
func (r *mutationResolver) DeleteClip(ctx context.Context, id string) (model.DeleteClipResult, error) {
	rawID, err := resolvers.NormalizeClipHash(id)
	if err != nil {
		return nil, err
	}
	return r.DoDeleteClip(ctx, rawID)
}

// StartDvr is the resolver for the startDVR field.
func (r *mutationResolver) StartDvr(ctx context.Context, streamID string, expiresAt *int) (model.StartDVRResult, error) {
	rawID, err := resolvers.NormalizeStreamID(streamID)
	if err != nil {
		return nil, err
	}
	res, err := r.DoStartDVR(ctx, rawID, expiresAt)
	if err != nil {
		return nil, err
	}
	// Map StartDVRResponse into DVRInfo (bound to GraphQL DVRRequest)
	now := timestamppb.Now()
	return &proto.DVRInfo{
		DvrHash:       res.DvrHash,
		StreamId:      &rawID,
		PlaybackId:    &res.PlaybackId,
		StorageNodeId: res.StorageNodeId,
		Status:        res.Status,
		CreatedAt:     now,
		UpdatedAt:     now,
	}, nil
}

// StopDvr is the resolver for the stopDVR field.
func (r *mutationResolver) StopDvr(ctx context.Context, dvrHash string) (model.StopDVRResult, error) {
	return r.DoStopDVR(ctx, dvrHash)
}

// DeleteDvr is the resolver for the deleteDVR field.
func (r *mutationResolver) DeleteDvr(ctx context.Context, dvrHash string) (model.DeleteDVRResult, error) {
	return r.DoDeleteDVR(ctx, dvrHash)
}

// CreateVodUpload is the resolver for the createVodUpload field.
func (r *mutationResolver) CreateVodUpload(ctx context.Context, input model.CreateVodUploadInput) (model.CreateVodUploadResult, error) {
	return r.DoCreateVodUpload(ctx, input)
}

// CompleteVodUpload is the resolver for the completeVodUpload field.
func (r *mutationResolver) CompleteVodUpload(ctx context.Context, input model.CompleteVodUploadInput) (model.CompleteVodUploadResult, error) {
	return r.DoCompleteVodUpload(ctx, input)
}

// AbortVodUpload is the resolver for the abortVodUpload field.
func (r *mutationResolver) AbortVodUpload(ctx context.Context, uploadID string) (model.AbortVodUploadResult, error) {
	return r.DoAbortVodUpload(ctx, uploadID)
}

// DeleteVodAsset is the resolver for the deleteVodAsset field.
func (r *mutationResolver) DeleteVodAsset(ctx context.Context, id string) (model.DeleteVodAssetResult, error) {
	rawID, err := resolvers.NormalizeVodHash(id)
	if err != nil {
		return nil, err
	}
	return r.DoDeleteVodAsset(ctx, rawID)
}

// CreatePayment is the resolver for the createPayment field.
func (r *mutationResolver) CreatePayment(ctx context.Context, input model.CreatePaymentInput) (model.CreatePaymentResult, error) {
	return r.DoCreatePayment(ctx, input)
}

// SubmitX402Payment is the resolver for the submitX402Payment field.
func (r *mutationResolver) SubmitX402Payment(ctx context.Context, payment string, resource *string) (model.SubmitX402PaymentResult, error) {
	return r.DoSubmitX402Payment(ctx, payment, resource)
}

// CreateStripeCheckout is the resolver for the createStripeCheckout field.
func (r *mutationResolver) CreateStripeCheckout(ctx context.Context, tierID string, billingPeriod string, successURL string, cancelURL string) (model.StripeCheckoutResult, error) {
	return r.DoCreateStripeCheckout(ctx, tierID, billingPeriod, successURL, cancelURL)
}

// CreateStripeBillingPortal is the resolver for the createStripeBillingPortal field.
func (r *mutationResolver) CreateStripeBillingPortal(ctx context.Context, returnURL string) (model.StripeBillingPortalResult, error) {
	return r.DoCreateStripeBillingPortal(ctx, returnURL)
}

// CreateMollieFirstPayment is the resolver for the createMollieFirstPayment field.
func (r *mutationResolver) CreateMollieFirstPayment(ctx context.Context, tierID string, method string, redirectURL string) (model.MollieFirstPaymentResult, error) {
	return r.DoCreateMollieFirstPayment(ctx, tierID, method, redirectURL)
}

// CreateMollieSubscription is the resolver for the createMollieSubscription field.
func (r *mutationResolver) CreateMollieSubscription(ctx context.Context, tierID string, mandateID string, description *string) (model.MollieSubscriptionResult, error) {
	return r.DoCreateMollieSubscription(ctx, tierID, mandateID, description)
}

// CreateCardTopup is the resolver for the createCardTopup field.
func (r *mutationResolver) CreateCardTopup(ctx context.Context, input model.CreateCardTopupInput) (*model.CardTopupResult, error) {
	return r.DoCreateCardTopup(ctx, input)
}

// CreateCryptoTopup is the resolver for the createCryptoTopup field.
func (r *mutationResolver) CreateCryptoTopup(ctx context.Context, input model.CreateCryptoTopupInput) (*model.CryptoTopupResult, error) {
	return r.DoCreateCryptoTopup(ctx, input)
}

// CryptoTopupStatus is the resolver for the cryptoTopupStatus field.
func (r *mutationResolver) CryptoTopupStatus(ctx context.Context, topupID string) (*model.CryptoTopupStatus, error) {
	return r.DoGetCryptoTopupStatus(ctx, topupID)
}

// UpdateBillingDetails is the resolver for the updateBillingDetails field.
func (r *mutationResolver) UpdateBillingDetails(ctx context.Context, input model.UpdateBillingDetailsInput) (*proto.BillingDetails, error) {
	return r.DoUpdateBillingDetails(ctx, input)
}

// UpdateSubscriptionCustomTerms is the resolver for the updateSubscriptionCustomTerms field.
func (r *mutationResolver) UpdateSubscriptionCustomTerms(ctx context.Context, tenantID string, input model.UpdateSubscriptionCustomTermsInput) (*proto.TenantSubscription, error) {
	return r.DoUpdateSubscriptionCustomTerms(ctx, tenantID, input)
}

// UpdateTenant is the resolver for the updateTenant field.
func (r *mutationResolver) UpdateTenant(ctx context.Context, input model.UpdateTenantInput) (model.UpdateTenantResult, error) {
	return r.DoUpdateTenant(ctx, input)
}

// SubscribeToCluster is the resolver for the subscribeToCluster field.
func (r *mutationResolver) SubscribeToCluster(ctx context.Context, clusterID string) (bool, error) {
	rawID, err := globalid.DecodeExpected(clusterID, globalid.TypeCluster)
	if err != nil {
		return false, err
	}
	return r.DoSubscribeToCluster(ctx, rawID)
}

// UnsubscribeFromCluster is the resolver for the unsubscribeFromCluster field.
func (r *mutationResolver) UnsubscribeFromCluster(ctx context.Context, clusterID string) (bool, error) {
	rawID, err := globalid.DecodeExpected(clusterID, globalid.TypeCluster)
	if err != nil {
		return false, err
	}
	return r.DoUnsubscribeFromCluster(ctx, rawID)
}

// CreatePrivateCluster is the resolver for the createPrivateCluster field.
func (r *mutationResolver) CreatePrivateCluster(ctx context.Context, input model.CreatePrivateClusterInput) (model.CreatePrivateClusterResult, error) {
	return r.DoCreatePrivateCluster(ctx, input)
}

// UpdateClusterMarketplace is the resolver for the updateClusterMarketplace field.
func (r *mutationResolver) UpdateClusterMarketplace(ctx context.Context, clusterID string, input model.UpdateClusterMarketplaceInput) (model.UpdateClusterResult, error) {
	rawID, err := globalid.DecodeExpected(clusterID, globalid.TypeCluster)
	if err != nil {
		return nil, err
	}
	return r.DoUpdateClusterMarketplace(ctx, rawID, input)
}

// CreateClusterInvite is the resolver for the createClusterInvite field.
func (r *mutationResolver) CreateClusterInvite(ctx context.Context, input model.CreateClusterInviteInput) (model.CreateClusterInviteResult, error) {
	return r.DoCreateClusterInvite(ctx, input)
}

// RevokeClusterInvite is the resolver for the revokeClusterInvite field.
func (r *mutationResolver) RevokeClusterInvite(ctx context.Context, inviteID string) (model.RevokeClusterInviteResult, error) {
	return r.DoRevokeClusterInvite(ctx, inviteID)
}

// RequestClusterSubscription is the resolver for the requestClusterSubscription field.
func (r *mutationResolver) RequestClusterSubscription(ctx context.Context, clusterID string, inviteToken *string) (model.ClusterSubscriptionResult, error) {
	rawID, err := globalid.DecodeExpected(clusterID, globalid.TypeCluster)
	if err != nil {
		return nil, err
	}
	return r.DoRequestClusterSubscription(ctx, rawID, inviteToken)
}

// AcceptClusterInvite is the resolver for the acceptClusterInvite field.
func (r *mutationResolver) AcceptClusterInvite(ctx context.Context, inviteToken string) (model.ClusterSubscriptionResult, error) {
	return r.DoAcceptClusterInvite(ctx, inviteToken)
}

// ApproveClusterSubscription is the resolver for the approveClusterSubscription field.
func (r *mutationResolver) ApproveClusterSubscription(ctx context.Context, subscriptionID string) (model.ClusterSubscriptionResult, error) {
	return r.DoApproveClusterSubscription(ctx, subscriptionID)
}

// RejectClusterSubscription is the resolver for the rejectClusterSubscription field.
func (r *mutationResolver) RejectClusterSubscription(ctx context.Context, subscriptionID string, reason *string) (model.ClusterSubscriptionResult, error) {
	return r.DoRejectClusterSubscription(ctx, subscriptionID, reason)
}

// CreateDeveloperToken is the resolver for the createDeveloperToken field.
func (r *mutationResolver) CreateDeveloperToken(ctx context.Context, input model.CreateDeveloperTokenInput) (model.CreateDeveloperTokenResult, error) {
	return r.DoCreateDeveloperToken(ctx, input)
}

// RevokeDeveloperToken is the resolver for the revokeDeveloperToken field.
func (r *mutationResolver) RevokeDeveloperToken(ctx context.Context, id string) (model.RevokeDeveloperTokenResult, error) {
	return r.DoRevokeDeveloperToken(ctx, id)
}

// CreateBootstrapToken is the resolver for the createBootstrapToken field.
func (r *mutationResolver) CreateBootstrapToken(ctx context.Context, input model.CreateBootstrapTokenInput) (model.CreateBootstrapTokenResult, error) {
	return r.DoCreateBootstrapToken(ctx, input)
}

// RevokeBootstrapToken is the resolver for the revokeBootstrapToken field.
func (r *mutationResolver) RevokeBootstrapToken(ctx context.Context, id string) (model.RevokeBootstrapTokenResult, error) {
	return r.DoRevokeBootstrapToken(ctx, id)
}

// CreateStreamKey is the resolver for the createStreamKey field.
func (r *mutationResolver) CreateStreamKey(ctx context.Context, streamID string, input model.CreateStreamKeyInput) (model.CreateStreamKeyResult, error) {
	rawID, err := resolvers.NormalizeStreamID(streamID)
	if err != nil {
		return nil, err
	}
	return r.DoCreateStreamKey(ctx, rawID, input)
}

// DeleteStreamKey is the resolver for the deleteStreamKey field.
func (r *mutationResolver) DeleteStreamKey(ctx context.Context, streamID string, keyID string) (model.DeleteStreamKeyResult, error) {
	rawID, err := resolvers.NormalizeStreamID(streamID)
	if err != nil {
		return nil, err
	}
	return r.DoDeleteStreamKey(ctx, rawID, keyID)
}

// WalletLogin is the resolver for the walletLogin field.
func (r *mutationResolver) WalletLogin(ctx context.Context, input model.WalletLoginInput) (model.WalletLoginResult, error) {
	return r.DoWalletLogin(ctx, input)
}

// LinkWallet is the resolver for the linkWallet field.
func (r *mutationResolver) LinkWallet(ctx context.Context, input model.WalletLoginInput) (model.LinkWalletResult, error) {
	return r.DoLinkWallet(ctx, input)
}

// UnlinkWallet is the resolver for the unlinkWallet field.
func (r *mutationResolver) UnlinkWallet(ctx context.Context, walletID string) (model.UnlinkWalletResult, error) {
	return r.DoUnlinkWallet(ctx, walletID)
}

// LinkEmail is the resolver for the linkEmail field.
func (r *mutationResolver) LinkEmail(ctx context.Context, input model.LinkEmailInput) (model.LinkEmailResult, error) {
	return r.DoLinkEmail(ctx, input)
}

// PromoteToPaid is the resolver for the promoteToPaid field.
func (r *mutationResolver) PromoteToPaid(ctx context.Context, tierID string) (model.PromoteToPaidResult, error) {
	return r.DoPromoteToPaid(ctx, tierID)
}

// DeleteSkipperConversation is the resolver for the deleteSkipperConversation field.
func (r *mutationResolver) DeleteSkipperConversation(ctx context.Context, id string) (bool, error) {
	return r.Resolver.DoDeleteSkipperConversation(ctx, id)
}

// UpdateSkipperConversation is the resolver for the updateSkipperConversation field.
func (r *mutationResolver) UpdateSkipperConversation(ctx context.Context, id string, title string) (*model.SkipperConversationSummary, error) {
	return r.Resolver.DoUpdateSkipperConversation(ctx, id, title)
}

// CreateConversation is the resolver for the createConversation field.
func (r *mutationResolver) CreateConversation(ctx context.Context, input model.CreateConversationInput) (model.CreateConversationResult, error) {
	resolver := r.Resolver
	if resolver == nil {
		return nil, fmt.Errorf("resolver unavailable")
	}
	return resolver.CreateConversation(ctx, input)
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.SendMessageInput) (model.SendMessageResult, error) {
	resolver := r.Resolver
	if resolver == nil {
		return nil, fmt.Errorf("resolver unavailable")
	}
	return resolver.SendMessage(ctx, input)
}

// ID is the resolver for the id field.
func (r *nodeMetricResolver) ID(ctx context.Context, obj *proto.NodeMetric) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeNodeMetric, obj.NodeId, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *nodeMetricResolver) Timestamp(ctx context.Context, obj *proto.NodeMetric) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// CPUUsage is the resolver for the cpuUsage field.
func (r *nodeMetricResolver) CPUUsage(ctx context.Context, obj *proto.NodeMetric) (float64, error) {
	return float64(obj.CpuUsage), nil
}

// MemoryTotal is the resolver for the memoryTotal field.
func (r *nodeMetricResolver) MemoryTotal(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.RamMax)
	return &v, nil
}

// MemoryUsed is the resolver for the memoryUsed field.
func (r *nodeMetricResolver) MemoryUsed(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.RamCurrent)
	return &v, nil
}

// DiskTotal is the resolver for the diskTotal field.
func (r *nodeMetricResolver) DiskTotal(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.DiskTotalBytes)
	return &v, nil
}

// DiskUsed is the resolver for the diskUsed field.
func (r *nodeMetricResolver) DiskUsed(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.DiskUsedBytes)
	return &v, nil
}

// ShmTotal is the resolver for the shmTotal field.
func (r *nodeMetricResolver) ShmTotal(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.ShmTotalBytes)
	return &v, nil
}

// ShmUsed is the resolver for the shmUsed field.
func (r *nodeMetricResolver) ShmUsed(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.ShmUsedBytes)
	return &v, nil
}

// NetworkRx is the resolver for the networkRx field.
func (r *nodeMetricResolver) NetworkRx(ctx context.Context, obj *proto.NodeMetric) (float64, error) {
	return float64(obj.BandwidthIn), nil
}

// NetworkTx is the resolver for the networkTx field.
func (r *nodeMetricResolver) NetworkTx(ctx context.Context, obj *proto.NodeMetric) (float64, error) {
	return float64(obj.BandwidthOut), nil
}

// UpSpeed is the resolver for the upSpeed field.
func (r *nodeMetricResolver) UpSpeed(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.UpSpeed)
	return &v, nil
}

// DownSpeed is the resolver for the downSpeed field.
func (r *nodeMetricResolver) DownSpeed(ctx context.Context, obj *proto.NodeMetric) (*float64, error) {
	v := float64(obj.DownSpeed)
	return &v, nil
}

// Status is the resolver for the status field.
func (r *nodeMetricResolver) Status(ctx context.Context, obj *proto.NodeMetric) (string, error) {
	if obj.IsHealthy {
		return "HEALTHY", nil
	}
	return "DEGRADED", nil
}

// Metadata is the resolver for the metadata field.
func (r *nodeMetricResolver) Metadata(ctx context.Context, obj *proto.NodeMetric) (*string, error) {
	if !r.CanViewSensitiveNodeData(ctx, obj.NodeId) {
		return nil, nil
	}
	if obj == nil || obj.Metadata == nil {
		return nil, nil
	}

	payload, err := json.Marshal(obj.Metadata.AsMap())
	if err != nil {
		return nil, fmt.Errorf("failed to marshal node metadata: %w", err)
	}

	result := string(payload)
	return &result, nil
}

// ID is the resolver for the id field.
func (r *nodeMetricHourlyResolver) ID(ctx context.Context, obj *proto.NodeMetricHourly) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeNodeMetricHourly, obj.NodeId, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *nodeMetricHourlyResolver) Timestamp(ctx context.Context, obj *proto.NodeMetricHourly) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// AvgCPU is the resolver for the avgCpu field.
func (r *nodeMetricHourlyResolver) AvgCPU(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.AvgCpu), nil
}

// PeakCPU is the resolver for the peakCpu field.
func (r *nodeMetricHourlyResolver) PeakCPU(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.PeakCpu), nil
}

// AvgMemory is the resolver for the avgMemory field.
func (r *nodeMetricHourlyResolver) AvgMemory(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.AvgMemory), nil
}

// PeakMemory is the resolver for the peakMemory field.
func (r *nodeMetricHourlyResolver) PeakMemory(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.PeakMemory), nil
}

// AvgDisk is the resolver for the avgDisk field.
func (r *nodeMetricHourlyResolver) AvgDisk(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.GetAvgDisk()), nil
}

// PeakDisk is the resolver for the peakDisk field.
func (r *nodeMetricHourlyResolver) PeakDisk(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.GetPeakDisk()), nil
}

// AvgShm is the resolver for the avgShm field.
func (r *nodeMetricHourlyResolver) AvgShm(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.AvgShm), nil
}

// PeakShm is the resolver for the peakShm field.
func (r *nodeMetricHourlyResolver) PeakShm(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.PeakShm), nil
}

// TotalBandwidthIn is the resolver for the totalBandwidthIn field.
func (r *nodeMetricHourlyResolver) TotalBandwidthIn(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.TotalBandwidthIn), nil
}

// TotalBandwidthOut is the resolver for the totalBandwidthOut field.
func (r *nodeMetricHourlyResolver) TotalBandwidthOut(ctx context.Context, obj *proto.NodeMetricHourly) (float64, error) {
	return float64(obj.TotalBandwidthOut), nil
}

// AvgCPU is the resolver for the avgCpu field.
func (r *nodeMetricsAggregatedResolver) AvgCPU(ctx context.Context, obj *proto.NodeMetricsAggregated) (float64, error) {
	return float64(obj.AvgCpu), nil
}

// AvgMemory is the resolver for the avgMemory field.
func (r *nodeMetricsAggregatedResolver) AvgMemory(ctx context.Context, obj *proto.NodeMetricsAggregated) (float64, error) {
	return float64(obj.AvgMemory), nil
}

// AvgDisk is the resolver for the avgDisk field.
func (r *nodeMetricsAggregatedResolver) AvgDisk(ctx context.Context, obj *proto.NodeMetricsAggregated) (float64, error) {
	return float64(obj.AvgDisk), nil
}

// AvgShm is the resolver for the avgShm field.
func (r *nodeMetricsAggregatedResolver) AvgShm(ctx context.Context, obj *proto.NodeMetricsAggregated) (float64, error) {
	return float64(obj.AvgShm), nil
}

// TotalBandwidthIn is the resolver for the totalBandwidthIn field.
func (r *nodeMetricsAggregatedResolver) TotalBandwidthIn(ctx context.Context, obj *proto.NodeMetricsAggregated) (float64, error) {
	return float64(obj.TotalBandwidthIn), nil
}

// TotalBandwidthOut is the resolver for the totalBandwidthOut field.
func (r *nodeMetricsAggregatedResolver) TotalBandwidthOut(ctx context.Context, obj *proto.NodeMetricsAggregated) (float64, error) {
	return float64(obj.TotalBandwidthOut), nil
}

// SampleCount is the resolver for the sampleCount field.
func (r *nodeMetricsAggregatedResolver) SampleCount(ctx context.Context, obj *proto.NodeMetricsAggregated) (int, error) {
	return int(obj.SampleCount), nil
}

// ID is the resolver for the id field.
func (r *nodePerformance5mResolver) ID(ctx context.Context, obj *proto.NodePerformance5M) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeNodePerformance5m, obj.NodeId, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *nodePerformance5mResolver) Timestamp(ctx context.Context, obj *proto.NodePerformance5M) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// AvgCPU is the resolver for the avgCpu field.
func (r *nodePerformance5mResolver) AvgCPU(ctx context.Context, obj *proto.NodePerformance5M) (float64, error) {
	return float64(obj.AvgCpu), nil
}

// MaxCPU is the resolver for the maxCpu field.
func (r *nodePerformance5mResolver) MaxCPU(ctx context.Context, obj *proto.NodePerformance5M) (float64, error) {
	return float64(obj.MaxCpu), nil
}

// AvgMemory is the resolver for the avgMemory field.
func (r *nodePerformance5mResolver) AvgMemory(ctx context.Context, obj *proto.NodePerformance5M) (float64, error) {
	return float64(obj.AvgMemory), nil
}

// MaxMemory is the resolver for the maxMemory field.
func (r *nodePerformance5mResolver) MaxMemory(ctx context.Context, obj *proto.NodePerformance5M) (float64, error) {
	return float64(obj.MaxMemory), nil
}

// TotalBandwidth is the resolver for the totalBandwidth field.
func (r *nodePerformance5mResolver) TotalBandwidth(ctx context.Context, obj *proto.NodePerformance5M) (float64, error) {
	return float64(obj.TotalBandwidth), nil
}

// Method is the resolver for the method field.
func (r *paymentResolver) Method(ctx context.Context, obj *proto.PaymentResponse) (model.PaymentMethod, error) {
	// Convert payment method string to GraphQL enum
	switch strings.ToLower(obj.Method) {
	case "card", "mollie":
		return model.PaymentMethodCard, nil
	case "crypto", "crypto_btc", "crypto_eth":
		return model.PaymentMethodCrypto, nil
	case "bank_transfer":
		return model.PaymentMethodBankTransfer, nil
	default:
		// Default to card if method not specified
		return model.PaymentMethodCard, nil
	}
}

// Status is the resolver for the status field.
func (r *paymentResolver) Status(ctx context.Context, obj *proto.PaymentResponse) (model.PaymentStatus, error) {
	s := strings.ToLower(obj.Status)
	switch s {
	case "pending":
		return model.PaymentStatusPending, nil
	case "confirmed":
		return model.PaymentStatusConfirmed, nil
	case "failed":
		return model.PaymentStatusFailed, nil
	default:
		return model.PaymentStatusPending, fmt.Errorf("unknown payment status: %s", obj.Status)
	}
}

// CreatedAt is the resolver for the createdAt field.
func (r *paymentResolver) CreatedAt(ctx context.Context, obj *proto.PaymentResponse) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, fmt.Errorf("payment createdAt is required but missing")
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// TotalBandwidth is the resolver for the totalBandwidth field.
func (r *platformOverviewResolver) TotalBandwidth(ctx context.Context, obj *proto.GetPlatformOverviewResponse) (float64, error) {
	return obj.PeakBandwidth, nil
}

// TotalUploadBytes is the resolver for the totalUploadBytes field.
func (r *platformOverviewResolver) TotalUploadBytes(ctx context.Context, obj *proto.GetPlatformOverviewResponse) (float64, error) {
	return float64(obj.TotalUploadBytes), nil
}

// TotalDownloadBytes is the resolver for the totalDownloadBytes field.
func (r *platformOverviewResolver) TotalDownloadBytes(ctx context.Context, obj *proto.GetPlatformOverviewResponse) (float64, error) {
	return float64(obj.TotalDownloadBytes), nil
}

// DailyStats is the resolver for the dailyStats field.
func (r *platformOverviewResolver) DailyStats(ctx context.Context, obj *proto.GetPlatformOverviewResponse, days *int) ([]*proto.TenantDailyStat, error) {
	return r.DoGetTenantDailyStats(ctx, days)
}

// BytesUp is the resolver for the bytesUp field.
func (r *playbackInstanceResolver) BytesUp(ctx context.Context, obj *proto.PlaybackInstance) (*float64, error) {
	if obj.BytesUp == 0 {
		return nil, nil
	}
	v := float64(obj.BytesUp)
	return &v, nil
}

// BytesDown is the resolver for the bytesDown field.
func (r *playbackInstanceResolver) BytesDown(ctx context.Context, obj *proto.PlaybackInstance) (*float64, error) {
	if obj.BytesDown == 0 {
		return nil, nil
	}
	v := float64(obj.BytesDown)
	return &v, nil
}

// LastUpdate is the resolver for the lastUpdate field.
func (r *playbackInstanceResolver) LastUpdate(ctx context.Context, obj *proto.PlaybackInstance) (*time.Time, error) {
	if obj.LastUpdate == nil {
		return nil, nil
	}
	t := obj.LastUpdate.AsTime()
	return &t, nil
}

// RecordingSizeBytes is the resolver for the recordingSizeBytes field.
func (r *playbackMetadataResolver) RecordingSizeBytes(ctx context.Context, obj *proto.PlaybackMetadata) (*float64, error) {
	if obj.RecordingSizeBytes == nil {
		return nil, nil
	}
	v := float64(*obj.RecordingSizeBytes)
	return &v, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *playbackMetadataResolver) CreatedAt(ctx context.Context, obj *proto.PlaybackMetadata) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// ProcessingUsageConnection is the resolver for the processingUsageConnection field.
func (r *processingUsageResolver) ProcessingUsageConnection(ctx context.Context, obj *markers.ProcessingUsage, page *model.ConnectionInput, streamID *string, processType *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.ProcessingUsageConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetProcessingUsageConnection(ctx, streamID, processType, timeRange, first, after, last, before, noCache)
}

// ID is the resolver for the id field.
func (r *processingUsageRecordResolver) ID(ctx context.Context, obj *proto.ProcessingUsageRecord) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeProcessingUsageRecord, obj.StreamId, obj.Id, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *processingUsageRecordResolver) Timestamp(ctx context.Context, obj *proto.ProcessingUsageRecord) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *processingUsageRecordResolver) StreamID(ctx context.Context, obj *proto.ProcessingUsageRecord) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *processingUsageRecordResolver) Stream(ctx context.Context, obj *proto.ProcessingUsageRecord) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// InputBytes is the resolver for the inputBytes field.
func (r *processingUsageRecordResolver) InputBytes(ctx context.Context, obj *proto.ProcessingUsageRecord) (*float64, error) {
	if obj.InputBytes == nil {
		return nil, nil
	}
	v := float64(*obj.InputBytes)
	return &v, nil
}

// OutputBytesTotal is the resolver for the outputBytesTotal field.
func (r *processingUsageRecordResolver) OutputBytesTotal(ctx context.Context, obj *proto.ProcessingUsageRecord) (*float64, error) {
	if obj.OutputBytesTotal == nil {
		return nil, nil
	}
	v := float64(*obj.OutputBytesTotal)
	return &v, nil
}

// InputBytesDelta is the resolver for the inputBytesDelta field.
func (r *processingUsageRecordResolver) InputBytesDelta(ctx context.Context, obj *proto.ProcessingUsageRecord) (*float64, error) {
	if obj.InputBytesDelta == nil {
		return nil, nil
	}
	v := float64(*obj.InputBytesDelta)
	return &v, nil
}

// OutputBytesDelta is the resolver for the outputBytesDelta field.
func (r *processingUsageRecordResolver) OutputBytesDelta(ctx context.Context, obj *proto.ProcessingUsageRecord) (*float64, error) {
	if obj.OutputBytesDelta == nil {
		return nil, nil
	}
	v := float64(*obj.OutputBytesDelta)
	return &v, nil
}

// Date is the resolver for the date field.
func (r *processingUsageSummaryResolver) Date(ctx context.Context, obj *proto.ProcessingUsageSummary) (*time.Time, error) {
	if obj.Date == nil {
		return nil, nil
	}
	t := obj.Date.AsTime()
	return &t, nil
}

// LivepeerSegmentCount is the resolver for the livepeerSegmentCount field.
func (r *processingUsageSummaryResolver) LivepeerSegmentCount(ctx context.Context, obj *proto.ProcessingUsageSummary) (int, error) {
	return int(obj.LivepeerSegmentCount), nil
}

// LivepeerUniqueStreams is the resolver for the livepeerUniqueStreams field.
func (r *processingUsageSummaryResolver) LivepeerUniqueStreams(ctx context.Context, obj *proto.ProcessingUsageSummary) (int, error) {
	return int(obj.LivepeerUniqueStreams), nil
}

// NativeAvSegmentCount is the resolver for the nativeAvSegmentCount field.
func (r *processingUsageSummaryResolver) NativeAvSegmentCount(ctx context.Context, obj *proto.ProcessingUsageSummary) (int, error) {
	return int(obj.NativeAvSegmentCount), nil
}

// NativeAvUniqueStreams is the resolver for the nativeAvUniqueStreams field.
func (r *processingUsageSummaryResolver) NativeAvUniqueStreams(ctx context.Context, obj *proto.ProcessingUsageSummary) (int, error) {
	return int(obj.NativeAvUniqueStreams), nil
}

// ID is the resolver for the id field.
func (r *qualityTierDailyResolver) ID(ctx context.Context, obj *proto.QualityTierDaily) (string, error) {
	dayPart := encodeProtoTimestampPart(obj.Day)
	return globalid.EncodeComposite(globalid.TypeQualityTierDaily, obj.StreamId, dayPart), nil
}

// Day is the resolver for the day field.
func (r *qualityTierDailyResolver) Day(ctx context.Context, obj *proto.QualityTierDaily) (*time.Time, error) {
	if obj.Day == nil {
		return nil, nil
	}
	t := obj.Day.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *qualityTierDailyResolver) StreamID(ctx context.Context, obj *proto.QualityTierDaily) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *qualityTierDailyResolver) Stream(ctx context.Context, obj *proto.QualityTierDaily) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// Tier2160pMinutes is the resolver for the tier2160pMinutes field.
func (r *qualityTierDailyResolver) Tier2160pMinutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.Tier_2160PMinutes), nil
}

// Tier1440pMinutes is the resolver for the tier1440pMinutes field.
func (r *qualityTierDailyResolver) Tier1440pMinutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.Tier_1440PMinutes), nil
}

// Tier1080pMinutes is the resolver for the tier1080pMinutes field.
func (r *qualityTierDailyResolver) Tier1080pMinutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.Tier_1080PMinutes), nil
}

// Tier720pMinutes is the resolver for the tier720pMinutes field.
func (r *qualityTierDailyResolver) Tier720pMinutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.Tier_720PMinutes), nil
}

// Tier480pMinutes is the resolver for the tier480pMinutes field.
func (r *qualityTierDailyResolver) Tier480pMinutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.Tier_480PMinutes), nil
}

// TierSdMinutes is the resolver for the tierSdMinutes field.
func (r *qualityTierDailyResolver) TierSdMinutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.TierSdMinutes), nil
}

// CodecH264Minutes is the resolver for the codecH264Minutes field.
func (r *qualityTierDailyResolver) CodecH264Minutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.CodecH264Minutes), nil
}

// CodecH265Minutes is the resolver for the codecH265Minutes field.
func (r *qualityTierDailyResolver) CodecH265Minutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.CodecH265Minutes), nil
}

// CodecVp9Minutes is the resolver for the codecVp9Minutes field.
func (r *qualityTierDailyResolver) CodecVp9Minutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.CodecVp9Minutes), nil
}

// CodecAv1Minutes is the resolver for the codecAv1Minutes field.
func (r *qualityTierDailyResolver) CodecAv1Minutes(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.CodecAv1Minutes), nil
}

// AvgBitrate is the resolver for the avgBitrate field.
func (r *qualityTierDailyResolver) AvgBitrate(ctx context.Context, obj *proto.QualityTierDaily) (int, error) {
	return int(obj.AvgBitrate), nil
}

// AvgFps is the resolver for the avgFps field.
func (r *qualityTierDailyResolver) AvgFps(ctx context.Context, obj *proto.QualityTierDaily) (float64, error) {
	return float64(obj.AvgFps), nil
}

// Tier2160pMinutes is the resolver for the tier2160pMinutes field.
func (r *qualityTierSummaryResolver) Tier2160pMinutes(ctx context.Context, obj *proto.QualityTierSummary) (int, error) {
	return int(obj.Tier_2160PMinutes), nil
}

// Tier1440pMinutes is the resolver for the tier1440pMinutes field.
func (r *qualityTierSummaryResolver) Tier1440pMinutes(ctx context.Context, obj *proto.QualityTierSummary) (int, error) {
	return int(obj.Tier_1440PMinutes), nil
}

// Tier1080pMinutes is the resolver for the tier1080pMinutes field.
func (r *qualityTierSummaryResolver) Tier1080pMinutes(ctx context.Context, obj *proto.QualityTierSummary) (int, error) {
	return int(obj.Tier_1080PMinutes), nil
}

// Tier720pMinutes is the resolver for the tier720pMinutes field.
func (r *qualityTierSummaryResolver) Tier720pMinutes(ctx context.Context, obj *proto.QualityTierSummary) (int, error) {
	return int(obj.Tier_720PMinutes), nil
}

// Tier480pMinutes is the resolver for the tier480pMinutes field.
func (r *qualityTierSummaryResolver) Tier480pMinutes(ctx context.Context, obj *proto.QualityTierSummary) (int, error) {
	return int(obj.Tier_480PMinutes), nil
}

// TierSdMinutes is the resolver for the tierSdMinutes field.
func (r *qualityTierSummaryResolver) TierSdMinutes(ctx context.Context, obj *proto.QualityTierSummary) (int, error) {
	return int(obj.TierSdMinutes), nil
}

// CodecH264Minutes is the resolver for the codecH264Minutes field.
func (r *qualityTierSummaryResolver) CodecH264Minutes(ctx context.Context, obj *proto.QualityTierSummary) (int, error) {
	return int(obj.CodecH264Minutes), nil
}

// CodecH265Minutes is the resolver for the codecH265Minutes field.
func (r *qualityTierSummaryResolver) CodecH265Minutes(ctx context.Context, obj *proto.QualityTierSummary) (int, error) {
	return int(obj.CodecH265Minutes), nil
}

// CodecVp9Minutes is the resolver for the codecVp9Minutes field.
func (r *qualityTierSummaryResolver) CodecVp9Minutes(ctx context.Context, obj *proto.QualityTierSummary) (int, error) {
	return int(obj.CodecVp9Minutes), nil
}

// CodecAv1Minutes is the resolver for the codecAv1Minutes field.
func (r *qualityTierSummaryResolver) CodecAv1Minutes(ctx context.Context, obj *proto.QualityTierSummary) (int, error) {
	return int(obj.CodecAv1Minutes), nil
}

// Analytics is the resolver for the analytics field.
func (r *queryResolver) Analytics(ctx context.Context) (*markers.Analytics, error) {
	return &markers.Analytics{}, nil
}

// StreamsConnection is the resolver for the streamsConnection field.
func (r *queryResolver) StreamsConnection(ctx context.Context, page *model.ConnectionInput) (*model.StreamsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetStreamsConnection(ctx, first, after, last, before)
}

// Stream is the resolver for the stream field.
func (r *queryResolver) Stream(ctx context.Context, id string) (*proto.Stream, error) {
	rawID, err := resolvers.NormalizeStreamID(id)
	if err != nil {
		return nil, err
	}
	return r.DoGetStream(ctx, rawID)
}

// ValidateStreamKey is the resolver for the validateStreamKey field.
func (r *queryResolver) ValidateStreamKey(ctx context.Context, streamKey string) (*model.StreamValidation, error) {
	return r.DoValidateStreamKey(ctx, streamKey)
}

// StreamKeysConnection is the resolver for the streamKeysConnection field.
func (r *queryResolver) StreamKeysConnection(ctx context.Context, page *model.ConnectionInput, streamID string) (*model.StreamKeysConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetStreamKeysConnection(ctx, streamID, first, after, last, before)
}

// ClipsConnection is the resolver for the clipsConnection field.
func (r *queryResolver) ClipsConnection(ctx context.Context, page *model.ConnectionInput, streamID *string) (*model.ClipsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetClipsConnection(ctx, streamID, first, after, last, before)
}

// Clip is the resolver for the clip field.
func (r *queryResolver) Clip(ctx context.Context, id string) (*proto.ClipInfo, error) {
	rawID, err := resolvers.NormalizeClipHash(id)
	if err != nil {
		return nil, err
	}
	return r.DoGetClip(ctx, rawID)
}

// BillingTiers is the resolver for the billingTiers field.
func (r *queryResolver) BillingTiers(ctx context.Context) ([]*proto.BillingTier, error) {
	return r.DoGetBillingTiers(ctx)
}

// InvoicesConnection is the resolver for the invoicesConnection field.
func (r *queryResolver) InvoicesConnection(ctx context.Context, page *model.ConnectionInput) (*model.InvoicesConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetInvoicesConnection(ctx, first, after, last, before)
}

// Invoice is the resolver for the invoice field.
func (r *queryResolver) Invoice(ctx context.Context, id string) (*proto.Invoice, error) {
	return r.DoGetInvoice(ctx, id)
}

// BillingStatus is the resolver for the billingStatus field.
func (r *queryResolver) BillingStatus(ctx context.Context) (*proto.BillingStatusResponse, error) {
	return r.DoGetBillingStatus(ctx)
}

// MollieMandates is the resolver for the mollieMandates field.
func (r *queryResolver) MollieMandates(ctx context.Context) ([]*proto.MollieMandate, error) {
	return r.DoListMollieMandates(ctx)
}

// PrepaidBalance is the resolver for the prepaidBalance field.
func (r *queryResolver) PrepaidBalance(ctx context.Context, currency *string) (*model.PrepaidBalance, error) {
	return r.DoGetPrepaidBalance(ctx, currency)
}

// BillingDetails is the resolver for the billingDetails field.
func (r *queryResolver) BillingDetails(ctx context.Context) (*proto.BillingDetails, error) {
	return r.DoGetBillingDetails(ctx)
}

// BalanceTransactionsConnection is the resolver for the balanceTransactionsConnection field.
func (r *queryResolver) BalanceTransactionsConnection(ctx context.Context, page *model.ConnectionInput, transactionType *string, timeRange *model.TimeRangeInput) (*model.BalanceTransactionsConnection, error) {
	return r.DoGetBalanceTransactionsConnection(ctx, page, transactionType, timeRange)
}

// TenantUsage is the resolver for the tenantUsage field.
func (r *queryResolver) TenantUsage(ctx context.Context, timeRange *model.TimeRangeInput) (*model.TenantUsage, error) {
	return r.DoGetTenantUsage(ctx, timeRange)
}

// UsageRecordsConnection is the resolver for the usageRecordsConnection field.
func (r *queryResolver) UsageRecordsConnection(ctx context.Context, page *model.ConnectionInput, timeRange *model.TimeRangeInput) (*model.UsageRecordsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetUsageRecordsConnection(ctx, timeRange, first, after, last, before)
}

// UsageAggregates is the resolver for the usageAggregates field.
func (r *queryResolver) UsageAggregates(ctx context.Context, timeRange model.TimeRangeInput, granularity *string, usageTypes []string) ([]*proto.UsageAggregate, error) {
	gran := "daily"
	if granularity != nil && *granularity != "" {
		gran = *granularity
	}
	return r.DoGetUsageAggregates(ctx, &timeRange, gran, usageTypes)
}

// Tenant is the resolver for the tenant field.
func (r *queryResolver) Tenant(ctx context.Context) (*proto.Tenant, error) {
	return r.DoGetTenant(ctx)
}

// ClustersConnection is the resolver for the clustersConnection field.
func (r *queryResolver) ClustersConnection(ctx context.Context, page *model.ConnectionInput) (*model.ClustersConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetClustersConnection(ctx, first, after, last, before)
}

// Cluster is the resolver for the cluster field.
func (r *queryResolver) Cluster(ctx context.Context, id string) (*proto.InfrastructureCluster, error) {
	rawID, err := globalid.DecodeExpected(id, globalid.TypeCluster)
	if err != nil {
		return nil, err
	}
	return r.DoGetCluster(ctx, rawID)
}

// NodesConnection is the resolver for the nodesConnection field.
func (r *queryResolver) NodesConnection(ctx context.Context, page *model.ConnectionInput, clusterID *string, status *model.NodeStatus, typeArg *string) (*model.NodesConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetNodesConnection(ctx, clusterID, status, typeArg, first, after, last, before)
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (model.Node, error) {
	typ, rawID, ok := globalid.Decode(id)
	if !ok {
		return nil, fmt.Errorf("invalid global id")
	}
	switch typ {
	case globalid.TypeStream:
		return r.DoGetStream(ctx, rawID)
	case globalid.TypeClip:
		normalized, err := resolvers.NormalizeClipHash(rawID)
		if err != nil {
			return nil, err
		}
		return r.DoGetClip(ctx, normalized)
	case globalid.TypeVodAsset:
		normalized, err := resolvers.NormalizeVodHash(rawID)
		if err != nil {
			return nil, err
		}
		return r.DoGetVodAsset(ctx, normalized)
	case globalid.TypeCluster:
		return r.DoGetCluster(ctx, rawID)
	case globalid.TypeInfrastructureNode:
		return r.DoGetNode(ctx, rawID)
	case globalid.TypeStreamEvent:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeStreamEvent, 3)
		if err != nil {
			return nil, err
		}
		streamID, eventID, tsPart := parts[0], parts[1], parts[2]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 100
		conn, err := r.DoGetStreamEventsConnection(ctx, streamIDGlobal, timeRangeAround(ts, time.Hour), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.EventId == eventID && timesClose(node.Timestamp, ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("stream event not found")
	case globalid.TypeBufferEvent:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeBufferEvent, 3)
		if err != nil {
			return nil, err
		}
		streamID, eventID, tsPart := parts[0], parts[1], parts[2]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 100
		conn, err := r.DoGetBufferEventsConnection(ctx, streamIDGlobal, timeRangeAround(ts, time.Hour), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.EventId == eventID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("buffer event not found")
	case globalid.TypeTrackListEvent:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeTrackListEvent, 3)
		if err != nil {
			return nil, err
		}
		streamID, eventID, tsPart := parts[0], parts[1], parts[2]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 100
		conn, err := r.DoGetTrackListEventsConnection(ctx, streamIDGlobal, timeRangeAround(ts, time.Hour), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.Id == eventID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("track list event not found")
	case globalid.TypeConnectionEvent:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeConnectionEvent, 3)
		if err != nil {
			return nil, err
		}
		streamID, eventID, tsPart := parts[0], parts[1], parts[2]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 100
		streamPtr := &streamIDGlobal
		conn, err := r.DoGetConnectionEventsConnection(ctx, streamPtr, timeRangeAround(ts, time.Hour), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.EventId == eventID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("connection event not found")
	case globalid.TypeViewerSession:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeViewerSession, 3)
		if err != nil {
			return nil, err
		}
		streamID, sessionID, tsPart := parts[0], parts[1], parts[2]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 200
		streamPtr := &streamIDGlobal
		conn, err := r.DoGetViewerSessionsConnection(ctx, streamPtr, timeRangeAround(ts, time.Hour), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.SessionId == sessionID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("viewer session not found")
	case globalid.TypeStreamHealthMetric:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeStreamHealthMetric, 3)
		if err != nil {
			return nil, err
		}
		streamID, nodeID, tsPart := parts[0], parts[1], parts[2]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 200
		conn, err := r.DoGetStreamHealthMetricsConnection(ctx, streamIDGlobal, timeRangeAround(ts, time.Minute*5), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.NodeId == nodeID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("stream health metric not found")
	case globalid.TypeStreamHealth5m:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeStreamHealth5m, 3)
		if err != nil {
			return nil, err
		}
		streamID, nodeID, tsPart := parts[0], parts[1], parts[2]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 200
		conn, err := r.DoGetStreamHealth5mConnection(ctx, streamIDGlobal, timeRangeAround(ts, time.Minute*10), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.NodeId == nodeID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("stream health 5m not found")
	case globalid.TypeStreamConnectionHourly:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeStreamConnectionHourly, 2)
		if err != nil {
			return nil, err
		}
		streamID, hourPart := parts[0], parts[1]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		hour, err := parseUnixNanoPart(hourPart)
		if err != nil {
			return nil, err
		}
		first := 200
		streamPtr := &streamIDGlobal
		conn, err := r.DoGetStreamConnectionHourlyConnection(ctx, streamPtr, timeRangeAround(hour, time.Hour*2), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.Hour != nil && timesClose(node.Hour.AsTime(), hour) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("stream connection hourly not found")
	case globalid.TypeClientMetrics5m:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeClientMetrics5m, 3)
		if err != nil {
			return nil, err
		}
		streamID, nodeID, tsPart := parts[0], parts[1], parts[2]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 200
		streamPtr := &streamIDGlobal
		nodePtr := &nodeID
		conn, err := r.DoGetClientMetrics5mConnection(ctx, streamPtr, nodePtr, timeRangeAround(ts, time.Minute*10), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.NodeId == nodeID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("client metrics 5m not found")
	case globalid.TypeQualityTierDaily:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeQualityTierDaily, 2)
		if err != nil {
			return nil, err
		}
		streamID, dayPart := parts[0], parts[1]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		day, err := parseUnixNanoPart(dayPart)
		if err != nil {
			return nil, err
		}
		first := 200
		streamPtr := &streamIDGlobal
		conn, err := r.DoGetQualityTierDailyConnection(ctx, streamPtr, timeRangeAround(day, time.Hour*24*2), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.Day != nil && timesClose(node.Day.AsTime(), day) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("quality tier daily not found")
	case globalid.TypeViewerHoursHourly:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeViewerHoursHourly, 3)
		if err != nil {
			return nil, err
		}
		streamID, countryCode, hourPart := parts[0], parts[1], parts[2]
		hour, err := parseUnixNanoPart(hourPart)
		if err != nil {
			return nil, err
		}
		first := 200
		var streamPtr *string
		if streamID != "" {
			streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
			streamPtr = &streamIDGlobal
		}
		conn, err := r.DoGetViewerHoursHourlyConnection(ctx, streamPtr, timeRangeAround(hour, time.Hour*2), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.CountryCode == countryCode && node.Hour != nil && timesClose(node.Hour.AsTime(), hour) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("viewer hours hourly not found")
	case globalid.TypeViewerGeoHourly:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeViewerGeoHourly, 2)
		if err != nil {
			return nil, err
		}
		countryCode, hourPart := parts[0], parts[1]
		hour, err := parseUnixNanoPart(hourPart)
		if err != nil {
			return nil, err
		}
		first := 200
		conn, err := r.DoGetViewerGeoHourlyConnection(ctx, timeRangeAround(hour, time.Hour*2), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.CountryCode == countryCode && node.Hour != nil && timesClose(node.Hour.AsTime(), hour) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("viewer geo hourly not found")
	case globalid.TypeStreamAnalyticsDaily:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeStreamAnalyticsDaily, 2)
		if err != nil {
			return nil, err
		}
		streamID, dayPart := parts[0], parts[1]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		day, err := parseUnixNanoPart(dayPart)
		if err != nil {
			return nil, err
		}
		first := 200
		streamPtr := &streamIDGlobal
		conn, err := r.DoGetStreamAnalyticsDailyConnection(ctx, streamPtr, timeRangeAround(day, time.Hour*24*2), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.Day != nil && timesClose(node.Day.AsTime(), day) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("stream analytics daily not found")
	case globalid.TypeTenantDailyStat:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeTenantDailyStat, 1)
		if err != nil {
			return nil, err
		}
		day, err := parseUnixNanoPart(parts[0])
		if err != nil {
			return nil, err
		}
		days := int(time.Since(day).Hours()/24) + 2
		if days < 1 {
			days = 1
		}
		stats, err := r.DoGetTenantDailyStats(ctx, &days)
		if err != nil {
			return nil, err
		}
		for _, node := range stats {
			if node != nil && node.Date != nil && timesClose(node.Date.AsTime(), day) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("tenant daily stat not found")
	case globalid.TypeNodePerformance5m:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeNodePerformance5m, 2)
		if err != nil {
			return nil, err
		}
		nodeID, tsPart := parts[0], parts[1]
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 200
		nodePtr := &nodeID
		conn, err := r.DoGetNodePerformance5mConnection(ctx, nodePtr, timeRangeAround(ts, time.Minute*10), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.NodeId == nodeID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("node performance 5m not found")
	case globalid.TypeNodeMetric:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeNodeMetric, 2)
		if err != nil {
			return nil, err
		}
		nodeID, tsPart := parts[0], parts[1]
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 200
		nodePtr := &nodeID
		conn, err := r.DoGetNodeMetricsConnection(ctx, nodePtr, timeRangeAround(ts, time.Minute*5), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.NodeId == nodeID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("node metric not found")
	case globalid.TypeNodeMetricHourly:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeNodeMetricHourly, 2)
		if err != nil {
			return nil, err
		}
		nodeID, tsPart := parts[0], parts[1]
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 200
		nodePtr := &nodeID
		conn, err := r.DoGetNodeMetrics1hConnection(ctx, timeRangeAround(ts, time.Hour*2), nodePtr, &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.NodeId == nodeID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("node metric hourly not found")
	case globalid.TypeStorageUsageRecord:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeStorageUsageRecord, 3)
		if err != nil {
			return nil, err
		}
		nodeID, storageScope, tsPart := parts[0], parts[1], parts[2]
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 200
		nodePtr := &nodeID
		scopePtr := &storageScope
		conn, err := r.DoGetStorageUsageConnection(ctx, nodePtr, scopePtr, timeRangeAround(ts, time.Hour*2), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.NodeId == nodeID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("storage usage record not found")
	case globalid.TypeStorageEvent:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeStorageEvent, 3)
		if err != nil {
			return nil, err
		}
		streamID, eventID, tsPart := parts[0], parts[1], parts[2]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 200
		streamPtr := &streamIDGlobal
		conn, err := r.DoGetStorageEventsConnection(ctx, streamPtr, nil, timeRangeAround(ts, time.Hour*2), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.Id == eventID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("storage event not found")
	case globalid.TypeProcessingUsageRecord:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeProcessingUsageRecord, 3)
		if err != nil {
			return nil, err
		}
		streamID, recordID, tsPart := parts[0], parts[1], parts[2]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 200
		streamPtr := &streamIDGlobal
		conn, err := r.DoGetProcessingUsageConnection(ctx, streamPtr, nil, timeRangeAround(ts, time.Hour*2), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.Id == recordID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("processing usage record not found")
	case globalid.TypeArtifactEvent:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeArtifactEvent, 3)
		if err != nil {
			return nil, err
		}
		streamID, requestID, tsPart := parts[0], parts[1], parts[2]
		streamIDGlobal := globalid.Encode(globalid.TypeStream, streamID)
		ts, err := parseUnixNanoPart(tsPart)
		if err != nil {
			return nil, err
		}
		first := 200
		streamPtr := &streamIDGlobal
		conn, err := r.DoGetArtifactEventsConnection(ctx, streamPtr, nil, nil, timeRangeAround(ts, time.Hour*2), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.RequestId == requestID && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), ts) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("artifact event not found")
	case globalid.TypeConversation:
		return r.Conversation(ctx, id)
	case globalid.TypeMessage:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeMessage, 2)
		if err != nil {
			return nil, err
		}
		conversationID, messageID := parts[0], parts[1]
		return r.MessageByID(ctx, conversationID, messageID)
	case globalid.TypeAPIUsageRecord:
		parts, err := globalid.DecodeCompositeExpected(id, globalid.TypeAPIUsageRecord, 4)
		if err != nil {
			return nil, err
		}
		hourPart, authType, operationType, operationName := parts[0], parts[1], parts[2], parts[3]
		hour, err := parseUnixNanoPart(hourPart)
		if err != nil {
			return nil, err
		}
		first := 200
		authTypePtr := &authType
		operationTypePtr := &operationType
		operationNamePtr := &operationName
		conn, err := r.DoGetAPIUsageConnection(ctx, authTypePtr, operationTypePtr, operationNamePtr, timeRangeAround(hour, time.Hour*2), &first, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		for _, node := range conn.Nodes {
			if node != nil && node.AuthType == authType && node.OperationType == operationType && node.OperationName == operationName && node.Timestamp != nil && timesClose(node.Timestamp.AsTime(), hour) {
				return node, nil
			}
		}
		return nil, fmt.Errorf("API usage record not found")
	default:
		return nil, fmt.Errorf("unsupported node type: %s", typ)
	}
}

// DiscoverServicesConnection is the resolver for the discoverServicesConnection field.
func (r *queryResolver) DiscoverServicesConnection(ctx context.Context, page *model.ConnectionInput, typeArg string, clusterID *string) (*model.ServiceInstancesConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetDiscoverServicesConnection(ctx, typeArg, clusterID, first, after, last, before)
}

// ClustersAccess is the resolver for the clustersAccess field.
func (r *queryResolver) ClustersAccess(ctx context.Context, first *int, after *string) ([]*model.ClusterAccess, error) {
	return r.DoGetClustersAccess(ctx, first, after)
}

// ClustersAccessConnection is the resolver for the clustersAccessConnection field.
func (r *queryResolver) ClustersAccessConnection(ctx context.Context, page *model.ConnectionInput) (*model.ClusterAccessConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetClustersAccessConnection(ctx, first, after, last, before)
}

// ClustersAvailable is the resolver for the clustersAvailable field.
func (r *queryResolver) ClustersAvailable(ctx context.Context, first *int, after *string) ([]*model.AvailableCluster, error) {
	return r.DoGetClustersAvailable(ctx, first, after)
}

// ClustersAvailableConnection is the resolver for the clustersAvailableConnection field.
func (r *queryResolver) ClustersAvailableConnection(ctx context.Context, page *model.ConnectionInput) (*model.AvailableClusterConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetClustersAvailableConnection(ctx, first, after, last, before)
}

// MySubscriptions is the resolver for the mySubscriptions field.
func (r *queryResolver) MySubscriptions(ctx context.Context, first *int, after *string) ([]*proto.InfrastructureCluster, error) {
	return r.DoListMySubscriptions(ctx, first, after)
}

// MySubscriptionsConnection is the resolver for the mySubscriptionsConnection field.
func (r *queryResolver) MySubscriptionsConnection(ctx context.Context, page *model.ConnectionInput) (*model.MySubscriptionsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetMySubscriptionsConnection(ctx, first, after, last, before)
}

// ServiceInstancesHealth is the resolver for the serviceInstancesHealth field.
func (r *queryResolver) ServiceInstancesHealth(ctx context.Context, serviceID *string) ([]*proto.ServiceInstanceHealth, error) {
	var resp *proto.ListServicesHealthResponse
	var err error
	if serviceID != nil && *serviceID != "" {
		resp, err = r.Clients.Quartermaster.GetServiceHealth(ctx, *serviceID)
	} else {
		resp, err = r.Clients.Quartermaster.ListServicesHealth(ctx, nil)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get service health: %w", err)
	}
	return resp.Instances, nil
}

// MarketplaceClusters is the resolver for the marketplaceClusters field.
func (r *queryResolver) MarketplaceClusters(ctx context.Context, first *int, after *string) ([]*proto.MarketplaceClusterEntry, error) {
	return r.DoListMarketplaceClusters(ctx, first, after)
}

// MarketplaceClustersConnection is the resolver for the marketplaceClustersConnection field.
func (r *queryResolver) MarketplaceClustersConnection(ctx context.Context, page *model.ConnectionInput) (*model.MarketplaceClusterConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetMarketplaceClustersConnection(ctx, first, after, last, before)
}

// MarketplaceCluster is the resolver for the marketplaceCluster field.
func (r *queryResolver) MarketplaceCluster(ctx context.Context, clusterID string) (*proto.MarketplaceClusterEntry, error) {
	rawID, err := globalid.DecodeExpected(clusterID, globalid.TypeCluster)
	if err != nil {
		return nil, err
	}
	return r.DoGetMarketplaceCluster(ctx, rawID, nil)
}

// PendingSubscriptions is the resolver for the pendingSubscriptions field.
func (r *queryResolver) PendingSubscriptions(ctx context.Context, clusterID string) ([]*proto.ClusterSubscription, error) {
	rawID, err := globalid.DecodeExpected(clusterID, globalid.TypeCluster)
	if err != nil {
		return nil, err
	}
	return r.DoListPendingSubscriptions(ctx, rawID)
}

// PendingSubscriptionsConnection is the resolver for the pendingSubscriptionsConnection field.
func (r *queryResolver) PendingSubscriptionsConnection(ctx context.Context, page *model.ConnectionInput, clusterID string) (*model.ClusterSubscriptionConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	rawID, err := globalid.DecodeExpected(clusterID, globalid.TypeCluster)
	if err != nil {
		return nil, err
	}
	return r.DoGetPendingSubscriptionsConnection(ctx, rawID, first, after, last, before)
}

// ClusterInvites is the resolver for the clusterInvites field.
func (r *queryResolver) ClusterInvites(ctx context.Context, clusterID string) ([]*proto.ClusterInvite, error) {
	rawID, err := globalid.DecodeExpected(clusterID, globalid.TypeCluster)
	if err != nil {
		return nil, err
	}
	return r.DoListClusterInvites(ctx, rawID)
}

// ClusterInvitesConnection is the resolver for the clusterInvitesConnection field.
func (r *queryResolver) ClusterInvitesConnection(ctx context.Context, page *model.ConnectionInput, clusterID string) (*model.ClusterInviteConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	rawID, err := globalid.DecodeExpected(clusterID, globalid.TypeCluster)
	if err != nil {
		return nil, err
	}
	return r.DoGetClusterInvitesConnection(ctx, rawID, first, after, last, before)
}

// MyClusterInvites is the resolver for the myClusterInvites field.
func (r *queryResolver) MyClusterInvites(ctx context.Context) ([]*proto.ClusterInvite, error) {
	return r.DoListMyClusterInvites(ctx)
}

// MyClusterInvitesConnection is the resolver for the myClusterInvitesConnection field.
func (r *queryResolver) MyClusterInvitesConnection(ctx context.Context, page *model.ConnectionInput) (*model.ClusterInviteConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetMyClusterInvitesConnection(ctx, first, after, last, before)
}

// DeveloperTokensConnection is the resolver for the developerTokensConnection field.
func (r *queryResolver) DeveloperTokensConnection(ctx context.Context, page *model.ConnectionInput) (*model.DeveloperTokensConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetDeveloperTokensConnection(ctx, first, after, last, before)
}

// BootstrapTokensConnection is the resolver for the bootstrapTokensConnection field.
func (r *queryResolver) BootstrapTokensConnection(ctx context.Context, page *model.ConnectionInput, kind *string) (*model.BootstrapTokenConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetBootstrapTokensConnection(ctx, kind, first, after, last, before)
}

// DvrRecordingsConnection is the resolver for the dvrRecordingsConnection field.
func (r *queryResolver) DvrRecordingsConnection(ctx context.Context, page *model.ConnectionInput, streamID *string) (*model.DVRRecordingsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetDVRRecordingsConnection(ctx, streamID, first, after, last, before)
}

// VodAsset is the resolver for the vodAsset field.
func (r *queryResolver) VodAsset(ctx context.Context, id string) (*model.VodAsset, error) {
	rawID, err := resolvers.NormalizeVodHash(id)
	if err != nil {
		return nil, err
	}
	return r.DoGetVodAsset(ctx, rawID)
}

// VodAssetsConnection is the resolver for the vodAssetsConnection field.
func (r *queryResolver) VodAssetsConnection(ctx context.Context, page *model.ConnectionInput) (*model.VodAssetsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetVodAssetsConnection(ctx, first, after, last, before)
}

// ResolveViewerEndpoint is the resolver for the resolveViewerEndpoint field.
// Returns proto.ViewerEndpointResponse directly via autobind.
func (r *queryResolver) ResolveViewerEndpoint(ctx context.Context, contentID string) (*proto.ViewerEndpointResponse, error) {
	// Extract viewer IP from request context
	var viewerIP *string

	// Extract IP from GraphQL request context
	if ginCtx := ctx.Value(ctxkeys.KeyGinContext); ginCtx != nil {
		if c, ok := ginCtx.(*gin.Context); ok {
			clientIP := c.ClientIP() // Gin's built-in method handles X-Forwarded-For, etc.
			viewerIP = &clientIP
		}
	}

	// Fallback: try to get from raw HTTP request
	if viewerIP == nil {
		if req := ctx.Value(ctxkeys.KeyHTTPRequest); req != nil {
			if httpReq, ok := req.(*http.Request); ok && httpReq != nil {
				clientIP := httpReq.Header.Get("X-Forwarded-For")
				if clientIP == "" {
					clientIP = httpReq.Header.Get("X-Real-IP")
				}
				if clientIP == "" {
					clientIP = httpReq.RemoteAddr
				}
				// Extract IP from potential "ip:port" format
				if idx := strings.LastIndex(clientIP, ":"); idx != -1 {
					clientIP = clientIP[:idx]
				}
				// Use first IP if comma-separated list
				if strings.Contains(clientIP, ",") {
					clientIP = strings.TrimSpace(strings.Split(clientIP, ",")[0])
				}
				viewerIP = &clientIP
			}
		}
	}

	// If we still don't have an IP, this is an error
	if viewerIP == nil {
		return nil, fmt.Errorf("unable to determine viewer IP address for GeoIP routing")
	}

	// Call Commodore's viewer endpoint resolution (which then calls Foghorn)
	// proto.ViewerEndpointResponse is autobound to GraphQL ViewerEndpointResponse
	return r.DoResolveViewerEndpoint(ctx, contentID, viewerIP)
}

// ResolveIngestEndpoint is the resolver for the resolveIngestEndpoint field.
func (r *queryResolver) ResolveIngestEndpoint(ctx context.Context, streamKey string) (*proto.IngestEndpointResponse, error) {
	// Extract client IP from request context for geo-routing
	var viewerIP *string

	if ginCtx := ctx.Value(ctxkeys.KeyGinContext); ginCtx != nil {
		if c, ok := ginCtx.(*gin.Context); ok {
			clientIP := c.ClientIP()
			viewerIP = &clientIP
		}
	}

	// Fallback: try to get from raw HTTP request
	if viewerIP == nil {
		if req := ctx.Value(ctxkeys.KeyHTTPRequest); req != nil {
			if httpReq, ok := req.(*http.Request); ok && httpReq != nil {
				clientIP := httpReq.Header.Get("X-Forwarded-For")
				if clientIP == "" {
					clientIP = httpReq.Header.Get("X-Real-IP")
				}
				if clientIP == "" {
					clientIP = httpReq.RemoteAddr
				}
				if idx := strings.LastIndex(clientIP, ":"); idx != -1 {
					clientIP = clientIP[:idx]
				}
				if strings.Contains(clientIP, ",") {
					clientIP = strings.TrimSpace(strings.Split(clientIP, ",")[0])
				}
				viewerIP = &clientIP
			}
		}
	}

	return r.DoResolveIngestEndpoint(ctx, streamKey, viewerIP)
}

// SkipperConversations is the resolver for the skipperConversations field.
func (r *queryResolver) SkipperConversations(ctx context.Context, limit *int, offset *int) ([]*model.SkipperConversationSummary, error) {
	return r.Resolver.DoSkipperConversations(ctx, limit, offset)
}

// SkipperConversation is the resolver for the skipperConversation field.
func (r *queryResolver) SkipperConversation(ctx context.Context, id string) (*model.SkipperConversation, error) {
	return r.Resolver.DoSkipperConversation(ctx, id)
}

// ConversationsConnection is the resolver for the conversationsConnection field.
func (r *queryResolver) ConversationsConnection(ctx context.Context, page *model.ConnectionInput) (*model.ConversationsConnection, error) {
	resolver := r.Resolver
	if resolver == nil {
		return nil, fmt.Errorf("resolver unavailable")
	}
	return resolver.ConversationsConnection(ctx, page)
}

// Conversation is the resolver for the conversation field.
func (r *queryResolver) Conversation(ctx context.Context, id string) (*model.Conversation, error) {
	resolver := r.Resolver
	if resolver == nil {
		return nil, fmt.Errorf("resolver unavailable")
	}
	return resolver.Conversation(ctx, id)
}

// MessagesConnection is the resolver for the messagesConnection field.
func (r *queryResolver) MessagesConnection(ctx context.Context, conversationID string, page *model.ConnectionInput) (*model.MessagesConnection, error) {
	resolver := r.Resolver
	if resolver == nil {
		return nil, fmt.Errorf("resolver unavailable")
	}
	return resolver.MessagesConnection(ctx, conversationID, page)
}

// Timestamp is the resolver for the timestamp field.
func (r *rebufferingEventResolver) Timestamp(ctx context.Context, obj *proto.RebufferingEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *rebufferingEventResolver) StreamID(ctx context.Context, obj *proto.RebufferingEvent) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *rebufferingEventResolver) Stream(ctx context.Context, obj *proto.RebufferingEvent) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// BufferState is the resolver for the bufferState field.
func (r *rebufferingEventResolver) BufferState(ctx context.Context, obj *proto.RebufferingEvent) (model.BufferState, error) {
	s := strings.ToUpper(obj.BufferState)
	switch s {
	case "FULL":
		return model.BufferStateFull, nil
	case "EMPTY":
		return model.BufferStateEmpty, nil
	case "DRY":
		return model.BufferStateDry, nil
	case "RECOVER":
		return model.BufferStateRecover, nil
	default:
		return model.BufferStateRecover, nil
	}
}

// PreviousState is the resolver for the previousState field.
func (r *rebufferingEventResolver) PreviousState(ctx context.Context, obj *proto.RebufferingEvent) (model.BufferState, error) {
	s := strings.ToUpper(obj.PrevState)
	switch s {
	case "FULL":
		return model.BufferStateFull, nil
	case "EMPTY":
		return model.BufferStateEmpty, nil
	case "DRY":
		return model.BufferStateDry, nil
	case "RECOVER":
		return model.BufferStateRecover, nil
	default:
		return model.BufferStateRecover, nil
	}
}

// RebufferStart is the resolver for the rebufferStart field.
func (r *rebufferingEventResolver) RebufferStart(ctx context.Context, obj *proto.RebufferingEvent) (bool, error) {
	return obj.RebufferStart != nil, nil
}

// RebufferEnd is the resolver for the rebufferEnd field.
func (r *rebufferingEventResolver) RebufferEnd(ctx context.Context, obj *proto.RebufferingEvent) (bool, error) {
	return obj.RebufferEnd != nil, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *routingEventResolver) Timestamp(ctx context.Context, obj *proto.RoutingEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *routingEventResolver) StreamID(ctx context.Context, obj *proto.RoutingEvent) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *routingEventResolver) Stream(ctx context.Context, obj *proto.RoutingEvent) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// LatencyMs is the resolver for the latencyMs field.
func (r *routingEventResolver) LatencyMs(ctx context.Context, obj *proto.RoutingEvent) (*float64, error) {
	v := float64(obj.LatencyMs)
	return &v, nil
}

// Status is the resolver for the status field.
func (r *serviceInstanceResolver) Status(ctx context.Context, obj *proto.ServiceInstance) (model.InstanceStatus, error) {
	s := strings.ToLower(obj.Status)
	switch s {
	case "running", "active":
		return model.InstanceStatusRunning, nil
	case "starting", "booting":
		return model.InstanceStatusStarting, nil
	case "stopping", "terminating":
		return model.InstanceStatusStopping, nil
	case "stopped", "inactive":
		return model.InstanceStatusStopped, nil
	case "error", "failed", "crashed":
		return model.InstanceStatusError, nil
	default:
		return model.InstanceStatusUnknown, nil
	}
}

// HealthStatus is the resolver for the healthStatus field.
func (r *serviceInstanceResolver) HealthStatus(ctx context.Context, obj *proto.ServiceInstance) (model.NodeStatus, error) {
	hs := strings.ToLower(obj.HealthStatus)
	switch hs {
	case "healthy", "ok", "passing":
		return model.NodeStatusHealthy, nil
	case "degraded", "warning":
		return model.NodeStatusDegraded, nil
	case "unhealthy", "failing", "error":
		return model.NodeStatusUnhealthy, nil
	default:
		return model.NodeStatusUnhealthy, nil
	}
}

// StartedAt is the resolver for the startedAt field.
func (r *serviceInstanceResolver) StartedAt(ctx context.Context, obj *proto.ServiceInstance) (*time.Time, error) {
	if obj.StartedAt == nil {
		return nil, nil
	}
	t := obj.StartedAt.AsTime()
	return &t, nil
}

// StoppedAt is the resolver for the stoppedAt field.
func (r *serviceInstanceResolver) StoppedAt(ctx context.Context, obj *proto.ServiceInstance) (*time.Time, error) {
	if obj.StoppedAt == nil {
		return nil, nil
	}
	t := obj.StoppedAt.AsTime()
	return &t, nil
}

// LastHealthCheck is the resolver for the lastHealthCheck field.
func (r *serviceInstanceResolver) LastHealthCheck(ctx context.Context, obj *proto.ServiceInstance) (*time.Time, error) {
	if obj.LastHealthCheck == nil {
		return nil, nil
	}
	t := obj.LastHealthCheck.AsTime()
	return &t, nil
}

// Host is the resolver for the host field.
func (r *serviceInstanceHealthResolver) Host(ctx context.Context, obj *proto.ServiceInstanceHealth) (*string, error) {
	if !r.CanViewSensitiveInfraData(ctx, obj.ClusterId) {
		return nil, nil
	}
	if obj.Host == nil || *obj.Host == "" {
		return nil, nil
	}
	return obj.Host, nil
}

// HealthEndpoint is the resolver for the healthEndpoint field.
func (r *serviceInstanceHealthResolver) HealthEndpoint(ctx context.Context, obj *proto.ServiceInstanceHealth) (*string, error) {
	if !r.CanViewSensitiveInfraData(ctx, obj.ClusterId) {
		return nil, nil
	}
	if obj.HealthEndpoint == nil || *obj.HealthEndpoint == "" {
		return nil, nil
	}
	return obj.HealthEndpoint, nil
}

// LastHealthCheck is the resolver for the lastHealthCheck field.
func (r *serviceInstanceHealthResolver) LastHealthCheck(ctx context.Context, obj *proto.ServiceInstanceHealth) (*time.Time, error) {
	if obj.LastHealthCheck == nil {
		return nil, nil
	}
	t := obj.LastHealthCheck.AsTime()
	return &t, nil
}

// Sources is the resolver for the sources field.
func (r *skipperMessageResolver) Sources(ctx context.Context, obj *model.SkipperMessage) (*string, error) {
	if obj.Sources == nil {
		return nil, nil
	}
	b, err := json.Marshal(obj.Sources)
	if err != nil {
		return nil, err
	}
	s := string(b)
	return &s, nil
}

// ToolsUsed is the resolver for the toolsUsed field.
func (r *skipperMessageResolver) ToolsUsed(ctx context.Context, obj *model.SkipperMessage) (*string, error) {
	if obj.ToolsUsed == nil {
		return nil, nil
	}
	b, err := json.Marshal(obj.ToolsUsed)
	if err != nil {
		return nil, err
	}
	s := string(b)
	return &s, nil
}

// Payload is the resolver for the payload field.
func (r *skipperToolDetailResolver) Payload(ctx context.Context, obj *model.SkipperToolDet) (string, error) {
	if obj.Payload == nil {
		return "{}", nil
	}
	b, err := json.Marshal(obj.Payload)
	if err != nil {
		return "", err
	}
	return string(b), nil
}

// ID is the resolver for the id field.
func (r *storageEventResolver) ID(ctx context.Context, obj *proto.StorageEvent) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeStorageEvent, obj.StreamId, obj.Id, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *storageEventResolver) Timestamp(ctx context.Context, obj *proto.StorageEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *storageEventResolver) StreamID(ctx context.Context, obj *proto.StorageEvent) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *storageEventResolver) Stream(ctx context.Context, obj *proto.StorageEvent) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *storageEventResolver) SizeBytes(ctx context.Context, obj *proto.StorageEvent) (float64, error) {
	return float64(obj.SizeBytes), nil
}

// StorageUsageConnection is the resolver for the storageUsageConnection field.
func (r *storageUsageResolver) StorageUsageConnection(ctx context.Context, obj *markers.StorageUsage, page *model.ConnectionInput, nodeID *string, storageScope *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.StorageUsageConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetStorageUsageConnection(ctx, nodeID, storageScope, timeRange, first, after, last, before, noCache)
}

// ID is the resolver for the id field.
func (r *storageUsageRecordResolver) ID(ctx context.Context, obj *proto.StorageUsageRecord) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeStorageUsageRecord, obj.NodeId, obj.StorageScope, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *storageUsageRecordResolver) Timestamp(ctx context.Context, obj *proto.StorageUsageRecord) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// TotalBytes is the resolver for the totalBytes field.
func (r *storageUsageRecordResolver) TotalBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.TotalBytes), nil
}

// FileCount is the resolver for the fileCount field.
func (r *storageUsageRecordResolver) FileCount(ctx context.Context, obj *proto.StorageUsageRecord) (int, error) {
	return int(obj.FileCount), nil
}

// DvrBytes is the resolver for the dvrBytes field.
func (r *storageUsageRecordResolver) DvrBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.DvrBytes), nil
}

// ClipBytes is the resolver for the clipBytes field.
func (r *storageUsageRecordResolver) ClipBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.ClipBytes), nil
}

// VodBytes is the resolver for the vodBytes field.
func (r *storageUsageRecordResolver) VodBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.VodBytes), nil
}

// FrozenDvrBytes is the resolver for the frozenDvrBytes field.
func (r *storageUsageRecordResolver) FrozenDvrBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.FrozenDvrBytes), nil
}

// FrozenClipBytes is the resolver for the frozenClipBytes field.
func (r *storageUsageRecordResolver) FrozenClipBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.FrozenClipBytes), nil
}

// FrozenVodBytes is the resolver for the frozenVodBytes field.
func (r *storageUsageRecordResolver) FrozenVodBytes(ctx context.Context, obj *proto.StorageUsageRecord) (float64, error) {
	return float64(obj.FrozenVodBytes), nil
}

// ID is the resolver for the id field.
func (r *streamResolver) ID(ctx context.Context, obj *proto.Stream) (string, error) {
	return globalid.Encode(globalid.TypeStream, obj.StreamId), nil
}

// Name is the resolver for the name field.
func (r *streamResolver) Name(ctx context.Context, obj *proto.Stream) (string, error) {
	return obj.Title, nil
}

// Record is the resolver for the record field.
func (r *streamResolver) Record(ctx context.Context, obj *proto.Stream) (bool, error) {
	return obj.IsRecording, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *streamResolver) CreatedAt(ctx context.Context, obj *proto.Stream) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *streamResolver) UpdatedAt(ctx context.Context, obj *proto.Stream) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// Metrics is the resolver for the metrics field.
func (r *streamResolver) Metrics(ctx context.Context, obj *proto.Stream) (*proto.StreamStatusResponse, error) {
	// In demo mode, return metrics from the stream object itself (set by demo.GenerateStreams)
	if middleware.IsDemoMode(ctx) {
		resp := &proto.StreamStatusResponse{
			Status:          obj.Status,
			CurrentViewers:  int64(obj.CurrentViewers),
			PeakViewers:     int64(obj.PeakViewers),
			TotalViews:      int64(obj.TotalViews),
			DurationSeconds: int64(obj.Duration),
			StartedAt:       obj.StartedAt,
			EndedAt:         obj.EndedAt,
		}
		// Add quality metrics for live/recording streams
		switch obj.Status {
		case "live", "recording":
			bufferState := "FULL"
			qualityTier := "1080p30"
			primaryWidth := int32(1920)
			primaryHeight := int32(1080)
			primaryFps := float32(30.0)
			primaryCodec := "H264"
			primaryBitrate := int32(4500)
			hasIssues := false
			resp.BufferState = &bufferState
			resp.QualityTier = &qualityTier
			resp.PrimaryWidth = &primaryWidth
			resp.PrimaryHeight = &primaryHeight
			resp.PrimaryFps = &primaryFps
			resp.PrimaryCodec = &primaryCodec
			resp.PrimaryBitrate = &primaryBitrate
			resp.HasIssues = &hasIssues
			resp.LastEventType = "stream-buffer"
			resp.LastEventAt = obj.UpdatedAt
		case "ended":
			// Ended streams have last event info
			resp.LastEventType = "stream-end"
			resp.LastEventAt = obj.EndedAt
		}
		return resp, nil
	}

	tenantID := ctxkeys.GetTenantID(ctx)
	if tenantID == "" {
		return nil, nil
	}

	// Use loader for request-scoped caching
	loaders := loaders.FromContext(ctx)
	if loaders == nil || loaders.StreamMetrics == nil {
		// Fallback: direct call
		return r.Clients.Periscope.GetStreamStatus(ctx, tenantID, obj.StreamId)
	}

	return loaders.StreamMetrics.Load(ctx, tenantID, obj.StreamId)
}

// ID is the resolver for the id field.
func (r *streamAnalyticsDailyResolver) ID(ctx context.Context, obj *proto.StreamAnalyticsDaily) (string, error) {
	dayPart := encodeProtoTimestampPart(obj.Day)
	return globalid.EncodeComposite(globalid.TypeStreamAnalyticsDaily, obj.StreamId, dayPart), nil
}

// Day is the resolver for the day field.
func (r *streamAnalyticsDailyResolver) Day(ctx context.Context, obj *proto.StreamAnalyticsDaily) (*time.Time, error) {
	if obj.Day == nil {
		return nil, nil
	}
	t := obj.Day.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *streamAnalyticsDailyResolver) StreamID(ctx context.Context, obj *proto.StreamAnalyticsDaily) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *streamAnalyticsDailyResolver) Stream(ctx context.Context, obj *proto.StreamAnalyticsDaily) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// EgressBytes is the resolver for the egressBytes field.
func (r *streamAnalyticsDailyResolver) EgressBytes(ctx context.Context, obj *proto.StreamAnalyticsDaily) (float64, error) {
	return float64(obj.EgressBytes), nil
}

// StreamID is the resolver for the streamId field.
func (r *streamAnalyticsSummaryResolver) StreamID(ctx context.Context, obj *proto.StreamAnalyticsSummary) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *streamAnalyticsSummaryResolver) Stream(ctx context.Context, obj *proto.StreamAnalyticsSummary) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// RangeAvgViewers is the resolver for the rangeAvgViewers field.
func (r *streamAnalyticsSummaryResolver) RangeAvgViewers(ctx context.Context, obj *proto.StreamAnalyticsSummary) (float64, error) {
	return float64(obj.RangeAvgViewers), nil
}

// RangePeakConcurrentViewers is the resolver for the rangePeakConcurrentViewers field.
func (r *streamAnalyticsSummaryResolver) RangePeakConcurrentViewers(ctx context.Context, obj *proto.StreamAnalyticsSummary) (int, error) {
	return int(obj.RangePeakConcurrentViewers), nil
}

// RangeAvgBufferHealth is the resolver for the rangeAvgBufferHealth field.
func (r *streamAnalyticsSummaryResolver) RangeAvgBufferHealth(ctx context.Context, obj *proto.StreamAnalyticsSummary) (float64, error) {
	return float64(obj.RangeAvgBufferHealth), nil
}

// RangeAvgBitrate is the resolver for the rangeAvgBitrate field.
func (r *streamAnalyticsSummaryResolver) RangeAvgBitrate(ctx context.Context, obj *proto.StreamAnalyticsSummary) (int, error) {
	return int(obj.RangeAvgBitrate), nil
}

// RangeAvgFps is the resolver for the rangeAvgFps field.
func (r *streamAnalyticsSummaryResolver) RangeAvgFps(ctx context.Context, obj *proto.StreamAnalyticsSummary) (float64, error) {
	return float64(obj.RangeAvgFps), nil
}

// RangePacketLossRate is the resolver for the rangePacketLossRate field.
func (r *streamAnalyticsSummaryResolver) RangePacketLossRate(ctx context.Context, obj *proto.StreamAnalyticsSummary) (*float64, error) {
	value := float64(obj.RangePacketLossRate)
	return &value, nil
}

// RangeAvgConnectionTime is the resolver for the rangeAvgConnectionTime field.
func (r *streamAnalyticsSummaryResolver) RangeAvgConnectionTime(ctx context.Context, obj *proto.StreamAnalyticsSummary) (*float64, error) {
	value := float64(obj.RangeAvgConnectionTime)
	return &value, nil
}

// RangeViewerHours is the resolver for the rangeViewerHours field.
func (r *streamAnalyticsSummaryResolver) RangeViewerHours(ctx context.Context, obj *proto.StreamAnalyticsSummary) (float64, error) {
	return float64(obj.RangeViewerHours), nil
}

// RangeEgressGb is the resolver for the rangeEgressGb field.
func (r *streamAnalyticsSummaryResolver) RangeEgressGb(ctx context.Context, obj *proto.StreamAnalyticsSummary) (float64, error) {
	return float64(obj.RangeEgressGb), nil
}

// RangeAvgSessionSeconds is the resolver for the rangeAvgSessionSeconds field.
func (r *streamAnalyticsSummaryResolver) RangeAvgSessionSeconds(ctx context.Context, obj *proto.StreamAnalyticsSummary) (float64, error) {
	return float64(obj.RangeAvgSessionSeconds), nil
}

// RangeAvgBytesPerSession is the resolver for the rangeAvgBytesPerSession field.
func (r *streamAnalyticsSummaryResolver) RangeAvgBytesPerSession(ctx context.Context, obj *proto.StreamAnalyticsSummary) (float64, error) {
	return float64(obj.RangeAvgBytesPerSession), nil
}

// RangeEgressSharePercent is the resolver for the rangeEgressSharePercent field.
func (r *streamAnalyticsSummaryResolver) RangeEgressSharePercent(ctx context.Context, obj *proto.StreamAnalyticsSummary) (*float64, error) {
	if obj.RangeEgressSharePercent == nil {
		return nil, nil
	}
	val := float64(*obj.RangeEgressSharePercent)
	return &val, nil
}

// RangeViewerSharePercent is the resolver for the rangeViewerSharePercent field.
func (r *streamAnalyticsSummaryResolver) RangeViewerSharePercent(ctx context.Context, obj *proto.StreamAnalyticsSummary) (*float64, error) {
	if obj.RangeViewerSharePercent == nil {
		return nil, nil
	}
	val := float64(*obj.RangeViewerSharePercent)
	return &val, nil
}

// RangeViewerHoursSharePercent is the resolver for the rangeViewerHoursSharePercent field.
func (r *streamAnalyticsSummaryResolver) RangeViewerHoursSharePercent(ctx context.Context, obj *proto.StreamAnalyticsSummary) (*float64, error) {
	if obj.RangeViewerHoursSharePercent == nil {
		return nil, nil
	}
	val := float64(*obj.RangeViewerHoursSharePercent)
	return &val, nil
}

// ID is the resolver for the id field.
func (r *streamConnectionHourlyResolver) ID(ctx context.Context, obj *proto.StreamConnectionHourly) (string, error) {
	hourPart := encodeProtoTimestampPart(obj.Hour)
	return globalid.EncodeComposite(globalid.TypeStreamConnectionHourly, obj.StreamId, hourPart), nil
}

// Hour is the resolver for the hour field.
func (r *streamConnectionHourlyResolver) Hour(ctx context.Context, obj *proto.StreamConnectionHourly) (*time.Time, error) {
	if obj.Hour == nil {
		return nil, nil
	}
	t := obj.Hour.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *streamConnectionHourlyResolver) StreamID(ctx context.Context, obj *proto.StreamConnectionHourly) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *streamConnectionHourlyResolver) Stream(ctx context.Context, obj *proto.StreamConnectionHourly) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// TotalBytes is the resolver for the totalBytes field.
func (r *streamConnectionHourlyResolver) TotalBytes(ctx context.Context, obj *proto.StreamConnectionHourly) (float64, error) {
	return float64(obj.TotalBytes), nil
}

// UniqueViewers is the resolver for the uniqueViewers field.
func (r *streamConnectionHourlyResolver) UniqueViewers(ctx context.Context, obj *proto.StreamConnectionHourly) (int, error) {
	return int(obj.UniqueViewers), nil
}

// TotalSessions is the resolver for the totalSessions field.
func (r *streamConnectionHourlyResolver) TotalSessions(ctx context.Context, obj *proto.StreamConnectionHourly) (int, error) {
	return int(obj.TotalSessions), nil
}

// ID is the resolver for the id field.
func (r *streamEventResolver) ID(ctx context.Context, obj *model.StreamEvent) (string, error) {
	tsPart := encodeTimePart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeStreamEvent, obj.StreamId, obj.EventId, tsPart), nil
}

// StreamID is the resolver for the streamId field.
func (r *streamEventResolver) StreamID(ctx context.Context, obj *model.StreamEvent) (string, error) {
	return encodeStreamID(obj.StreamId)
}

// Stream is the resolver for the stream field.
func (r *streamEventResolver) Stream(ctx context.Context, obj *model.StreamEvent) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.StreamId)
}

// Payload is the resolver for the payload field.
func (r *streamEventResolver) Payload(ctx context.Context, obj *model.StreamEvent) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if obj.Payload == nil || *obj.Payload == "" {
		return nil, nil
	}
	return obj.Payload, nil
}

// ID is the resolver for the id field.
func (r *streamHealth5mResolver) ID(ctx context.Context, obj *proto.StreamHealth5M) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeStreamHealth5m, obj.StreamId, obj.NodeId, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *streamHealth5mResolver) Timestamp(ctx context.Context, obj *proto.StreamHealth5M) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// AvgFps is the resolver for the avgFps field.
func (r *streamHealth5mResolver) AvgFps(ctx context.Context, obj *proto.StreamHealth5M) (float64, error) {
	return float64(obj.AvgFps), nil
}

// AvgBufferHealth is the resolver for the avgBufferHealth field.
func (r *streamHealth5mResolver) AvgBufferHealth(ctx context.Context, obj *proto.StreamHealth5M) (float64, error) {
	return float64(obj.AvgBufferHealth), nil
}

// AvgFrameJitterMs is the resolver for the avgFrameJitterMs field.
func (r *streamHealth5mResolver) AvgFrameJitterMs(ctx context.Context, obj *proto.StreamHealth5M) (*float64, error) {
	if obj.AvgFrameJitterMs == nil {
		return nil, nil
	}
	v := float64(*obj.AvgFrameJitterMs)
	return &v, nil
}

// MaxFrameJitterMs is the resolver for the maxFrameJitterMs field.
func (r *streamHealth5mResolver) MaxFrameJitterMs(ctx context.Context, obj *proto.StreamHealth5M) (*float64, error) {
	if obj.MaxFrameJitterMs == nil {
		return nil, nil
	}
	v := float64(*obj.MaxFrameJitterMs)
	return &v, nil
}

// ID is the resolver for the id field.
func (r *streamHealthMetricResolver) ID(ctx context.Context, obj *proto.StreamHealthMetric) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeStreamHealthMetric, obj.StreamId, obj.NodeId, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *streamHealthMetricResolver) Timestamp(ctx context.Context, obj *proto.StreamHealthMetric) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *streamHealthMetricResolver) StreamID(ctx context.Context, obj *proto.StreamHealthMetric) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *streamHealthMetricResolver) Stream(ctx context.Context, obj *proto.StreamHealthMetric) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// Fps is the resolver for the fps field.
func (r *streamHealthMetricResolver) Fps(ctx context.Context, obj *proto.StreamHealthMetric) (*float64, error) {
	if obj.Fps == 0 {
		return nil, nil
	}
	v := float64(obj.Fps)
	return &v, nil
}

// FrameMsMax is the resolver for the frameMsMax field.
func (r *streamHealthMetricResolver) FrameMsMax(ctx context.Context, obj *proto.StreamHealthMetric) (*float64, error) {
	if obj.FrameMsMax == nil {
		return nil, nil
	}
	v := float64(*obj.FrameMsMax)
	return &v, nil
}

// FrameMsMin is the resolver for the frameMsMin field.
func (r *streamHealthMetricResolver) FrameMsMin(ctx context.Context, obj *proto.StreamHealthMetric) (*float64, error) {
	if obj.FrameMsMin == nil {
		return nil, nil
	}
	v := float64(*obj.FrameMsMin)
	return &v, nil
}

// KeyframeMsMax is the resolver for the keyframeMsMax field.
func (r *streamHealthMetricResolver) KeyframeMsMax(ctx context.Context, obj *proto.StreamHealthMetric) (*float64, error) {
	if obj.KeyframeMsMax == nil {
		return nil, nil
	}
	v := float64(*obj.KeyframeMsMax)
	return &v, nil
}

// KeyframeMsMin is the resolver for the keyframeMsMin field.
func (r *streamHealthMetricResolver) KeyframeMsMin(ctx context.Context, obj *proto.StreamHealthMetric) (*float64, error) {
	if obj.KeyframeMsMin == nil {
		return nil, nil
	}
	v := float64(*obj.KeyframeMsMin)
	return &v, nil
}

// BufferState is the resolver for the bufferState field.
func (r *streamHealthMetricResolver) BufferState(ctx context.Context, obj *proto.StreamHealthMetric) (model.BufferState, error) {
	s := strings.ToUpper(obj.BufferState)
	switch s {
	case "FULL":
		return model.BufferStateFull, nil
	case "EMPTY":
		return model.BufferStateEmpty, nil
	case "DRY":
		return model.BufferStateDry, nil
	case "RECOVER":
		return model.BufferStateRecover, nil
	default:
		return model.BufferStateRecover, nil
	}
}

// BufferHealth is the resolver for the bufferHealth field.
func (r *streamHealthMetricResolver) BufferHealth(ctx context.Context, obj *proto.StreamHealthMetric) (*float64, error) {
	v := float64(obj.BufferHealth)
	return &v, nil
}

// AudioChannels is the resolver for the audioChannels field.
func (r *streamHealthMetricResolver) AudioChannels(ctx context.Context, obj *proto.StreamHealthMetric) (*int, error) {
	if obj.PrimaryAudioChannels == nil {
		return nil, nil
	}
	v := int(*obj.PrimaryAudioChannels)
	return &v, nil
}

// AudioSampleRate is the resolver for the audioSampleRate field.
func (r *streamHealthMetricResolver) AudioSampleRate(ctx context.Context, obj *proto.StreamHealthMetric) (*int, error) {
	if obj.PrimaryAudioSampleRate == nil {
		return nil, nil
	}
	v := int(*obj.PrimaryAudioSampleRate)
	return &v, nil
}

// AudioCodec is the resolver for the audioCodec field.
func (r *streamHealthMetricResolver) AudioCodec(ctx context.Context, obj *proto.StreamHealthMetric) (*string, error) {
	if obj.PrimaryAudioCodec != nil {
		return obj.PrimaryAudioCodec, nil
	}
	// Fallback to generic codec field if no audio-specific codec
	if obj.Codec == "" {
		return nil, nil
	}
	return &obj.Codec, nil
}

// AudioBitrate is the resolver for the audioBitrate field.
func (r *streamHealthMetricResolver) AudioBitrate(ctx context.Context, obj *proto.StreamHealthMetric) (*int, error) {
	if obj.PrimaryAudioBitrate == nil {
		return nil, nil
	}
	v := int(*obj.PrimaryAudioBitrate)
	return &v, nil
}

// StreamID is the resolver for the streamId field.
func (r *streamKeyResolver) StreamID(ctx context.Context, obj *proto.StreamKey) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *streamKeyResolver) Stream(ctx context.Context, obj *proto.StreamKey) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// LastUsedAt is the resolver for the lastUsedAt field.
func (r *streamKeyResolver) LastUsedAt(ctx context.Context, obj *proto.StreamKey) (*time.Time, error) {
	if obj.LastUsedAt == nil {
		return nil, nil
	}
	t := obj.LastUsedAt.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *streamKeyResolver) CreatedAt(ctx context.Context, obj *proto.StreamKey) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// Status is the resolver for the status field.
func (r *streamMetricsResolver) Status(ctx context.Context, obj *proto.StreamStatusResponse) (model.StreamStatus, error) {
	switch obj.Status {
	case "live":
		return model.StreamStatusLive, nil
	case "offline":
		return model.StreamStatusOffline, nil
	case "recording":
		return model.StreamStatusRecording, nil
	case "ended":
		return model.StreamStatusEnded, nil
	default:
		return model.StreamStatusOffline, nil
	}
}

// IsLive is the resolver for the isLive field.
func (r *streamMetricsResolver) IsLive(ctx context.Context, obj *proto.StreamStatusResponse) (bool, error) {
	return obj.Status == "live", nil
}

// StartedAt is the resolver for the startedAt field.
func (r *streamMetricsResolver) StartedAt(ctx context.Context, obj *proto.StreamStatusResponse) (*time.Time, error) {
	if obj.StartedAt == nil {
		return nil, nil
	}
	t := obj.StartedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *streamMetricsResolver) UpdatedAt(ctx context.Context, obj *proto.StreamStatusResponse) (*time.Time, error) {
	if obj.UpdatedAt == nil {
		return nil, fmt.Errorf("stream metrics updatedAt is required but missing")
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// UploadedBytes is the resolver for the uploadedBytes field.
func (r *streamMetricsResolver) UploadedBytes(ctx context.Context, obj *proto.StreamStatusResponse) (float64, error) {
	if obj.UploadedBytes == nil {
		return 0, nil
	}
	return float64(*obj.UploadedBytes), nil
}

// DownloadedBytes is the resolver for the downloadedBytes field.
func (r *streamMetricsResolver) DownloadedBytes(ctx context.Context, obj *proto.StreamStatusResponse) (float64, error) {
	if obj.DownloadedBytes == nil {
		return 0, nil
	}
	return float64(*obj.DownloadedBytes), nil
}

// ViewerSeconds is the resolver for the viewerSeconds field.
func (r *streamMetricsResolver) ViewerSeconds(ctx context.Context, obj *proto.StreamStatusResponse) (float64, error) {
	if obj.ViewerSeconds == nil {
		return 0, nil
	}
	return float64(*obj.ViewerSeconds), nil
}

// PacketsSent is the resolver for the packetsSent field.
func (r *streamMetricsResolver) PacketsSent(ctx context.Context, obj *proto.StreamStatusResponse) (*float64, error) {
	if obj.PacketsSent == nil {
		return nil, nil
	}
	v := float64(*obj.PacketsSent)
	return &v, nil
}

// PacketsLost is the resolver for the packetsLost field.
func (r *streamMetricsResolver) PacketsLost(ctx context.Context, obj *proto.StreamStatusResponse) (*float64, error) {
	if obj.PacketsLost == nil {
		return nil, nil
	}
	v := float64(*obj.PacketsLost)
	return &v, nil
}

// PacketsRetransmitted is the resolver for the packetsRetransmitted field.
func (r *streamMetricsResolver) PacketsRetransmitted(ctx context.Context, obj *proto.StreamStatusResponse) (*float64, error) {
	if obj.PacketsRetransmitted == nil {
		return nil, nil
	}
	v := float64(*obj.PacketsRetransmitted)
	return &v, nil
}

// PrimaryFps is the resolver for the primaryFps field.
func (r *streamMetricsResolver) PrimaryFps(ctx context.Context, obj *proto.StreamStatusResponse) (*float64, error) {
	if obj.PrimaryFps == nil {
		return nil, nil
	}
	v := float64(*obj.PrimaryFps)
	return &v, nil
}

// ViewerGeographicsConnection is the resolver for the viewerGeographicsConnection field.
func (r *streamingUsageResolver) ViewerGeographicsConnection(ctx context.Context, obj *markers.StreamingUsage, page *model.ConnectionInput, streamID *string, timeRange *model.TimeRangeInput) (*model.ViewerGeographicsConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetViewerGeographicsConnection(ctx, streamID, timeRange, first, after, last, before)
}

// GeographicDistribution is the resolver for the geographicDistribution field.
func (r *streamingUsageResolver) GeographicDistribution(ctx context.Context, obj *markers.StreamingUsage, streamID *string, timeRange *model.TimeRangeInput, topN *int) (*model.GeographicDistribution, error) {
	return r.DoGetGeographicDistribution(ctx, streamID, timeRange, topN)
}

// StreamAnalyticsSummary is the resolver for the streamAnalyticsSummary field.
func (r *streamingUsageResolver) StreamAnalyticsSummary(ctx context.Context, obj *markers.StreamingUsage, streamID string, timeRange *model.TimeRangeInput) (*proto.StreamAnalyticsSummary, error) {
	return r.DoGetStreamAnalyticsSummary(ctx, streamID, timeRange)
}

// StreamAnalyticsSummariesConnection is the resolver for the streamAnalyticsSummariesConnection field.
func (r *streamingUsageResolver) StreamAnalyticsSummariesConnection(ctx context.Context, obj *markers.StreamingUsage, page *model.ConnectionInput, timeRange model.TimeRangeInput, sortBy *proto.StreamSummarySortField, sortOrder *proto.SortOrder) (*model.StreamAnalyticsSummaryConnection, error) {
	return r.DoGetStreamAnalyticsSummariesConnection(ctx, page, &timeRange, sortBy, sortOrder)
}

// ViewerHoursHourlyConnection is the resolver for the viewerHoursHourlyConnection field.
func (r *streamingUsageResolver) ViewerHoursHourlyConnection(ctx context.Context, obj *markers.StreamingUsage, page *model.ConnectionInput, streamID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.ViewerHoursHourlyConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetViewerHoursHourlyConnection(ctx, streamID, timeRange, first, after, last, before, noCache)
}

// ViewerGeoHourlyConnection is the resolver for the viewerGeoHourlyConnection field.
func (r *streamingUsageResolver) ViewerGeoHourlyConnection(ctx context.Context, obj *markers.StreamingUsage, page *model.ConnectionInput, timeRange *model.TimeRangeInput, noCache *bool) (*model.ViewerGeoHourlyConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetViewerGeoHourlyConnection(ctx, timeRange, first, after, last, before, noCache)
}

// ViewerTimeSeriesConnection is the resolver for the viewerTimeSeriesConnection field.
func (r *streamingUsageResolver) ViewerTimeSeriesConnection(ctx context.Context, obj *markers.StreamingUsage, page *model.ConnectionInput, streamID string, timeRange *model.TimeRangeInput, interval *string) (*model.ViewerTimeSeriesConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetViewerTimeSeriesConnection(ctx, streamID, timeRange, interval, first, after, last, before)
}

// QualityTierDailyConnection is the resolver for the qualityTierDailyConnection field.
func (r *streamingUsageResolver) QualityTierDailyConnection(ctx context.Context, obj *markers.StreamingUsage, page *model.ConnectionInput, streamID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.QualityTierDailyConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetQualityTierDailyConnection(ctx, streamID, timeRange, first, after, last, before, noCache)
}

// StreamConnectionHourlyConnection is the resolver for the streamConnectionHourlyConnection field.
func (r *streamingUsageResolver) StreamConnectionHourlyConnection(ctx context.Context, obj *markers.StreamingUsage, page *model.ConnectionInput, streamID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.StreamConnectionHourlyConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetStreamConnectionHourlyConnection(ctx, streamID, timeRange, first, after, last, before, noCache)
}

// TenantAnalyticsDailyConnection is the resolver for the tenantAnalyticsDailyConnection field.
func (r *streamingUsageResolver) TenantAnalyticsDailyConnection(ctx context.Context, obj *markers.StreamingUsage, page *model.ConnectionInput, timeRange *model.TimeRangeInput, noCache *bool) (*model.TenantAnalyticsDailyConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetTenantAnalyticsDailyConnection(ctx, timeRange, first, after, last, before, noCache)
}

// StreamAnalyticsDailyConnection is the resolver for the streamAnalyticsDailyConnection field.
func (r *streamingUsageResolver) StreamAnalyticsDailyConnection(ctx context.Context, obj *markers.StreamingUsage, page *model.ConnectionInput, streamID *string, timeRange *model.TimeRangeInput, noCache *bool) (*model.StreamAnalyticsDailyConnection, error) {
	first, after, last, before := mergeConnectionInput(page, nil, nil, nil, nil)
	return r.DoGetStreamAnalyticsDailyConnection(ctx, streamID, timeRange, first, after, last, before, noCache)
}

// LiveStreamEvents is the resolver for the liveStreamEvents field.
func (r *subscriptionResolver) LiveStreamEvents(ctx context.Context, streamID *string) (<-chan *model.StreamEvent, error) {
	return r.DoStreamUpdates(ctx, streamID)
}

// LiveViewerMetrics is the resolver for the liveViewerMetrics field.
func (r *subscriptionResolver) LiveViewerMetrics(ctx context.Context, streamID string) (<-chan *proto.ClientLifecycleUpdate, error) {
	return r.DoAnalyticsUpdates(ctx, streamID)
}

// LiveConnectionEvents is the resolver for the liveConnectionEvents field.
func (r *subscriptionResolver) LiveConnectionEvents(ctx context.Context, streamID *string) (<-chan *proto.ConnectionEvent, error) {
	return r.DoConnectionEvents(ctx, streamID)
}

// LiveTrackListUpdates is the resolver for the liveTrackListUpdates field.
func (r *subscriptionResolver) LiveTrackListUpdates(ctx context.Context, streamID string) (<-chan *proto.StreamTrackListTrigger, error) {
	return r.DoTrackListUpdates(ctx, streamID)
}

// LiveClipLifecycle is the resolver for the liveClipLifecycle field.
func (r *subscriptionResolver) LiveClipLifecycle(ctx context.Context, streamID string) (<-chan *proto.ClipLifecycleData, error) {
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required for subscriptions: %w", err)
	}
	rawID, err := resolvers.NormalizeStreamID(streamID)
	if err != nil {
		return nil, err
	}
	jwtToken := ctxkeys.GetJWTToken(ctx)
	cfg := resolvers.ConnectionConfig{UserID: user.UserID, TenantID: user.TenantID, JWT: jwtToken}
	return r.SubManager.SubscribeToLifecycle(ctx, cfg, rawID)
}

// LiveDvrLifecycle is the resolver for the liveDvrLifecycle field.
func (r *subscriptionResolver) LiveDvrLifecycle(ctx context.Context, streamID string) (<-chan *proto.DVRLifecycleData, error) {
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required for subscriptions: %w", err)
	}
	rawID, err := resolvers.NormalizeStreamID(streamID)
	if err != nil {
		return nil, err
	}
	jwtToken := ctxkeys.GetJWTToken(ctx)
	cfg := resolvers.ConnectionConfig{UserID: user.UserID, TenantID: user.TenantID, JWT: jwtToken}
	return r.SubManager.SubscribeToDVRLifecycle(ctx, cfg, rawID)
}

// LiveVodLifecycle is the resolver for the liveVodLifecycle field.
func (r *subscriptionResolver) LiveVodLifecycle(ctx context.Context) (<-chan *proto.VodLifecycleData, error) {
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required for subscriptions: %w", err)
	}
	jwtToken := ctxkeys.GetJWTToken(ctx)
	cfg := resolvers.ConnectionConfig{UserID: user.UserID, TenantID: user.TenantID, JWT: jwtToken}
	return r.SubManager.SubscribeToVodLifecycle(ctx, cfg)
}

// LiveStorageEvents is the resolver for the liveStorageEvents field.
func (r *subscriptionResolver) LiveStorageEvents(ctx context.Context, streamID *string) (<-chan *proto.StorageEvent, error) {
	return r.DoStorageEvents(ctx, streamID)
}

// LiveProcessingEvents is the resolver for the liveProcessingEvents field.
func (r *subscriptionResolver) LiveProcessingEvents(ctx context.Context, streamID *string) (<-chan *proto.ProcessingUsageRecord, error) {
	return r.DoProcessingEvents(ctx, streamID)
}

// LiveSystemHealth is the resolver for the liveSystemHealth field.
func (r *subscriptionResolver) LiveSystemHealth(ctx context.Context) (<-chan *proto.NodeLifecycleUpdate, error) {
	return r.DoSystemUpdates(ctx)
}

// LiveFirehose is the resolver for the liveFirehose field.
func (r *subscriptionResolver) LiveFirehose(ctx context.Context) (<-chan *model.TenantEvent, error) {
	if r.Metrics != nil {
		r.Metrics.Operations.WithLabelValues("subscription_firehose", "requested").Inc()
	}

	// Demo mode returns mock events
	if middleware.IsDemoMode(ctx) {
		r.Logger.Debug("Returning demo firehose subscription")
		if r.Metrics != nil {
			r.Metrics.Operations.WithLabelValues("subscription_firehose", "demo").Inc()
		}
		ch := make(chan *model.TenantEvent, 10)
		go func() {
			defer close(ch)
			// Send demo events periodically
			ticker := time.NewTicker(2 * time.Second)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					// Send a random demo event
					ch <- &model.TenantEvent{
						Type:      "demo_event",
						Channel:   "STREAMS",
						Timestamp: time.Now(),
					}
				}
			}
		}()
		return ch, nil
	}

	r.Logger.Info("Setting up firehose subscription")
	user, err := middleware.RequireAuth(ctx)
	if err != nil {
		if r.Metrics != nil {
			r.Metrics.Operations.WithLabelValues("subscription_firehose", "auth_error").Inc()
		}
		return nil, fmt.Errorf("authentication required for firehose subscription: %w", err)
	}

	jwtToken := ctxkeys.GetJWTToken(ctx)

	config := resolvers.ConnectionConfig{UserID: user.UserID, TenantID: user.TenantID, JWT: jwtToken}
	ch, err := r.SubManager.SubscribeToFirehose(ctx, config)
	if err != nil {
		if r.Metrics != nil {
			r.Metrics.Operations.WithLabelValues("subscription_firehose", "error").Inc()
		}
		r.Logger.WithError(err).WithFields(logging.Fields{
			"user_id":   user.UserID,
			"tenant_id": user.TenantID,
		}).Error("Failed to setup firehose subscription")
		return nil, fmt.Errorf("failed to setup firehose subscription: %w", err)
	}

	r.Logger.WithFields(logging.Fields{
		"user_id":   user.UserID,
		"tenant_id": user.TenantID,
	}).Info("Successfully setup firehose subscription")

	if r.Metrics != nil {
		r.Metrics.Operations.WithLabelValues("subscription_firehose", "success").Inc()
	}
	return ch, nil
}

// SkipperChat is the resolver for the skipperChat field.
func (r *subscriptionResolver) SkipperChat(ctx context.Context, input model.SkipperChatInput) (<-chan model.SkipperChatEvent, error) {
	return r.Resolver.DoSkipperChat(ctx, input)
}

// LiveMessageReceived is the resolver for the liveMessageReceived field.
// Streams new messages for a specific conversation via Signalman's CHANNEL_MESSAGING.
func (r *subscriptionResolver) LiveMessageReceived(ctx context.Context, conversationID string) (<-chan *model.Message, error) {
	return r.DoMessageUpdates(ctx, conversationID)
}

// LiveConversationUpdates is the resolver for the liveConversationUpdates field.
// Streams conversation lifecycle updates via Signalman's CHANNEL_MESSAGING.
func (r *subscriptionResolver) LiveConversationUpdates(ctx context.Context, conversationID *string) (<-chan *model.Conversation, error) {
	return r.DoConversationUpdates(ctx, conversationID)
}

// NodeID is the resolver for the nodeId field.
// Returns the database UUID (node_uuid) for reliable frontend lookups, not the logical name (node_id).
func (r *systemHealthEventResolver) NodeID(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*string, error) {
	// NodeUuid is enriched by Foghorn from Quartermaster lookup
	return obj.NodeUuid, nil
}

// Node is the resolver for the node field.
func (r *systemHealthEventResolver) Node(ctx context.Context, obj *proto.NodeLifecycleUpdate) (string, error) {
	return obj.NodeId, nil
}

// Status is the resolver for the status field.
func (r *systemHealthEventResolver) Status(ctx context.Context, obj *proto.NodeLifecycleUpdate) (model.NodeStatus, error) {
	if obj.IsHealthy {
		return model.NodeStatusHealthy, nil
	}
	return model.NodeStatusUnhealthy, nil
}

// CPUTenths is the resolver for the cpuTenths field.
func (r *systemHealthEventResolver) CPUTenths(ctx context.Context, obj *proto.NodeLifecycleUpdate) (int, error) {
	return int(obj.CpuTenths), nil
}

// RAMMax is the resolver for the ramMax field.
func (r *systemHealthEventResolver) RAMMax(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*float64, error) {
	v := float64(obj.RamMax)
	return &v, nil
}

// RAMCurrent is the resolver for the ramCurrent field.
func (r *systemHealthEventResolver) RAMCurrent(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*float64, error) {
	v := float64(obj.RamCurrent)
	return &v, nil
}

// DiskTotalBytes is the resolver for the diskTotalBytes field.
func (r *systemHealthEventResolver) DiskTotalBytes(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*float64, error) {
	v := float64(obj.DiskTotalBytes)
	return &v, nil
}

// DiskUsedBytes is the resolver for the diskUsedBytes field.
func (r *systemHealthEventResolver) DiskUsedBytes(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*float64, error) {
	v := float64(obj.DiskUsedBytes)
	return &v, nil
}

// ShmTotalBytes is the resolver for the shmTotalBytes field.
func (r *systemHealthEventResolver) ShmTotalBytes(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*float64, error) {
	v := float64(obj.ShmTotalBytes)
	return &v, nil
}

// ShmUsedBytes is the resolver for the shmUsedBytes field.
func (r *systemHealthEventResolver) ShmUsedBytes(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*float64, error) {
	v := float64(obj.ShmUsedBytes)
	return &v, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *systemHealthEventResolver) Timestamp(ctx context.Context, obj *proto.NodeLifecycleUpdate) (*time.Time, error) {
	if obj.Timestamp == 0 {
		return nil, nil
	}
	t := time.Unix(obj.Timestamp, 0)
	return &t, nil
}

// Cluster is the resolver for the cluster field.
func (r *tenantResolver) Cluster(ctx context.Context, obj *proto.Tenant) (*string, error) {
	return obj.PrimaryClusterId, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *tenantResolver) CreatedAt(ctx context.Context, obj *proto.Tenant) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// Day is the resolver for the day field.
func (r *tenantAnalyticsDailyResolver) Day(ctx context.Context, obj *proto.TenantAnalyticsDaily) (*time.Time, error) {
	if obj.Day == nil {
		return nil, nil
	}
	t := obj.Day.AsTime()
	return &t, nil
}

// EgressBytes is the resolver for the egressBytes field.
func (r *tenantAnalyticsDailyResolver) EgressBytes(ctx context.Context, obj *proto.TenantAnalyticsDaily) (float64, error) {
	return float64(obj.EgressBytes), nil
}

// ID is the resolver for the id field.
func (r *tenantDailyStatResolver) ID(ctx context.Context, obj *proto.TenantDailyStat) (string, error) {
	dayPart := encodeProtoTimestampPart(obj.Date)
	return globalid.EncodeComposite(globalid.TypeTenantDailyStat, dayPart), nil
}

// Date is the resolver for the date field.
func (r *tenantDailyStatResolver) Date(ctx context.Context, obj *proto.TenantDailyStat) (*time.Time, error) {
	if obj.Date == nil {
		return nil, nil
	}
	t := obj.Date.AsTime()
	return &t, nil
}

// TotalBytes is the resolver for the totalBytes field.
func (r *tenantStorageUsageResolver) TotalBytes(ctx context.Context, obj *proto.TenantStorageUsage) (float64, error) {
	return float64(obj.TotalBytes), nil
}

// FileCount is the resolver for the fileCount field.
func (r *tenantStorageUsageResolver) FileCount(ctx context.Context, obj *proto.TenantStorageUsage) (int, error) {
	return int(obj.FileCount), nil
}

// DvrBytes is the resolver for the dvrBytes field.
func (r *tenantStorageUsageResolver) DvrBytes(ctx context.Context, obj *proto.TenantStorageUsage) (float64, error) {
	return float64(obj.DvrBytes), nil
}

// ClipBytes is the resolver for the clipBytes field.
func (r *tenantStorageUsageResolver) ClipBytes(ctx context.Context, obj *proto.TenantStorageUsage) (float64, error) {
	return float64(obj.ClipBytes), nil
}

// VodBytes is the resolver for the vodBytes field.
func (r *tenantStorageUsageResolver) VodBytes(ctx context.Context, obj *proto.TenantStorageUsage) (float64, error) {
	return float64(obj.VodBytes), nil
}

// FrozenDvrBytes is the resolver for the frozenDvrBytes field.
func (r *tenantStorageUsageResolver) FrozenDvrBytes(ctx context.Context, obj *proto.TenantStorageUsage) (float64, error) {
	return float64(obj.FrozenDvrBytes), nil
}

// FrozenClipBytes is the resolver for the frozenClipBytes field.
func (r *tenantStorageUsageResolver) FrozenClipBytes(ctx context.Context, obj *proto.TenantStorageUsage) (float64, error) {
	return float64(obj.FrozenClipBytes), nil
}

// FrozenVodBytes is the resolver for the frozenVodBytes field.
func (r *tenantStorageUsageResolver) FrozenVodBytes(ctx context.Context, obj *proto.TenantStorageUsage) (float64, error) {
	return float64(obj.FrozenVodBytes), nil
}

// StartedAt is the resolver for the startedAt field.
func (r *tenantSubscriptionResolver) StartedAt(ctx context.Context, obj *proto.TenantSubscription) (*time.Time, error) {
	if obj.StartedAt == nil || !obj.StartedAt.IsValid() {
		return nil, nil
	}
	t := obj.StartedAt.AsTime()
	return &t, nil
}

// TrialEndsAt is the resolver for the trialEndsAt field.
func (r *tenantSubscriptionResolver) TrialEndsAt(ctx context.Context, obj *proto.TenantSubscription) (*time.Time, error) {
	if obj.TrialEndsAt == nil || !obj.TrialEndsAt.IsValid() {
		return nil, nil
	}
	t := obj.TrialEndsAt.AsTime()
	return &t, nil
}

// NextBillingDate is the resolver for the nextBillingDate field.
func (r *tenantSubscriptionResolver) NextBillingDate(ctx context.Context, obj *proto.TenantSubscription) (*time.Time, error) {
	if obj.NextBillingDate == nil || !obj.NextBillingDate.IsValid() {
		return nil, nil
	}
	t := obj.NextBillingDate.AsTime()
	return &t, nil
}

// CancelledAt is the resolver for the cancelledAt field.
func (r *tenantSubscriptionResolver) CancelledAt(ctx context.Context, obj *proto.TenantSubscription) (*time.Time, error) {
	if obj.CancelledAt == nil || !obj.CancelledAt.IsValid() {
		return nil, nil
	}
	t := obj.CancelledAt.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *tenantSubscriptionResolver) CreatedAt(ctx context.Context, obj *proto.TenantSubscription) (*time.Time, error) {
	if obj.CreatedAt == nil || !obj.CreatedAt.IsValid() {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *tenantSubscriptionResolver) UpdatedAt(ctx context.Context, obj *proto.TenantSubscription) (*time.Time, error) {
	if obj.UpdatedAt == nil || !obj.UpdatedAt.IsValid() {
		return nil, nil
	}
	t := obj.UpdatedAt.AsTime()
	return &t, nil
}

// Start is the resolver for the start field.
func (r *timeRangeResolver) Start(ctx context.Context, obj *proto.TimeRange) (*time.Time, error) {
	if obj.Start == nil {
		return nil, fmt.Errorf("time range start is required but missing")
	}
	t := obj.Start.AsTime()
	return &t, nil
}

// End is the resolver for the end field.
func (r *timeRangeResolver) End(ctx context.Context, obj *proto.TimeRange) (*time.Time, error) {
	if obj.End == nil {
		return nil, fmt.Errorf("time range end is required but missing")
	}
	t := obj.End.AsTime()
	return &t, nil
}

// ID is the resolver for the id field.
func (r *trackListEventResolver) ID(ctx context.Context, obj *proto.TrackListEvent) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeTrackListEvent, obj.StreamId, obj.Id, tsPart), nil
}

// StreamID is the resolver for the streamId field.
func (r *trackListEventResolver) StreamID(ctx context.Context, obj *proto.TrackListEvent) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *trackListEventResolver) Stream(ctx context.Context, obj *proto.TrackListEvent) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// Timestamp is the resolver for the timestamp field.
func (r *trackListEventResolver) Timestamp(ctx context.Context, obj *proto.TrackListEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *trackListUpdateResolver) StreamID(ctx context.Context, obj *proto.StreamTrackListTrigger) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *trackListUpdateResolver) Stream(ctx context.Context, obj *proto.StreamTrackListTrigger) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// PeriodStart is the resolver for the periodStart field.
func (r *usageAggregateResolver) PeriodStart(ctx context.Context, obj *proto.UsageAggregate) (*time.Time, error) {
	if obj.PeriodStart == nil {
		return nil, nil
	}
	t := obj.PeriodStart.AsTime()
	return &t, nil
}

// PeriodEnd is the resolver for the periodEnd field.
func (r *usageAggregateResolver) PeriodEnd(ctx context.Context, obj *proto.UsageAggregate) (*time.Time, error) {
	if obj.PeriodEnd == nil {
		return nil, nil
	}
	t := obj.PeriodEnd.AsTime()
	return &t, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *usageRecordResolver) CreatedAt(ctx context.Context, obj *proto.UsageRecord) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// PeriodStart is the resolver for the periodStart field.
func (r *usageRecordResolver) PeriodStart(ctx context.Context, obj *proto.UsageRecord) (*time.Time, error) {
	if obj.PeriodStart == nil {
		return nil, nil
	}
	t := obj.PeriodStart.AsTime()
	return &t, nil
}

// PeriodEnd is the resolver for the periodEnd field.
func (r *usageRecordResolver) PeriodEnd(ctx context.Context, obj *proto.UsageRecord) (*time.Time, error) {
	if obj.PeriodEnd == nil {
		return nil, nil
	}
	t := obj.PeriodEnd.AsTime()
	return &t, nil
}

// PeriodStart is the resolver for the periodStart field.
func (r *usageSummaryResolver) PeriodStart(ctx context.Context, obj *proto.UsageSummary) (*time.Time, error) {
	start, _ := parsePeriodRange(obj.Period)
	return start, nil
}

// PeriodEnd is the resolver for the periodEnd field.
func (r *usageSummaryResolver) PeriodEnd(ctx context.Context, obj *proto.UsageSummary) (*time.Time, error) {
	_, end := parsePeriodRange(obj.Period)
	return end, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *usageSummaryResolver) Timestamp(ctx context.Context, obj *proto.UsageSummary) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// LivepeerSegmentCount is the resolver for the livepeerSegmentCount field.
func (r *usageSummaryResolver) LivepeerSegmentCount(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetLivepeerSegmentCount()), nil
}

// LivepeerUniqueStreams is the resolver for the livepeerUniqueStreams field.
func (r *usageSummaryResolver) LivepeerUniqueStreams(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetLivepeerUniqueStreams()), nil
}

// NativeAvSegmentCount is the resolver for the nativeAvSegmentCount field.
func (r *usageSummaryResolver) NativeAvSegmentCount(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetNativeAvSegmentCount()), nil
}

// NativeAvUniqueStreams is the resolver for the nativeAvUniqueStreams field.
func (r *usageSummaryResolver) NativeAvUniqueStreams(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetNativeAvUniqueStreams()), nil
}

// ClipsCreated is the resolver for the clipsCreated field.
func (r *usageSummaryResolver) ClipsCreated(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetClipsCreated()), nil
}

// ClipsDeleted is the resolver for the clipsDeleted field.
func (r *usageSummaryResolver) ClipsDeleted(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetClipsDeleted()), nil
}

// DvrCreated is the resolver for the dvrCreated field.
func (r *usageSummaryResolver) DvrCreated(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetDvrCreated()), nil
}

// DvrDeleted is the resolver for the dvrDeleted field.
func (r *usageSummaryResolver) DvrDeleted(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetDvrDeleted()), nil
}

// VodCreated is the resolver for the vodCreated field.
func (r *usageSummaryResolver) VodCreated(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetVodCreated()), nil
}

// VodDeleted is the resolver for the vodDeleted field.
func (r *usageSummaryResolver) VodDeleted(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetVodDeleted()), nil
}

// ClipBytes is the resolver for the clipBytes field.
func (r *usageSummaryResolver) ClipBytes(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetClipBytes()), nil
}

// DvrBytes is the resolver for the dvrBytes field.
func (r *usageSummaryResolver) DvrBytes(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetDvrBytes()), nil
}

// VodBytes is the resolver for the vodBytes field.
func (r *usageSummaryResolver) VodBytes(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetVodBytes()), nil
}

// FrozenClipBytes is the resolver for the frozenClipBytes field.
func (r *usageSummaryResolver) FrozenClipBytes(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetFrozenClipBytes()), nil
}

// FrozenDvrBytes is the resolver for the frozenDvrBytes field.
func (r *usageSummaryResolver) FrozenDvrBytes(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetFrozenDvrBytes()), nil
}

// FrozenVodBytes is the resolver for the frozenVodBytes field.
func (r *usageSummaryResolver) FrozenVodBytes(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetFrozenVodBytes()), nil
}

// FreezeCount is the resolver for the freezeCount field.
func (r *usageSummaryResolver) FreezeCount(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetFreezeCount()), nil
}

// FreezeBytes is the resolver for the freezeBytes field.
func (r *usageSummaryResolver) FreezeBytes(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetFreezeBytes()), nil
}

// DefrostCount is the resolver for the defrostCount field.
func (r *usageSummaryResolver) DefrostCount(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetDefrostCount()), nil
}

// DefrostBytes is the resolver for the defrostBytes field.
func (r *usageSummaryResolver) DefrostBytes(ctx context.Context, obj *proto.UsageSummary) (int, error) {
	return int(obj.GetDefrostBytes()), nil
}

// Name is the resolver for the name field.
func (r *userResolver) Name(ctx context.Context, obj *proto.User) (*string, error) {
	if obj.FirstName != "" || obj.LastName != "" {
		fullName := obj.FirstName + " " + obj.LastName
		fullName = strings.TrimSpace(fullName)
		return &fullName, nil
	}
	return nil, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *userResolver) CreatedAt(ctx context.Context, obj *proto.User) (*time.Time, error) {
	if obj.CreatedAt == nil {
		return nil, nil
	}
	t := obj.CreatedAt.AsTime()
	return &t, nil
}

// Wallets is the resolver for the wallets field.
func (r *userResolver) Wallets(ctx context.Context, obj *proto.User) ([]*model.WalletIdentity, error) {
	if len(obj.Wallets) == 0 {
		return []*model.WalletIdentity{}, nil
	}

	result := make([]*model.WalletIdentity, 0, len(obj.Wallets))
	for _, w := range obj.Wallets {
		wallet := &model.WalletIdentity{
			ID:        w.Id,
			Address:   w.WalletAddress,
			CreatedAt: w.CreatedAt.AsTime(),
		}
		if w.LastAuthAt != nil {
			t := w.LastAuthAt.AsTime()
			wallet.LastAuthAt = &t
		}
		result = append(result, wallet)
	}
	return result, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *viewerCountBucketResolver) Timestamp(ctx context.Context, obj *proto.ViewerCountBucket) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *viewerCountBucketResolver) StreamID(ctx context.Context, obj *proto.ViewerCountBucket) (*string, error) {
	return encodeStreamIDOptional(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *viewerCountBucketResolver) Stream(ctx context.Context, obj *proto.ViewerCountBucket) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// Outputs is the resolver for the outputs field.
func (r *viewerEndpointResolver) Outputs(ctx context.Context, obj *proto.ViewerEndpoint) (*string, error) {
	if len(obj.Outputs) == 0 {
		return nil, nil
	}
	b, err := json.Marshal(obj.Outputs)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal outputs: %w", err)
	}
	s := string(b)
	return &s, nil
}

// ID is the resolver for the id field.
func (r *viewerGeoHourlyResolver) ID(ctx context.Context, obj *proto.ViewerGeoHourly) (string, error) {
	hourPart := encodeProtoTimestampPart(obj.Hour)
	return globalid.EncodeComposite(globalid.TypeViewerGeoHourly, obj.CountryCode, hourPart), nil
}

// Hour is the resolver for the hour field.
func (r *viewerGeoHourlyResolver) Hour(ctx context.Context, obj *proto.ViewerGeoHourly) (*time.Time, error) {
	if obj.Hour == nil {
		return nil, nil
	}
	t := obj.Hour.AsTime()
	return &t, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *viewerGeographicResolver) Timestamp(ctx context.Context, obj *proto.ConnectionEvent) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *viewerGeographicResolver) StreamID(ctx context.Context, obj *proto.ConnectionEvent) (*string, error) {
	return encodeStreamIDOptional(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *viewerGeographicResolver) Stream(ctx context.Context, obj *proto.ConnectionEvent) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// ViewerCount is the resolver for the viewerCount field.
func (r *viewerGeographicResolver) ViewerCount(ctx context.Context, obj *proto.ConnectionEvent) (*int, error) {
	v := 0
	if obj.EventType == "connect" {
		v = 1
	}
	return &v, nil
}

// ConnectionAddr is the resolver for the connectionAddr field.
func (r *viewerGeographicResolver) ConnectionAddr(ctx context.Context, obj *proto.ConnectionEvent) (*string, error) {
	// Redacted for privacy - client IPs are not exposed via API
	return nil, nil
}

// Source is the resolver for the source field.
func (r *viewerGeographicResolver) Source(ctx context.Context, obj *proto.ConnectionEvent) (*string, error) {
	if obj.Connector != "" {
		v := obj.Connector
		return &v, nil
	}
	return nil, nil
}

// SessionDurationSeconds is the resolver for the sessionDurationSeconds field.
func (r *viewerGeographicResolver) SessionDurationSeconds(ctx context.Context, obj *proto.ConnectionEvent) (*int, error) {
	if obj.SessionDurationSeconds == 0 {
		return nil, nil
	}
	v := int(obj.SessionDurationSeconds)
	return &v, nil
}

// BytesTransferred is the resolver for the bytesTransferred field.
func (r *viewerGeographicResolver) BytesTransferred(ctx context.Context, obj *proto.ConnectionEvent) (*float64, error) {
	if obj.BytesTransferred == 0 {
		return nil, nil
	}
	v := float64(obj.BytesTransferred)
	return &v, nil
}

// ID is the resolver for the id field.
func (r *viewerHoursHourlyResolver) ID(ctx context.Context, obj *proto.ViewerHoursHourly) (string, error) {
	hourPart := encodeProtoTimestampPart(obj.Hour)
	return globalid.EncodeComposite(globalid.TypeViewerHoursHourly, obj.StreamId, obj.CountryCode, hourPart), nil
}

// Hour is the resolver for the hour field.
func (r *viewerHoursHourlyResolver) Hour(ctx context.Context, obj *proto.ViewerHoursHourly) (*time.Time, error) {
	if obj.Hour == nil {
		return nil, nil
	}
	t := obj.Hour.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *viewerHoursHourlyResolver) StreamID(ctx context.Context, obj *proto.ViewerHoursHourly) (*string, error) {
	return encodeStreamIDOptional(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *viewerHoursHourlyResolver) Stream(ctx context.Context, obj *proto.ViewerHoursHourly) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// TotalBytes is the resolver for the totalBytes field.
func (r *viewerHoursHourlyResolver) TotalBytes(ctx context.Context, obj *proto.ViewerHoursHourly) (float64, error) {
	return float64(obj.TotalBytes), nil
}

// ViewerHours is the resolver for the viewerHours field.
func (r *viewerHoursHourlyResolver) ViewerHours(ctx context.Context, obj *proto.ViewerHoursHourly) (float64, error) {
	// Computed: totalSessionSeconds / 3600
	return float64(obj.TotalSessionSeconds) / 3600.0, nil
}

// EgressGb is the resolver for the egressGb field.
func (r *viewerHoursHourlyResolver) EgressGb(ctx context.Context, obj *proto.ViewerHoursHourly) (float64, error) {
	// Computed: totalBytes / 1e9
	return float64(obj.TotalBytes) / 1e9, nil
}

// StreamID is the resolver for the streamId field.
func (r *viewerMetricsResolver) StreamID(ctx context.Context, obj *proto.ClientLifecycleUpdate) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *viewerMetricsResolver) Stream(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// Host is the resolver for the host field.
func (r *viewerMetricsResolver) Host(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*string, error) {
	// Redacted for privacy - client IPs are not exposed via API
	return nil, nil
}

// ConnectionTime is the resolver for the connectionTime field.
func (r *viewerMetricsResolver) ConnectionTime(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*float64, error) {
	if obj.ConnectionTime == nil {
		return nil, nil
	}
	v := float64(*obj.ConnectionTime)
	return &v, nil
}

// Position is the resolver for the position field.
func (r *viewerMetricsResolver) Position(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*float64, error) {
	if obj.Position == nil {
		return nil, nil
	}
	v := float64(*obj.Position)
	return &v, nil
}

// BandwidthInBps is the resolver for the bandwidthInBps field.
func (r *viewerMetricsResolver) BandwidthInBps(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*int, error) {
	if obj.BandwidthInBps == nil {
		return nil, nil
	}
	v := int(*obj.BandwidthInBps)
	return &v, nil
}

// BandwidthOutBps is the resolver for the bandwidthOutBps field.
func (r *viewerMetricsResolver) BandwidthOutBps(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*int, error) {
	if obj.BandwidthOutBps == nil {
		return nil, nil
	}
	v := int(*obj.BandwidthOutBps)
	return &v, nil
}

// BytesDownloaded is the resolver for the bytesDownloaded field.
func (r *viewerMetricsResolver) BytesDownloaded(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*float64, error) {
	if obj.BytesDownloaded == nil {
		return nil, nil
	}
	v := float64(*obj.BytesDownloaded)
	return &v, nil
}

// BytesUploaded is the resolver for the bytesUploaded field.
func (r *viewerMetricsResolver) BytesUploaded(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*float64, error) {
	if obj.BytesUploaded == nil {
		return nil, nil
	}
	v := float64(*obj.BytesUploaded)
	return &v, nil
}

// PacketsSent is the resolver for the packetsSent field.
func (r *viewerMetricsResolver) PacketsSent(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*int, error) {
	if obj.PacketsSent == nil {
		return nil, nil
	}
	v := int(*obj.PacketsSent)
	return &v, nil
}

// PacketsLost is the resolver for the packetsLost field.
func (r *viewerMetricsResolver) PacketsLost(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*int, error) {
	if obj.PacketsLost == nil {
		return nil, nil
	}
	v := int(*obj.PacketsLost)
	return &v, nil
}

// PacketsRetransmitted is the resolver for the packetsRetransmitted field.
func (r *viewerMetricsResolver) PacketsRetransmitted(ctx context.Context, obj *proto.ClientLifecycleUpdate) (*int, error) {
	if obj.PacketsRetransmitted == nil {
		return nil, nil
	}
	v := int(*obj.PacketsRetransmitted)
	return &v, nil
}

// ID is the resolver for the id field.
func (r *viewerSessionResolver) ID(ctx context.Context, obj *proto.ViewerSession) (string, error) {
	tsPart := encodeProtoTimestampPart(obj.Timestamp)
	return globalid.EncodeComposite(globalid.TypeViewerSession, obj.StreamId, obj.SessionId, tsPart), nil
}

// Timestamp is the resolver for the timestamp field.
func (r *viewerSessionResolver) Timestamp(ctx context.Context, obj *proto.ViewerSession) (*time.Time, error) {
	if obj.Timestamp == nil {
		return nil, nil
	}
	t := obj.Timestamp.AsTime()
	return &t, nil
}

// StreamID is the resolver for the streamId field.
func (r *viewerSessionResolver) StreamID(ctx context.Context, obj *proto.ViewerSession) (string, error) {
	return encodeStreamID(obj.GetStreamId())
}

// Stream is the resolver for the stream field.
func (r *viewerSessionResolver) Stream(ctx context.Context, obj *proto.ViewerSession) (*proto.Stream, error) {
	return r.resolveStreamByID(ctx, obj.GetStreamId())
}

// ConnectedAt is the resolver for the connectedAt field.
func (r *viewerSessionResolver) ConnectedAt(ctx context.Context, obj *proto.ViewerSession) (*time.Time, error) {
	if obj.ConnectedAt == nil {
		return nil, nil
	}
	t := obj.ConnectedAt.AsTime()
	return &t, nil
}

// DisconnectedAt is the resolver for the disconnectedAt field.
func (r *viewerSessionResolver) DisconnectedAt(ctx context.Context, obj *proto.ViewerSession) (*time.Time, error) {
	if obj.DisconnectedAt == nil {
		return nil, nil
	}
	t := obj.DisconnectedAt.AsTime()
	return &t, nil
}

// BytesUp is the resolver for the bytesUp field.
func (r *viewerSessionResolver) BytesUp(ctx context.Context, obj *proto.ViewerSession) (*float64, error) {
	if obj.BytesUp == 0 {
		return nil, nil
	}
	v := float64(obj.BytesUp)
	return &v, nil
}

// BytesDown is the resolver for the bytesDown field.
func (r *viewerSessionResolver) BytesDown(ctx context.Context, obj *proto.ViewerSession) (*float64, error) {
	if obj.BytesDown == 0 {
		return nil, nil
	}
	v := float64(obj.BytesDown)
	return &v, nil
}

// ConnectionQuality is the resolver for the connectionQuality field.
func (r *viewerSessionResolver) ConnectionQuality(ctx context.Context, obj *proto.ViewerSession) (*float64, error) {
	v := float64(obj.ConnectionQuality)
	return &v, nil
}

// BufferHealth is the resolver for the bufferHealth field.
func (r *viewerSessionResolver) BufferHealth(ctx context.Context, obj *proto.ViewerSession) (*float64, error) {
	v := float64(obj.BufferHealth)
	return &v, nil
}

// Status is the resolver for the status field.
func (r *vodLifecycleResolver) Status(ctx context.Context, obj *proto.VodLifecycleData) (int, error) {
	return int(obj.Status), nil
}

// PlaybackID is the resolver for the playbackId field.
func (r *vodLifecycleResolver) PlaybackID(ctx context.Context, obj *proto.VodLifecycleData) (*string, error) {
	return r.resolveArtifactPlaybackID(ctx, "vod", obj.GetVodHash()), nil
}

// SizeBytes is the resolver for the sizeBytes field.
func (r *vodLifecycleResolver) SizeBytes(ctx context.Context, obj *proto.VodLifecycleData) (*float64, error) {
	if obj.SizeBytes == nil {
		return nil, nil
	}
	v := float64(*obj.SizeBytes)
	return &v, nil
}

// S3Url is the resolver for the s3Url field.
func (r *vodLifecycleResolver) S3Url(ctx context.Context, obj *proto.VodLifecycleData) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if obj.S3Url == nil || *obj.S3Url == "" {
		return nil, nil
	}
	return obj.S3Url, nil
}

// FilePath is the resolver for the filePath field.
func (r *vodLifecycleResolver) FilePath(ctx context.Context, obj *proto.VodLifecycleData) (*string, error) {
	if !r.CanViewSensitiveTenantData(ctx) {
		return nil, nil
	}
	if obj.FilePath == nil || *obj.FilePath == "" {
		return nil, nil
	}
	return obj.FilePath, nil
}

// APIUsage returns generated.APIUsageResolver implementation.
func (r *Resolver) APIUsage() generated.APIUsageResolver { return &aPIUsageResolver{r} }

// APIUsageOperationSummary returns generated.APIUsageOperationSummaryResolver implementation.
func (r *Resolver) APIUsageOperationSummary() generated.APIUsageOperationSummaryResolver {
	return &aPIUsageOperationSummaryResolver{r}
}

// APIUsageRecord returns generated.APIUsageRecordResolver implementation.
func (r *Resolver) APIUsageRecord() generated.APIUsageRecordResolver {
	return &aPIUsageRecordResolver{r}
}

// APIUsageSummary returns generated.APIUsageSummaryResolver implementation.
func (r *Resolver) APIUsageSummary() generated.APIUsageSummaryResolver {
	return &aPIUsageSummaryResolver{r}
}

// Analytics returns generated.AnalyticsResolver implementation.
func (r *Resolver) Analytics() generated.AnalyticsResolver { return &analyticsResolver{r} }

// AnalyticsHealth returns generated.AnalyticsHealthResolver implementation.
func (r *Resolver) AnalyticsHealth() generated.AnalyticsHealthResolver {
	return &analyticsHealthResolver{r}
}

// AnalyticsInfra returns generated.AnalyticsInfraResolver implementation.
func (r *Resolver) AnalyticsInfra() generated.AnalyticsInfraResolver {
	return &analyticsInfraResolver{r}
}

// AnalyticsLifecycle returns generated.AnalyticsLifecycleResolver implementation.
func (r *Resolver) AnalyticsLifecycle() generated.AnalyticsLifecycleResolver {
	return &analyticsLifecycleResolver{r}
}

// AnalyticsUsage returns generated.AnalyticsUsageResolver implementation.
func (r *Resolver) AnalyticsUsage() generated.AnalyticsUsageResolver {
	return &analyticsUsageResolver{r}
}

// ArtifactEvent returns generated.ArtifactEventResolver implementation.
func (r *Resolver) ArtifactEvent() generated.ArtifactEventResolver { return &artifactEventResolver{r} }

// ArtifactState returns generated.ArtifactStateResolver implementation.
func (r *Resolver) ArtifactState() generated.ArtifactStateResolver { return &artifactStateResolver{r} }

// BillingDetails returns generated.BillingDetailsResolver implementation.
func (r *Resolver) BillingDetails() generated.BillingDetailsResolver {
	return &billingDetailsResolver{r}
}

// BillingStatus returns generated.BillingStatusResolver implementation.
func (r *Resolver) BillingStatus() generated.BillingStatusResolver { return &billingStatusResolver{r} }

// BootstrapToken returns generated.BootstrapTokenResolver implementation.
func (r *Resolver) BootstrapToken() generated.BootstrapTokenResolver {
	return &bootstrapTokenResolver{r}
}

// BufferEvent returns generated.BufferEventResolver implementation.
func (r *Resolver) BufferEvent() generated.BufferEventResolver { return &bufferEventResolver{r} }

// CityMetric returns generated.CityMetricResolver implementation.
func (r *Resolver) CityMetric() generated.CityMetricResolver { return &cityMetricResolver{r} }

// ClientMetrics5m returns generated.ClientMetrics5mResolver implementation.
func (r *Resolver) ClientMetrics5m() generated.ClientMetrics5mResolver {
	return &clientMetrics5mResolver{r}
}

// Clip returns generated.ClipResolver implementation.
func (r *Resolver) Clip() generated.ClipResolver { return &clipResolver{r} }

// ClipLifecycle returns generated.ClipLifecycleResolver implementation.
func (r *Resolver) ClipLifecycle() generated.ClipLifecycleResolver { return &clipLifecycleResolver{r} }

// Cluster returns generated.ClusterResolver implementation.
func (r *Resolver) Cluster() generated.ClusterResolver { return &clusterResolver{r} }

// ClusterInvite returns generated.ClusterInviteResolver implementation.
func (r *Resolver) ClusterInvite() generated.ClusterInviteResolver { return &clusterInviteResolver{r} }

// ClusterSubscription returns generated.ClusterSubscriptionResolver implementation.
func (r *Resolver) ClusterSubscription() generated.ClusterSubscriptionResolver {
	return &clusterSubscriptionResolver{r}
}

// ConnectionEvent returns generated.ConnectionEventResolver implementation.
func (r *Resolver) ConnectionEvent() generated.ConnectionEventResolver {
	return &connectionEventResolver{r}
}

// CountryMetric returns generated.CountryMetricResolver implementation.
func (r *Resolver) CountryMetric() generated.CountryMetricResolver { return &countryMetricResolver{r} }

// DVREvent returns generated.DVREventResolver implementation.
func (r *Resolver) DVREvent() generated.DVREventResolver { return &dVREventResolver{r} }

// DVRRequest returns generated.DVRRequestResolver implementation.
func (r *Resolver) DVRRequest() generated.DVRRequestResolver { return &dVRRequestResolver{r} }

// DeveloperToken returns generated.DeveloperTokenResolver implementation.
func (r *Resolver) DeveloperToken() generated.DeveloperTokenResolver {
	return &developerTokenResolver{r}
}

// GeoBucket returns generated.GeoBucketResolver implementation.
func (r *Resolver) GeoBucket() generated.GeoBucketResolver { return &geoBucketResolver{r} }

// GeographicDistribution returns generated.GeographicDistributionResolver implementation.
func (r *Resolver) GeographicDistribution() generated.GeographicDistributionResolver {
	return &geographicDistributionResolver{r}
}

// InfrastructureNode returns generated.InfrastructureNodeResolver implementation.
func (r *Resolver) InfrastructureNode() generated.InfrastructureNodeResolver {
	return &infrastructureNodeResolver{r}
}

// IngestMetadata returns generated.IngestMetadataResolver implementation.
func (r *Resolver) IngestMetadata() generated.IngestMetadataResolver {
	return &ingestMetadataResolver{r}
}

// Invoice returns generated.InvoiceResolver implementation.
func (r *Resolver) Invoice() generated.InvoiceResolver { return &invoiceResolver{r} }

// LiveNode returns generated.LiveNodeResolver implementation.
func (r *Resolver) LiveNode() generated.LiveNodeResolver { return &liveNodeResolver{r} }

// LiveUsageSummary returns generated.LiveUsageSummaryResolver implementation.
func (r *Resolver) LiveUsageSummary() generated.LiveUsageSummaryResolver {
	return &liveUsageSummaryResolver{r}
}

// MollieMandate returns generated.MollieMandateResolver implementation.
func (r *Resolver) MollieMandate() generated.MollieMandateResolver { return &mollieMandateResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// NodeMetric returns generated.NodeMetricResolver implementation.
func (r *Resolver) NodeMetric() generated.NodeMetricResolver { return &nodeMetricResolver{r} }

// NodeMetricHourly returns generated.NodeMetricHourlyResolver implementation.
func (r *Resolver) NodeMetricHourly() generated.NodeMetricHourlyResolver {
	return &nodeMetricHourlyResolver{r}
}

// NodeMetricsAggregated returns generated.NodeMetricsAggregatedResolver implementation.
func (r *Resolver) NodeMetricsAggregated() generated.NodeMetricsAggregatedResolver {
	return &nodeMetricsAggregatedResolver{r}
}

// NodePerformance5m returns generated.NodePerformance5mResolver implementation.
func (r *Resolver) NodePerformance5m() generated.NodePerformance5mResolver {
	return &nodePerformance5mResolver{r}
}

// Payment returns generated.PaymentResolver implementation.
func (r *Resolver) Payment() generated.PaymentResolver { return &paymentResolver{r} }

// PlatformOverview returns generated.PlatformOverviewResolver implementation.
func (r *Resolver) PlatformOverview() generated.PlatformOverviewResolver {
	return &platformOverviewResolver{r}
}

// PlaybackInstance returns generated.PlaybackInstanceResolver implementation.
func (r *Resolver) PlaybackInstance() generated.PlaybackInstanceResolver {
	return &playbackInstanceResolver{r}
}

// PlaybackMetadata returns generated.PlaybackMetadataResolver implementation.
func (r *Resolver) PlaybackMetadata() generated.PlaybackMetadataResolver {
	return &playbackMetadataResolver{r}
}

// ProcessingUsage returns generated.ProcessingUsageResolver implementation.
func (r *Resolver) ProcessingUsage() generated.ProcessingUsageResolver {
	return &processingUsageResolver{r}
}

// ProcessingUsageRecord returns generated.ProcessingUsageRecordResolver implementation.
func (r *Resolver) ProcessingUsageRecord() generated.ProcessingUsageRecordResolver {
	return &processingUsageRecordResolver{r}
}

// ProcessingUsageSummary returns generated.ProcessingUsageSummaryResolver implementation.
func (r *Resolver) ProcessingUsageSummary() generated.ProcessingUsageSummaryResolver {
	return &processingUsageSummaryResolver{r}
}

// QualityTierDaily returns generated.QualityTierDailyResolver implementation.
func (r *Resolver) QualityTierDaily() generated.QualityTierDailyResolver {
	return &qualityTierDailyResolver{r}
}

// QualityTierSummary returns generated.QualityTierSummaryResolver implementation.
func (r *Resolver) QualityTierSummary() generated.QualityTierSummaryResolver {
	return &qualityTierSummaryResolver{r}
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// RebufferingEvent returns generated.RebufferingEventResolver implementation.
func (r *Resolver) RebufferingEvent() generated.RebufferingEventResolver {
	return &rebufferingEventResolver{r}
}

// RoutingEvent returns generated.RoutingEventResolver implementation.
func (r *Resolver) RoutingEvent() generated.RoutingEventResolver { return &routingEventResolver{r} }

// ServiceInstance returns generated.ServiceInstanceResolver implementation.
func (r *Resolver) ServiceInstance() generated.ServiceInstanceResolver {
	return &serviceInstanceResolver{r}
}

// ServiceInstanceHealth returns generated.ServiceInstanceHealthResolver implementation.
func (r *Resolver) ServiceInstanceHealth() generated.ServiceInstanceHealthResolver {
	return &serviceInstanceHealthResolver{r}
}

// SkipperMessage returns generated.SkipperMessageResolver implementation.
func (r *Resolver) SkipperMessage() generated.SkipperMessageResolver {
	return &skipperMessageResolver{r}
}

// SkipperToolDetail returns generated.SkipperToolDetailResolver implementation.
func (r *Resolver) SkipperToolDetail() generated.SkipperToolDetailResolver {
	return &skipperToolDetailResolver{r}
}

// StorageEvent returns generated.StorageEventResolver implementation.
func (r *Resolver) StorageEvent() generated.StorageEventResolver { return &storageEventResolver{r} }

// StorageUsage returns generated.StorageUsageResolver implementation.
func (r *Resolver) StorageUsage() generated.StorageUsageResolver { return &storageUsageResolver{r} }

// StorageUsageRecord returns generated.StorageUsageRecordResolver implementation.
func (r *Resolver) StorageUsageRecord() generated.StorageUsageRecordResolver {
	return &storageUsageRecordResolver{r}
}

// Stream returns generated.StreamResolver implementation.
func (r *Resolver) Stream() generated.StreamResolver { return &streamResolver{r} }

// StreamAnalyticsDaily returns generated.StreamAnalyticsDailyResolver implementation.
func (r *Resolver) StreamAnalyticsDaily() generated.StreamAnalyticsDailyResolver {
	return &streamAnalyticsDailyResolver{r}
}

// StreamAnalyticsSummary returns generated.StreamAnalyticsSummaryResolver implementation.
func (r *Resolver) StreamAnalyticsSummary() generated.StreamAnalyticsSummaryResolver {
	return &streamAnalyticsSummaryResolver{r}
}

// StreamConnectionHourly returns generated.StreamConnectionHourlyResolver implementation.
func (r *Resolver) StreamConnectionHourly() generated.StreamConnectionHourlyResolver {
	return &streamConnectionHourlyResolver{r}
}

// StreamEvent returns generated.StreamEventResolver implementation.
func (r *Resolver) StreamEvent() generated.StreamEventResolver { return &streamEventResolver{r} }

// StreamHealth5m returns generated.StreamHealth5mResolver implementation.
func (r *Resolver) StreamHealth5m() generated.StreamHealth5mResolver {
	return &streamHealth5mResolver{r}
}

// StreamHealthMetric returns generated.StreamHealthMetricResolver implementation.
func (r *Resolver) StreamHealthMetric() generated.StreamHealthMetricResolver {
	return &streamHealthMetricResolver{r}
}

// StreamKey returns generated.StreamKeyResolver implementation.
func (r *Resolver) StreamKey() generated.StreamKeyResolver { return &streamKeyResolver{r} }

// StreamMetrics returns generated.StreamMetricsResolver implementation.
func (r *Resolver) StreamMetrics() generated.StreamMetricsResolver { return &streamMetricsResolver{r} }

// StreamingUsage returns generated.StreamingUsageResolver implementation.
func (r *Resolver) StreamingUsage() generated.StreamingUsageResolver {
	return &streamingUsageResolver{r}
}

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// SystemHealthEvent returns generated.SystemHealthEventResolver implementation.
func (r *Resolver) SystemHealthEvent() generated.SystemHealthEventResolver {
	return &systemHealthEventResolver{r}
}

// Tenant returns generated.TenantResolver implementation.
func (r *Resolver) Tenant() generated.TenantResolver { return &tenantResolver{r} }

// TenantAnalyticsDaily returns generated.TenantAnalyticsDailyResolver implementation.
func (r *Resolver) TenantAnalyticsDaily() generated.TenantAnalyticsDailyResolver {
	return &tenantAnalyticsDailyResolver{r}
}

// TenantDailyStat returns generated.TenantDailyStatResolver implementation.
func (r *Resolver) TenantDailyStat() generated.TenantDailyStatResolver {
	return &tenantDailyStatResolver{r}
}

// TenantStorageUsage returns generated.TenantStorageUsageResolver implementation.
func (r *Resolver) TenantStorageUsage() generated.TenantStorageUsageResolver {
	return &tenantStorageUsageResolver{r}
}

// TenantSubscription returns generated.TenantSubscriptionResolver implementation.
func (r *Resolver) TenantSubscription() generated.TenantSubscriptionResolver {
	return &tenantSubscriptionResolver{r}
}

// TimeRange returns generated.TimeRangeResolver implementation.
func (r *Resolver) TimeRange() generated.TimeRangeResolver { return &timeRangeResolver{r} }

// TrackListEvent returns generated.TrackListEventResolver implementation.
func (r *Resolver) TrackListEvent() generated.TrackListEventResolver {
	return &trackListEventResolver{r}
}

// TrackListUpdate returns generated.TrackListUpdateResolver implementation.
func (r *Resolver) TrackListUpdate() generated.TrackListUpdateResolver {
	return &trackListUpdateResolver{r}
}

// UsageAggregate returns generated.UsageAggregateResolver implementation.
func (r *Resolver) UsageAggregate() generated.UsageAggregateResolver {
	return &usageAggregateResolver{r}
}

// UsageRecord returns generated.UsageRecordResolver implementation.
func (r *Resolver) UsageRecord() generated.UsageRecordResolver { return &usageRecordResolver{r} }

// UsageSummary returns generated.UsageSummaryResolver implementation.
func (r *Resolver) UsageSummary() generated.UsageSummaryResolver { return &usageSummaryResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

// ViewerCountBucket returns generated.ViewerCountBucketResolver implementation.
func (r *Resolver) ViewerCountBucket() generated.ViewerCountBucketResolver {
	return &viewerCountBucketResolver{r}
}

// ViewerEndpoint returns generated.ViewerEndpointResolver implementation.
func (r *Resolver) ViewerEndpoint() generated.ViewerEndpointResolver {
	return &viewerEndpointResolver{r}
}

// ViewerGeoHourly returns generated.ViewerGeoHourlyResolver implementation.
func (r *Resolver) ViewerGeoHourly() generated.ViewerGeoHourlyResolver {
	return &viewerGeoHourlyResolver{r}
}

// ViewerGeographic returns generated.ViewerGeographicResolver implementation.
func (r *Resolver) ViewerGeographic() generated.ViewerGeographicResolver {
	return &viewerGeographicResolver{r}
}

// ViewerHoursHourly returns generated.ViewerHoursHourlyResolver implementation.
func (r *Resolver) ViewerHoursHourly() generated.ViewerHoursHourlyResolver {
	return &viewerHoursHourlyResolver{r}
}

// ViewerMetrics returns generated.ViewerMetricsResolver implementation.
func (r *Resolver) ViewerMetrics() generated.ViewerMetricsResolver { return &viewerMetricsResolver{r} }

// ViewerSession returns generated.ViewerSessionResolver implementation.
func (r *Resolver) ViewerSession() generated.ViewerSessionResolver { return &viewerSessionResolver{r} }

// VodLifecycle returns generated.VodLifecycleResolver implementation.
func (r *Resolver) VodLifecycle() generated.VodLifecycleResolver { return &vodLifecycleResolver{r} }

type aPIUsageResolver struct{ *Resolver }
type aPIUsageOperationSummaryResolver struct{ *Resolver }
type aPIUsageRecordResolver struct{ *Resolver }
type aPIUsageSummaryResolver struct{ *Resolver }
type analyticsResolver struct{ *Resolver }
type analyticsHealthResolver struct{ *Resolver }
type analyticsInfraResolver struct{ *Resolver }
type analyticsLifecycleResolver struct{ *Resolver }
type analyticsUsageResolver struct{ *Resolver }
type artifactEventResolver struct{ *Resolver }
type artifactStateResolver struct{ *Resolver }
type billingDetailsResolver struct{ *Resolver }
type billingStatusResolver struct{ *Resolver }
type bootstrapTokenResolver struct{ *Resolver }
type bufferEventResolver struct{ *Resolver }
type cityMetricResolver struct{ *Resolver }
type clientMetrics5mResolver struct{ *Resolver }
type clipResolver struct{ *Resolver }
type clipLifecycleResolver struct{ *Resolver }
type clusterResolver struct{ *Resolver }
type clusterInviteResolver struct{ *Resolver }
type clusterSubscriptionResolver struct{ *Resolver }
type connectionEventResolver struct{ *Resolver }
type countryMetricResolver struct{ *Resolver }
type dVREventResolver struct{ *Resolver }
type dVRRequestResolver struct{ *Resolver }
type developerTokenResolver struct{ *Resolver }
type geoBucketResolver struct{ *Resolver }
type geographicDistributionResolver struct{ *Resolver }
type infrastructureNodeResolver struct{ *Resolver }
type ingestMetadataResolver struct{ *Resolver }
type invoiceResolver struct{ *Resolver }
type liveNodeResolver struct{ *Resolver }
type liveUsageSummaryResolver struct{ *Resolver }
type mollieMandateResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type nodeMetricResolver struct{ *Resolver }
type nodeMetricHourlyResolver struct{ *Resolver }
type nodeMetricsAggregatedResolver struct{ *Resolver }
type nodePerformance5mResolver struct{ *Resolver }
type paymentResolver struct{ *Resolver }
type platformOverviewResolver struct{ *Resolver }
type playbackInstanceResolver struct{ *Resolver }
type playbackMetadataResolver struct{ *Resolver }
type processingUsageResolver struct{ *Resolver }
type processingUsageRecordResolver struct{ *Resolver }
type processingUsageSummaryResolver struct{ *Resolver }
type qualityTierDailyResolver struct{ *Resolver }
type qualityTierSummaryResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type rebufferingEventResolver struct{ *Resolver }
type routingEventResolver struct{ *Resolver }
type serviceInstanceResolver struct{ *Resolver }
type serviceInstanceHealthResolver struct{ *Resolver }
type skipperMessageResolver struct{ *Resolver }
type skipperToolDetailResolver struct{ *Resolver }
type storageEventResolver struct{ *Resolver }
type storageUsageResolver struct{ *Resolver }
type storageUsageRecordResolver struct{ *Resolver }
type streamResolver struct{ *Resolver }
type streamAnalyticsDailyResolver struct{ *Resolver }
type streamAnalyticsSummaryResolver struct{ *Resolver }
type streamConnectionHourlyResolver struct{ *Resolver }
type streamEventResolver struct{ *Resolver }
type streamHealth5mResolver struct{ *Resolver }
type streamHealthMetricResolver struct{ *Resolver }
type streamKeyResolver struct{ *Resolver }
type streamMetricsResolver struct{ *Resolver }
type streamingUsageResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type systemHealthEventResolver struct{ *Resolver }
type tenantResolver struct{ *Resolver }
type tenantAnalyticsDailyResolver struct{ *Resolver }
type tenantDailyStatResolver struct{ *Resolver }
type tenantStorageUsageResolver struct{ *Resolver }
type tenantSubscriptionResolver struct{ *Resolver }
type timeRangeResolver struct{ *Resolver }
type trackListEventResolver struct{ *Resolver }
type trackListUpdateResolver struct{ *Resolver }
type usageAggregateResolver struct{ *Resolver }
type usageRecordResolver struct{ *Resolver }
type usageSummaryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type viewerCountBucketResolver struct{ *Resolver }
type viewerEndpointResolver struct{ *Resolver }
type viewerGeoHourlyResolver struct{ *Resolver }
type viewerGeographicResolver struct{ *Resolver }
type viewerHoursHourlyResolver struct{ *Resolver }
type viewerMetricsResolver struct{ *Resolver }
type viewerSessionResolver struct{ *Resolver }
type vodLifecycleResolver struct{ *Resolver }
