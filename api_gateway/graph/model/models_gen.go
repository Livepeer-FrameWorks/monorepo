// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"frameworks/pkg/proto"
	"io"
	"strconv"
	"time"
)

type AbortVodUploadResult interface {
	IsAbortVodUploadResult()
}

type ClusterSubscriptionResult interface {
	IsClusterSubscriptionResult()
}

type CompleteVodUploadResult interface {
	IsCompleteVodUploadResult()
}

type CreateBootstrapTokenResult interface {
	IsCreateBootstrapTokenResult()
}

type CreateClipResult interface {
	IsCreateClipResult()
}

type CreateClusterInviteResult interface {
	IsCreateClusterInviteResult()
}

type CreateConversationResult interface {
	IsCreateConversationResult()
}

type CreateDeveloperTokenResult interface {
	IsCreateDeveloperTokenResult()
}

type CreatePaymentResult interface {
	IsCreatePaymentResult()
}

type CreatePrivateClusterResult interface {
	IsCreatePrivateClusterResult()
}

type CreateStreamKeyResult interface {
	IsCreateStreamKeyResult()
}

type CreateStreamResult interface {
	IsCreateStreamResult()
}

type CreateVodUploadResult interface {
	IsCreateVodUploadResult()
}

type DeleteClipResult interface {
	IsDeleteClipResult()
}

type DeleteDVRResult interface {
	IsDeleteDVRResult()
}

type DeleteStreamKeyResult interface {
	IsDeleteStreamKeyResult()
}

type DeleteStreamResult interface {
	IsDeleteStreamResult()
}

type DeleteVodAssetResult interface {
	IsDeleteVodAssetResult()
}

type Error interface {
	IsError()
	GetMessage() string
	GetCode() *string
}

type LinkEmailResult interface {
	IsLinkEmailResult()
}

type LinkWalletResult interface {
	IsLinkWalletResult()
}

type MollieFirstPaymentResult interface {
	IsMollieFirstPaymentResult()
}

type MollieSubscriptionResult interface {
	IsMollieSubscriptionResult()
}

type PromoteToPaidResult interface {
	IsPromoteToPaidResult()
}

type RevokeBootstrapTokenResult interface {
	IsRevokeBootstrapTokenResult()
}

type RevokeClusterInviteResult interface {
	IsRevokeClusterInviteResult()
}

type RevokeDeveloperTokenResult interface {
	IsRevokeDeveloperTokenResult()
}

type SendMessageResult interface {
	IsSendMessageResult()
}

type StartDVRResult interface {
	IsStartDVRResult()
}

type StopDVRResult interface {
	IsStopDVRResult()
}

type StripeBillingPortalResult interface {
	IsStripeBillingPortalResult()
}

type StripeCheckoutResult interface {
	IsStripeCheckoutResult()
}

type SubmitX402PaymentResult interface {
	IsSubmitX402PaymentResult()
}

type UnlinkWalletResult interface {
	IsUnlinkWalletResult()
}

type UpdateClusterResult interface {
	IsUpdateClusterResult()
}

type UpdateStreamResult interface {
	IsUpdateStreamResult()
}

type UpdateTenantResult interface {
	IsUpdateTenantResult()
}

type WalletLoginResult interface {
	IsWalletLoginResult()
}

type APIUsageConnection struct {
	Edges              []*APIUsageEdge                   `json:"edges"`
	Nodes              []*proto.APIUsageRecord           `json:"nodes"`
	PageInfo           *PageInfo                         `json:"pageInfo"`
	TotalCount         int                               `json:"totalCount"`
	Summaries          []*proto.APIUsageSummary          `json:"summaries"`
	OperationSummaries []*proto.APIUsageOperationSummary `json:"operationSummaries"`
}

type APIUsageEdge struct {
	Cursor string                `json:"cursor"`
	Node   *proto.APIUsageRecord `json:"node"`
}

// Resource allocation configuration.
type AllocationDetailsInput struct {
	// Resource limit (null = unlimited).
	Limit *float64 `json:"limit,omitempty"`
	// Price per unit above the limit.
	UnitPrice *float64 `json:"unitPrice,omitempty"`
	// Unit of measurement (GiB, hours, etc.).
	Unit *string `json:"unit,omitempty"`
}

type ArtifactEventEdge struct {
	Cursor string           `json:"cursor"`
	Node   *proto.ClipEvent `json:"node"`
}

type ArtifactEventsConnection struct {
	Edges      []*ArtifactEventEdge `json:"edges"`
	Nodes      []*proto.ClipEvent   `json:"nodes"`
	PageInfo   *PageInfo            `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

type ArtifactStateEdge struct {
	Cursor string               `json:"cursor"`
	Node   *proto.ArtifactState `json:"node"`
}

type ArtifactStatesConnection struct {
	Edges      []*ArtifactStateEdge   `json:"edges"`
	Nodes      []*proto.ArtifactState `json:"nodes"`
	PageInfo   *PageInfo              `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

type AuthError struct {
	Message string  `json:"message"`
	Code    *string `json:"code,omitempty"`
}

func (AuthError) IsError()                {}
func (this AuthError) GetMessage() string { return this.Message }
func (this AuthError) GetCode() *string   { return this.Code }

func (AuthError) IsCreateStreamResult() {}

func (AuthError) IsUpdateStreamResult() {}

func (AuthError) IsDeleteStreamResult() {}

func (AuthError) IsCreateClipResult() {}

func (AuthError) IsDeleteClipResult() {}

func (AuthError) IsCreateStreamKeyResult() {}

func (AuthError) IsDeleteStreamKeyResult() {}

func (AuthError) IsStartDVRResult() {}

func (AuthError) IsStopDVRResult() {}

func (AuthError) IsDeleteDVRResult() {}

func (AuthError) IsCreateVodUploadResult() {}

func (AuthError) IsCompleteVodUploadResult() {}

func (AuthError) IsAbortVodUploadResult() {}

func (AuthError) IsDeleteVodAssetResult() {}

func (AuthError) IsCreatePaymentResult() {}

func (AuthError) IsSubmitX402PaymentResult() {}

func (AuthError) IsStripeCheckoutResult() {}

func (AuthError) IsStripeBillingPortalResult() {}

func (AuthError) IsMollieFirstPaymentResult() {}

func (AuthError) IsMollieSubscriptionResult() {}

func (AuthError) IsUpdateTenantResult() {}

func (AuthError) IsCreateDeveloperTokenResult() {}

func (AuthError) IsRevokeDeveloperTokenResult() {}

func (AuthError) IsCreateBootstrapTokenResult() {}

func (AuthError) IsRevokeBootstrapTokenResult() {}

func (AuthError) IsCreatePrivateClusterResult() {}

func (AuthError) IsUpdateClusterResult() {}

func (AuthError) IsCreateClusterInviteResult() {}

func (AuthError) IsRevokeClusterInviteResult() {}

func (AuthError) IsClusterSubscriptionResult() {}

func (AuthError) IsLinkWalletResult() {}

func (AuthError) IsUnlinkWalletResult() {}

func (AuthError) IsLinkEmailResult() {}

func (AuthError) IsPromoteToPaidResult() {}

func (AuthError) IsCreateConversationResult() {}

func (AuthError) IsSendMessageResult() {}

type AvailableCluster struct {
	ClusterID   string   `json:"clusterId"`
	ClusterName string   `json:"clusterName"`
	Tiers       []string `json:"tiers"`
	AutoEnroll  bool     `json:"autoEnroll"`
}

type AvailableClusterConnection struct {
	Edges      []*AvailableClusterEdge `json:"edges"`
	Nodes      []*AvailableCluster     `json:"nodes"`
	PageInfo   *PageInfo               `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

type AvailableClusterEdge struct {
	Cursor string            `json:"cursor"`
	Node   *AvailableCluster `json:"node"`
}

// Balance transaction connection for pagination.
type BalanceTransactionEdge struct {
	Cursor string              `json:"cursor"`
	Node   *BalanceTransaction `json:"node"`
}

type BalanceTransactionsConnection struct {
	Edges      []*BalanceTransactionEdge `json:"edges"`
	Nodes      []*BalanceTransaction     `json:"nodes"`
	PageInfo   *PageInfo                 `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

// Input for billing address.
type BillingAddressInput struct {
	// Street address line 1.
	Street string `json:"street"`
	// City name.
	City string `json:"city"`
	// State or province.
	State *string `json:"state,omitempty"`
	// Postal or ZIP code.
	PostalCode string `json:"postalCode"`
	// ISO 3166-1 alpha-2 country code.
	Country string `json:"country"`
}

// Feature flag configuration for custom subscriptions.
type BillingFeaturesInput struct {
	// DVR recording capability.
	Recording *bool `json:"recording,omitempty"`
	// Analytics dashboard access.
	Analytics *bool `json:"analytics,omitempty"`
	// Custom branding options.
	CustomBranding *bool `json:"customBranding,omitempty"`
	// API access for automation.
	APIAccess *bool `json:"apiAccess,omitempty"`
	// Support level (community, email, priority, dedicated).
	SupportLevel *string `json:"supportLevel,omitempty"`
	// SLA guarantees.
	SLA *bool `json:"sla,omitempty"`
}

type BootstrapTokenConnection struct {
	Edges      []*BootstrapTokenEdge   `json:"edges"`
	Nodes      []*proto.BootstrapToken `json:"nodes"`
	PageInfo   *PageInfo               `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

type BootstrapTokenEdge struct {
	Cursor string                `json:"cursor"`
	Node   *proto.BootstrapToken `json:"node"`
}

type BufferEventEdge struct {
	Cursor string             `json:"cursor"`
	Node   *proto.BufferEvent `json:"node"`
}

type BufferEventsConnection struct {
	Edges      []*BufferEventEdge   `json:"edges"`
	Nodes      []*proto.BufferEvent `json:"nodes"`
	PageInfo   *PageInfo            `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// Result from creating a card top-up checkout session.
type CardTopupResult struct {
	// Internal top-up ID for tracking.
	TopupID string `json:"topupId"`
	// URL to redirect user for checkout.
	CheckoutURL string `json:"checkoutUrl"`
	// When the checkout session expires.
	ExpiresAt time.Time `json:"expiresAt"`
}

type ClientMetrics5mConnection struct {
	Edges      []*ClientMetrics5mEdge   `json:"edges"`
	Nodes      []*proto.ClientMetrics5M `json:"nodes"`
	PageInfo   *PageInfo                `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

type ClientMetrics5mEdge struct {
	Cursor string                 `json:"cursor"`
	Node   *proto.ClientMetrics5M `json:"node"`
}

type ClipEdge struct {
	Cursor string          `json:"cursor"`
	Node   *proto.ClipInfo `json:"node"`
}

type ClipsConnection struct {
	Edges      []*ClipEdge       `json:"edges"`
	Nodes      []*proto.ClipInfo `json:"nodes"`
	PageInfo   *PageInfo         `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

type ClusterAccess struct {
	ClusterID      string  `json:"clusterId"`
	ClusterName    string  `json:"clusterName"`
	AccessLevel    string  `json:"accessLevel"`
	ResourceLimits *string `json:"resourceLimits,omitempty"`
}

type ClusterAccessConnection struct {
	Edges      []*ClusterAccessEdge `json:"edges"`
	Nodes      []*ClusterAccess     `json:"nodes"`
	PageInfo   *PageInfo            `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

type ClusterAccessEdge struct {
	Cursor string         `json:"cursor"`
	Node   *ClusterAccess `json:"node"`
}

type ClusterEdge struct {
	Cursor string                       `json:"cursor"`
	Node   *proto.InfrastructureCluster `json:"node"`
}

type ClusterInviteConnection struct {
	Edges      []*ClusterInviteEdge   `json:"edges"`
	Nodes      []*proto.ClusterInvite `json:"nodes"`
	PageInfo   *PageInfo              `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

type ClusterInviteEdge struct {
	Cursor string               `json:"cursor"`
	Node   *proto.ClusterInvite `json:"node"`
}

type ClusterSubscriptionConnection struct {
	Edges      []*ClusterSubscriptionEdge   `json:"edges"`
	Nodes      []*proto.ClusterSubscription `json:"nodes"`
	PageInfo   *PageInfo                    `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

type ClusterSubscriptionEdge struct {
	Cursor string                     `json:"cursor"`
	Node   *proto.ClusterSubscription `json:"node"`
}

type ClustersConnection struct {
	Edges      []*ClusterEdge                 `json:"edges"`
	Nodes      []*proto.InfrastructureCluster `json:"nodes"`
	PageInfo   *PageInfo                      `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

// Input for completing a multipart VOD upload.
// Call after all parts have been uploaded to S3.
type CompleteVodUploadInput struct {
	// Upload session ID from createVodUpload.
	UploadID string `json:"uploadId"`
	// ETags from each successfully uploaded part.
	Parts []*VodUploadCompletedPart `json:"parts"`
}

type ConnectionEventEdge struct {
	Cursor string                 `json:"cursor"`
	Node   *proto.ConnectionEvent `json:"node"`
}

type ConnectionEventsConnection struct {
	Edges      []*ConnectionEventEdge   `json:"edges"`
	Nodes      []*proto.ConnectionEvent `json:"nodes"`
	PageInfo   *PageInfo                `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// Standard cursor-based pagination input for all connections.
// Follows the Relay Connection specification for consistent pagination.
//
// ## Forward Pagination
// Use `first` and `after` to paginate forward:
// ```graphql
// streamsConnection(page: { first: 10, after: "cursor..." })
// ```
//
// ## Backward Pagination
// Use `last` and `before` to paginate backward:
// ```graphql
// streamsConnection(page: { last: 10, before: "cursor..." })
// ```
type ConnectionInput struct {
	// Number of items to fetch (forward pagination). Default: 50, Max: 500.
	First *int `json:"first,omitempty"`
	// Cursor to start fetching after (forward pagination).
	After *string `json:"after,omitempty"`
	// Number of items to fetch (backward pagination).
	Last *int `json:"last,omitempty"`
	// Cursor to start fetching before (backward pagination).
	Before *string `json:"before,omitempty"`
}

// A support conversation between tenant and support team.
// Conversations can contain multiple messages and have a status.
type Conversation struct {
	// The globally unique identifier for this conversation.
	ID string `json:"id"`
	// Optional subject line for the conversation.
	Subject *string `json:"subject,omitempty"`
	// Current status of the conversation.
	Status proto.ConversationStatus `json:"status"`
	// The last message in this conversation.
	LastMessage *Message `json:"lastMessage,omitempty"`
	// Number of unread messages.
	UnreadCount int `json:"unreadCount"`
	// When the conversation was created.
	CreatedAt time.Time `json:"createdAt"`
	// When the conversation was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

func (Conversation) IsCreateConversationResult() {}

func (Conversation) IsNode() {}

// A conversation edge in a connection.
type ConversationEdge struct {
	// The conversation.
	Node *Conversation `json:"node"`
	// Cursor for this edge.
	Cursor string `json:"cursor"`
}

// Paginated list of conversations.
type ConversationsConnection struct {
	// List of conversations.
	Edges []*ConversationEdge `json:"edges"`
	// Pagination information.
	PageInfo *PageInfo `json:"pageInfo"`
	// Total count of conversations.
	TotalCount int `json:"totalCount"`
}

type CostEntry struct {
	ResourceType string  `json:"resourceType"`
	Cost         float64 `json:"cost"`
}

type CountryTimeSeries struct {
	Timestamp   time.Time `json:"timestamp"`
	CountryCode string    `json:"countryCode"`
	ViewerCount int       `json:"viewerCount"`
}

// Input for creating a bootstrap token for node provisioning.
type CreateBootstrapTokenInput struct {
	// Human-readable name for the token.
	Name string `json:"name"`
	// Token type (edge_node, service).
	Type BootstrapTokenType `json:"type"`
	// Days until expiration.
	ExpiresIn *int `json:"expiresIn,omitempty"`
	// Maximum number of uses allowed.
	UsageLimit *int `json:"usageLimit,omitempty"`
	// Target cluster UUID (required for edge_node tokens; not the Relay ID).
	ClusterID *string `json:"clusterId,omitempty"`
}

// Input for creating a card-based prepaid balance top-up.
type CreateCardTopupInput struct {
	// Amount to top up in cents. Minimum $5.00 (500 cents).
	AmountCents int `json:"amountCents"`
	// Currency code (default: USD).
	Currency *string `json:"currency,omitempty"`
	// Payment provider to use.
	Provider CardPaymentProvider `json:"provider"`
	// URL to redirect after successful payment.
	SuccessURL string `json:"successUrl"`
	// URL to redirect if user cancels.
	CancelURL string `json:"cancelUrl"`
	// Optional billing email for invoice.
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Optional billing name for invoice.
	BillingName *string `json:"billingName,omitempty"`
	// Optional company name for invoice.
	BillingCompany *string `json:"billingCompany,omitempty"`
	// Optional VAT number for invoice.
	BillingVatNumber *string `json:"billingVatNumber,omitempty"`
}

// Input for creating a clip from a live stream's DVR buffer.
// Time specification depends on the selected mode.
type CreateClipInput struct {
	// Stream to create the clip from (Stream.id, Relay global ID).
	StreamID string `json:"streamId"`
	// Display title for the clip.
	Title string `json:"title"`
	// Optional description.
	Description *string `json:"description,omitempty"`
	// Time mode (ABSOLUTE, RELATIVE, DURATION, CLIP_NOW). Default: ABSOLUTE.
	Mode *ClipCreationMode `json:"mode,omitempty"`
	// Start time as Unix timestamp (ABSOLUTE/DURATION mode).
	StartUnix *int `json:"startUnix,omitempty"`
	// End time as Unix timestamp (ABSOLUTE mode).
	StopUnix *int `json:"stopUnix,omitempty"`
	// Start time as seconds from stream start (RELATIVE mode).
	StartMedia *int `json:"startMedia,omitempty"`
	// End time as seconds from stream start (RELATIVE mode).
	StopMedia *int `json:"stopMedia,omitempty"`
	// Clip duration in seconds (DURATION/CLIP_NOW mode).
	Duration *int `json:"duration,omitempty"`
	// Optional expiration as Unix timestamp.
	ExpiresAt *int `json:"expiresAt,omitempty"`
	// Deprecated: Use startUnix instead.
	StartTime *int `json:"startTime,omitempty"`
	// Deprecated: Use stopUnix instead.
	EndTime *int `json:"endTime,omitempty"`
}

// Input for creating a cluster access invite.
type CreateClusterInviteInput struct {
	// Target cluster ID.
	ClusterID string `json:"clusterId"`
	// Tenant to invite.
	InvitedTenantID string `json:"invitedTenantId"`
	// Access level (read, write, admin).
	AccessLevel *string `json:"accessLevel,omitempty"`
	// Resource limits for the invited tenant.
	ResourceLimits *string `json:"resourceLimits,omitempty"`
	// Days until invite expires.
	ExpiresInDays *int `json:"expiresInDays,omitempty"`
}

// Input for creating a new conversation.
type CreateConversationInput struct {
	// Optional subject line.
	Subject *string `json:"subject,omitempty"`
	// Initial message content (required).
	Message string `json:"message"`
	// Optional page URL where conversation was initiated.
	PageURL *string `json:"pageUrl,omitempty"`
}

// Input for creating a crypto top-up deposit address.
type CreateCryptoTopupInput struct {
	// Expected top-up amount in cents. Must be positive. Actual credit based on received amount.
	AmountCents int `json:"amountCents"`
	// Crypto asset to receive.
	Asset proto.CryptoAsset `json:"asset"`
	// Target currency for balance (default: USD).
	Currency *string `json:"currency,omitempty"`
}

// Input for creating a developer API token.
type CreateDeveloperTokenInput struct {
	// Human-readable name for the token.
	Name string `json:"name"`
	// Comma-separated permission scopes (read:streams, write:streams, etc.).
	Permissions *string `json:"permissions,omitempty"`
	// Days until expiration (null = non-expiring).
	ExpiresIn *int `json:"expiresIn,omitempty"`
}

type CreatePaymentInput struct {
	InvoiceID string        `json:"invoiceId"`
	Amount    float64       `json:"amount"`
	Currency  *string       `json:"currency,omitempty"`
	Method    PaymentMethod `json:"method"`
	ReturnURL *string       `json:"returnUrl,omitempty"`
}

// Input for creating a private streaming cluster.
type CreatePrivateClusterInput struct {
	// Human-readable cluster name.
	ClusterName string `json:"clusterName"`
	// Geographic region for the cluster.
	Region *string `json:"region,omitempty"`
	// Short description for marketplace listing.
	ShortDescription *string `json:"shortDescription,omitempty"`
}

// Input for creating a new live stream.
type CreateStreamInput struct {
	// Human-readable name for the stream.
	Name string `json:"name"`
	// Optional description for the stream.
	Description *string `json:"description,omitempty"`
	// Enable DVR recording (default: false).
	Record *bool `json:"record,omitempty"`
}

// Input for creating an additional stream key.
type CreateStreamKeyInput struct {
	// Human-readable name for the key.
	Name string `json:"name"`
}

// Input for initiating a multipart VOD upload.
// Returns presigned S3 URLs for uploading file parts.
type CreateVodUploadInput struct {
	// Original filename (for metadata and content-type detection).
	Filename string `json:"filename"`
	// Total file size in bytes (required for part calculation).
	SizeBytes float64 `json:"sizeBytes"`
	// MIME type (video/mp4, video/webm, etc.). Auto-detected if omitted.
	ContentType *string `json:"contentType,omitempty"`
	// Optional display title for the asset.
	Title *string `json:"title,omitempty"`
	// Optional description for the asset.
	Description *string `json:"description,omitempty"`
}

// Result from creating a crypto top-up.
// Contains the deposit address for the agent to send funds.
type CryptoTopupResult struct {
	// Internal top-up ID for tracking/polling.
	TopupID string `json:"topupId"`
	// HD-derived Ethereum address to send funds to.
	DepositAddress string `json:"depositAddress"`
	// Asset to send (ETH, USDC, or LPT).
	Asset proto.CryptoAsset `json:"asset"`
	// Human-readable asset symbol.
	AssetSymbol string `json:"assetSymbol"`
	// Expected amount in cents (echoed from input).
	ExpectedAmountCents int `json:"expectedAmountCents"`
	// When this deposit address expires (24 hours from creation).
	ExpiresAt time.Time `json:"expiresAt"`
}

// Status of a crypto top-up (for polling).
type CryptoTopupStatus struct {
	// Top-up ID.
	ID string `json:"id"`
	// Deposit address.
	DepositAddress string `json:"depositAddress"`
	// Asset being received.
	Asset proto.CryptoAsset `json:"asset"`
	// Current status: pending, confirming, completed, expired.
	Status string `json:"status"`
	// Blockchain transaction hash (when detected).
	TxHash *string `json:"txHash,omitempty"`
	// Number of block confirmations.
	Confirmations int `json:"confirmations"`
	// Amount received in smallest unit (wei for ETH).
	ReceivedAmountWei *string `json:"receivedAmountWei,omitempty"`
	// Amount credited to balance in cents (after conversion).
	CreditedAmountCents *int `json:"creditedAmountCents,omitempty"`
	// When the deposit address expires.
	ExpiresAt time.Time `json:"expiresAt"`
	// When payment was first detected on-chain.
	DetectedAt *time.Time `json:"detectedAt,omitempty"`
	// When balance was credited.
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

// Custom pricing configuration for enterprise subscriptions.
type CustomPricingInput struct {
	// Custom base monthly price.
	BasePrice *float64 `json:"basePrice,omitempty"`
	// Discount rate (0.0 to 1.0).
	DiscountRate *float64 `json:"discountRate,omitempty"`
	// Custom overage rates.
	OverageRates *OverageRatesInput `json:"overageRates,omitempty"`
}

type DVRRecordingEdge struct {
	Cursor string         `json:"cursor"`
	Node   *proto.DVRInfo `json:"node"`
}

type DVRRecordingsConnection struct {
	Edges      []*DVRRecordingEdge `json:"edges"`
	Nodes      []*proto.DVRInfo    `json:"nodes"`
	PageInfo   *PageInfo           `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

type DeleteSuccess struct {
	Success   bool   `json:"success"`
	DeletedID string `json:"deletedId"`
}

func (DeleteSuccess) IsDeleteStreamResult() {}

func (DeleteSuccess) IsDeleteClipResult() {}

func (DeleteSuccess) IsDeleteStreamKeyResult() {}

func (DeleteSuccess) IsStopDVRResult() {}

func (DeleteSuccess) IsDeleteDVRResult() {}

func (DeleteSuccess) IsAbortVodUploadResult() {}

func (DeleteSuccess) IsDeleteVodAssetResult() {}

func (DeleteSuccess) IsRevokeDeveloperTokenResult() {}

func (DeleteSuccess) IsRevokeBootstrapTokenResult() {}

func (DeleteSuccess) IsRevokeClusterInviteResult() {}

func (DeleteSuccess) IsUnlinkWalletResult() {}

type DeveloperTokenEdge struct {
	Cursor string              `json:"cursor"`
	Node   *proto.APITokenInfo `json:"node"`
}

type DeveloperTokensConnection struct {
	Edges      []*DeveloperTokenEdge `json:"edges"`
	Nodes      []*proto.APITokenInfo `json:"nodes"`
	PageInfo   *PageInfo             `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

type InvoiceEdge struct {
	Cursor string         `json:"cursor"`
	Node   *proto.Invoice `json:"node"`
}

type InvoicesConnection struct {
	Edges      []*InvoiceEdge   `json:"edges"`
	Nodes      []*proto.Invoice `json:"nodes"`
	PageInfo   *PageInfo        `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// Input for linking email to a wallet-only account.
type LinkEmailInput struct {
	// Email address to link.
	Email string `json:"email"`
	// Password to set for email-based login.
	Password string `json:"password"`
}

// Successful email link response.
type LinkEmailPayload struct {
	// Whether the operation succeeded.
	Success bool `json:"success"`
	// Human-readable status message.
	Message string `json:"message"`
	// Whether a verification email was sent.
	VerificationSent bool `json:"verificationSent"`
}

func (LinkEmailPayload) IsLinkEmailResult() {}

type MarketplaceClusterConnection struct {
	Edges      []*MarketplaceClusterEdge        `json:"edges"`
	Nodes      []*proto.MarketplaceClusterEntry `json:"nodes"`
	PageInfo   *PageInfo                        `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

type MarketplaceClusterEdge struct {
	Cursor string                         `json:"cursor"`
	Node   *proto.MarketplaceClusterEntry `json:"node"`
}

// A message within a support conversation.
type Message struct {
	// The globally unique identifier for this message.
	ID string `json:"id"`
	// The conversation this message belongs to.
	ConversationID string `json:"conversationId"`
	// The message content.
	Content string `json:"content"`
	// Who sent this message.
	Sender proto.MessageSender `json:"sender"`
	// When the message was sent.
	CreatedAt time.Time `json:"createdAt"`
}

func (Message) IsSendMessageResult() {}

func (Message) IsNode() {}

// A message edge in a connection.
type MessageEdge struct {
	// The message.
	Node *Message `json:"node"`
	// Cursor for this edge.
	Cursor string `json:"cursor"`
}

// Paginated list of messages.
type MessagesConnection struct {
	// List of messages.
	Edges []*MessageEdge `json:"edges"`
	// Pagination information.
	PageInfo *PageInfo `json:"pageInfo"`
	// Total count of messages.
	TotalCount int `json:"totalCount"`
}

// Mollie First Payment - redirect URL for initial payment that creates a mandate.
type MollieFirstPayment struct {
	// Mollie payment ID (tr_xxx).
	PaymentID string `json:"paymentId"`
	// Mollie customer ID (cst_xxx).
	CustomerID string `json:"customerId"`
	// URL to redirect user to for payment.
	PaymentURL string `json:"paymentUrl"`
}

func (MollieFirstPayment) IsMollieFirstPaymentResult() {}

// Mollie Subscription - recurring subscription created after mandate is valid.
type MollieSubscription struct {
	// Mollie subscription ID (sub_xxx).
	SubscriptionID string `json:"subscriptionId"`
	// Subscription status (active, pending, etc.).
	Status string `json:"status"`
	// Next payment date (ISO 8601).
	NextPaymentDate *string `json:"nextPaymentDate,omitempty"`
}

func (MollieSubscription) IsMollieSubscriptionResult() {}

// Root Mutation type - the entry point for all write operations.
//
// All mutations return union types with explicit error states per GraphQL best practices.
// Check the result type to handle success/error cases appropriately.
type Mutation struct {
}

type MySubscriptionEdge struct {
	Cursor string                       `json:"cursor"`
	Node   *proto.InfrastructureCluster `json:"node"`
}

type MySubscriptionsConnection struct {
	Edges      []*MySubscriptionEdge          `json:"edges"`
	Nodes      []*proto.InfrastructureCluster `json:"nodes"`
	PageInfo   *PageInfo                      `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

type NodeEdge struct {
	Cursor string                    `json:"cursor"`
	Node   *proto.InfrastructureNode `json:"node"`
}

type NodeMetricEdge struct {
	Cursor string            `json:"cursor"`
	Node   *proto.NodeMetric `json:"node"`
}

type NodeMetricHourlyEdge struct {
	Cursor string                  `json:"cursor"`
	Node   *proto.NodeMetricHourly `json:"node"`
}

type NodeMetrics1hConnection struct {
	Edges      []*NodeMetricHourlyEdge   `json:"edges"`
	Nodes      []*proto.NodeMetricHourly `json:"nodes"`
	PageInfo   *PageInfo                 `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

type NodeMetricsConnection struct {
	Edges      []*NodeMetricEdge   `json:"edges"`
	Nodes      []*proto.NodeMetric `json:"nodes"`
	PageInfo   *PageInfo           `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

type NodePerformance5mConnection struct {
	Edges      []*NodePerformance5mEdge   `json:"edges"`
	Nodes      []*proto.NodePerformance5M `json:"nodes"`
	PageInfo   *PageInfo                  `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

type NodePerformance5mEdge struct {
	Cursor string                   `json:"cursor"`
	Node   *proto.NodePerformance5M `json:"node"`
}

type NodesConnection struct {
	Edges      []*NodeEdge                 `json:"edges"`
	Nodes      []*proto.InfrastructureNode `json:"nodes"`
	PageInfo   *PageInfo                   `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

type NotFoundError struct {
	Message      string  `json:"message"`
	Code         *string `json:"code,omitempty"`
	ResourceType string  `json:"resourceType"`
	ResourceID   string  `json:"resourceId"`
}

func (NotFoundError) IsError()                {}
func (this NotFoundError) GetMessage() string { return this.Message }
func (this NotFoundError) GetCode() *string   { return this.Code }

func (NotFoundError) IsUpdateStreamResult() {}

func (NotFoundError) IsDeleteStreamResult() {}

func (NotFoundError) IsCreateClipResult() {}

func (NotFoundError) IsDeleteClipResult() {}

func (NotFoundError) IsCreateStreamKeyResult() {}

func (NotFoundError) IsDeleteStreamKeyResult() {}

func (NotFoundError) IsStartDVRResult() {}

func (NotFoundError) IsStopDVRResult() {}

func (NotFoundError) IsDeleteDVRResult() {}

func (NotFoundError) IsCompleteVodUploadResult() {}

func (NotFoundError) IsAbortVodUploadResult() {}

func (NotFoundError) IsDeleteVodAssetResult() {}

func (NotFoundError) IsSubmitX402PaymentResult() {}

func (NotFoundError) IsStripeCheckoutResult() {}

func (NotFoundError) IsStripeBillingPortalResult() {}

func (NotFoundError) IsMollieFirstPaymentResult() {}

func (NotFoundError) IsMollieSubscriptionResult() {}

func (NotFoundError) IsRevokeDeveloperTokenResult() {}

func (NotFoundError) IsRevokeBootstrapTokenResult() {}

func (NotFoundError) IsUpdateClusterResult() {}

func (NotFoundError) IsCreateClusterInviteResult() {}

func (NotFoundError) IsRevokeClusterInviteResult() {}

func (NotFoundError) IsClusterSubscriptionResult() {}

func (NotFoundError) IsUnlinkWalletResult() {}

func (NotFoundError) IsSendMessageResult() {}

// Overage rate configuration for custom pricing.
type OverageRatesInput struct {
	// Bandwidth overage configuration.
	Bandwidth *AllocationDetailsInput `json:"bandwidth,omitempty"`
	// Storage overage configuration.
	Storage *AllocationDetailsInput `json:"storage,omitempty"`
	// Compute overage configuration.
	Compute *AllocationDetailsInput `json:"compute,omitempty"`
}

type PageInfo struct {
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
}

type ProcessingUsageConnection struct {
	Edges      []*ProcessingUsageEdge          `json:"edges"`
	Nodes      []*proto.ProcessingUsageRecord  `json:"nodes"`
	PageInfo   *PageInfo                       `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
	Summaries  []*proto.ProcessingUsageSummary `json:"summaries"`
}

type ProcessingUsageEdge struct {
	Cursor string                       `json:"cursor"`
	Node   *proto.ProcessingUsageRecord `json:"node"`
}

// Successful promotion to postpaid billing.
type PromoteToPaidPayload struct {
	// Whether the promotion succeeded.
	Success bool `json:"success"`
	// Human-readable status message.
	Message string `json:"message"`
	// The new billing model (postpaid).
	NewBillingModel string `json:"newBillingModel"`
	// Prepaid balance carried forward as credit (in cents).
	CreditBalanceCents int `json:"creditBalanceCents"`
	// The new subscription ID.
	SubscriptionID string `json:"subscriptionId"`
}

func (PromoteToPaidPayload) IsPromoteToPaidResult() {}

type QualityTierDailyConnection struct {
	Edges      []*QualityTierDailyEdge   `json:"edges"`
	Nodes      []*proto.QualityTierDaily `json:"nodes"`
	PageInfo   *PageInfo                 `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

type QualityTierDailyEdge struct {
	Cursor string                  `json:"cursor"`
	Node   *proto.QualityTierDaily `json:"node"`
}

// Root Query type - the entry point for all read operations.
//
// List and object fields are nullable per GraphQL best practices,
// enabling graceful degradation when individual services are unavailable.
// Most connection fields are non-null, but some may be nullable when upstream data is optional.
type Query struct {
}

type RateLimitError struct {
	Message    string  `json:"message"`
	Code       *string `json:"code,omitempty"`
	RetryAfter *int    `json:"retryAfter,omitempty"`
}

func (RateLimitError) IsError()                {}
func (this RateLimitError) GetMessage() string { return this.Message }
func (this RateLimitError) GetCode() *string   { return this.Code }

func (RateLimitError) IsCreateDeveloperTokenResult() {}

type RebufferingEventEdge struct {
	Cursor string                  `json:"cursor"`
	Node   *proto.RebufferingEvent `json:"node"`
}

type RebufferingEventsConnection struct {
	Edges      []*RebufferingEventEdge   `json:"edges"`
	Nodes      []*proto.RebufferingEvent `json:"nodes"`
	PageInfo   *PageInfo                 `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

type RoutingEventEdge struct {
	Cursor string              `json:"cursor"`
	Node   *proto.RoutingEvent `json:"node"`
}

type RoutingEventsConnection struct {
	Edges      []*RoutingEventEdge   `json:"edges"`
	Nodes      []*proto.RoutingEvent `json:"nodes"`
	PageInfo   *PageInfo             `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

// Input for sending a message.
type SendMessageInput struct {
	// The conversation ID to send the message to.
	ConversationID string `json:"conversationId"`
	// The message content.
	Content string `json:"content"`
}

type ServiceInstanceEdge struct {
	Cursor string                 `json:"cursor"`
	Node   *proto.ServiceInstance `json:"node"`
}

type ServiceInstancesConnection struct {
	Edges      []*ServiceInstanceEdge   `json:"edges"`
	Nodes      []*proto.ServiceInstance `json:"nodes"`
	PageInfo   *PageInfo                `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

type StorageEventEdge struct {
	Cursor string              `json:"cursor"`
	Node   *proto.StorageEvent `json:"node"`
}

type StorageEventsConnection struct {
	Edges      []*StorageEventEdge   `json:"edges"`
	Nodes      []*proto.StorageEvent `json:"nodes"`
	PageInfo   *PageInfo             `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

type StorageUsageConnection struct {
	Edges      []*StorageUsageEdge         `json:"edges"`
	Nodes      []*proto.StorageUsageRecord `json:"nodes"`
	PageInfo   *PageInfo                   `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

type StorageUsageEdge struct {
	Cursor string                    `json:"cursor"`
	Node   *proto.StorageUsageRecord `json:"node"`
}

type StreamAnalyticsDailyConnection struct {
	Edges      []*StreamAnalyticsDailyEdge   `json:"edges"`
	Nodes      []*proto.StreamAnalyticsDaily `json:"nodes"`
	PageInfo   *PageInfo                     `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

type StreamAnalyticsDailyEdge struct {
	Cursor string                      `json:"cursor"`
	Node   *proto.StreamAnalyticsDaily `json:"node"`
}

type StreamConnectionHourlyConnection struct {
	Edges      []*StreamConnectionHourlyEdge   `json:"edges"`
	Nodes      []*proto.StreamConnectionHourly `json:"nodes"`
	PageInfo   *PageInfo                       `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

type StreamConnectionHourlyEdge struct {
	Cursor string                        `json:"cursor"`
	Node   *proto.StreamConnectionHourly `json:"node"`
}

type StreamEdge struct {
	Cursor string        `json:"cursor"`
	Node   *proto.Stream `json:"node"`
}

type StreamEventEdge struct {
	Cursor string       `json:"cursor"`
	Node   *StreamEvent `json:"node"`
}

type StreamEventsConnection struct {
	Edges      []*StreamEventEdge `json:"edges"`
	Nodes      []*StreamEvent     `json:"nodes"`
	PageInfo   *PageInfo          `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

type StreamHealth5mConnection struct {
	Edges      []*StreamHealth5mEdge   `json:"edges"`
	Nodes      []*proto.StreamHealth5M `json:"nodes"`
	PageInfo   *PageInfo               `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

type StreamHealth5mEdge struct {
	Cursor string                `json:"cursor"`
	Node   *proto.StreamHealth5M `json:"node"`
}

type StreamHealthMetricEdge struct {
	Cursor string                    `json:"cursor"`
	Node   *proto.StreamHealthMetric `json:"node"`
}

type StreamHealthMetricsConnection struct {
	Edges      []*StreamHealthMetricEdge   `json:"edges"`
	Nodes      []*proto.StreamHealthMetric `json:"nodes"`
	PageInfo   *PageInfo                   `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

type StreamKeyEdge struct {
	Cursor string           `json:"cursor"`
	Node   *proto.StreamKey `json:"node"`
}

type StreamKeysConnection struct {
	Edges      []*StreamKeyEdge   `json:"edges"`
	Nodes      []*proto.StreamKey `json:"nodes"`
	PageInfo   *PageInfo          `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

type StreamValidation struct {
	Status    ValidationStatus `json:"status"`
	StreamKey string           `json:"streamKey"`
	Error     *string          `json:"error,omitempty"`
}

type StreamsConnection struct {
	Edges      []*StreamEdge   `json:"edges"`
	Nodes      []*proto.Stream `json:"nodes"`
	PageInfo   *PageInfo       `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// Stripe Billing Portal Session - redirect URL for subscription management.
type StripeBillingPortalSession struct {
	// URL to redirect user to for billing management.
	PortalURL string `json:"portalUrl"`
}

func (StripeBillingPortalSession) IsStripeBillingPortalResult() {}

// Stripe Checkout Session - redirect URL for hosted checkout.
type StripeCheckoutSession struct {
	// Stripe Checkout Session ID (cs_xxx).
	SessionID string `json:"sessionId"`
	// URL to redirect user to for checkout.
	CheckoutURL string `json:"checkoutUrl"`
}

func (StripeCheckoutSession) IsStripeCheckoutResult() {}

// Real-time subscriptions for live event streaming via WebSocket.
// All subscriptions are tenant-scoped and require authentication.
// Events are delivered as they occur with minimal latency.
type Subscription struct {
}

type TenantAnalyticsDailyConnection struct {
	Edges      []*TenantAnalyticsDailyEdge   `json:"edges"`
	Nodes      []*proto.TenantAnalyticsDaily `json:"nodes"`
	PageInfo   *PageInfo                     `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

type TenantAnalyticsDailyEdge struct {
	Cursor string                      `json:"cursor"`
	Node   *proto.TenantAnalyticsDaily `json:"node"`
}

type TenantUsage struct {
	BillingPeriod string        `json:"billingPeriod"`
	Usage         []*UsageEntry `json:"usage"`
	Costs         []*CostEntry  `json:"costs"`
	TotalCost     float64       `json:"totalCost"`
	Currency      string        `json:"currency"`
}

// Time range for filtering time-series data.
type TimeRangeInput struct {
	// Start of the time range.
	Start time.Time `json:"start"`
	// End of the time range.
	End time.Time `json:"end"`
}

type TrackListEventEdge struct {
	Cursor string                `json:"cursor"`
	Node   *proto.TrackListEvent `json:"node"`
}

type TrackListEventsConnection struct {
	Edges      []*TrackListEventEdge   `json:"edges"`
	Nodes      []*proto.TrackListEvent `json:"nodes"`
	PageInfo   *PageInfo               `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

// Input for updating billing details.
type UpdateBillingDetailsInput struct {
	// Billing contact email.
	Email *string `json:"email,omitempty"`
	// Company name for invoices.
	Company *string `json:"company,omitempty"`
	// VAT number (EU format: XX123456789).
	VatNumber *string `json:"vatNumber,omitempty"`
	// Structured billing address.
	Address *BillingAddressInput `json:"address,omitempty"`
}

// Input for updating cluster marketplace settings.
type UpdateClusterMarketplaceInput struct {
	// Marketplace visibility (PUBLIC, PRIVATE, INVITE_ONLY).
	Visibility *proto.ClusterVisibility `json:"visibility,omitempty"`
	// Pricing model for subscriptions.
	PricingModel *proto.ClusterPricingModel `json:"pricingModel,omitempty"`
	// Monthly subscription price in cents.
	MonthlyPriceCents *int `json:"monthlyPriceCents,omitempty"`
	// Whether access requires owner approval.
	RequiresApproval *bool `json:"requiresApproval,omitempty"`
	// Short marketplace description.
	ShortDescription *string `json:"shortDescription,omitempty"`
}

// Input for updating an existing stream.
// All fields are optional - only provided fields are updated.
type UpdateStreamInput struct {
	// New name for the stream.
	Name *string `json:"name,omitempty"`
	// New description for the stream.
	Description *string `json:"description,omitempty"`
	// Enable or disable DVR recording.
	Record *bool `json:"record,omitempty"`
}

// Input for updating enterprise subscription custom terms.
type UpdateSubscriptionCustomTermsInput struct {
	// Custom pricing overrides.
	CustomPricing *CustomPricingInput `json:"customPricing,omitempty"`
	// Custom feature flags.
	CustomFeatures *BillingFeaturesInput `json:"customFeatures,omitempty"`
	// Custom resource allocations.
	CustomAllocations *AllocationDetailsInput `json:"customAllocations,omitempty"`
}

// Input for updating tenant settings.
type UpdateTenantInput struct {
	// New tenant name.
	Name *string `json:"name,omitempty"`
	// Custom settings JSON.
	Settings *string `json:"settings,omitempty"`
}

type UsageEntry struct {
	ResourceType string  `json:"resourceType"`
	Amount       float64 `json:"amount"`
}

type UsageRecordEdge struct {
	Cursor string             `json:"cursor"`
	Node   *proto.UsageRecord `json:"node"`
}

type UsageRecordsConnection struct {
	Edges      []*UsageRecordEdge   `json:"edges"`
	Nodes      []*proto.UsageRecord `json:"nodes"`
	PageInfo   *PageInfo            `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

type ValidationError struct {
	Message    string  `json:"message"`
	Code       *string `json:"code,omitempty"`
	Field      *string `json:"field,omitempty"`
	Constraint *string `json:"constraint,omitempty"`
}

func (ValidationError) IsError()                {}
func (this ValidationError) GetMessage() string { return this.Message }
func (this ValidationError) GetCode() *string   { return this.Code }

func (ValidationError) IsCreateStreamResult() {}

func (ValidationError) IsUpdateStreamResult() {}

func (ValidationError) IsCreateClipResult() {}

func (ValidationError) IsCreateStreamKeyResult() {}

func (ValidationError) IsStartDVRResult() {}

func (ValidationError) IsCreateVodUploadResult() {}

func (ValidationError) IsCompleteVodUploadResult() {}

func (ValidationError) IsCreatePaymentResult() {}

func (ValidationError) IsSubmitX402PaymentResult() {}

func (ValidationError) IsStripeCheckoutResult() {}

func (ValidationError) IsStripeBillingPortalResult() {}

func (ValidationError) IsMollieFirstPaymentResult() {}

func (ValidationError) IsMollieSubscriptionResult() {}

func (ValidationError) IsUpdateTenantResult() {}

func (ValidationError) IsCreateDeveloperTokenResult() {}

func (ValidationError) IsCreateBootstrapTokenResult() {}

func (ValidationError) IsCreatePrivateClusterResult() {}

func (ValidationError) IsUpdateClusterResult() {}

func (ValidationError) IsCreateClusterInviteResult() {}

func (ValidationError) IsClusterSubscriptionResult() {}

func (ValidationError) IsWalletLoginResult() {}

func (ValidationError) IsLinkWalletResult() {}

func (ValidationError) IsLinkEmailResult() {}

func (ValidationError) IsPromoteToPaidResult() {}

func (ValidationError) IsCreateConversationResult() {}

func (ValidationError) IsSendMessageResult() {}

type ViewerCountBucketEdge struct {
	Cursor string                   `json:"cursor"`
	Node   *proto.ViewerCountBucket `json:"node"`
}

type ViewerGeoHourlyConnection struct {
	Edges      []*ViewerGeoHourlyEdge   `json:"edges"`
	Nodes      []*proto.ViewerGeoHourly `json:"nodes"`
	PageInfo   *PageInfo                `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

type ViewerGeoHourlyEdge struct {
	Cursor string                 `json:"cursor"`
	Node   *proto.ViewerGeoHourly `json:"node"`
}

type ViewerGeographicEdge struct {
	Cursor string                 `json:"cursor"`
	Node   *proto.ConnectionEvent `json:"node"`
}

type ViewerGeographicsConnection struct {
	Edges      []*ViewerGeographicEdge  `json:"edges"`
	Nodes      []*proto.ConnectionEvent `json:"nodes"`
	PageInfo   *PageInfo                `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

type ViewerHoursHourlyConnection struct {
	Edges      []*ViewerHoursHourlyEdge   `json:"edges"`
	Nodes      []*proto.ViewerHoursHourly `json:"nodes"`
	PageInfo   *PageInfo                  `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

type ViewerHoursHourlyEdge struct {
	Cursor string                   `json:"cursor"`
	Node   *proto.ViewerHoursHourly `json:"node"`
}

type ViewerSessionEdge struct {
	Cursor string               `json:"cursor"`
	Node   *proto.ViewerSession `json:"node"`
}

type ViewerSessionsConnection struct {
	Edges      []*ViewerSessionEdge   `json:"edges"`
	Nodes      []*proto.ViewerSession `json:"nodes"`
	PageInfo   *PageInfo              `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

type ViewerTimeSeriesConnection struct {
	Edges      []*ViewerCountBucketEdge   `json:"edges"`
	Nodes      []*proto.ViewerCountBucket `json:"nodes"`
	PageInfo   *PageInfo                  `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

// A Video-on-Demand asset uploaded by the tenant.
// VOD assets can be played back using the playbackId in playback URLs.
type VodAsset struct {
	// Global unique identifier for Relay compatibility.
	ID string `json:"id"`
	// Internal hash used for playback URL resolution.
	ArtifactHash string `json:"artifactHash"`
	// Public playback identifier for generating playback URLs.
	PlaybackID string `json:"playbackId"`
	// Optional display title for the asset.
	Title *string `json:"title,omitempty"`
	// Optional description of the asset content.
	Description *string `json:"description,omitempty"`
	// Original filename when uploaded.
	Filename *string `json:"filename,omitempty"`
	// Current processing/storage status of the asset.
	Status VodAssetStatus `json:"status"`
	// Where the asset is stored (s3, local, freezing, defrosting).
	StorageLocation string `json:"storageLocation"`
	// File size in bytes (available after validation).
	SizeBytes *float64 `json:"sizeBytes,omitempty"`
	// Video duration in milliseconds.
	DurationMs *int `json:"durationMs,omitempty"`
	// Video resolution (e.g., '1920x1080').
	Resolution *string `json:"resolution,omitempty"`
	// Video codec (h264, h265, vp9, av1).
	VideoCodec *string `json:"videoCodec,omitempty"`
	// Audio codec (aac, opus).
	AudioCodec *string `json:"audioCodec,omitempty"`
	// Average bitrate in kbps.
	BitrateKbps *int `json:"bitrateKbps,omitempty"`
	// When the asset was created/uploaded.
	CreatedAt time.Time `json:"createdAt"`
	// When the asset was last modified.
	UpdatedAt time.Time `json:"updatedAt"`
	// Optional expiration time for auto-deletion.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// Error message if processing failed.
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

func (VodAsset) IsCompleteVodUploadResult() {}

func (VodAsset) IsNode() {}

type VodAssetEdge struct {
	Cursor string    `json:"cursor"`
	Node   *VodAsset `json:"node"`
}

type VodAssetsConnection struct {
	Edges      []*VodAssetEdge `json:"edges"`
	Nodes      []*VodAsset     `json:"nodes"`
	PageInfo   *PageInfo       `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// Completed part info returned by S3 after each part upload.
type VodUploadCompletedPart struct {
	// 1-indexed part number.
	PartNumber int `json:"partNumber"`
	// ETag header value returned by S3 on part upload.
	Etag string `json:"etag"`
}

// Response from createVodUpload with S3 multipart upload instructions.
// Use the presigned URLs to upload file parts directly to S3.
type VodUploadSession struct {
	// Upload session ID (S3 uploadId).
	ID string `json:"id"`
	// Internal artifact ID.
	ArtifactID string `json:"artifactId"`
	// Hash for playback URL resolution.
	ArtifactHash string `json:"artifactHash"`
	// Public playback identifier.
	PlaybackID string `json:"playbackId"`
	// Recommended part size in bytes.
	PartSize float64 `json:"partSize"`
	// Presigned URLs for each part.
	Parts []*proto.VodUploadPart `json:"parts"`
	// When presigned URLs expire (typically 2 hours).
	ExpiresAt time.Time `json:"expiresAt"`
}

func (VodUploadSession) IsCreateVodUploadResult() {}

// Input for wallet-based authentication.
// The signature proves ownership of the wallet address.
type WalletLoginInput struct {
	// Ethereum address (0x-prefixed, 40 hex characters).
	Address string `json:"address"`
	// Message that was signed, including timestamp and nonce for replay protection.
	Message string `json:"message"`
	// EIP-191 personal_sign signature (0x-prefixed, 65 bytes hex).
	Signature string `json:"signature"`
}

// Result from submitting an x402 payment for settlement.
type X402PaymentResult struct {
	// Whether the payment settlement succeeded.
	Success bool `json:"success"`
	// True if this was an auth-only payload (always false for settlement).
	IsAuthOnly bool `json:"isAuthOnly"`
	// Tenant that was credited.
	TenantID string `json:"tenantId"`
	// Wallet address that paid.
	WalletAddress string `json:"walletAddress"`
	// Amount credited in cents.
	CreditedCents int `json:"creditedCents"`
	// New balance in cents (if available).
	NewBalanceCents *int `json:"newBalanceCents,omitempty"`
	// Blockchain transaction hash (if available).
	TxHash *string `json:"txHash,omitempty"`
	// Human-readable status message.
	Message string `json:"message"`
}

func (X402PaymentResult) IsSubmitX402PaymentResult() {}

type BootstrapTokenType string

const (
	BootstrapTokenTypeEdgeNode BootstrapTokenType = "EDGE_NODE"
	BootstrapTokenTypeService  BootstrapTokenType = "SERVICE"
)

var AllBootstrapTokenType = []BootstrapTokenType{
	BootstrapTokenTypeEdgeNode,
	BootstrapTokenTypeService,
}

func (e BootstrapTokenType) IsValid() bool {
	switch e {
	case BootstrapTokenTypeEdgeNode, BootstrapTokenTypeService:
		return true
	}
	return false
}

func (e BootstrapTokenType) String() string {
	return string(e)
}

func (e *BootstrapTokenType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BootstrapTokenType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BootstrapTokenType", str)
	}
	return nil
}

func (e BootstrapTokenType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BootstrapTokenType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BootstrapTokenType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type BufferState string

const (
	BufferStateFull    BufferState = "FULL"
	BufferStateEmpty   BufferState = "EMPTY"
	BufferStateDry     BufferState = "DRY"
	BufferStateRecover BufferState = "RECOVER"
)

var AllBufferState = []BufferState{
	BufferStateFull,
	BufferStateEmpty,
	BufferStateDry,
	BufferStateRecover,
}

func (e BufferState) IsValid() bool {
	switch e {
	case BufferStateFull, BufferStateEmpty, BufferStateDry, BufferStateRecover:
		return true
	}
	return false
}

func (e BufferState) String() string {
	return string(e)
}

func (e *BufferState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BufferState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BufferState", str)
	}
	return nil
}

func (e BufferState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BufferState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BufferState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Card payment provider for top-ups.
type CardPaymentProvider string

const (
	// Stripe checkout.
	CardPaymentProviderStripe CardPaymentProvider = "STRIPE"
	// Mollie checkout.
	CardPaymentProviderMollie CardPaymentProvider = "MOLLIE"
)

var AllCardPaymentProvider = []CardPaymentProvider{
	CardPaymentProviderStripe,
	CardPaymentProviderMollie,
}

func (e CardPaymentProvider) IsValid() bool {
	switch e {
	case CardPaymentProviderStripe, CardPaymentProviderMollie:
		return true
	}
	return false
}

func (e CardPaymentProvider) String() string {
	return string(e)
}

func (e *CardPaymentProvider) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardPaymentProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardPaymentProvider", str)
	}
	return nil
}

func (e CardPaymentProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CardPaymentProvider) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CardPaymentProvider) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Clip creation mode determines how time fields are interpreted.
type ClipCreationMode string

const (
	// Use startUnix and stopUnix as Unix timestamps in seconds.
	ClipCreationModeAbsolute ClipCreationMode = "ABSOLUTE"
	// Use startMedia and stopMedia as seconds from stream start.
	ClipCreationModeRelative ClipCreationMode = "RELATIVE"
	// Use startUnix (or startMedia) plus duration.
	ClipCreationModeDuration ClipCreationMode = "DURATION"
	// Clip the last N seconds from the current live position.
	ClipCreationModeClipNow ClipCreationMode = "CLIP_NOW"
)

var AllClipCreationMode = []ClipCreationMode{
	ClipCreationModeAbsolute,
	ClipCreationModeRelative,
	ClipCreationModeDuration,
	ClipCreationModeClipNow,
}

func (e ClipCreationMode) IsValid() bool {
	switch e {
	case ClipCreationModeAbsolute, ClipCreationModeRelative, ClipCreationModeDuration, ClipCreationModeClipNow:
		return true
	}
	return false
}

func (e ClipCreationMode) String() string {
	return string(e)
}

func (e *ClipCreationMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClipCreationMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClipCreationMode", str)
	}
	return nil
}

func (e ClipCreationMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ClipCreationMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ClipCreationMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Service instance lifecycle status.
type InstanceStatus string

const (
	// Service is running and healthy.
	InstanceStatusRunning InstanceStatus = "RUNNING"
	// Service is starting up.
	InstanceStatusStarting InstanceStatus = "STARTING"
	// Service is shutting down.
	InstanceStatusStopping InstanceStatus = "STOPPING"
	// Service is stopped.
	InstanceStatusStopped InstanceStatus = "STOPPED"
	// Service encountered an error.
	InstanceStatusError InstanceStatus = "ERROR"
	// Service status unknown.
	InstanceStatusUnknown InstanceStatus = "UNKNOWN"
)

var AllInstanceStatus = []InstanceStatus{
	InstanceStatusRunning,
	InstanceStatusStarting,
	InstanceStatusStopping,
	InstanceStatusStopped,
	InstanceStatusError,
	InstanceStatusUnknown,
}

func (e InstanceStatus) IsValid() bool {
	switch e {
	case InstanceStatusRunning, InstanceStatusStarting, InstanceStatusStopping, InstanceStatusStopped, InstanceStatusError, InstanceStatusUnknown:
		return true
	}
	return false
}

func (e InstanceStatus) String() string {
	return string(e)
}

func (e *InstanceStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstanceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstanceStatus", str)
	}
	return nil
}

func (e InstanceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InstanceStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InstanceStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Invoice lifecycle status.
type InvoiceStatus string

const (
	// Invoice being prepared, not yet sent.
	InvoiceStatusDraft InvoiceStatus = "DRAFT"
	// Invoice sent, awaiting payment.
	InvoiceStatusPending InvoiceStatus = "PENDING"
	// Invoice paid in full.
	InvoiceStatusPaid InvoiceStatus = "PAID"
	// Payment past due date.
	InvoiceStatusOverdue InvoiceStatus = "OVERDUE"
	// Payment processing failed.
	InvoiceStatusFailed InvoiceStatus = "FAILED"
	// Invoice cancelled.
	InvoiceStatusCancelled InvoiceStatus = "CANCELLED"
)

var AllInvoiceStatus = []InvoiceStatus{
	InvoiceStatusDraft,
	InvoiceStatusPending,
	InvoiceStatusPaid,
	InvoiceStatusOverdue,
	InvoiceStatusFailed,
	InvoiceStatusCancelled,
}

func (e InvoiceStatus) IsValid() bool {
	switch e {
	case InvoiceStatusDraft, InvoiceStatusPending, InvoiceStatusPaid, InvoiceStatusOverdue, InvoiceStatusFailed, InvoiceStatusCancelled:
		return true
	}
	return false
}

func (e InvoiceStatus) String() string {
	return string(e)
}

func (e *InvoiceStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InvoiceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InvoiceStatus", str)
	}
	return nil
}

func (e InvoiceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InvoiceStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InvoiceStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type NodeStatus string

const (
	NodeStatusHealthy   NodeStatus = "HEALTHY"
	NodeStatusDegraded  NodeStatus = "DEGRADED"
	NodeStatusUnhealthy NodeStatus = "UNHEALTHY"
)

var AllNodeStatus = []NodeStatus{
	NodeStatusHealthy,
	NodeStatusDegraded,
	NodeStatusUnhealthy,
}

func (e NodeStatus) IsValid() bool {
	switch e {
	case NodeStatusHealthy, NodeStatusDegraded, NodeStatusUnhealthy:
		return true
	}
	return false
}

func (e NodeStatus) String() string {
	return string(e)
}

func (e *NodeStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeStatus", str)
	}
	return nil
}

func (e NodeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NodeStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NodeStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Supported payment methods.
type PaymentMethod string

const (
	// Credit/debit card via Stripe.
	PaymentMethodCard PaymentMethod = "CARD"
	// Cryptocurrency payment.
	PaymentMethodCrypto PaymentMethod = "CRYPTO"
	// ACH/wire bank transfer.
	PaymentMethodBankTransfer PaymentMethod = "BANK_TRANSFER"
)

var AllPaymentMethod = []PaymentMethod{
	PaymentMethodCard,
	PaymentMethodCrypto,
	PaymentMethodBankTransfer,
}

func (e PaymentMethod) IsValid() bool {
	switch e {
	case PaymentMethodCard, PaymentMethodCrypto, PaymentMethodBankTransfer:
		return true
	}
	return false
}

func (e PaymentMethod) String() string {
	return string(e)
}

func (e *PaymentMethod) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentMethod", str)
	}
	return nil
}

func (e PaymentMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PaymentMethod) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PaymentMethod) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Payment processing status.
type PaymentStatus string

const (
	// Payment initiated, awaiting confirmation.
	PaymentStatusPending PaymentStatus = "PENDING"
	// Payment successfully processed.
	PaymentStatusConfirmed PaymentStatus = "CONFIRMED"
	// Payment failed or declined.
	PaymentStatusFailed PaymentStatus = "FAILED"
)

var AllPaymentStatus = []PaymentStatus{
	PaymentStatusPending,
	PaymentStatusConfirmed,
	PaymentStatusFailed,
}

func (e PaymentStatus) IsValid() bool {
	switch e {
	case PaymentStatusPending, PaymentStatusConfirmed, PaymentStatusFailed:
		return true
	}
	return false
}

func (e PaymentStatus) String() string {
	return string(e)
}

func (e *PaymentStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentStatus", str)
	}
	return nil
}

func (e PaymentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PaymentStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PaymentStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Sort direction for ordered results.
type SortOrder string

const (
	// Ascending order (oldest first, A-Z).
	SortOrderAsc SortOrder = "ASC"
	// Descending order (newest first, Z-A).
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SortOrder) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SortOrder) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StreamEventSource string

const (
	StreamEventSourceHistorical StreamEventSource = "HISTORICAL"
	StreamEventSourceLive       StreamEventSource = "LIVE"
)

var AllStreamEventSource = []StreamEventSource{
	StreamEventSourceHistorical,
	StreamEventSourceLive,
}

func (e StreamEventSource) IsValid() bool {
	switch e {
	case StreamEventSourceHistorical, StreamEventSourceLive:
		return true
	}
	return false
}

func (e StreamEventSource) String() string {
	return string(e)
}

func (e *StreamEventSource) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamEventSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamEventSource", str)
	}
	return nil
}

func (e StreamEventSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StreamEventSource) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StreamEventSource) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StreamEventType string

const (
	StreamEventTypeStreamLifecycleUpdate StreamEventType = "STREAM_LIFECYCLE_UPDATE"
	StreamEventTypeStreamStart           StreamEventType = "STREAM_START"
	StreamEventTypeStreamEnd             StreamEventType = "STREAM_END"
	StreamEventTypeBufferUpdate          StreamEventType = "BUFFER_UPDATE"
	StreamEventTypeTrackListUpdate       StreamEventType = "TRACK_LIST_UPDATE"
	StreamEventTypePlayRewrite           StreamEventType = "PLAY_REWRITE"
	StreamEventTypeStreamSource          StreamEventType = "STREAM_SOURCE"
)

var AllStreamEventType = []StreamEventType{
	StreamEventTypeStreamLifecycleUpdate,
	StreamEventTypeStreamStart,
	StreamEventTypeStreamEnd,
	StreamEventTypeBufferUpdate,
	StreamEventTypeTrackListUpdate,
	StreamEventTypePlayRewrite,
	StreamEventTypeStreamSource,
}

func (e StreamEventType) IsValid() bool {
	switch e {
	case StreamEventTypeStreamLifecycleUpdate, StreamEventTypeStreamStart, StreamEventTypeStreamEnd, StreamEventTypeBufferUpdate, StreamEventTypeTrackListUpdate, StreamEventTypePlayRewrite, StreamEventTypeStreamSource:
		return true
	}
	return false
}

func (e StreamEventType) String() string {
	return string(e)
}

func (e *StreamEventType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamEventType", str)
	}
	return nil
}

func (e StreamEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StreamEventType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StreamEventType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Live stream status.
type StreamStatus string

const (
	// Stream is not broadcasting.
	StreamStatusOffline StreamStatus = "OFFLINE"
	// Stream is currently live.
	StreamStatusLive StreamStatus = "LIVE"
	// Stream is live and recording.
	StreamStatusRecording StreamStatus = "RECORDING"
	// Stream has ended (no longer live).
	StreamStatusEnded StreamStatus = "ENDED"
)

var AllStreamStatus = []StreamStatus{
	StreamStatusOffline,
	StreamStatusLive,
	StreamStatusRecording,
	StreamStatusEnded,
}

func (e StreamStatus) IsValid() bool {
	switch e {
	case StreamStatusOffline, StreamStatusLive, StreamStatusRecording, StreamStatusEnded:
		return true
	}
	return false
}

func (e StreamStatus) String() string {
	return string(e)
}

func (e *StreamStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamStatus", str)
	}
	return nil
}

func (e StreamStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StreamStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StreamStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ValidationStatus string

const (
	ValidationStatusValid   ValidationStatus = "VALID"
	ValidationStatusInvalid ValidationStatus = "INVALID"
	ValidationStatusError   ValidationStatus = "ERROR"
)

var AllValidationStatus = []ValidationStatus{
	ValidationStatusValid,
	ValidationStatusInvalid,
	ValidationStatusError,
}

func (e ValidationStatus) IsValid() bool {
	switch e {
	case ValidationStatusValid, ValidationStatusInvalid, ValidationStatusError:
		return true
	}
	return false
}

func (e ValidationStatus) String() string {
	return string(e)
}

func (e *ValidationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidationStatus", str)
	}
	return nil
}

func (e ValidationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ValidationStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ValidationStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// VOD asset processing status.
type VodAssetStatus string

const (
	// S3 multipart upload in progress.
	VodAssetStatusUploading VodAssetStatus = "UPLOADING"
	// Upload complete, validating and extracting metadata.
	VodAssetStatusProcessing VodAssetStatus = "PROCESSING"
	// Validated and ready for playback.
	VodAssetStatusReady VodAssetStatus = "READY"
	// Validation failed or upload error.
	VodAssetStatusFailed VodAssetStatus = "FAILED"
	// Marked for deletion.
	VodAssetStatusDeleted VodAssetStatus = "DELETED"
)

var AllVodAssetStatus = []VodAssetStatus{
	VodAssetStatusUploading,
	VodAssetStatusProcessing,
	VodAssetStatusReady,
	VodAssetStatusFailed,
	VodAssetStatusDeleted,
}

func (e VodAssetStatus) IsValid() bool {
	switch e {
	case VodAssetStatusUploading, VodAssetStatusProcessing, VodAssetStatusReady, VodAssetStatusFailed, VodAssetStatusDeleted:
		return true
	}
	return false
}

func (e VodAssetStatus) String() string {
	return string(e)
}

func (e *VodAssetStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VodAssetStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VodAssetStatus", str)
	}
	return nil
}

func (e VodAssetStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VodAssetStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VodAssetStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
