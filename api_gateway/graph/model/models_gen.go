// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
)

type CityMetric struct {
	City        string   `json:"city"`
	CountryCode *string  `json:"countryCode,omitempty"`
	ViewerCount int      `json:"viewerCount"`
	Percentage  float64  `json:"percentage"`
	Latitude    *float64 `json:"latitude,omitempty"`
	Longitude   *float64 `json:"longitude,omitempty"`
}

type CountryMetric struct {
	CountryCode string        `json:"countryCode"`
	ViewerCount int           `json:"viewerCount"`
	Percentage  float64       `json:"percentage"`
	Cities      []*CityMetric `json:"cities,omitempty"`
}

type CountryTimeSeries struct {
	Timestamp   time.Time `json:"timestamp"`
	CountryCode string    `json:"countryCode"`
	ViewerCount int       `json:"viewerCount"`
}

type CreateClipInput struct {
	Stream      string  `json:"stream"`
	StartTime   int     `json:"startTime"`
	EndTime     int     `json:"endTime"`
	Title       string  `json:"title"`
	Description *string `json:"description,omitempty"`
}

type CreateDeveloperTokenInput struct {
	Name        string  `json:"name"`
	Permissions *string `json:"permissions,omitempty"`
	ExpiresIn   *int    `json:"expiresIn,omitempty"`
}

type CreatePaymentInput struct {
	Amount   float64       `json:"amount"`
	Currency *string       `json:"currency,omitempty"`
	Method   PaymentMethod `json:"method"`
}

type CreateStreamInput struct {
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	Record      *bool   `json:"record,omitempty"`
}

type CreateStreamKeyInput struct {
	Name string `json:"name"`
}

type GeographicDistribution struct {
	TimeRange        *TimeRange           `json:"timeRange"`
	Stream           *string              `json:"stream,omitempty"`
	TopCountries     []*CountryMetric     `json:"topCountries"`
	TopCities        []*CityMetric        `json:"topCities"`
	UniqueCountries  int                  `json:"uniqueCountries"`
	UniqueCities     int                  `json:"uniqueCities"`
	TotalViewers     int                  `json:"totalViewers"`
	ViewersByCountry []*CountryTimeSeries `json:"viewersByCountry"`
}

type LineItem struct {
	Description string  `json:"description"`
	Quantity    int     `json:"quantity"`
	UnitPrice   float64 `json:"unitPrice"`
	Total       float64 `json:"total"`
}

type LoadBalancingMetric struct {
	Timestamp       time.Time `json:"timestamp"`
	Stream          string    `json:"stream"`
	SelectedNode    string    `json:"selectedNode"`
	NodeID          *string   `json:"nodeId,omitempty"`
	ClientIP        *string   `json:"clientIp,omitempty"`
	ClientCountry   *string   `json:"clientCountry,omitempty"`
	ClientLatitude  *float64  `json:"clientLatitude,omitempty"`
	ClientLongitude *float64  `json:"clientLongitude,omitempty"`
	NodeLatitude    *float64  `json:"nodeLatitude,omitempty"`
	NodeLongitude   *float64  `json:"nodeLongitude,omitempty"`
	NodeName        *string   `json:"nodeName,omitempty"`
	Score           *int      `json:"score,omitempty"`
	Status          string    `json:"status"`
	Details         *string   `json:"details,omitempty"`
	RoutingDistance *float64  `json:"routingDistance,omitempty"`
	EventType       *string   `json:"eventType,omitempty"`
	Source          *string   `json:"source,omitempty"`
}

type Mutation struct {
}

type NodeMetricHourly struct {
	Timestamp         time.Time `json:"timestamp"`
	NodeID            string    `json:"nodeId"`
	AvgCPU            float64   `json:"avgCpu"`
	PeakCPU           float64   `json:"peakCpu"`
	AvgMemory         float64   `json:"avgMemory"`
	PeakMemory        float64   `json:"peakMemory"`
	TotalBandwidthIn  int       `json:"totalBandwidthIn"`
	TotalBandwidthOut int       `json:"totalBandwidthOut"`
	AvgHealthScore    float64   `json:"avgHealthScore"`
	WasHealthy        bool      `json:"wasHealthy"`
}

type PaginationInput struct {
	Limit  *int `json:"limit,omitempty"`
	Offset *int `json:"offset,omitempty"`
}

type Query struct {
}

type RebufferingEvent struct {
	Timestamp            time.Time   `json:"timestamp"`
	Stream               string      `json:"stream"`
	NodeID               string      `json:"nodeId"`
	BufferState          BufferState `json:"bufferState"`
	PreviousState        BufferState `json:"previousState"`
	RebufferStart        bool        `json:"rebufferStart"`
	RebufferEnd          bool        `json:"rebufferEnd"`
	HealthScore          *float64    `json:"healthScore,omitempty"`
	FrameJitterMs        *float64    `json:"frameJitterMs,omitempty"`
	PacketLossPercentage *float64    `json:"packetLossPercentage,omitempty"`
}

type StreamHealthAlert struct {
	Timestamp            time.Time     `json:"timestamp"`
	Stream               string        `json:"stream"`
	NodeID               string        `json:"nodeId"`
	AlertType            AlertType     `json:"alertType"`
	Severity             AlertSeverity `json:"severity"`
	HealthScore          *float64      `json:"healthScore,omitempty"`
	FrameJitterMs        *float64      `json:"frameJitterMs,omitempty"`
	PacketLossPercentage *float64      `json:"packetLossPercentage,omitempty"`
	IssuesDescription    *string       `json:"issuesDescription,omitempty"`
	BufferState          *BufferState  `json:"bufferState,omitempty"`
	QualityTier          *string       `json:"qualityTier,omitempty"`
}

type StreamQualityChange struct {
	Timestamp           time.Time         `json:"timestamp"`
	Stream              string            `json:"stream"`
	NodeID              string            `json:"nodeId"`
	ChangeType          QualityChangeType `json:"changeType"`
	PreviousQualityTier *string           `json:"previousQualityTier,omitempty"`
	NewQualityTier      *string           `json:"newQualityTier,omitempty"`
	PreviousResolution  *string           `json:"previousResolution,omitempty"`
	NewResolution       *string           `json:"newResolution,omitempty"`
	PreviousCodec       *string           `json:"previousCodec,omitempty"`
	NewCodec            *string           `json:"newCodec,omitempty"`
	PreviousTracks      *string           `json:"previousTracks,omitempty"`
	NewTracks           *string           `json:"newTracks,omitempty"`
}

type StreamValidation struct {
	Valid     bool    `json:"valid"`
	StreamKey string  `json:"streamKey"`
	Error     *string `json:"error,omitempty"`
}

type Subscription struct {
}

type SystemHealthEvent struct {
	Node        string     `json:"node"`
	Cluster     string     `json:"cluster"`
	Status      NodeStatus `json:"status"`
	CPUUsage    float64    `json:"cpuUsage"`
	MemoryUsage float64    `json:"memoryUsage"`
	DiskUsage   float64    `json:"diskUsage"`
	HealthScore float64    `json:"healthScore"`
	Timestamp   time.Time  `json:"timestamp"`
}

type TenantClusterAssignment struct {
	ID                        string    `json:"id"`
	TenantID                  string    `json:"tenantId"`
	ClusterID                 string    `json:"clusterId"`
	DeploymentTier            *string   `json:"deploymentTier,omitempty"`
	Priority                  int       `json:"priority"`
	IsPrimary                 bool      `json:"isPrimary"`
	IsActive                  bool      `json:"isActive"`
	MaxStreamsOnCluster       *int      `json:"maxStreamsOnCluster,omitempty"`
	MaxViewersOnCluster       *int      `json:"maxViewersOnCluster,omitempty"`
	MaxBandwidthMbpsOnCluster *int      `json:"maxBandwidthMbpsOnCluster,omitempty"`
	FallbackWhenFull          bool      `json:"fallbackWhenFull"`
	CreatedAt                 time.Time `json:"createdAt"`
	UpdatedAt                 time.Time `json:"updatedAt"`
}

type TimeRange struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

type TimeRangeInput struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

type UpdateStreamInput struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	Record      *bool   `json:"record,omitempty"`
}

type UpdateTenantInput struct {
	Name     *string `json:"name,omitempty"`
	Settings *string `json:"settings,omitempty"`
}

type ViewerMetrics struct {
	Stream            string    `json:"stream"`
	CurrentViewers    int       `json:"currentViewers"`
	ViewerCount       int       `json:"viewerCount"`
	PeakViewers       int       `json:"peakViewers"`
	Bandwidth         float64   `json:"bandwidth"`
	ConnectionQuality *float64  `json:"connectionQuality,omitempty"`
	BufferHealth      *float64  `json:"bufferHealth,omitempty"`
	Timestamp         time.Time `json:"timestamp"`
}

type AlertSeverity string

const (
	AlertSeverityLow      AlertSeverity = "LOW"
	AlertSeverityMedium   AlertSeverity = "MEDIUM"
	AlertSeverityHigh     AlertSeverity = "HIGH"
	AlertSeverityCritical AlertSeverity = "CRITICAL"
)

var AllAlertSeverity = []AlertSeverity{
	AlertSeverityLow,
	AlertSeverityMedium,
	AlertSeverityHigh,
	AlertSeverityCritical,
}

func (e AlertSeverity) IsValid() bool {
	switch e {
	case AlertSeverityLow, AlertSeverityMedium, AlertSeverityHigh, AlertSeverityCritical:
		return true
	}
	return false
}

func (e AlertSeverity) String() string {
	return string(e)
}

func (e *AlertSeverity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertSeverity", str)
	}
	return nil
}

func (e AlertSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AlertSeverity) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AlertSeverity) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AlertType string

const (
	AlertTypeHighJitter          AlertType = "HIGH_JITTER"
	AlertTypeKeyframeInstability AlertType = "KEYFRAME_INSTABILITY"
	AlertTypePacketLoss          AlertType = "PACKET_LOSS"
	AlertTypeRebuffering         AlertType = "REBUFFERING"
	AlertTypeQualityDegradation  AlertType = "QUALITY_DEGRADATION"
)

var AllAlertType = []AlertType{
	AlertTypeHighJitter,
	AlertTypeKeyframeInstability,
	AlertTypePacketLoss,
	AlertTypeRebuffering,
	AlertTypeQualityDegradation,
}

func (e AlertType) IsValid() bool {
	switch e {
	case AlertTypeHighJitter, AlertTypeKeyframeInstability, AlertTypePacketLoss, AlertTypeRebuffering, AlertTypeQualityDegradation:
		return true
	}
	return false
}

func (e AlertType) String() string {
	return string(e)
}

func (e *AlertType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertType", str)
	}
	return nil
}

func (e AlertType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AlertType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AlertType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type BufferState string

const (
	BufferStateFull    BufferState = "FULL"
	BufferStateEmpty   BufferState = "EMPTY"
	BufferStateDry     BufferState = "DRY"
	BufferStateRecover BufferState = "RECOVER"
)

var AllBufferState = []BufferState{
	BufferStateFull,
	BufferStateEmpty,
	BufferStateDry,
	BufferStateRecover,
}

func (e BufferState) IsValid() bool {
	switch e {
	case BufferStateFull, BufferStateEmpty, BufferStateDry, BufferStateRecover:
		return true
	}
	return false
}

func (e BufferState) String() string {
	return string(e)
}

func (e *BufferState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BufferState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BufferState", str)
	}
	return nil
}

func (e BufferState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BufferState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BufferState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type InstanceStatus string

const (
	InstanceStatusRunning  InstanceStatus = "RUNNING"
	InstanceStatusStarting InstanceStatus = "STARTING"
	InstanceStatusStopping InstanceStatus = "STOPPING"
	InstanceStatusStopped  InstanceStatus = "STOPPED"
	InstanceStatusError    InstanceStatus = "ERROR"
	InstanceStatusUnknown  InstanceStatus = "UNKNOWN"
)

var AllInstanceStatus = []InstanceStatus{
	InstanceStatusRunning,
	InstanceStatusStarting,
	InstanceStatusStopping,
	InstanceStatusStopped,
	InstanceStatusError,
	InstanceStatusUnknown,
}

func (e InstanceStatus) IsValid() bool {
	switch e {
	case InstanceStatusRunning, InstanceStatusStarting, InstanceStatusStopping, InstanceStatusStopped, InstanceStatusError, InstanceStatusUnknown:
		return true
	}
	return false
}

func (e InstanceStatus) String() string {
	return string(e)
}

func (e *InstanceStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstanceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstanceStatus", str)
	}
	return nil
}

func (e InstanceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InstanceStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InstanceStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type InvoiceStatus string

const (
	InvoiceStatusPending   InvoiceStatus = "PENDING"
	InvoiceStatusPaid      InvoiceStatus = "PAID"
	InvoiceStatusFailed    InvoiceStatus = "FAILED"
	InvoiceStatusCancelled InvoiceStatus = "CANCELLED"
)

var AllInvoiceStatus = []InvoiceStatus{
	InvoiceStatusPending,
	InvoiceStatusPaid,
	InvoiceStatusFailed,
	InvoiceStatusCancelled,
}

func (e InvoiceStatus) IsValid() bool {
	switch e {
	case InvoiceStatusPending, InvoiceStatusPaid, InvoiceStatusFailed, InvoiceStatusCancelled:
		return true
	}
	return false
}

func (e InvoiceStatus) String() string {
	return string(e)
}

func (e *InvoiceStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InvoiceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InvoiceStatus", str)
	}
	return nil
}

func (e InvoiceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InvoiceStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InvoiceStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type NodeStatus string

const (
	NodeStatusHealthy   NodeStatus = "HEALTHY"
	NodeStatusDegraded  NodeStatus = "DEGRADED"
	NodeStatusUnhealthy NodeStatus = "UNHEALTHY"
)

var AllNodeStatus = []NodeStatus{
	NodeStatusHealthy,
	NodeStatusDegraded,
	NodeStatusUnhealthy,
}

func (e NodeStatus) IsValid() bool {
	switch e {
	case NodeStatusHealthy, NodeStatusDegraded, NodeStatusUnhealthy:
		return true
	}
	return false
}

func (e NodeStatus) String() string {
	return string(e)
}

func (e *NodeStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeStatus", str)
	}
	return nil
}

func (e NodeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NodeStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NodeStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PaymentMethod string

const (
	PaymentMethodCard         PaymentMethod = "CARD"
	PaymentMethodCrypto       PaymentMethod = "CRYPTO"
	PaymentMethodBankTransfer PaymentMethod = "BANK_TRANSFER"
)

var AllPaymentMethod = []PaymentMethod{
	PaymentMethodCard,
	PaymentMethodCrypto,
	PaymentMethodBankTransfer,
}

func (e PaymentMethod) IsValid() bool {
	switch e {
	case PaymentMethodCard, PaymentMethodCrypto, PaymentMethodBankTransfer:
		return true
	}
	return false
}

func (e PaymentMethod) String() string {
	return string(e)
}

func (e *PaymentMethod) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentMethod", str)
	}
	return nil
}

func (e PaymentMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PaymentMethod) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PaymentMethod) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PaymentStatus string

const (
	PaymentStatusPending   PaymentStatus = "PENDING"
	PaymentStatusConfirmed PaymentStatus = "CONFIRMED"
	PaymentStatusFailed    PaymentStatus = "FAILED"
)

var AllPaymentStatus = []PaymentStatus{
	PaymentStatusPending,
	PaymentStatusConfirmed,
	PaymentStatusFailed,
}

func (e PaymentStatus) IsValid() bool {
	switch e {
	case PaymentStatusPending, PaymentStatusConfirmed, PaymentStatusFailed:
		return true
	}
	return false
}

func (e PaymentStatus) String() string {
	return string(e)
}

func (e *PaymentStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentStatus", str)
	}
	return nil
}

func (e PaymentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PaymentStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PaymentStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type QualityChangeType string

const (
	QualityChangeTypeCodecChange      QualityChangeType = "CODEC_CHANGE"
	QualityChangeTypeResolutionChange QualityChangeType = "RESOLUTION_CHANGE"
	QualityChangeTypeBitrateChange    QualityChangeType = "BITRATE_CHANGE"
	QualityChangeTypeTrackAdded       QualityChangeType = "TRACK_ADDED"
	QualityChangeTypeTrackRemoved     QualityChangeType = "TRACK_REMOVED"
	QualityChangeTypeTrackUpdate      QualityChangeType = "TRACK_UPDATE"
)

var AllQualityChangeType = []QualityChangeType{
	QualityChangeTypeCodecChange,
	QualityChangeTypeResolutionChange,
	QualityChangeTypeBitrateChange,
	QualityChangeTypeTrackAdded,
	QualityChangeTypeTrackRemoved,
	QualityChangeTypeTrackUpdate,
}

func (e QualityChangeType) IsValid() bool {
	switch e {
	case QualityChangeTypeCodecChange, QualityChangeTypeResolutionChange, QualityChangeTypeBitrateChange, QualityChangeTypeTrackAdded, QualityChangeTypeTrackRemoved, QualityChangeTypeTrackUpdate:
		return true
	}
	return false
}

func (e QualityChangeType) String() string {
	return string(e)
}

func (e *QualityChangeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = QualityChangeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid QualityChangeType", str)
	}
	return nil
}

func (e QualityChangeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *QualityChangeType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e QualityChangeType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SortOrder string

const (
	SortOrderAsc  SortOrder = "ASC"
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SortOrder) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SortOrder) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StreamEventType string

const (
	StreamEventTypeStreamStart     StreamEventType = "STREAM_START"
	StreamEventTypeStreamEnd       StreamEventType = "STREAM_END"
	StreamEventTypeStreamError     StreamEventType = "STREAM_ERROR"
	StreamEventTypeBufferUpdate    StreamEventType = "BUFFER_UPDATE"
	StreamEventTypeTrackListUpdate StreamEventType = "TRACK_LIST_UPDATE"
)

var AllStreamEventType = []StreamEventType{
	StreamEventTypeStreamStart,
	StreamEventTypeStreamEnd,
	StreamEventTypeStreamError,
	StreamEventTypeBufferUpdate,
	StreamEventTypeTrackListUpdate,
}

func (e StreamEventType) IsValid() bool {
	switch e {
	case StreamEventTypeStreamStart, StreamEventTypeStreamEnd, StreamEventTypeStreamError, StreamEventTypeBufferUpdate, StreamEventTypeTrackListUpdate:
		return true
	}
	return false
}

func (e StreamEventType) String() string {
	return string(e)
}

func (e *StreamEventType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamEventType", str)
	}
	return nil
}

func (e StreamEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StreamEventType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StreamEventType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StreamStatus string

const (
	StreamStatusOffline   StreamStatus = "OFFLINE"
	StreamStatusLive      StreamStatus = "LIVE"
	StreamStatusRecording StreamStatus = "RECORDING"
	StreamStatusEnded     StreamStatus = "ENDED"
)

var AllStreamStatus = []StreamStatus{
	StreamStatusOffline,
	StreamStatusLive,
	StreamStatusRecording,
	StreamStatusEnded,
}

func (e StreamStatus) IsValid() bool {
	switch e {
	case StreamStatusOffline, StreamStatusLive, StreamStatusRecording, StreamStatusEnded:
		return true
	}
	return false
}

func (e StreamStatus) String() string {
	return string(e)
}

func (e *StreamStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamStatus", str)
	}
	return nil
}

func (e StreamStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StreamStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StreamStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
