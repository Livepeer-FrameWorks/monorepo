# GraphQL schema location (shared schema)
schema:
  - ../pkg/graphql/schema.graphql

# Where should the generated server code go?
exec:
  filename: graph/generated/generated.go
  package: generated

# Where should any generated models go?
model:
  filename: graph/model/models_gen.go
  package: model

# Where should the resolver implementations go?
resolver:
  layout: follow-schema
  dir: graph
  package: graph
  filename_template: "{name}.resolvers.go"

# Optional: turn on or off automatic camelCase marshaling for field names
autobind:
  - frameworks/pkg/proto

# Map GraphQL types to existing Go models (comprehensive mapping)
# NOTE: Using pb.* proto types for all analytics/streaming types
models:
  # Analytics types - bound to proto types
  StreamAnalytics:
    model:
      - frameworks/pkg/proto.StreamAnalytics
  RoutingEvent:
    model:
      - frameworks/pkg/proto.RoutingEvent
  ViewerMetric:
    model:
      - frameworks/pkg/proto.ViewerSession
  ViewerMetrics5m:
    model:
      - frameworks/pkg/proto.ViewerSession5M
  ConnectionEvent:
    model:
      - frameworks/pkg/proto.ConnectionEvent
    fields:
      connectionAddr:
        resolver: true  # Redact client IP for privacy
  StreamHealthMetric:
    model:
      - frameworks/pkg/proto.StreamHealthMetric
  ViewerCountBucket:
    model:
      - frameworks/pkg/proto.ViewerCountBucket
  CountryMetric:
    model:
      - frameworks/pkg/proto.CountryMetric
  CountryMetrics:
    model:
      - frameworks/pkg/proto.CountryMetrics
  CityMetric:
    model:
      - frameworks/pkg/proto.CityMetric
  PlatformOverview:
    model:
      - frameworks/pkg/proto.GetPlatformOverviewResponse
  ViewerGeographic:
    model:
      - frameworks/pkg/proto.ConnectionEvent
    fields:
      connectionAddr:
        resolver: true  # Redact client IP for privacy
  StreamEvent:
    model:
      - frameworks/pkg/proto.StreamEvent
  # Query types - bound to periscope.proto types (analytics API responses)
  TrackListEvent:
    model:
      - frameworks/pkg/proto.TrackListEvent
  ClipEvent:
    model:
      - frameworks/pkg/proto.ClipEvent
  ArtifactState:
    model:
      - frameworks/pkg/proto.ArtifactState
  StreamTrack:
    model:
      - frameworks/pkg/proto.StreamTrack

  # Pre-aggregated analytics types (Materialized Views)
  StreamConnectionHourly:
    model:
      - frameworks/pkg/proto.StreamConnectionHourly
  ClientMetrics5m:
    model:
      - frameworks/pkg/proto.ClientMetrics5M
  QualityTierDaily:
    model:
      - frameworks/pkg/proto.QualityTierDaily
  QualityChangesHourly:
    model:
      - frameworks/pkg/proto.QualityChangesHourly
  StorageUsageRecord:
    model:
      - frameworks/pkg/proto.StorageUsageRecord
  StreamHealth5m:
    model:
      - frameworks/pkg/proto.StreamHealth5M
  NodePerformance5m:
    model:
      - frameworks/pkg/proto.NodePerformance5M
  ViewerHoursHourly:
    model:
      - frameworks/pkg/proto.ViewerHoursHourly
  ViewerGeoHourly:
    model:
      - frameworks/pkg/proto.ViewerGeoHourly
  TenantDailyStat:
    model:
      - frameworks/pkg/proto.TenantDailyStat

  # Real-time subscription types - bound to ipc.proto types (raw Kafka events via Signalman)
  ViewerMetrics:
    model:
      - frameworks/pkg/proto.ClientLifecycleUpdate
    fields:
      host:
        resolver: true  # Redact client IP for privacy
  SystemHealthEvent:
    model:
      - frameworks/pkg/proto.NodeLifecycleUpdate
    fields:
      nodeId:
        resolver: true  # Return node_uuid (database UUID) not node_id (logical name)
  DVREvent:
    model:
      - frameworks/pkg/proto.DVRLifecycleData
  TrackListUpdate:
    model:
      - frameworks/pkg/proto.StreamTrackListTrigger
  ClipLifecycle:
    model:
      - frameworks/pkg/proto.ClipLifecycleData

  # Real-time stream subscription types - direct proto passthrough
  # StreamLifecycleUpdate is now available via Signalman (added to EventData oneof)
  StreamLifecycleUpdate:
    model:
      - frameworks/pkg/proto.StreamLifecycleUpdate
    fields:
      # Security: Don't expose internal identifiers
      tenantId:
        resolver: true  # Return nil - internal only
  StreamEndEvent:
    model:
      - frameworks/pkg/proto.StreamEndTrigger
  StreamBufferEvent:
    model:
      - frameworks/pkg/proto.StreamBufferTrigger
  VodLifecycle:
    model:
      - frameworks/pkg/proto.VodLifecycleData
    fields:
      # Security: Don't expose internal identifiers
      tenantId:
        resolver: true  # Return nil - internal only
      userId:
        resolver: true  # Return nil - internal only

  # Stream management types - bound to proto types
  Stream:
    model:
      - frameworks/pkg/proto.Stream
  StreamMetrics:
    model:
      - frameworks/pkg/proto.StreamStatusResponse
  StreamKey:
    model:
      - frameworks/pkg/proto.StreamKey
  Recording:
    model:
      - frameworks/pkg/proto.Recording
  Clip:
    model:
      - frameworks/pkg/proto.ClipInfo
    fields:
      # Lifecycle fields resolved from Periscope (batch lookup by clipHash)
      status:
        resolver: true
      sizeBytes:
        resolver: true
      storageLocation:
        resolver: true
      nodeId:
        resolver: true
      storagePath:
        resolver: true
      accessCount:
        resolver: true
  ClipViewingUrls:
    model:
      - frameworks/pkg/proto.ClipViewingURLs
  DVRRequest:
    model:
      - frameworks/pkg/proto.DVRInfo
    fields:
      # Lifecycle fields resolved from Periscope (batch lookup by dvrHash)
      status:
        resolver: true
      sizeBytes:
        resolver: true
      storageLocation:
        resolver: true
      storageNodeId:
        resolver: true
      manifestPath:
        resolver: true
      startedAt:
        resolver: true
      endedAt:
        resolver: true
      durationSeconds:
        resolver: true
      errorMessage:
        resolver: true
      s3Url:
        resolver: true
      frozenAt:
        resolver: true

  # VOD upload types - generated by gqlgen (not bound to proto)
  # Because VodAsset/VodUploadSession are used in unions, they need marker interface methods
  # which proto types don't have. Let gqlgen generate them and convert in resolvers.

  # Viewer endpoint resolution types - bound to proto types
  ViewerEndpointResponse:
    model:
      - frameworks/pkg/proto.ViewerEndpointResponse
  ViewerEndpoint:
    model:
      - frameworks/pkg/proto.ViewerEndpoint
  PlaybackMetadata:
    model:
      - frameworks/pkg/proto.PlaybackMetadata
  PlaybackTrack:
    model:
      - frameworks/pkg/proto.PlaybackTrack
  PlaybackInstance:
    model:
      - frameworks/pkg/proto.PlaybackInstance

  # Stream meta types - bound to proto types
  StreamMetaResponse:
    model:
      - frameworks/pkg/proto.StreamMetaResponse
  MetaSummary:
    model:
      - frameworks/pkg/proto.MetaSummary
  TrackSummary:
    model:
      - frameworks/pkg/proto.TrackSummary

  # Billing types - bound to proto types
  BillingStatus:
    model:
      - frameworks/pkg/proto.BillingStatusResponse
  BillingTier:
    model:
      - frameworks/pkg/proto.BillingTier
  BillingFeatures:
    model:
      - frameworks/pkg/proto.BillingFeatures
  AllocationDetails:
    model:
      - frameworks/pkg/proto.AllocationDetails
  OverageRates:
    model:
      - frameworks/pkg/proto.OverageRates
  Invoice:
    model:
      - frameworks/pkg/proto.Invoice
  Payment:
    model:
      - frameworks/pkg/proto.PaymentResponse
  UsageRecord:
    model:
      - frameworks/pkg/proto.UsageRecord
  UsageSummary:
    model:
      - frameworks/pkg/proto.UsageSummary
  # TenantUsage, UsageEntry, CostEntry remain as model types
  # because proto.TenantUsageResponse uses map<string, double>
  # which doesn't map directly to GraphQL arrays

  # Infrastructure types - bound to proto types
  ServiceInstance:
    model:
      - frameworks/pkg/proto.ServiceInstance
  ServiceInstanceHealth:
    model:
      - frameworks/pkg/proto.ServiceInstanceHealth
  NodeMetric:
    model:
      - frameworks/pkg/proto.NodeMetric
  TimeRange:
    model:
      - frameworks/pkg/proto.TimeRange
  Cluster:
    model:
      - frameworks/pkg/proto.InfrastructureCluster
  Node:
    model:
      - frameworks/pkg/proto.InfrastructureNode

  # Cluster Marketplace types - bound to proto types
  MarketplaceCluster:
    model:
      - frameworks/pkg/proto.MarketplaceClusterEntry
  ClusterSubscription:
    model:
      - frameworks/pkg/proto.ClusterSubscription
  ClusterInvite:
    model:
      - frameworks/pkg/proto.ClusterInvite

  # Tenant types - bound to proto types
  Tenant:
    model:
      - frameworks/pkg/proto.Tenant
  User:
    model:
      - frameworks/pkg/proto.User
  DeveloperToken:
    model:
      - frameworks/pkg/proto.APITokenInfo
  BootstrapToken:
    model:
      - frameworks/pkg/proto.BootstrapToken

  Money:
    model:
      - github.com/99designs/gqlgen/graphql.Float
  Currency:
    model:
      - github.com/99designs/gqlgen/graphql.String

  # Cluster marketplace enums - bound to proto types
  ClusterVisibility:
    model:
      - frameworks/pkg/proto.ClusterVisibility
  ClusterPricingModel:
    model:
      - frameworks/pkg/proto.ClusterPricingModel
  ClusterSubscriptionStatus:
    model:
      - frameworks/pkg/proto.ClusterSubscriptionStatus


# Skip generation for these types (we'll implement them manually)
skip_validation: true
