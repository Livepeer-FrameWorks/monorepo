// Code generated by manual extension. DO NOT EDIT.
// This file adds GraphQL union interface markers and enum marshaling to proto types.

package proto

import (
	"fmt"
	"io"
	"strconv"
)

// Stream implements union interfaces
func (*Stream) IsCreateStreamResult() {}
func (*Stream) IsUpdateStreamResult() {}

// ClipInfo (from shared.proto) implements union interfaces (GraphQL type: Clip)
func (*ClipInfo) IsCreateClipResult() {}

// StreamKey implements union interfaces
func (*StreamKey) IsCreateStreamKeyResult() {}

// PaymentResponse implements union interfaces (GraphQL type: Payment)
func (*PaymentResponse) IsCreatePaymentResult() {}

// Tenant implements union interfaces
func (*Tenant) IsUpdateTenantResult() {}

// APITokenInfo implements union interfaces (GraphQL type: DeveloperToken)
func (*APITokenInfo) IsCreateDeveloperTokenResult() {}

// BootstrapToken implements union interfaces
func (*BootstrapToken) IsCreateBootstrapTokenResult() {}

// DVRInfo (from shared.proto) implements union interfaces (GraphQL type: DVRRequest)
func (*DVRInfo) IsStartDVRResult() {}

// Cluster Marketplace union interface implementations

// CreatePrivateClusterResponse implements union interfaces
func (*CreatePrivateClusterResponse) IsCreatePrivateClusterResult() {}

// InfrastructureCluster (GraphQL type: Cluster) implements union interfaces
func (*InfrastructureCluster) IsUpdateClusterResult() {}

// ClusterInvite implements union interfaces
func (*ClusterInvite) IsCreateClusterInviteResult() {}

// ClusterSubscription implements union interfaces
func (*ClusterSubscription) IsClusterSubscriptionResult() {}

// ============================================================================
// GraphQL ENUM MARSHALING
// ============================================================================

// MarshalGQL implements the graphql.Marshaler interface for ClusterVisibility
func (e ClusterVisibility) MarshalGQL(w io.Writer) {
	var s string
	switch e {
	case ClusterVisibility_CLUSTER_VISIBILITY_PUBLIC:
		s = "PUBLIC"
	case ClusterVisibility_CLUSTER_VISIBILITY_UNLISTED:
		s = "UNLISTED"
	case ClusterVisibility_CLUSTER_VISIBILITY_PRIVATE:
		s = "PRIVATE"
	default:
		s = "PRIVATE"
	}
	io.WriteString(w, strconv.Quote(s))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for ClusterVisibility
func (e *ClusterVisibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}
	switch str {
	case "PUBLIC":
		*e = ClusterVisibility_CLUSTER_VISIBILITY_PUBLIC
	case "UNLISTED":
		*e = ClusterVisibility_CLUSTER_VISIBILITY_UNLISTED
	case "PRIVATE":
		*e = ClusterVisibility_CLUSTER_VISIBILITY_PRIVATE
	default:
		return fmt.Errorf("%s is not a valid ClusterVisibility", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for ClusterPricingModel
func (e ClusterPricingModel) MarshalGQL(w io.Writer) {
	var s string
	switch e {
	case ClusterPricingModel_CLUSTER_PRICING_FREE_UNMETERED:
		s = "FREE_UNMETERED"
	case ClusterPricingModel_CLUSTER_PRICING_METERED:
		s = "METERED"
	case ClusterPricingModel_CLUSTER_PRICING_MONTHLY:
		s = "MONTHLY"
	case ClusterPricingModel_CLUSTER_PRICING_TIER_INHERIT:
		s = "TIER_INHERIT"
	case ClusterPricingModel_CLUSTER_PRICING_CUSTOM:
		s = "CUSTOM"
	default:
		s = "TIER_INHERIT"
	}
	io.WriteString(w, strconv.Quote(s))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for ClusterPricingModel
func (e *ClusterPricingModel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}
	switch str {
	case "FREE_UNMETERED":
		*e = ClusterPricingModel_CLUSTER_PRICING_FREE_UNMETERED
	case "METERED":
		*e = ClusterPricingModel_CLUSTER_PRICING_METERED
	case "MONTHLY":
		*e = ClusterPricingModel_CLUSTER_PRICING_MONTHLY
	case "TIER_INHERIT":
		*e = ClusterPricingModel_CLUSTER_PRICING_TIER_INHERIT
	case "CUSTOM":
		*e = ClusterPricingModel_CLUSTER_PRICING_CUSTOM
	default:
		return fmt.Errorf("%s is not a valid ClusterPricingModel", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for ClusterSubscriptionStatus
func (e ClusterSubscriptionStatus) MarshalGQL(w io.Writer) {
	var s string
	switch e {
	case ClusterSubscriptionStatus_SUBSCRIPTION_STATUS_PENDING_APPROVAL:
		s = "PENDING_APPROVAL"
	case ClusterSubscriptionStatus_SUBSCRIPTION_STATUS_ACTIVE:
		s = "ACTIVE"
	case ClusterSubscriptionStatus_SUBSCRIPTION_STATUS_SUSPENDED:
		s = "SUSPENDED"
	case ClusterSubscriptionStatus_SUBSCRIPTION_STATUS_REJECTED:
		s = "REJECTED"
	default:
		s = "PENDING_APPROVAL"
	}
	io.WriteString(w, strconv.Quote(s))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for ClusterSubscriptionStatus
func (e *ClusterSubscriptionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}
	switch str {
	case "PENDING_APPROVAL":
		*e = ClusterSubscriptionStatus_SUBSCRIPTION_STATUS_PENDING_APPROVAL
	case "ACTIVE":
		*e = ClusterSubscriptionStatus_SUBSCRIPTION_STATUS_ACTIVE
	case "SUSPENDED":
		*e = ClusterSubscriptionStatus_SUBSCRIPTION_STATUS_SUSPENDED
	case "REJECTED":
		*e = ClusterSubscriptionStatus_SUBSCRIPTION_STATUS_REJECTED
	default:
		return fmt.Errorf("%s is not a valid ClusterSubscriptionStatus", str)
	}
	return nil
}

// ============================================================================
// MESSAGING ENUM MARSHALING
// ============================================================================

// MarshalGQL implements the graphql.Marshaler interface for ConversationStatus
func (e ConversationStatus) MarshalGQL(w io.Writer) {
	var s string
	switch e {
	case ConversationStatus_CONVERSATION_STATUS_OPEN:
		s = "OPEN"
	case ConversationStatus_CONVERSATION_STATUS_RESOLVED:
		s = "RESOLVED"
	case ConversationStatus_CONVERSATION_STATUS_PENDING:
		s = "PENDING"
	default:
		s = "OPEN"
	}
	io.WriteString(w, strconv.Quote(s))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for ConversationStatus
func (e *ConversationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}
	switch str {
	case "OPEN":
		*e = ConversationStatus_CONVERSATION_STATUS_OPEN
	case "RESOLVED":
		*e = ConversationStatus_CONVERSATION_STATUS_RESOLVED
	case "PENDING":
		*e = ConversationStatus_CONVERSATION_STATUS_PENDING
	default:
		return fmt.Errorf("%s is not a valid ConversationStatus", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for MessageSender
func (e MessageSender) MarshalGQL(w io.Writer) {
	var s string
	switch e {
	case MessageSender_MESSAGE_SENDER_USER:
		s = "USER"
	case MessageSender_MESSAGE_SENDER_AGENT:
		s = "AGENT"
	case MessageSender_MESSAGE_SENDER_SYSTEM:
		s = "SYSTEM"
	default:
		s = "USER"
	}
	io.WriteString(w, strconv.Quote(s))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for MessageSender
func (e *MessageSender) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}
	switch str {
	case "USER":
		*e = MessageSender_MESSAGE_SENDER_USER
	case "AGENT":
		*e = MessageSender_MESSAGE_SENDER_AGENT
	case "SYSTEM":
		*e = MessageSender_MESSAGE_SENDER_SYSTEM
	default:
		return fmt.Errorf("%s is not a valid MessageSender", str)
	}
	return nil
}

// ============================================================================
// CRYPTO ASSET ENUM MARSHALING
// ============================================================================

// MarshalGQL implements the graphql.Marshaler interface for CryptoAsset
func (e CryptoAsset) MarshalGQL(w io.Writer) {
	var s string
	switch e {
	case CryptoAsset_CRYPTO_ASSET_ETH:
		s = "ETH"
	case CryptoAsset_CRYPTO_ASSET_USDC:
		s = "USDC"
	case CryptoAsset_CRYPTO_ASSET_LPT:
		s = "LPT"
	default:
		s = "ETH"
	}
	io.WriteString(w, strconv.Quote(s))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for CryptoAsset
func (e *CryptoAsset) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}
	switch str {
	case "ETH":
		*e = CryptoAsset_CRYPTO_ASSET_ETH
	case "USDC":
		*e = CryptoAsset_CRYPTO_ASSET_USDC
	case "LPT":
		*e = CryptoAsset_CRYPTO_ASSET_LPT
	default:
		return fmt.Errorf("%s is not a valid CryptoAsset", str)
	}
	return nil
}
