// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.4
// source: foghorn_federation.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type QueryStreamRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	StreamName        string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`                         // Internal stream name to look up
	ViewerLat         float64                `protobuf:"fixed64,2,opt,name=viewer_lat,json=viewerLat,proto3" json:"viewer_lat,omitempty"`                          // Viewer latitude for remote geo-scoring
	ViewerLon         float64                `protobuf:"fixed64,3,opt,name=viewer_lon,json=viewerLon,proto3" json:"viewer_lon,omitempty"`                          // Viewer longitude for remote geo-scoring
	RequestingCluster string                 `protobuf:"bytes,4,opt,name=requesting_cluster,json=requestingCluster,proto3" json:"requesting_cluster,omitempty"`    // Cluster ID of the requester (prevents loops)
	TenantId          string                 `protobuf:"bytes,5,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`                               // For shared-lb: filter edges by tenant
	IsSourceSelection bool                   `protobuf:"varint,6,opt,name=is_source_selection,json=isSourceSelection,proto3" json:"is_source_selection,omitempty"` // True = source selection (only origin nodes with active inputs)
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QueryStreamRequest) Reset() {
	*x = QueryStreamRequest{}
	mi := &file_foghorn_federation_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryStreamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryStreamRequest) ProtoMessage() {}

func (x *QueryStreamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryStreamRequest.ProtoReflect.Descriptor instead.
func (*QueryStreamRequest) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{0}
}

func (x *QueryStreamRequest) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *QueryStreamRequest) GetViewerLat() float64 {
	if x != nil {
		return x.ViewerLat
	}
	return 0
}

func (x *QueryStreamRequest) GetViewerLon() float64 {
	if x != nil {
		return x.ViewerLon
	}
	return 0
}

func (x *QueryStreamRequest) GetRequestingCluster() string {
	if x != nil {
		return x.RequestingCluster
	}
	return ""
}

func (x *QueryStreamRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *QueryStreamRequest) GetIsSourceSelection() bool {
	if x != nil {
		return x.IsSourceSelection
	}
	return false
}

type QueryStreamResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Candidates      []*EdgeCandidate       `protobuf:"bytes,1,rep,name=candidates,proto3" json:"candidates,omitempty"`
	OriginClusterId string                 `protobuf:"bytes,2,opt,name=origin_cluster_id,json=originClusterId,proto3" json:"origin_cluster_id,omitempty"` // Cluster where this stream ingests
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *QueryStreamResponse) Reset() {
	*x = QueryStreamResponse{}
	mi := &file_foghorn_federation_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryStreamResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryStreamResponse) ProtoMessage() {}

func (x *QueryStreamResponse) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryStreamResponse.ProtoReflect.Descriptor instead.
func (*QueryStreamResponse) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{1}
}

func (x *QueryStreamResponse) GetCandidates() []*EdgeCandidate {
	if x != nil {
		return x.Candidates
	}
	return nil
}

func (x *QueryStreamResponse) GetOriginClusterId() string {
	if x != nil {
		return x.OriginClusterId
	}
	return ""
}

type EdgeCandidate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	BaseUrl       string                 `protobuf:"bytes,2,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`             // Public HTTPS URL of the edge node
	DtscUrl       string                 `protobuf:"bytes,3,opt,name=dtsc_url,json=dtscUrl,proto3" json:"dtsc_url,omitempty"`             // DTSC pull URL for origin-pull replication
	BwScore       uint64                 `protobuf:"varint,4,opt,name=bw_score,json=bwScore,proto3" json:"bw_score,omitempty"`            // Pre-computed bandwidth score
	GeoScore      uint64                 `protobuf:"varint,5,opt,name=geo_score,json=geoScore,proto3" json:"geo_score,omitempty"`         // Pre-computed geo score relative to viewer
	IsOrigin      bool                   `protobuf:"varint,6,opt,name=is_origin,json=isOrigin,proto3" json:"is_origin,omitempty"`         // True if this node has the original ingest
	BufferState   string                 `protobuf:"bytes,7,opt,name=buffer_state,json=bufferState,proto3" json:"buffer_state,omitempty"` // FULL, DRY, RECOVER, etc.
	GeoLat        float64                `protobuf:"fixed64,8,opt,name=geo_lat,json=geoLat,proto3" json:"geo_lat,omitempty"`
	GeoLon        float64                `protobuf:"fixed64,9,opt,name=geo_lon,json=geoLon,proto3" json:"geo_lon,omitempty"`
	ViewerCount   uint32                 `protobuf:"varint,10,opt,name=viewer_count,json=viewerCount,proto3" json:"viewer_count,omitempty"`
	CpuPercent    float64                `protobuf:"fixed64,11,opt,name=cpu_percent,json=cpuPercent,proto3" json:"cpu_percent,omitempty"`
	BwAvailable   uint64                 `protobuf:"varint,12,opt,name=bw_available,json=bwAvailable,proto3" json:"bw_available,omitempty"` // Available bandwidth in bytes/sec
	RamUsed       uint64                 `protobuf:"varint,13,opt,name=ram_used,json=ramUsed,proto3" json:"ram_used,omitempty"`
	RamMax        uint64                 `protobuf:"varint,14,opt,name=ram_max,json=ramMax,proto3" json:"ram_max,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EdgeCandidate) Reset() {
	*x = EdgeCandidate{}
	mi := &file_foghorn_federation_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EdgeCandidate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EdgeCandidate) ProtoMessage() {}

func (x *EdgeCandidate) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EdgeCandidate.ProtoReflect.Descriptor instead.
func (*EdgeCandidate) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{2}
}

func (x *EdgeCandidate) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *EdgeCandidate) GetBaseUrl() string {
	if x != nil {
		return x.BaseUrl
	}
	return ""
}

func (x *EdgeCandidate) GetDtscUrl() string {
	if x != nil {
		return x.DtscUrl
	}
	return ""
}

func (x *EdgeCandidate) GetBwScore() uint64 {
	if x != nil {
		return x.BwScore
	}
	return 0
}

func (x *EdgeCandidate) GetGeoScore() uint64 {
	if x != nil {
		return x.GeoScore
	}
	return 0
}

func (x *EdgeCandidate) GetIsOrigin() bool {
	if x != nil {
		return x.IsOrigin
	}
	return false
}

func (x *EdgeCandidate) GetBufferState() string {
	if x != nil {
		return x.BufferState
	}
	return ""
}

func (x *EdgeCandidate) GetGeoLat() float64 {
	if x != nil {
		return x.GeoLat
	}
	return 0
}

func (x *EdgeCandidate) GetGeoLon() float64 {
	if x != nil {
		return x.GeoLon
	}
	return 0
}

func (x *EdgeCandidate) GetViewerCount() uint32 {
	if x != nil {
		return x.ViewerCount
	}
	return 0
}

func (x *EdgeCandidate) GetCpuPercent() float64 {
	if x != nil {
		return x.CpuPercent
	}
	return 0
}

func (x *EdgeCandidate) GetBwAvailable() uint64 {
	if x != nil {
		return x.BwAvailable
	}
	return 0
}

func (x *EdgeCandidate) GetRamUsed() uint64 {
	if x != nil {
		return x.RamUsed
	}
	return 0
}

func (x *EdgeCandidate) GetRamMax() uint64 {
	if x != nil {
		return x.RamMax
	}
	return 0
}

type OriginPullNotification struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StreamName    string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	SourceNodeId  string                 `protobuf:"bytes,2,opt,name=source_node_id,json=sourceNodeId,proto3" json:"source_node_id,omitempty"`    // Preferred source edge (or empty for auto-select)
	DestClusterId string                 `protobuf:"bytes,3,opt,name=dest_cluster_id,json=destClusterId,proto3" json:"dest_cluster_id,omitempty"` // Cluster that will pull the stream
	DestNodeId    string                 `protobuf:"bytes,4,opt,name=dest_node_id,json=destNodeId,proto3" json:"dest_node_id,omitempty"`          // Edge node in dest cluster that will pull
	EstViewers    uint32                 `protobuf:"varint,5,opt,name=est_viewers,json=estViewers,proto3" json:"est_viewers,omitempty"`           // Estimated viewer count driving this pull
	TenantId      string                 `protobuf:"bytes,6,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`                  // Stream owner tenant
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OriginPullNotification) Reset() {
	*x = OriginPullNotification{}
	mi := &file_foghorn_federation_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OriginPullNotification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OriginPullNotification) ProtoMessage() {}

func (x *OriginPullNotification) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OriginPullNotification.ProtoReflect.Descriptor instead.
func (*OriginPullNotification) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{3}
}

func (x *OriginPullNotification) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *OriginPullNotification) GetSourceNodeId() string {
	if x != nil {
		return x.SourceNodeId
	}
	return ""
}

func (x *OriginPullNotification) GetDestClusterId() string {
	if x != nil {
		return x.DestClusterId
	}
	return ""
}

func (x *OriginPullNotification) GetDestNodeId() string {
	if x != nil {
		return x.DestNodeId
	}
	return ""
}

func (x *OriginPullNotification) GetEstViewers() uint32 {
	if x != nil {
		return x.EstViewers
	}
	return 0
}

func (x *OriginPullNotification) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

type OriginPullAck struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Accepted      bool                   `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`
	Reason        string                 `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`                  // Rejection reason or informational message
	DtscUrl       string                 `protobuf:"bytes,3,opt,name=dtsc_url,json=dtscUrl,proto3" json:"dtsc_url,omitempty"` // DTSC URL to pull from (set when accepted)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OriginPullAck) Reset() {
	*x = OriginPullAck{}
	mi := &file_foghorn_federation_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OriginPullAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OriginPullAck) ProtoMessage() {}

func (x *OriginPullAck) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OriginPullAck.ProtoReflect.Descriptor instead.
func (*OriginPullAck) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{4}
}

func (x *OriginPullAck) GetAccepted() bool {
	if x != nil {
		return x.Accepted
	}
	return false
}

func (x *OriginPullAck) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *OriginPullAck) GetDtscUrl() string {
	if x != nil {
		return x.DtscUrl
	}
	return ""
}

type PrepareArtifactRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	ArtifactId        string                 `protobuf:"bytes,1,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"` // Artifact hash (clip/dvr/vod)
	ClipHash          string                 `protobuf:"bytes,2,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`       // Legacy: clip hash alias
	RequestingCluster string                 `protobuf:"bytes,3,opt,name=requesting_cluster,json=requestingCluster,proto3" json:"requesting_cluster,omitempty"`
	ArtifactType      string                 `protobuf:"bytes,4,opt,name=artifact_type,json=artifactType,proto3" json:"artifact_type,omitempty"` // "clip", "dvr", "vod"
	TenantId          string                 `protobuf:"bytes,5,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *PrepareArtifactRequest) Reset() {
	*x = PrepareArtifactRequest{}
	mi := &file_foghorn_federation_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareArtifactRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareArtifactRequest) ProtoMessage() {}

func (x *PrepareArtifactRequest) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareArtifactRequest.ProtoReflect.Descriptor instead.
func (*PrepareArtifactRequest) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{5}
}

func (x *PrepareArtifactRequest) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

func (x *PrepareArtifactRequest) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *PrepareArtifactRequest) GetRequestingCluster() string {
	if x != nil {
		return x.RequestingCluster
	}
	return ""
}

func (x *PrepareArtifactRequest) GetArtifactType() string {
	if x != nil {
		return x.ArtifactType
	}
	return ""
}

func (x *PrepareArtifactRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

type PrepareArtifactResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Url             string                 `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"` // Presigned S3 GET URL (clip/vod single file)
	SizeBytes       uint64                 `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Ready           bool                   `protobuf:"varint,3,opt,name=ready,proto3" json:"ready,omitempty"`                                              // True if artifact is immediately available
	EstReadySeconds uint32                 `protobuf:"varint,4,opt,name=est_ready_seconds,json=estReadySeconds,proto3" json:"est_ready_seconds,omitempty"` // Estimated time until ready (for async prep)
	Error           string                 `protobuf:"bytes,5,opt,name=error,proto3" json:"error,omitempty"`
	SegmentUrls     map[string]string      `protobuf:"bytes,6,rep,name=segment_urls,json=segmentUrls,proto3" json:"segment_urls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // DVR: segment filename -> presigned GET URL
	Format          string                 `protobuf:"bytes,7,opt,name=format,proto3" json:"format,omitempty"`                                                                                                        // Container format (mp4, m3u8, etc.)
	InternalName    string                 `protobuf:"bytes,8,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`                                                                        // Stream internal name for routing
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PrepareArtifactResponse) Reset() {
	*x = PrepareArtifactResponse{}
	mi := &file_foghorn_federation_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareArtifactResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareArtifactResponse) ProtoMessage() {}

func (x *PrepareArtifactResponse) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareArtifactResponse.ProtoReflect.Descriptor instead.
func (*PrepareArtifactResponse) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{6}
}

func (x *PrepareArtifactResponse) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *PrepareArtifactResponse) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *PrepareArtifactResponse) GetReady() bool {
	if x != nil {
		return x.Ready
	}
	return false
}

func (x *PrepareArtifactResponse) GetEstReadySeconds() uint32 {
	if x != nil {
		return x.EstReadySeconds
	}
	return 0
}

func (x *PrepareArtifactResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *PrepareArtifactResponse) GetSegmentUrls() map[string]string {
	if x != nil {
		return x.SegmentUrls
	}
	return nil
}

func (x *PrepareArtifactResponse) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *PrepareArtifactResponse) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

type RemoteClipRequest struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	InternalName         string                 `protobuf:"bytes,1,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`
	TenantId             string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	UserId               string                 `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ClipHash             string                 `protobuf:"bytes,4,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`
	ArtifactInternalName string                 `protobuf:"bytes,5,opt,name=artifact_internal_name,json=artifactInternalName,proto3" json:"artifact_internal_name,omitempty"`
	PlaybackId           string                 `protobuf:"bytes,6,opt,name=playback_id,json=playbackId,proto3" json:"playback_id,omitempty"`
	Format               string                 `protobuf:"bytes,7,opt,name=format,proto3" json:"format,omitempty"`
	StartUnix            int64                  `protobuf:"varint,8,opt,name=start_unix,json=startUnix,proto3" json:"start_unix,omitempty"`
	StopUnix             int64                  `protobuf:"varint,9,opt,name=stop_unix,json=stopUnix,proto3" json:"stop_unix,omitempty"`
	StartMs              int64                  `protobuf:"varint,10,opt,name=start_ms,json=startMs,proto3" json:"start_ms,omitempty"`
	StopMs               int64                  `protobuf:"varint,11,opt,name=stop_ms,json=stopMs,proto3" json:"stop_ms,omitempty"`
	DurationSec          int64                  `protobuf:"varint,12,opt,name=duration_sec,json=durationSec,proto3" json:"duration_sec,omitempty"`
	RequestingCluster    string                 `protobuf:"bytes,13,opt,name=requesting_cluster,json=requestingCluster,proto3" json:"requesting_cluster,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *RemoteClipRequest) Reset() {
	*x = RemoteClipRequest{}
	mi := &file_foghorn_federation_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoteClipRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteClipRequest) ProtoMessage() {}

func (x *RemoteClipRequest) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoteClipRequest.ProtoReflect.Descriptor instead.
func (*RemoteClipRequest) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{7}
}

func (x *RemoteClipRequest) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *RemoteClipRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *RemoteClipRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *RemoteClipRequest) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *RemoteClipRequest) GetArtifactInternalName() string {
	if x != nil {
		return x.ArtifactInternalName
	}
	return ""
}

func (x *RemoteClipRequest) GetPlaybackId() string {
	if x != nil {
		return x.PlaybackId
	}
	return ""
}

func (x *RemoteClipRequest) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *RemoteClipRequest) GetStartUnix() int64 {
	if x != nil {
		return x.StartUnix
	}
	return 0
}

func (x *RemoteClipRequest) GetStopUnix() int64 {
	if x != nil {
		return x.StopUnix
	}
	return 0
}

func (x *RemoteClipRequest) GetStartMs() int64 {
	if x != nil {
		return x.StartMs
	}
	return 0
}

func (x *RemoteClipRequest) GetStopMs() int64 {
	if x != nil {
		return x.StopMs
	}
	return 0
}

func (x *RemoteClipRequest) GetDurationSec() int64 {
	if x != nil {
		return x.DurationSec
	}
	return 0
}

func (x *RemoteClipRequest) GetRequestingCluster() string {
	if x != nil {
		return x.RequestingCluster
	}
	return ""
}

type RemoteClipResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Accepted      bool                   `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`
	Reason        string                 `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	ClipHash      string                 `protobuf:"bytes,3,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`
	StorageNodeId string                 `protobuf:"bytes,4,opt,name=storage_node_id,json=storageNodeId,proto3" json:"storage_node_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoteClipResponse) Reset() {
	*x = RemoteClipResponse{}
	mi := &file_foghorn_federation_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoteClipResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteClipResponse) ProtoMessage() {}

func (x *RemoteClipResponse) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoteClipResponse.ProtoReflect.Descriptor instead.
func (*RemoteClipResponse) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{8}
}

func (x *RemoteClipResponse) GetAccepted() bool {
	if x != nil {
		return x.Accepted
	}
	return false
}

func (x *RemoteClipResponse) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *RemoteClipResponse) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *RemoteClipResponse) GetStorageNodeId() string {
	if x != nil {
		return x.StorageNodeId
	}
	return ""
}

type RemoteDVRRequest struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	InternalName         string                 `protobuf:"bytes,1,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`
	TenantId             string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	UserId               string                 `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	DvrHash              string                 `protobuf:"bytes,4,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`
	ArtifactInternalName string                 `protobuf:"bytes,5,opt,name=artifact_internal_name,json=artifactInternalName,proto3" json:"artifact_internal_name,omitempty"`
	PlaybackId           string                 `protobuf:"bytes,6,opt,name=playback_id,json=playbackId,proto3" json:"playback_id,omitempty"`
	RequestingCluster    string                 `protobuf:"bytes,7,opt,name=requesting_cluster,json=requestingCluster,proto3" json:"requesting_cluster,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *RemoteDVRRequest) Reset() {
	*x = RemoteDVRRequest{}
	mi := &file_foghorn_federation_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoteDVRRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteDVRRequest) ProtoMessage() {}

func (x *RemoteDVRRequest) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoteDVRRequest.ProtoReflect.Descriptor instead.
func (*RemoteDVRRequest) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{9}
}

func (x *RemoteDVRRequest) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *RemoteDVRRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *RemoteDVRRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *RemoteDVRRequest) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *RemoteDVRRequest) GetArtifactInternalName() string {
	if x != nil {
		return x.ArtifactInternalName
	}
	return ""
}

func (x *RemoteDVRRequest) GetPlaybackId() string {
	if x != nil {
		return x.PlaybackId
	}
	return ""
}

func (x *RemoteDVRRequest) GetRequestingCluster() string {
	if x != nil {
		return x.RequestingCluster
	}
	return ""
}

type RemoteDVRResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Accepted      bool                   `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`
	Reason        string                 `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	DvrHash       string                 `protobuf:"bytes,3,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoteDVRResponse) Reset() {
	*x = RemoteDVRResponse{}
	mi := &file_foghorn_federation_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoteDVRResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteDVRResponse) ProtoMessage() {}

func (x *RemoteDVRResponse) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoteDVRResponse.ProtoReflect.Descriptor instead.
func (*RemoteDVRResponse) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{10}
}

func (x *RemoteDVRResponse) GetAccepted() bool {
	if x != nil {
		return x.Accepted
	}
	return false
}

func (x *RemoteDVRResponse) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *RemoteDVRResponse) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

// PeerMessage wraps all bidirectional stream payloads.
// New payload types can be added to the oneof without breaking existing peers.
type PeerMessage struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	ClusterId string                 `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Types that are valid to be assigned to Payload:
	//
	//	*PeerMessage_EdgeTelemetry
	//	*PeerMessage_ReplicationEvent
	//	*PeerMessage_ClusterSummary
	//	*PeerMessage_StreamLifecycle
	//	*PeerMessage_StreamAd
	//	*PeerMessage_ArtifactAd
	//	*PeerMessage_PeerHeartbeat
	//	*PeerMessage_CapacitySummary
	Payload       isPeerMessage_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PeerMessage) Reset() {
	*x = PeerMessage{}
	mi := &file_foghorn_federation_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PeerMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PeerMessage) ProtoMessage() {}

func (x *PeerMessage) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PeerMessage.ProtoReflect.Descriptor instead.
func (*PeerMessage) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{11}
}

func (x *PeerMessage) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *PeerMessage) GetPayload() isPeerMessage_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *PeerMessage) GetEdgeTelemetry() *EdgeTelemetry {
	if x != nil {
		if x, ok := x.Payload.(*PeerMessage_EdgeTelemetry); ok {
			return x.EdgeTelemetry
		}
	}
	return nil
}

func (x *PeerMessage) GetReplicationEvent() *ReplicationEvent {
	if x != nil {
		if x, ok := x.Payload.(*PeerMessage_ReplicationEvent); ok {
			return x.ReplicationEvent
		}
	}
	return nil
}

func (x *PeerMessage) GetClusterSummary() *ClusterEdgeSummary {
	if x != nil {
		if x, ok := x.Payload.(*PeerMessage_ClusterSummary); ok {
			return x.ClusterSummary
		}
	}
	return nil
}

func (x *PeerMessage) GetStreamLifecycle() *StreamLifecycleEvent {
	if x != nil {
		if x, ok := x.Payload.(*PeerMessage_StreamLifecycle); ok {
			return x.StreamLifecycle
		}
	}
	return nil
}

func (x *PeerMessage) GetStreamAd() *StreamAdvertisement {
	if x != nil {
		if x, ok := x.Payload.(*PeerMessage_StreamAd); ok {
			return x.StreamAd
		}
	}
	return nil
}

func (x *PeerMessage) GetArtifactAd() *ArtifactAdvertisement {
	if x != nil {
		if x, ok := x.Payload.(*PeerMessage_ArtifactAd); ok {
			return x.ArtifactAd
		}
	}
	return nil
}

func (x *PeerMessage) GetPeerHeartbeat() *PeerHeartbeat {
	if x != nil {
		if x, ok := x.Payload.(*PeerMessage_PeerHeartbeat); ok {
			return x.PeerHeartbeat
		}
	}
	return nil
}

func (x *PeerMessage) GetCapacitySummary() *CapacitySummary {
	if x != nil {
		if x, ok := x.Payload.(*PeerMessage_CapacitySummary); ok {
			return x.CapacitySummary
		}
	}
	return nil
}

type isPeerMessage_Payload interface {
	isPeerMessage_Payload()
}

type PeerMessage_EdgeTelemetry struct {
	EdgeTelemetry *EdgeTelemetry `protobuf:"bytes,2,opt,name=edge_telemetry,json=edgeTelemetry,proto3,oneof"`
}

type PeerMessage_ReplicationEvent struct {
	ReplicationEvent *ReplicationEvent `protobuf:"bytes,3,opt,name=replication_event,json=replicationEvent,proto3,oneof"`
}

type PeerMessage_ClusterSummary struct {
	ClusterSummary *ClusterEdgeSummary `protobuf:"bytes,4,opt,name=cluster_summary,json=clusterSummary,proto3,oneof"`
}

type PeerMessage_StreamLifecycle struct {
	StreamLifecycle *StreamLifecycleEvent `protobuf:"bytes,5,opt,name=stream_lifecycle,json=streamLifecycle,proto3,oneof"`
}

type PeerMessage_StreamAd struct {
	StreamAd *StreamAdvertisement `protobuf:"bytes,6,opt,name=stream_ad,json=streamAd,proto3,oneof"`
}

type PeerMessage_ArtifactAd struct {
	ArtifactAd *ArtifactAdvertisement `protobuf:"bytes,7,opt,name=artifact_ad,json=artifactAd,proto3,oneof"`
}

type PeerMessage_PeerHeartbeat struct {
	PeerHeartbeat *PeerHeartbeat `protobuf:"bytes,8,opt,name=peer_heartbeat,json=peerHeartbeat,proto3,oneof"`
}

type PeerMessage_CapacitySummary struct {
	CapacitySummary *CapacitySummary `protobuf:"bytes,9,opt,name=capacity_summary,json=capacitySummary,proto3,oneof"`
}

func (*PeerMessage_EdgeTelemetry) isPeerMessage_Payload() {}

func (*PeerMessage_ReplicationEvent) isPeerMessage_Payload() {}

func (*PeerMessage_ClusterSummary) isPeerMessage_Payload() {}

func (*PeerMessage_StreamLifecycle) isPeerMessage_Payload() {}

func (*PeerMessage_StreamAd) isPeerMessage_Payload() {}

func (*PeerMessage_ArtifactAd) isPeerMessage_Payload() {}

func (*PeerMessage_PeerHeartbeat) isPeerMessage_Payload() {}

func (*PeerMessage_CapacitySummary) isPeerMessage_Payload() {}

// StreamLifecycleEvent signals that a stream went live or offline on a cluster.
// Broadcast via PeerChannel so peers can reject duplicate ingest within the
// telemetry window (~5s). Receiving clusters write to Redis; any instance can
// check during PUSH_REWRITE.
type StreamLifecycleEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	InternalName  string                 `protobuf:"bytes,1,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`
	TenantId      string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	ClusterId     string                 `protobuf:"bytes,3,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	IsLive        bool                   `protobuf:"varint,4,opt,name=is_live,json=isLive,proto3" json:"is_live,omitempty"`
	TimestampUnix int64                  `protobuf:"varint,5,opt,name=timestamp_unix,json=timestampUnix,proto3" json:"timestamp_unix,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamLifecycleEvent) Reset() {
	*x = StreamLifecycleEvent{}
	mi := &file_foghorn_federation_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamLifecycleEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamLifecycleEvent) ProtoMessage() {}

func (x *StreamLifecycleEvent) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamLifecycleEvent.ProtoReflect.Descriptor instead.
func (*StreamLifecycleEvent) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{12}
}

func (x *StreamLifecycleEvent) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *StreamLifecycleEvent) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *StreamLifecycleEvent) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *StreamLifecycleEvent) GetIsLive() bool {
	if x != nil {
		return x.IsLive
	}
	return false
}

func (x *StreamLifecycleEvent) GetTimestampUnix() int64 {
	if x != nil {
		return x.TimestampUnix
	}
	return 0
}

// EdgeTelemetry is pushed every 5s for edges involved in active replications.
// The receiving cluster writes this to Redis for cross-cluster scoring.
type EdgeTelemetry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StreamName    string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	NodeId        string                 `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	BaseUrl       string                 `protobuf:"bytes,3,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`
	BwAvailable   uint64                 `protobuf:"varint,4,opt,name=bw_available,json=bwAvailable,proto3" json:"bw_available,omitempty"` // Available bandwidth in bytes/sec
	ViewerCount   uint32                 `protobuf:"varint,5,opt,name=viewer_count,json=viewerCount,proto3" json:"viewer_count,omitempty"`
	CpuPercent    float64                `protobuf:"fixed64,6,opt,name=cpu_percent,json=cpuPercent,proto3" json:"cpu_percent,omitempty"` // 0-100
	RamUsed       uint64                 `protobuf:"varint,7,opt,name=ram_used,json=ramUsed,proto3" json:"ram_used,omitempty"`           // bytes
	RamMax        uint64                 `protobuf:"varint,8,opt,name=ram_max,json=ramMax,proto3" json:"ram_max,omitempty"`              // bytes
	GeoLat        float64                `protobuf:"fixed64,9,opt,name=geo_lat,json=geoLat,proto3" json:"geo_lat,omitempty"`
	GeoLon        float64                `protobuf:"fixed64,10,opt,name=geo_lon,json=geoLon,proto3" json:"geo_lon,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EdgeTelemetry) Reset() {
	*x = EdgeTelemetry{}
	mi := &file_foghorn_federation_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EdgeTelemetry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EdgeTelemetry) ProtoMessage() {}

func (x *EdgeTelemetry) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EdgeTelemetry.ProtoReflect.Descriptor instead.
func (*EdgeTelemetry) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{13}
}

func (x *EdgeTelemetry) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *EdgeTelemetry) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *EdgeTelemetry) GetBaseUrl() string {
	if x != nil {
		return x.BaseUrl
	}
	return ""
}

func (x *EdgeTelemetry) GetBwAvailable() uint64 {
	if x != nil {
		return x.BwAvailable
	}
	return 0
}

func (x *EdgeTelemetry) GetViewerCount() uint32 {
	if x != nil {
		return x.ViewerCount
	}
	return 0
}

func (x *EdgeTelemetry) GetCpuPercent() float64 {
	if x != nil {
		return x.CpuPercent
	}
	return 0
}

func (x *EdgeTelemetry) GetRamUsed() uint64 {
	if x != nil {
		return x.RamUsed
	}
	return 0
}

func (x *EdgeTelemetry) GetRamMax() uint64 {
	if x != nil {
		return x.RamMax
	}
	return 0
}

func (x *EdgeTelemetry) GetGeoLat() float64 {
	if x != nil {
		return x.GeoLat
	}
	return 0
}

func (x *EdgeTelemetry) GetGeoLon() float64 {
	if x != nil {
		return x.GeoLon
	}
	return 0
}

// ReplicationEvent signals that a stream replication has started or stopped.
// Used to fix redirect loops: once cluster A has a stream via origin-pull,
// cluster B learns about it and can redirect viewers to A.
type ReplicationEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StreamName    string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	NodeId        string                 `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`          // Edge node hosting the replication
	ClusterId     string                 `protobuf:"bytes,3,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"` // Cluster hosting the replication
	BaseUrl       string                 `protobuf:"bytes,4,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`       // Public URL of the edge
	DtscUrl       string                 `protobuf:"bytes,5,opt,name=dtsc_url,json=dtscUrl,proto3" json:"dtsc_url,omitempty"`       // DTSC URL of the replicated stream
	Available     bool                   `protobuf:"varint,6,opt,name=available,proto3" json:"available,omitempty"`                 // True = replication active, false = stopped
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicationEvent) Reset() {
	*x = ReplicationEvent{}
	mi := &file_foghorn_federation_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicationEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicationEvent) ProtoMessage() {}

func (x *ReplicationEvent) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicationEvent.ProtoReflect.Descriptor instead.
func (*ReplicationEvent) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{14}
}

func (x *ReplicationEvent) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *ReplicationEvent) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *ReplicationEvent) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *ReplicationEvent) GetBaseUrl() string {
	if x != nil {
		return x.BaseUrl
	}
	return ""
}

func (x *ReplicationEvent) GetDtscUrl() string {
	if x != nil {
		return x.DtscUrl
	}
	return ""
}

func (x *ReplicationEvent) GetAvailable() bool {
	if x != nil {
		return x.Available
	}
	return false
}

// ClusterEdgeSummary provides smoothed (30s moving average) edge telemetry
// for an entire cluster. Sent by the official coverage cluster to a tenant's
// preferred cluster via PeerChannel every 30s. Enables the preferred Foghorn
// to score official-cluster edges alongside local edges without per-viewer RPCs.
type ClusterEdgeSummary struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Edges         []*EdgeSnapshot        `protobuf:"bytes,1,rep,name=edges,proto3" json:"edges,omitempty"`
	Timestamp     int64                  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"` // Unix timestamp of this summary
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClusterEdgeSummary) Reset() {
	*x = ClusterEdgeSummary{}
	mi := &file_foghorn_federation_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterEdgeSummary) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterEdgeSummary) ProtoMessage() {}

func (x *ClusterEdgeSummary) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterEdgeSummary.ProtoReflect.Descriptor instead.
func (*ClusterEdgeSummary) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{15}
}

func (x *ClusterEdgeSummary) GetEdges() []*EdgeSnapshot {
	if x != nil {
		return x.Edges
	}
	return nil
}

func (x *ClusterEdgeSummary) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// EdgeSnapshot is a smoothed view of a single edge node's capacity.
type EdgeSnapshot struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	NodeId         string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	BaseUrl        string                 `protobuf:"bytes,2,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`
	GeoLat         float64                `protobuf:"fixed64,3,opt,name=geo_lat,json=geoLat,proto3" json:"geo_lat,omitempty"`
	GeoLon         float64                `protobuf:"fixed64,4,opt,name=geo_lon,json=geoLon,proto3" json:"geo_lon,omitempty"`
	BwAvailableAvg uint64                 `protobuf:"varint,5,opt,name=bw_available_avg,json=bwAvailableAvg,proto3" json:"bw_available_avg,omitempty"` // 30s moving average, bytes/sec
	CpuPercentAvg  float64                `protobuf:"fixed64,6,opt,name=cpu_percent_avg,json=cpuPercentAvg,proto3" json:"cpu_percent_avg,omitempty"`   // 30s moving average, 0-100
	RamUsed        uint64                 `protobuf:"varint,7,opt,name=ram_used,json=ramUsed,proto3" json:"ram_used,omitempty"`
	RamMax         uint64                 `protobuf:"varint,8,opt,name=ram_max,json=ramMax,proto3" json:"ram_max,omitempty"`
	TotalViewers   uint32                 `protobuf:"varint,9,opt,name=total_viewers,json=totalViewers,proto3" json:"total_viewers,omitempty"`
	Roles          []string               `protobuf:"bytes,10,rep,name=roles,proto3" json:"roles,omitempty"` // e.g., "edge", "ingest", "storage"
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *EdgeSnapshot) Reset() {
	*x = EdgeSnapshot{}
	mi := &file_foghorn_federation_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EdgeSnapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EdgeSnapshot) ProtoMessage() {}

func (x *EdgeSnapshot) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EdgeSnapshot.ProtoReflect.Descriptor instead.
func (*EdgeSnapshot) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{16}
}

func (x *EdgeSnapshot) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *EdgeSnapshot) GetBaseUrl() string {
	if x != nil {
		return x.BaseUrl
	}
	return ""
}

func (x *EdgeSnapshot) GetGeoLat() float64 {
	if x != nil {
		return x.GeoLat
	}
	return 0
}

func (x *EdgeSnapshot) GetGeoLon() float64 {
	if x != nil {
		return x.GeoLon
	}
	return 0
}

func (x *EdgeSnapshot) GetBwAvailableAvg() uint64 {
	if x != nil {
		return x.BwAvailableAvg
	}
	return 0
}

func (x *EdgeSnapshot) GetCpuPercentAvg() float64 {
	if x != nil {
		return x.CpuPercentAvg
	}
	return 0
}

func (x *EdgeSnapshot) GetRamUsed() uint64 {
	if x != nil {
		return x.RamUsed
	}
	return 0
}

func (x *EdgeSnapshot) GetRamMax() uint64 {
	if x != nil {
		return x.RamMax
	}
	return 0
}

func (x *EdgeSnapshot) GetTotalViewers() uint32 {
	if x != nil {
		return x.TotalViewers
	}
	return 0
}

func (x *EdgeSnapshot) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

// ArtifactAdvertisement carries hot artifact locations from a peer cluster.
// Pushed via PeerChannel every 30s. The receiving cluster stores these in Redis
// so playback resolution can route to peer edges that already have the artifact
// warm, avoiding unnecessary S3 freeze/defrost round-trips.
type ArtifactAdvertisement struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Artifacts     []*ArtifactLocation    `protobuf:"bytes,1,rep,name=artifacts,proto3" json:"artifacts,omitempty"`
	Timestamp     int64                  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"` // Unix seconds
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArtifactAdvertisement) Reset() {
	*x = ArtifactAdvertisement{}
	mi := &file_foghorn_federation_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArtifactAdvertisement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArtifactAdvertisement) ProtoMessage() {}

func (x *ArtifactAdvertisement) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArtifactAdvertisement.ProtoReflect.Descriptor instead.
func (*ArtifactAdvertisement) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{17}
}

func (x *ArtifactAdvertisement) GetArtifacts() []*ArtifactLocation {
	if x != nil {
		return x.Artifacts
	}
	return nil
}

func (x *ArtifactAdvertisement) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// ArtifactLocation describes a single hot artifact on a specific edge node.
type ArtifactLocation struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ArtifactHash  string                 `protobuf:"bytes,1,opt,name=artifact_hash,json=artifactHash,proto3" json:"artifact_hash,omitempty"`
	ArtifactType  string                 `protobuf:"bytes,2,opt,name=artifact_type,json=artifactType,proto3" json:"artifact_type,omitempty"` // clip, dvr, vod
	NodeId        string                 `protobuf:"bytes,3,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	BaseUrl       string                 `protobuf:"bytes,4,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"` // Edge public URL
	SizeBytes     uint64                 `protobuf:"varint,5,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	AccessCount   uint32                 `protobuf:"varint,6,opt,name=access_count,json=accessCount,proto3" json:"access_count,omitempty"`    // Popularity signal for scoring
	LastAccessed  int64                  `protobuf:"varint,7,opt,name=last_accessed,json=lastAccessed,proto3" json:"last_accessed,omitempty"` // Unix seconds
	GeoLat        float64                `protobuf:"fixed64,8,opt,name=geo_lat,json=geoLat,proto3" json:"geo_lat,omitempty"`
	GeoLon        float64                `protobuf:"fixed64,9,opt,name=geo_lon,json=geoLon,proto3" json:"geo_lon,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArtifactLocation) Reset() {
	*x = ArtifactLocation{}
	mi := &file_foghorn_federation_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArtifactLocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArtifactLocation) ProtoMessage() {}

func (x *ArtifactLocation) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArtifactLocation.ProtoReflect.Descriptor instead.
func (*ArtifactLocation) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{18}
}

func (x *ArtifactLocation) GetArtifactHash() string {
	if x != nil {
		return x.ArtifactHash
	}
	return ""
}

func (x *ArtifactLocation) GetArtifactType() string {
	if x != nil {
		return x.ArtifactType
	}
	return ""
}

func (x *ArtifactLocation) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *ArtifactLocation) GetBaseUrl() string {
	if x != nil {
		return x.BaseUrl
	}
	return ""
}

func (x *ArtifactLocation) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *ArtifactLocation) GetAccessCount() uint32 {
	if x != nil {
		return x.AccessCount
	}
	return 0
}

func (x *ArtifactLocation) GetLastAccessed() int64 {
	if x != nil {
		return x.LastAccessed
	}
	return 0
}

func (x *ArtifactLocation) GetGeoLat() float64 {
	if x != nil {
		return x.GeoLat
	}
	return 0
}

func (x *ArtifactLocation) GetGeoLon() float64 {
	if x != nil {
		return x.GeoLon
	}
	return 0
}

// StreamAdvertisement is the autonomous routing primitive for the dCDN media plane.
// Pushed every 5s for all live streams. Receiving peers build a local stream
// directory (Adj-RIB-In): playback_id reverse index + per-stream edge table.
// Replaces Commodore ResolvePlaybackID + QueryStream RPC in steady state.
type StreamAdvertisement struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	InternalName    string                 `protobuf:"bytes,1,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`
	TenantId        string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	PlaybackId      string                 `protobuf:"bytes,3,opt,name=playback_id,json=playbackId,proto3" json:"playback_id,omitempty"`                  // For local reverse-index (replaces Commodore resolve)
	OriginClusterId string                 `protobuf:"bytes,4,opt,name=origin_cluster_id,json=originClusterId,proto3" json:"origin_cluster_id,omitempty"` // Cluster where stream originally ingested
	IsLive          bool                   `protobuf:"varint,5,opt,name=is_live,json=isLive,proto3" json:"is_live,omitempty"`                             // false = stream withdrawal
	Edges           []*PeerStreamEdge      `protobuf:"bytes,6,rep,name=edges,proto3" json:"edges,omitempty"`
	Timestamp       int64                  `protobuf:"varint,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"` // Unix seconds
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StreamAdvertisement) Reset() {
	*x = StreamAdvertisement{}
	mi := &file_foghorn_federation_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamAdvertisement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamAdvertisement) ProtoMessage() {}

func (x *StreamAdvertisement) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamAdvertisement.ProtoReflect.Descriptor instead.
func (*StreamAdvertisement) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{19}
}

func (x *StreamAdvertisement) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *StreamAdvertisement) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *StreamAdvertisement) GetPlaybackId() string {
	if x != nil {
		return x.PlaybackId
	}
	return ""
}

func (x *StreamAdvertisement) GetOriginClusterId() string {
	if x != nil {
		return x.OriginClusterId
	}
	return ""
}

func (x *StreamAdvertisement) GetIsLive() bool {
	if x != nil {
		return x.IsLive
	}
	return false
}

func (x *StreamAdvertisement) GetEdges() []*PeerStreamEdge {
	if x != nil {
		return x.Edges
	}
	return nil
}

func (x *StreamAdvertisement) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// PeerStreamEdge describes a single edge node serving a specific stream.
type PeerStreamEdge struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	BaseUrl       string                 `protobuf:"bytes,2,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`              // Public HTTPS URL
	DtscUrl       string                 `protobuf:"bytes,3,opt,name=dtsc_url,json=dtscUrl,proto3" json:"dtsc_url,omitempty"`              // DTSC pull URL for origin-pull cascading
	IsOrigin      bool                   `protobuf:"varint,4,opt,name=is_origin,json=isOrigin,proto3" json:"is_origin,omitempty"`          // True if node has original ingest input
	BwAvailable   uint64                 `protobuf:"varint,5,opt,name=bw_available,json=bwAvailable,proto3" json:"bw_available,omitempty"` // Available bandwidth (bytes/sec)
	CpuPercent    float64                `protobuf:"fixed64,6,opt,name=cpu_percent,json=cpuPercent,proto3" json:"cpu_percent,omitempty"`   // 0-100
	ViewerCount   uint32                 `protobuf:"varint,7,opt,name=viewer_count,json=viewerCount,proto3" json:"viewer_count,omitempty"`
	GeoLat        float64                `protobuf:"fixed64,8,opt,name=geo_lat,json=geoLat,proto3" json:"geo_lat,omitempty"`
	GeoLon        float64                `protobuf:"fixed64,9,opt,name=geo_lon,json=geoLon,proto3" json:"geo_lon,omitempty"`
	BufferState   string                 `protobuf:"bytes,10,opt,name=buffer_state,json=bufferState,proto3" json:"buffer_state,omitempty"` // FULL, DRY, RECOVER, etc.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PeerStreamEdge) Reset() {
	*x = PeerStreamEdge{}
	mi := &file_foghorn_federation_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PeerStreamEdge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PeerStreamEdge) ProtoMessage() {}

func (x *PeerStreamEdge) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PeerStreamEdge.ProtoReflect.Descriptor instead.
func (*PeerStreamEdge) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{20}
}

func (x *PeerStreamEdge) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *PeerStreamEdge) GetBaseUrl() string {
	if x != nil {
		return x.BaseUrl
	}
	return ""
}

func (x *PeerStreamEdge) GetDtscUrl() string {
	if x != nil {
		return x.DtscUrl
	}
	return ""
}

func (x *PeerStreamEdge) GetIsOrigin() bool {
	if x != nil {
		return x.IsOrigin
	}
	return false
}

func (x *PeerStreamEdge) GetBwAvailable() uint64 {
	if x != nil {
		return x.BwAvailable
	}
	return 0
}

func (x *PeerStreamEdge) GetCpuPercent() float64 {
	if x != nil {
		return x.CpuPercent
	}
	return 0
}

func (x *PeerStreamEdge) GetViewerCount() uint32 {
	if x != nil {
		return x.ViewerCount
	}
	return 0
}

func (x *PeerStreamEdge) GetGeoLat() float64 {
	if x != nil {
		return x.GeoLat
	}
	return 0
}

func (x *PeerStreamEdge) GetGeoLon() float64 {
	if x != nil {
		return x.GeoLon
	}
	return 0
}

func (x *PeerStreamEdge) GetBufferState() string {
	if x != nil {
		return x.BufferState
	}
	return ""
}

// PeerHeartbeat provides session liveness and capability exchange.
// Sent every 10s. Missing 3 consecutive heartbeats = peer considered dead.
type PeerHeartbeat struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	ProtocolVersion  uint32                 `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	StreamCount      uint32                 `protobuf:"varint,2,opt,name=stream_count,json=streamCount,proto3" json:"stream_count,omitempty"`                  // Total live streams on this cluster
	TotalBwAvailable uint64                 `protobuf:"varint,3,opt,name=total_bw_available,json=totalBwAvailable,proto3" json:"total_bw_available,omitempty"` // Aggregate available bandwidth (bytes/sec)
	EdgeCount        uint32                 `protobuf:"varint,4,opt,name=edge_count,json=edgeCount,proto3" json:"edge_count,omitempty"`                        // Number of online edge nodes
	UptimeSeconds    int64                  `protobuf:"varint,5,opt,name=uptime_seconds,json=uptimeSeconds,proto3" json:"uptime_seconds,omitempty"`
	Capabilities     []string               `protobuf:"bytes,6,rep,name=capabilities,proto3" json:"capabilities,omitempty"` // Feature flags: "stream_ad", "artifact_ad", etc.
	// Foghorn geo (self-GeoIP'd on startup, exchanged for map visualization)
	FoghornLat      float64 `protobuf:"fixed64,7,opt,name=foghorn_lat,json=foghornLat,proto3" json:"foghorn_lat,omitempty"`
	FoghornLon      float64 `protobuf:"fixed64,8,opt,name=foghorn_lon,json=foghornLon,proto3" json:"foghorn_lon,omitempty"`
	FoghornLocation string  `protobuf:"bytes,9,opt,name=foghorn_location,json=foghornLocation,proto3" json:"foghorn_location,omitempty"`
	FoghornRegion   string  `protobuf:"bytes,10,opt,name=foghorn_region,json=foghornRegion,proto3" json:"foghorn_region,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PeerHeartbeat) Reset() {
	*x = PeerHeartbeat{}
	mi := &file_foghorn_federation_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PeerHeartbeat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PeerHeartbeat) ProtoMessage() {}

func (x *PeerHeartbeat) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PeerHeartbeat.ProtoReflect.Descriptor instead.
func (*PeerHeartbeat) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{21}
}

func (x *PeerHeartbeat) GetProtocolVersion() uint32 {
	if x != nil {
		return x.ProtocolVersion
	}
	return 0
}

func (x *PeerHeartbeat) GetStreamCount() uint32 {
	if x != nil {
		return x.StreamCount
	}
	return 0
}

func (x *PeerHeartbeat) GetTotalBwAvailable() uint64 {
	if x != nil {
		return x.TotalBwAvailable
	}
	return 0
}

func (x *PeerHeartbeat) GetEdgeCount() uint32 {
	if x != nil {
		return x.EdgeCount
	}
	return 0
}

func (x *PeerHeartbeat) GetUptimeSeconds() int64 {
	if x != nil {
		return x.UptimeSeconds
	}
	return 0
}

func (x *PeerHeartbeat) GetCapabilities() []string {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *PeerHeartbeat) GetFoghornLat() float64 {
	if x != nil {
		return x.FoghornLat
	}
	return 0
}

func (x *PeerHeartbeat) GetFoghornLon() float64 {
	if x != nil {
		return x.FoghornLon
	}
	return 0
}

func (x *PeerHeartbeat) GetFoghornLocation() string {
	if x != nil {
		return x.FoghornLocation
	}
	return ""
}

func (x *PeerHeartbeat) GetFoghornRegion() string {
	if x != nil {
		return x.FoghornRegion
	}
	return ""
}

// CapacitySummary advertises cluster-wide aggregate capacity for dCDN
// capacity trading and marketplace bidding. Not on the per-viewer hot path;
// used for cluster-level routing decisions (which cluster should a tenant use?).
type CapacitySummary struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	TotalBandwidth     uint64                 `protobuf:"varint,1,opt,name=total_bandwidth,json=totalBandwidth,proto3" json:"total_bandwidth,omitempty"`             // Total cluster bandwidth (bytes/sec)
	AvailableBandwidth uint64                 `protobuf:"varint,2,opt,name=available_bandwidth,json=availableBandwidth,proto3" json:"available_bandwidth,omitempty"` // Available bandwidth (bytes/sec)
	TotalEdges         uint32                 `protobuf:"varint,3,opt,name=total_edges,json=totalEdges,proto3" json:"total_edges,omitempty"`
	AvailableEdges     uint32                 `protobuf:"varint,4,opt,name=available_edges,json=availableEdges,proto3" json:"available_edges,omitempty"`
	TotalStorage       uint64                 `protobuf:"varint,5,opt,name=total_storage,json=totalStorage,proto3" json:"total_storage,omitempty"`             // bytes
	AvailableStorage   uint64                 `protobuf:"varint,6,opt,name=available_storage,json=availableStorage,proto3" json:"available_storage,omitempty"` // bytes
	Timestamp          int64                  `protobuf:"varint,8,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                                       // Unix seconds
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *CapacitySummary) Reset() {
	*x = CapacitySummary{}
	mi := &file_foghorn_federation_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CapacitySummary) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CapacitySummary) ProtoMessage() {}

func (x *CapacitySummary) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CapacitySummary.ProtoReflect.Descriptor instead.
func (*CapacitySummary) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{22}
}

func (x *CapacitySummary) GetTotalBandwidth() uint64 {
	if x != nil {
		return x.TotalBandwidth
	}
	return 0
}

func (x *CapacitySummary) GetAvailableBandwidth() uint64 {
	if x != nil {
		return x.AvailableBandwidth
	}
	return 0
}

func (x *CapacitySummary) GetTotalEdges() uint32 {
	if x != nil {
		return x.TotalEdges
	}
	return 0
}

func (x *CapacitySummary) GetAvailableEdges() uint32 {
	if x != nil {
		return x.AvailableEdges
	}
	return 0
}

func (x *CapacitySummary) GetTotalStorage() uint64 {
	if x != nil {
		return x.TotalStorage
	}
	return 0
}

func (x *CapacitySummary) GetAvailableStorage() uint64 {
	if x != nil {
		return x.AvailableStorage
	}
	return 0
}

func (x *CapacitySummary) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// ListTenantArtifactsRequest asks a cluster for all artifact metadata belonging to a tenant.
type ListTenantArtifactsRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	TenantId          string                 `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	RequestingCluster string                 `protobuf:"bytes,2,opt,name=requesting_cluster,json=requestingCluster,proto3" json:"requesting_cluster,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ListTenantArtifactsRequest) Reset() {
	*x = ListTenantArtifactsRequest{}
	mi := &file_foghorn_federation_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListTenantArtifactsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListTenantArtifactsRequest) ProtoMessage() {}

func (x *ListTenantArtifactsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListTenantArtifactsRequest.ProtoReflect.Descriptor instead.
func (*ListTenantArtifactsRequest) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{23}
}

func (x *ListTenantArtifactsRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *ListTenantArtifactsRequest) GetRequestingCluster() string {
	if x != nil {
		return x.RequestingCluster
	}
	return ""
}

// ListTenantArtifactsResponse returns artifact metadata for bulk migration.
type ListTenantArtifactsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Artifacts     []*ArtifactMetadata    `protobuf:"bytes,1,rep,name=artifacts,proto3" json:"artifacts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListTenantArtifactsResponse) Reset() {
	*x = ListTenantArtifactsResponse{}
	mi := &file_foghorn_federation_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListTenantArtifactsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListTenantArtifactsResponse) ProtoMessage() {}

func (x *ListTenantArtifactsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListTenantArtifactsResponse.ProtoReflect.Descriptor instead.
func (*ListTenantArtifactsResponse) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{24}
}

func (x *ListTenantArtifactsResponse) GetArtifacts() []*ArtifactMetadata {
	if x != nil {
		return x.Artifacts
	}
	return nil
}

// ArtifactMetadata is the cold-storage record for a single artifact.
type ArtifactMetadata struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ArtifactHash    string                 `protobuf:"bytes,1,opt,name=artifact_hash,json=artifactHash,proto3" json:"artifact_hash,omitempty"`
	ArtifactType    string                 `protobuf:"bytes,2,opt,name=artifact_type,json=artifactType,proto3" json:"artifact_type,omitempty"`
	InternalName    string                 `protobuf:"bytes,3,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`
	Format          string                 `protobuf:"bytes,4,opt,name=format,proto3" json:"format,omitempty"`
	StorageLocation string                 `protobuf:"bytes,5,opt,name=storage_location,json=storageLocation,proto3" json:"storage_location,omitempty"`
	SyncStatus      string                 `protobuf:"bytes,6,opt,name=sync_status,json=syncStatus,proto3" json:"sync_status,omitempty"`
	S3Url           string                 `protobuf:"bytes,7,opt,name=s3_url,json=s3Url,proto3" json:"s3_url,omitempty"`
	SizeBytes       uint64                 `protobuf:"varint,8,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	CreatedAt       int64                  `protobuf:"varint,9,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"` // Unix seconds
	FrozenAt        int64                  `protobuf:"varint,10,opt,name=frozen_at,json=frozenAt,proto3" json:"frozen_at,omitempty"`   // Unix seconds
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ArtifactMetadata) Reset() {
	*x = ArtifactMetadata{}
	mi := &file_foghorn_federation_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArtifactMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArtifactMetadata) ProtoMessage() {}

func (x *ArtifactMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArtifactMetadata.ProtoReflect.Descriptor instead.
func (*ArtifactMetadata) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{25}
}

func (x *ArtifactMetadata) GetArtifactHash() string {
	if x != nil {
		return x.ArtifactHash
	}
	return ""
}

func (x *ArtifactMetadata) GetArtifactType() string {
	if x != nil {
		return x.ArtifactType
	}
	return ""
}

func (x *ArtifactMetadata) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *ArtifactMetadata) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *ArtifactMetadata) GetStorageLocation() string {
	if x != nil {
		return x.StorageLocation
	}
	return ""
}

func (x *ArtifactMetadata) GetSyncStatus() string {
	if x != nil {
		return x.SyncStatus
	}
	return ""
}

func (x *ArtifactMetadata) GetS3Url() string {
	if x != nil {
		return x.S3Url
	}
	return ""
}

func (x *ArtifactMetadata) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *ArtifactMetadata) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *ArtifactMetadata) GetFrozenAt() int64 {
	if x != nil {
		return x.FrozenAt
	}
	return 0
}

// MigrateArtifactMetadataRequest triggers a bulk copy of artifact records
// from a source cluster to the local cluster for a given tenant.
type MigrateArtifactMetadataRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	TenantId        string                 `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	SourceClusterId string                 `protobuf:"bytes,2,opt,name=source_cluster_id,json=sourceClusterId,proto3" json:"source_cluster_id,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *MigrateArtifactMetadataRequest) Reset() {
	*x = MigrateArtifactMetadataRequest{}
	mi := &file_foghorn_federation_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MigrateArtifactMetadataRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MigrateArtifactMetadataRequest) ProtoMessage() {}

func (x *MigrateArtifactMetadataRequest) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MigrateArtifactMetadataRequest.ProtoReflect.Descriptor instead.
func (*MigrateArtifactMetadataRequest) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{26}
}

func (x *MigrateArtifactMetadataRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *MigrateArtifactMetadataRequest) GetSourceClusterId() string {
	if x != nil {
		return x.SourceClusterId
	}
	return ""
}

// MigrateArtifactMetadataResponse reports migration results.
type MigrateArtifactMetadataResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MigratedCount int32                  `protobuf:"varint,1,opt,name=migrated_count,json=migratedCount,proto3" json:"migrated_count,omitempty"`
	AlreadyExists int32                  `protobuf:"varint,2,opt,name=already_exists,json=alreadyExists,proto3" json:"already_exists,omitempty"`
	Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MigrateArtifactMetadataResponse) Reset() {
	*x = MigrateArtifactMetadataResponse{}
	mi := &file_foghorn_federation_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MigrateArtifactMetadataResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MigrateArtifactMetadataResponse) ProtoMessage() {}

func (x *MigrateArtifactMetadataResponse) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MigrateArtifactMetadataResponse.ProtoReflect.Descriptor instead.
func (*MigrateArtifactMetadataResponse) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{27}
}

func (x *MigrateArtifactMetadataResponse) GetMigratedCount() int32 {
	if x != nil {
		return x.MigratedCount
	}
	return 0
}

func (x *MigrateArtifactMetadataResponse) GetAlreadyExists() int32 {
	if x != nil {
		return x.AlreadyExists
	}
	return 0
}

func (x *MigrateArtifactMetadataResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// ForwardArtifactCommandRequest forwards an artifact operation to a peer cluster.
type ForwardArtifactCommandRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Command       string                 `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`                               // "stop_dvr", "delete_clip", "delete_dvr", "delete_vod"
	ArtifactHash  string                 `protobuf:"bytes,2,opt,name=artifact_hash,json=artifactHash,proto3" json:"artifact_hash,omitempty"` // Clip hash, DVR hash, or VOD hash
	TenantId      string                 `protobuf:"bytes,3,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	StreamId      string                 `protobuf:"bytes,4,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"` // Optional, used by StopDVR for stream context
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ForwardArtifactCommandRequest) Reset() {
	*x = ForwardArtifactCommandRequest{}
	mi := &file_foghorn_federation_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ForwardArtifactCommandRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ForwardArtifactCommandRequest) ProtoMessage() {}

func (x *ForwardArtifactCommandRequest) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ForwardArtifactCommandRequest.ProtoReflect.Descriptor instead.
func (*ForwardArtifactCommandRequest) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{28}
}

func (x *ForwardArtifactCommandRequest) GetCommand() string {
	if x != nil {
		return x.Command
	}
	return ""
}

func (x *ForwardArtifactCommandRequest) GetArtifactHash() string {
	if x != nil {
		return x.ArtifactHash
	}
	return ""
}

func (x *ForwardArtifactCommandRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *ForwardArtifactCommandRequest) GetStreamId() string {
	if x != nil {
		return x.StreamId
	}
	return ""
}

type ForwardArtifactCommandResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Handled       bool                   `protobuf:"varint,1,opt,name=handled,proto3" json:"handled,omitempty"` // True if this cluster owned the artifact and processed the command
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`      // Error message if handled=false
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ForwardArtifactCommandResponse) Reset() {
	*x = ForwardArtifactCommandResponse{}
	mi := &file_foghorn_federation_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ForwardArtifactCommandResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ForwardArtifactCommandResponse) ProtoMessage() {}

func (x *ForwardArtifactCommandResponse) ProtoReflect() protoreflect.Message {
	mi := &file_foghorn_federation_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ForwardArtifactCommandResponse.ProtoReflect.Descriptor instead.
func (*ForwardArtifactCommandResponse) Descriptor() ([]byte, []int) {
	return file_foghorn_federation_proto_rawDescGZIP(), []int{29}
}

func (x *ForwardArtifactCommandResponse) GetHandled() bool {
	if x != nil {
		return x.Handled
	}
	return false
}

func (x *ForwardArtifactCommandResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

var File_foghorn_federation_proto protoreflect.FileDescriptor

const file_foghorn_federation_proto_rawDesc = "" +
	"\n" +
	"\x18foghorn_federation.proto\x12\x12foghorn_federation\"\xef\x01\n" +
	"\x12QueryStreamRequest\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12\x1d\n" +
	"\n" +
	"viewer_lat\x18\x02 \x01(\x01R\tviewerLat\x12\x1d\n" +
	"\n" +
	"viewer_lon\x18\x03 \x01(\x01R\tviewerLon\x12-\n" +
	"\x12requesting_cluster\x18\x04 \x01(\tR\x11requestingCluster\x12\x1b\n" +
	"\ttenant_id\x18\x05 \x01(\tR\btenantId\x12.\n" +
	"\x13is_source_selection\x18\x06 \x01(\bR\x11isSourceSelection\"\x84\x01\n" +
	"\x13QueryStreamResponse\x12A\n" +
	"\n" +
	"candidates\x18\x01 \x03(\v2!.foghorn_federation.EdgeCandidateR\n" +
	"candidates\x12*\n" +
	"\x11origin_cluster_id\x18\x02 \x01(\tR\x0foriginClusterId\"\xa3\x03\n" +
	"\rEdgeCandidate\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x19\n" +
	"\bbase_url\x18\x02 \x01(\tR\abaseUrl\x12\x19\n" +
	"\bdtsc_url\x18\x03 \x01(\tR\adtscUrl\x12\x19\n" +
	"\bbw_score\x18\x04 \x01(\x04R\abwScore\x12\x1b\n" +
	"\tgeo_score\x18\x05 \x01(\x04R\bgeoScore\x12\x1b\n" +
	"\tis_origin\x18\x06 \x01(\bR\bisOrigin\x12!\n" +
	"\fbuffer_state\x18\a \x01(\tR\vbufferState\x12\x17\n" +
	"\ageo_lat\x18\b \x01(\x01R\x06geoLat\x12\x17\n" +
	"\ageo_lon\x18\t \x01(\x01R\x06geoLon\x12!\n" +
	"\fviewer_count\x18\n" +
	" \x01(\rR\vviewerCount\x12\x1f\n" +
	"\vcpu_percent\x18\v \x01(\x01R\n" +
	"cpuPercent\x12!\n" +
	"\fbw_available\x18\f \x01(\x04R\vbwAvailable\x12\x19\n" +
	"\bram_used\x18\r \x01(\x04R\aramUsed\x12\x17\n" +
	"\aram_max\x18\x0e \x01(\x04R\x06ramMax\"\xe7\x01\n" +
	"\x16OriginPullNotification\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12$\n" +
	"\x0esource_node_id\x18\x02 \x01(\tR\fsourceNodeId\x12&\n" +
	"\x0fdest_cluster_id\x18\x03 \x01(\tR\rdestClusterId\x12 \n" +
	"\fdest_node_id\x18\x04 \x01(\tR\n" +
	"destNodeId\x12\x1f\n" +
	"\vest_viewers\x18\x05 \x01(\rR\n" +
	"estViewers\x12\x1b\n" +
	"\ttenant_id\x18\x06 \x01(\tR\btenantId\"^\n" +
	"\rOriginPullAck\x12\x1a\n" +
	"\baccepted\x18\x01 \x01(\bR\baccepted\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\x12\x19\n" +
	"\bdtsc_url\x18\x03 \x01(\tR\adtscUrl\"\xc7\x01\n" +
	"\x16PrepareArtifactRequest\x12\x1f\n" +
	"\vartifact_id\x18\x01 \x01(\tR\n" +
	"artifactId\x12\x1b\n" +
	"\tclip_hash\x18\x02 \x01(\tR\bclipHash\x12-\n" +
	"\x12requesting_cluster\x18\x03 \x01(\tR\x11requestingCluster\x12#\n" +
	"\rartifact_type\x18\x04 \x01(\tR\fartifactType\x12\x1b\n" +
	"\ttenant_id\x18\x05 \x01(\tR\btenantId\"\x80\x03\n" +
	"\x17PrepareArtifactResponse\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x02 \x01(\x04R\tsizeBytes\x12\x14\n" +
	"\x05ready\x18\x03 \x01(\bR\x05ready\x12*\n" +
	"\x11est_ready_seconds\x18\x04 \x01(\rR\x0festReadySeconds\x12\x14\n" +
	"\x05error\x18\x05 \x01(\tR\x05error\x12_\n" +
	"\fsegment_urls\x18\x06 \x03(\v2<.foghorn_federation.PrepareArtifactResponse.SegmentUrlsEntryR\vsegmentUrls\x12\x16\n" +
	"\x06format\x18\a \x01(\tR\x06format\x12#\n" +
	"\rinternal_name\x18\b \x01(\tR\finternalName\x1a>\n" +
	"\x10SegmentUrlsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xbc\x03\n" +
	"\x11RemoteClipRequest\x12#\n" +
	"\rinternal_name\x18\x01 \x01(\tR\finternalName\x12\x1b\n" +
	"\ttenant_id\x18\x02 \x01(\tR\btenantId\x12\x17\n" +
	"\auser_id\x18\x03 \x01(\tR\x06userId\x12\x1b\n" +
	"\tclip_hash\x18\x04 \x01(\tR\bclipHash\x124\n" +
	"\x16artifact_internal_name\x18\x05 \x01(\tR\x14artifactInternalName\x12\x1f\n" +
	"\vplayback_id\x18\x06 \x01(\tR\n" +
	"playbackId\x12\x16\n" +
	"\x06format\x18\a \x01(\tR\x06format\x12\x1d\n" +
	"\n" +
	"start_unix\x18\b \x01(\x03R\tstartUnix\x12\x1b\n" +
	"\tstop_unix\x18\t \x01(\x03R\bstopUnix\x12\x19\n" +
	"\bstart_ms\x18\n" +
	" \x01(\x03R\astartMs\x12\x17\n" +
	"\astop_ms\x18\v \x01(\x03R\x06stopMs\x12!\n" +
	"\fduration_sec\x18\f \x01(\x03R\vdurationSec\x12-\n" +
	"\x12requesting_cluster\x18\r \x01(\tR\x11requestingCluster\"\x8d\x01\n" +
	"\x12RemoteClipResponse\x12\x1a\n" +
	"\baccepted\x18\x01 \x01(\bR\baccepted\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\x12\x1b\n" +
	"\tclip_hash\x18\x03 \x01(\tR\bclipHash\x12&\n" +
	"\x0fstorage_node_id\x18\x04 \x01(\tR\rstorageNodeId\"\x8e\x02\n" +
	"\x10RemoteDVRRequest\x12#\n" +
	"\rinternal_name\x18\x01 \x01(\tR\finternalName\x12\x1b\n" +
	"\ttenant_id\x18\x02 \x01(\tR\btenantId\x12\x17\n" +
	"\auser_id\x18\x03 \x01(\tR\x06userId\x12\x19\n" +
	"\bdvr_hash\x18\x04 \x01(\tR\advrHash\x124\n" +
	"\x16artifact_internal_name\x18\x05 \x01(\tR\x14artifactInternalName\x12\x1f\n" +
	"\vplayback_id\x18\x06 \x01(\tR\n" +
	"playbackId\x12-\n" +
	"\x12requesting_cluster\x18\a \x01(\tR\x11requestingCluster\"b\n" +
	"\x11RemoteDVRResponse\x12\x1a\n" +
	"\baccepted\x18\x01 \x01(\bR\baccepted\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\x12\x19\n" +
	"\bdvr_hash\x18\x03 \x01(\tR\advrHash\"\xb6\x05\n" +
	"\vPeerMessage\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tR\tclusterId\x12J\n" +
	"\x0eedge_telemetry\x18\x02 \x01(\v2!.foghorn_federation.EdgeTelemetryH\x00R\redgeTelemetry\x12S\n" +
	"\x11replication_event\x18\x03 \x01(\v2$.foghorn_federation.ReplicationEventH\x00R\x10replicationEvent\x12Q\n" +
	"\x0fcluster_summary\x18\x04 \x01(\v2&.foghorn_federation.ClusterEdgeSummaryH\x00R\x0eclusterSummary\x12U\n" +
	"\x10stream_lifecycle\x18\x05 \x01(\v2(.foghorn_federation.StreamLifecycleEventH\x00R\x0fstreamLifecycle\x12F\n" +
	"\tstream_ad\x18\x06 \x01(\v2'.foghorn_federation.StreamAdvertisementH\x00R\bstreamAd\x12L\n" +
	"\vartifact_ad\x18\a \x01(\v2).foghorn_federation.ArtifactAdvertisementH\x00R\n" +
	"artifactAd\x12J\n" +
	"\x0epeer_heartbeat\x18\b \x01(\v2!.foghorn_federation.PeerHeartbeatH\x00R\rpeerHeartbeat\x12P\n" +
	"\x10capacity_summary\x18\t \x01(\v2#.foghorn_federation.CapacitySummaryH\x00R\x0fcapacitySummaryB\t\n" +
	"\apayload\"\xb7\x01\n" +
	"\x14StreamLifecycleEvent\x12#\n" +
	"\rinternal_name\x18\x01 \x01(\tR\finternalName\x12\x1b\n" +
	"\ttenant_id\x18\x02 \x01(\tR\btenantId\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x03 \x01(\tR\tclusterId\x12\x17\n" +
	"\ais_live\x18\x04 \x01(\bR\x06isLive\x12%\n" +
	"\x0etimestamp_unix\x18\x05 \x01(\x03R\rtimestampUnix\"\xb1\x02\n" +
	"\rEdgeTelemetry\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12\x17\n" +
	"\anode_id\x18\x02 \x01(\tR\x06nodeId\x12\x19\n" +
	"\bbase_url\x18\x03 \x01(\tR\abaseUrl\x12!\n" +
	"\fbw_available\x18\x04 \x01(\x04R\vbwAvailable\x12!\n" +
	"\fviewer_count\x18\x05 \x01(\rR\vviewerCount\x12\x1f\n" +
	"\vcpu_percent\x18\x06 \x01(\x01R\n" +
	"cpuPercent\x12\x19\n" +
	"\bram_used\x18\a \x01(\x04R\aramUsed\x12\x17\n" +
	"\aram_max\x18\b \x01(\x04R\x06ramMax\x12\x17\n" +
	"\ageo_lat\x18\t \x01(\x01R\x06geoLat\x12\x17\n" +
	"\ageo_lon\x18\n" +
	" \x01(\x01R\x06geoLon\"\xbf\x01\n" +
	"\x10ReplicationEvent\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12\x17\n" +
	"\anode_id\x18\x02 \x01(\tR\x06nodeId\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x03 \x01(\tR\tclusterId\x12\x19\n" +
	"\bbase_url\x18\x04 \x01(\tR\abaseUrl\x12\x19\n" +
	"\bdtsc_url\x18\x05 \x01(\tR\adtscUrl\x12\x1c\n" +
	"\tavailable\x18\x06 \x01(\bR\tavailable\"j\n" +
	"\x12ClusterEdgeSummary\x126\n" +
	"\x05edges\x18\x01 \x03(\v2 .foghorn_federation.EdgeSnapshotR\x05edges\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\"\xb5\x02\n" +
	"\fEdgeSnapshot\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x19\n" +
	"\bbase_url\x18\x02 \x01(\tR\abaseUrl\x12\x17\n" +
	"\ageo_lat\x18\x03 \x01(\x01R\x06geoLat\x12\x17\n" +
	"\ageo_lon\x18\x04 \x01(\x01R\x06geoLon\x12(\n" +
	"\x10bw_available_avg\x18\x05 \x01(\x04R\x0ebwAvailableAvg\x12&\n" +
	"\x0fcpu_percent_avg\x18\x06 \x01(\x01R\rcpuPercentAvg\x12\x19\n" +
	"\bram_used\x18\a \x01(\x04R\aramUsed\x12\x17\n" +
	"\aram_max\x18\b \x01(\x04R\x06ramMax\x12#\n" +
	"\rtotal_viewers\x18\t \x01(\rR\ftotalViewers\x12\x14\n" +
	"\x05roles\x18\n" +
	" \x03(\tR\x05roles\"y\n" +
	"\x15ArtifactAdvertisement\x12B\n" +
	"\tartifacts\x18\x01 \x03(\v2$.foghorn_federation.ArtifactLocationR\tartifacts\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\"\xa9\x02\n" +
	"\x10ArtifactLocation\x12#\n" +
	"\rartifact_hash\x18\x01 \x01(\tR\fartifactHash\x12#\n" +
	"\rartifact_type\x18\x02 \x01(\tR\fartifactType\x12\x17\n" +
	"\anode_id\x18\x03 \x01(\tR\x06nodeId\x12\x19\n" +
	"\bbase_url\x18\x04 \x01(\tR\abaseUrl\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x05 \x01(\x04R\tsizeBytes\x12!\n" +
	"\faccess_count\x18\x06 \x01(\rR\vaccessCount\x12#\n" +
	"\rlast_accessed\x18\a \x01(\x03R\flastAccessed\x12\x17\n" +
	"\ageo_lat\x18\b \x01(\x01R\x06geoLat\x12\x17\n" +
	"\ageo_lon\x18\t \x01(\x01R\x06geoLon\"\x95\x02\n" +
	"\x13StreamAdvertisement\x12#\n" +
	"\rinternal_name\x18\x01 \x01(\tR\finternalName\x12\x1b\n" +
	"\ttenant_id\x18\x02 \x01(\tR\btenantId\x12\x1f\n" +
	"\vplayback_id\x18\x03 \x01(\tR\n" +
	"playbackId\x12*\n" +
	"\x11origin_cluster_id\x18\x04 \x01(\tR\x0foriginClusterId\x12\x17\n" +
	"\ais_live\x18\x05 \x01(\bR\x06isLive\x128\n" +
	"\x05edges\x18\x06 \x03(\v2\".foghorn_federation.PeerStreamEdgeR\x05edges\x12\x1c\n" +
	"\ttimestamp\x18\a \x01(\x03R\ttimestamp\"\xb8\x02\n" +
	"\x0ePeerStreamEdge\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x19\n" +
	"\bbase_url\x18\x02 \x01(\tR\abaseUrl\x12\x19\n" +
	"\bdtsc_url\x18\x03 \x01(\tR\adtscUrl\x12\x1b\n" +
	"\tis_origin\x18\x04 \x01(\bR\bisOrigin\x12!\n" +
	"\fbw_available\x18\x05 \x01(\x04R\vbwAvailable\x12\x1f\n" +
	"\vcpu_percent\x18\x06 \x01(\x01R\n" +
	"cpuPercent\x12!\n" +
	"\fviewer_count\x18\a \x01(\rR\vviewerCount\x12\x17\n" +
	"\ageo_lat\x18\b \x01(\x01R\x06geoLat\x12\x17\n" +
	"\ageo_lon\x18\t \x01(\x01R\x06geoLon\x12!\n" +
	"\fbuffer_state\x18\n" +
	" \x01(\tR\vbufferState\"\x89\x03\n" +
	"\rPeerHeartbeat\x12)\n" +
	"\x10protocol_version\x18\x01 \x01(\rR\x0fprotocolVersion\x12!\n" +
	"\fstream_count\x18\x02 \x01(\rR\vstreamCount\x12,\n" +
	"\x12total_bw_available\x18\x03 \x01(\x04R\x10totalBwAvailable\x12\x1d\n" +
	"\n" +
	"edge_count\x18\x04 \x01(\rR\tedgeCount\x12%\n" +
	"\x0euptime_seconds\x18\x05 \x01(\x03R\ruptimeSeconds\x12\"\n" +
	"\fcapabilities\x18\x06 \x03(\tR\fcapabilities\x12\x1f\n" +
	"\vfoghorn_lat\x18\a \x01(\x01R\n" +
	"foghornLat\x12\x1f\n" +
	"\vfoghorn_lon\x18\b \x01(\x01R\n" +
	"foghornLon\x12)\n" +
	"\x10foghorn_location\x18\t \x01(\tR\x0ffoghornLocation\x12%\n" +
	"\x0efoghorn_region\x18\n" +
	" \x01(\tR\rfoghornRegion\"\xab\x02\n" +
	"\x0fCapacitySummary\x12'\n" +
	"\x0ftotal_bandwidth\x18\x01 \x01(\x04R\x0etotalBandwidth\x12/\n" +
	"\x13available_bandwidth\x18\x02 \x01(\x04R\x12availableBandwidth\x12\x1f\n" +
	"\vtotal_edges\x18\x03 \x01(\rR\n" +
	"totalEdges\x12'\n" +
	"\x0favailable_edges\x18\x04 \x01(\rR\x0eavailableEdges\x12#\n" +
	"\rtotal_storage\x18\x05 \x01(\x04R\ftotalStorage\x12+\n" +
	"\x11available_storage\x18\x06 \x01(\x04R\x10availableStorage\x12\x1c\n" +
	"\ttimestamp\x18\b \x01(\x03R\ttimestampJ\x04\b\a\x10\b\"h\n" +
	"\x1aListTenantArtifactsRequest\x12\x1b\n" +
	"\ttenant_id\x18\x01 \x01(\tR\btenantId\x12-\n" +
	"\x12requesting_cluster\x18\x02 \x01(\tR\x11requestingCluster\"a\n" +
	"\x1bListTenantArtifactsResponse\x12B\n" +
	"\tartifacts\x18\x01 \x03(\v2$.foghorn_federation.ArtifactMetadataR\tartifacts\"\xd7\x02\n" +
	"\x10ArtifactMetadata\x12#\n" +
	"\rartifact_hash\x18\x01 \x01(\tR\fartifactHash\x12#\n" +
	"\rartifact_type\x18\x02 \x01(\tR\fartifactType\x12#\n" +
	"\rinternal_name\x18\x03 \x01(\tR\finternalName\x12\x16\n" +
	"\x06format\x18\x04 \x01(\tR\x06format\x12)\n" +
	"\x10storage_location\x18\x05 \x01(\tR\x0fstorageLocation\x12\x1f\n" +
	"\vsync_status\x18\x06 \x01(\tR\n" +
	"syncStatus\x12\x15\n" +
	"\x06s3_url\x18\a \x01(\tR\x05s3Url\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\b \x01(\x04R\tsizeBytes\x12\x1d\n" +
	"\n" +
	"created_at\x18\t \x01(\x03R\tcreatedAt\x12\x1b\n" +
	"\tfrozen_at\x18\n" +
	" \x01(\x03R\bfrozenAt\"i\n" +
	"\x1eMigrateArtifactMetadataRequest\x12\x1b\n" +
	"\ttenant_id\x18\x01 \x01(\tR\btenantId\x12*\n" +
	"\x11source_cluster_id\x18\x02 \x01(\tR\x0fsourceClusterId\"\x85\x01\n" +
	"\x1fMigrateArtifactMetadataResponse\x12%\n" +
	"\x0emigrated_count\x18\x01 \x01(\x05R\rmigratedCount\x12%\n" +
	"\x0ealready_exists\x18\x02 \x01(\x05R\ralreadyExists\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"\x98\x01\n" +
	"\x1dForwardArtifactCommandRequest\x12\x18\n" +
	"\acommand\x18\x01 \x01(\tR\acommand\x12#\n" +
	"\rartifact_hash\x18\x02 \x01(\tR\fartifactHash\x12\x1b\n" +
	"\ttenant_id\x18\x03 \x01(\tR\btenantId\x12\x1b\n" +
	"\tstream_id\x18\x04 \x01(\tR\bstreamId\"P\n" +
	"\x1eForwardArtifactCommandResponse\x12\x18\n" +
	"\ahandled\x18\x01 \x01(\bR\ahandled\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error2\xd8\a\n" +
	"\x11FoghornFederation\x12^\n" +
	"\vQueryStream\x12&.foghorn_federation.QueryStreamRequest\x1a'.foghorn_federation.QueryStreamResponse\x12a\n" +
	"\x10NotifyOriginPull\x12*.foghorn_federation.OriginPullNotification\x1a!.foghorn_federation.OriginPullAck\x12j\n" +
	"\x0fPrepareArtifact\x12*.foghorn_federation.PrepareArtifactRequest\x1a+.foghorn_federation.PrepareArtifactResponse\x12a\n" +
	"\x10CreateRemoteClip\x12%.foghorn_federation.RemoteClipRequest\x1a&.foghorn_federation.RemoteClipResponse\x12^\n" +
	"\x0fCreateRemoteDVR\x12$.foghorn_federation.RemoteDVRRequest\x1a%.foghorn_federation.RemoteDVRResponse\x12S\n" +
	"\vPeerChannel\x12\x1f.foghorn_federation.PeerMessage\x1a\x1f.foghorn_federation.PeerMessage(\x010\x01\x12v\n" +
	"\x13ListTenantArtifacts\x12..foghorn_federation.ListTenantArtifactsRequest\x1a/.foghorn_federation.ListTenantArtifactsResponse\x12\x82\x01\n" +
	"\x17MigrateArtifactMetadata\x122.foghorn_federation.MigrateArtifactMetadataRequest\x1a3.foghorn_federation.MigrateArtifactMetadataResponse\x12\x7f\n" +
	"\x16ForwardArtifactCommand\x121.foghorn_federation.ForwardArtifactCommandRequest\x1a2.foghorn_federation.ForwardArtifactCommandResponseB\x16Z\x14frameworks/pkg/protob\x06proto3"

var (
	file_foghorn_federation_proto_rawDescOnce sync.Once
	file_foghorn_federation_proto_rawDescData []byte
)

func file_foghorn_federation_proto_rawDescGZIP() []byte {
	file_foghorn_federation_proto_rawDescOnce.Do(func() {
		file_foghorn_federation_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_foghorn_federation_proto_rawDesc), len(file_foghorn_federation_proto_rawDesc)))
	})
	return file_foghorn_federation_proto_rawDescData
}

var file_foghorn_federation_proto_msgTypes = make([]protoimpl.MessageInfo, 31)
var file_foghorn_federation_proto_goTypes = []any{
	(*QueryStreamRequest)(nil),              // 0: foghorn_federation.QueryStreamRequest
	(*QueryStreamResponse)(nil),             // 1: foghorn_federation.QueryStreamResponse
	(*EdgeCandidate)(nil),                   // 2: foghorn_federation.EdgeCandidate
	(*OriginPullNotification)(nil),          // 3: foghorn_federation.OriginPullNotification
	(*OriginPullAck)(nil),                   // 4: foghorn_federation.OriginPullAck
	(*PrepareArtifactRequest)(nil),          // 5: foghorn_federation.PrepareArtifactRequest
	(*PrepareArtifactResponse)(nil),         // 6: foghorn_federation.PrepareArtifactResponse
	(*RemoteClipRequest)(nil),               // 7: foghorn_federation.RemoteClipRequest
	(*RemoteClipResponse)(nil),              // 8: foghorn_federation.RemoteClipResponse
	(*RemoteDVRRequest)(nil),                // 9: foghorn_federation.RemoteDVRRequest
	(*RemoteDVRResponse)(nil),               // 10: foghorn_federation.RemoteDVRResponse
	(*PeerMessage)(nil),                     // 11: foghorn_federation.PeerMessage
	(*StreamLifecycleEvent)(nil),            // 12: foghorn_federation.StreamLifecycleEvent
	(*EdgeTelemetry)(nil),                   // 13: foghorn_federation.EdgeTelemetry
	(*ReplicationEvent)(nil),                // 14: foghorn_federation.ReplicationEvent
	(*ClusterEdgeSummary)(nil),              // 15: foghorn_federation.ClusterEdgeSummary
	(*EdgeSnapshot)(nil),                    // 16: foghorn_federation.EdgeSnapshot
	(*ArtifactAdvertisement)(nil),           // 17: foghorn_federation.ArtifactAdvertisement
	(*ArtifactLocation)(nil),                // 18: foghorn_federation.ArtifactLocation
	(*StreamAdvertisement)(nil),             // 19: foghorn_federation.StreamAdvertisement
	(*PeerStreamEdge)(nil),                  // 20: foghorn_federation.PeerStreamEdge
	(*PeerHeartbeat)(nil),                   // 21: foghorn_federation.PeerHeartbeat
	(*CapacitySummary)(nil),                 // 22: foghorn_federation.CapacitySummary
	(*ListTenantArtifactsRequest)(nil),      // 23: foghorn_federation.ListTenantArtifactsRequest
	(*ListTenantArtifactsResponse)(nil),     // 24: foghorn_federation.ListTenantArtifactsResponse
	(*ArtifactMetadata)(nil),                // 25: foghorn_federation.ArtifactMetadata
	(*MigrateArtifactMetadataRequest)(nil),  // 26: foghorn_federation.MigrateArtifactMetadataRequest
	(*MigrateArtifactMetadataResponse)(nil), // 27: foghorn_federation.MigrateArtifactMetadataResponse
	(*ForwardArtifactCommandRequest)(nil),   // 28: foghorn_federation.ForwardArtifactCommandRequest
	(*ForwardArtifactCommandResponse)(nil),  // 29: foghorn_federation.ForwardArtifactCommandResponse
	nil,                                     // 30: foghorn_federation.PrepareArtifactResponse.SegmentUrlsEntry
}
var file_foghorn_federation_proto_depIdxs = []int32{
	2,  // 0: foghorn_federation.QueryStreamResponse.candidates:type_name -> foghorn_federation.EdgeCandidate
	30, // 1: foghorn_federation.PrepareArtifactResponse.segment_urls:type_name -> foghorn_federation.PrepareArtifactResponse.SegmentUrlsEntry
	13, // 2: foghorn_federation.PeerMessage.edge_telemetry:type_name -> foghorn_federation.EdgeTelemetry
	14, // 3: foghorn_federation.PeerMessage.replication_event:type_name -> foghorn_federation.ReplicationEvent
	15, // 4: foghorn_federation.PeerMessage.cluster_summary:type_name -> foghorn_federation.ClusterEdgeSummary
	12, // 5: foghorn_federation.PeerMessage.stream_lifecycle:type_name -> foghorn_federation.StreamLifecycleEvent
	19, // 6: foghorn_federation.PeerMessage.stream_ad:type_name -> foghorn_federation.StreamAdvertisement
	17, // 7: foghorn_federation.PeerMessage.artifact_ad:type_name -> foghorn_federation.ArtifactAdvertisement
	21, // 8: foghorn_federation.PeerMessage.peer_heartbeat:type_name -> foghorn_federation.PeerHeartbeat
	22, // 9: foghorn_federation.PeerMessage.capacity_summary:type_name -> foghorn_federation.CapacitySummary
	16, // 10: foghorn_federation.ClusterEdgeSummary.edges:type_name -> foghorn_federation.EdgeSnapshot
	18, // 11: foghorn_federation.ArtifactAdvertisement.artifacts:type_name -> foghorn_federation.ArtifactLocation
	20, // 12: foghorn_federation.StreamAdvertisement.edges:type_name -> foghorn_federation.PeerStreamEdge
	25, // 13: foghorn_federation.ListTenantArtifactsResponse.artifacts:type_name -> foghorn_federation.ArtifactMetadata
	0,  // 14: foghorn_federation.FoghornFederation.QueryStream:input_type -> foghorn_federation.QueryStreamRequest
	3,  // 15: foghorn_federation.FoghornFederation.NotifyOriginPull:input_type -> foghorn_federation.OriginPullNotification
	5,  // 16: foghorn_federation.FoghornFederation.PrepareArtifact:input_type -> foghorn_federation.PrepareArtifactRequest
	7,  // 17: foghorn_federation.FoghornFederation.CreateRemoteClip:input_type -> foghorn_federation.RemoteClipRequest
	9,  // 18: foghorn_federation.FoghornFederation.CreateRemoteDVR:input_type -> foghorn_federation.RemoteDVRRequest
	11, // 19: foghorn_federation.FoghornFederation.PeerChannel:input_type -> foghorn_federation.PeerMessage
	23, // 20: foghorn_federation.FoghornFederation.ListTenantArtifacts:input_type -> foghorn_federation.ListTenantArtifactsRequest
	26, // 21: foghorn_federation.FoghornFederation.MigrateArtifactMetadata:input_type -> foghorn_federation.MigrateArtifactMetadataRequest
	28, // 22: foghorn_federation.FoghornFederation.ForwardArtifactCommand:input_type -> foghorn_federation.ForwardArtifactCommandRequest
	1,  // 23: foghorn_federation.FoghornFederation.QueryStream:output_type -> foghorn_federation.QueryStreamResponse
	4,  // 24: foghorn_federation.FoghornFederation.NotifyOriginPull:output_type -> foghorn_federation.OriginPullAck
	6,  // 25: foghorn_federation.FoghornFederation.PrepareArtifact:output_type -> foghorn_federation.PrepareArtifactResponse
	8,  // 26: foghorn_federation.FoghornFederation.CreateRemoteClip:output_type -> foghorn_federation.RemoteClipResponse
	10, // 27: foghorn_federation.FoghornFederation.CreateRemoteDVR:output_type -> foghorn_federation.RemoteDVRResponse
	11, // 28: foghorn_federation.FoghornFederation.PeerChannel:output_type -> foghorn_federation.PeerMessage
	24, // 29: foghorn_federation.FoghornFederation.ListTenantArtifacts:output_type -> foghorn_federation.ListTenantArtifactsResponse
	27, // 30: foghorn_federation.FoghornFederation.MigrateArtifactMetadata:output_type -> foghorn_federation.MigrateArtifactMetadataResponse
	29, // 31: foghorn_federation.FoghornFederation.ForwardArtifactCommand:output_type -> foghorn_federation.ForwardArtifactCommandResponse
	23, // [23:32] is the sub-list for method output_type
	14, // [14:23] is the sub-list for method input_type
	14, // [14:14] is the sub-list for extension type_name
	14, // [14:14] is the sub-list for extension extendee
	0,  // [0:14] is the sub-list for field type_name
}

func init() { file_foghorn_federation_proto_init() }
func file_foghorn_federation_proto_init() {
	if File_foghorn_federation_proto != nil {
		return
	}
	file_foghorn_federation_proto_msgTypes[11].OneofWrappers = []any{
		(*PeerMessage_EdgeTelemetry)(nil),
		(*PeerMessage_ReplicationEvent)(nil),
		(*PeerMessage_ClusterSummary)(nil),
		(*PeerMessage_StreamLifecycle)(nil),
		(*PeerMessage_StreamAd)(nil),
		(*PeerMessage_ArtifactAd)(nil),
		(*PeerMessage_PeerHeartbeat)(nil),
		(*PeerMessage_CapacitySummary)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_foghorn_federation_proto_rawDesc), len(file_foghorn_federation_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   31,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_foghorn_federation_proto_goTypes,
		DependencyIndexes: file_foghorn_federation_proto_depIdxs,
		MessageInfos:      file_foghorn_federation_proto_msgTypes,
	}.Build()
	File_foghorn_federation_proto = out.File
	file_foghorn_federation_proto_goTypes = nil
	file_foghorn_federation_proto_depIdxs = nil
}
