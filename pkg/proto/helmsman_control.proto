syntax = "proto3";

package helmsmancontrol;

option go_package = "frameworks/pkg/proto";

import "google/protobuf/timestamp.proto";

// Bidirectional control channel between Helmsman (client) and Foghorn (server)
// Helmsman dials Foghorn and sends Register/NodeUpdate; Foghorn sends ClipPullRequest

service HelmsmanControl {
  rpc Connect(stream ControlMessage) returns (stream ControlMessage);
  rpc ResolveClipHash(ClipHashRequest) returns (ClipHashResponse);
}

message ControlMessage {
  string request_id = 1; // Correlates requests/responses
  google.protobuf.Timestamp sent_at = 2;
  oneof payload {
    Register register = 10;
    NodeUpdate node_update = 11;
    ClipPullRequest clip_pull_request = 12;
    ClipProgress clip_progress = 13;
    ClipDone clip_done = 14;
    ControlError error = 15;
    Heartbeat heartbeat = 16;
    StreamHealthUpdate stream_health_update = 17;
    DVRStartRequest dvr_start_request = 18;
    DVRProgress dvr_progress = 19;
    DVRStopped dvr_stopped = 20;
    DVRStopRequest dvr_stop_request = 21;
    DVRReadyRequest dvr_ready_request = 22;
    DVRReadyResponse dvr_ready_response = 23;
  }
}

message Register {
  string node_id = 1;
  repeated string roles = 2; // e.g., ingest, edge, storage, processing
  bool cap_ingest = 3;
  bool cap_edge = 4;
  bool cap_storage = 5;
  bool cap_processing = 6;
  // Storage hints
  string storage_local = 7;
  string storage_bucket = 8;
  string storage_prefix = 9;
}

message NodeUpdate {
  string node_id = 1;
  // Resource metrics
  uint32 cpu_tenths = 2;         // 0-1000
  uint64 ram_max = 3;            // MiB
  uint64 ram_current = 4;        // MiB
  uint64 up_speed = 5;           // bytes/sec
  uint64 down_speed = 6;         // bytes/sec
  uint64 bw_limit = 7;           // bytes/sec
  // Geo/location
  double latitude = 8;
  double longitude = 9;
  string location = 10;
  uint32 active_streams = 11;
  
  // Extended metrics (matching HTTP payload)
  string base_url = 12;
  bool is_healthy = 13;
  string event_type = 14;
  int64 timestamp = 15;
  
  // Node capabilities
  NodeCapabilities capabilities = 16;
  
  // Storage information
  StorageInfo storage = 17;
  
  // Node limits and usage
  NodeLimits limits = 18;
  
  // Stream metrics
  map<string, StreamData> streams = 19;
  
  // Stored artifacts
  repeated StoredArtifact artifacts = 20;
  
  // MistServer outputs configuration (parsed from koekjes endpoint)
  string outputs_json = 21;
}

message NodeCapabilities {
  bool ingest = 1;
  bool edge = 2;
  bool storage = 3;
  bool processing = 4;
  repeated string roles = 5;
}

message StorageInfo {
  string local_path = 1;
  string s3_bucket = 2;
  string s3_prefix = 3;
}

message NodeLimits {
  int32 max_transcodes = 1;
  uint64 storage_capacity_bytes = 2;
  uint64 storage_used_bytes = 3;
}

message StreamData {
  uint64 total = 1;          // Total viewers
  uint32 inputs = 2;         // Input count
  uint64 bytes_up = 3;       // Upload bytes
  uint64 bytes_down = 4;     // Download bytes
  uint32 bandwidth = 5;      // Bandwidth per viewer
}

message StoredArtifact {
  // Security: Use opaque identifiers, never expose tenant_id on edge nodes
  string clip_hash = 1;      // Opaque identifier for the clip
  string stream_name = 2;    // Stream name (safe to expose)
  string file_path = 3;      // Local file path on storage node
  string s3_url = 4;         // S3 URL if uploaded to cloud storage
  uint64 size_bytes = 5;     // File size in bytes
  int64 created_at = 6;      // Creation timestamp (Unix seconds)
  string format = 7;         // File format (mp4, webm, etc.)
}

message ClipPullRequest {
  // Security: Use opaque identifiers, never expose tenant_id on edge nodes
  string clip_hash = 1;           // Opaque identifier for the clip
  string stream_name = 2;         // Stream name for MistServer (no tenant info)
  // Timing (one of):
  optional int64 start_unix = 3;   // seconds
  optional int64 stop_unix = 4;    // seconds
  optional int64 start_ms = 5;     // since stream start
  optional int64 stop_ms = 6;      // since stream start
  optional int64 duration_sec = 7; // seconds
  // Output
  string format = 8;              // mp4 default
  string output_name = 9;         // suggested basename
  // Optional explicit Mist HTTP base (e.g., http://node:8080) to pull from
  string source_base_url = 10;
  // Request tracking
  string request_id = 11;         // Unique request ID for tracking
}

message ClipProgress {
  string request_id = 1;
  uint32 percent = 2;        // 0..100
  string message = 3;
}

message ClipDone {
  string request_id = 1;
  string file_path = 2;     // local path on storage node (if applicable)
  string s3_url = 3;        // s3://bucket/key or https URL (if applicable)
  uint64 size_bytes = 4;
  string status = 5;        // success|failed
  string error = 6;         // filled when failed
}

message ControlError {
  string code = 1;
  string message = 2;
}

message Heartbeat {
  string node_id = 1;
}

message StreamHealthUpdate {
  string node_id = 1;
  string stream_name = 2;
  string internal_name = 3;
  bool is_healthy = 4;
  int64 timestamp = 5;
  StreamHealthDetails details = 6;
}

message StreamHealthDetails {
  string buffer_state = 1;        // FULL, EMPTY, DRY, RECOVER
  string status = 2;              // live, offline
  string stream_details = 3;      // JSON string from MistServer
}

message ClipHashRequest {
  string clip_hash = 1;
}

message ClipHashResponse {
  string clip_hash = 1;
  string tenant_id = 2;
  string stream_name = 3;
}

// DVR (Digital Video Recording) messages
message DVRStartRequest {
  string dvr_hash = 1;           // Unique DVR identifier (32-char hex) - generated by Foghorn
  string internal_name = 2;      // Stream internal name (same as stream name)
  string source_base_url = 3;    // DTSC source URL to pull from - filled by Foghorn  
  string request_id = 4;         // Unique request ID for tracking
  DVRConfig config = 5;          // Recording configuration
  string tenant_id = 6;          // Tenant ID for the stream
  string user_id = 7;            // User ID for the stream
}

message DVRConfig {
  bool enabled = 1;              // Whether DVR is enabled
  int32 retention_days = 2;      // How long to keep the recording
  string format = 3;             // ts, mp4, etc.
  int32 segment_duration = 4;    // Segment duration in seconds
}

message DVRProgress {
  string request_id = 1;
  string dvr_hash = 2;           // DVR identifier
  string status = 3;             // recording, segments_available, etc.
  int64 started_at = 4;          // Unix timestamp when recording started
  int32 segment_count = 5;       // Number of segments recorded so far
  uint64 size_bytes = 6;         // Total size of recording so far
  string message = 7;            // Optional progress message
}

message DVRStopped {
  string request_id = 1;
  string dvr_hash = 2;           // DVR identifier
  string status = 3;             // completed, failed, terminated
  string error = 4;              // Error message if failed
  int64 started_at = 5;          // Unix timestamp when recording started
  int64 ended_at = 6;            // Unix timestamp when recording ended
  int32 duration_seconds = 7;    // Total duration of the recording
  uint64 size_bytes = 8;         // Total size of the recording
  string manifest_path = 9;      // Path to the m3u8 manifest for playback
}

message DVRStopRequest {
  string dvr_hash = 1;           // Unique DVR identifier to stop (empty = stop all for internal_name)
  string request_id = 2;         // Request ID for tracking
  optional string internal_name = 3;  // Stream internal name (for stopping all DVR recordings for a stream)
}

message DVRReadyRequest {
  string dvr_hash = 1;           // Which DVR job we're asking about
  string node_id = 2;            // Which storage node is asking
}

message DVRReadyResponse {
  string dvr_hash = 1;           // DVR identifier
  bool ready = 2;                // Is stream ready for pulling?
  string source_uri = 3;         // Full DTSC URI when ready (e.g., "http://ingest-node:8080/stream_name.dtsc")
  DVRConfig config = 4;          // Potentially updated config based on stream characteristics
  string reason = 5;             // If not ready, why? (e.g., "stream_booting", "stream_unhealthy", "stream_offline")
}

