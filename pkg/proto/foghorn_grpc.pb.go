// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.1
// source: foghorn.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ClipControlService_CreateClip_FullMethodName  = "/foghorn.ClipControlService/CreateClip"
	ClipControlService_GetClips_FullMethodName    = "/foghorn.ClipControlService/GetClips"
	ClipControlService_GetClip_FullMethodName     = "/foghorn.ClipControlService/GetClip"
	ClipControlService_GetClipURLs_FullMethodName = "/foghorn.ClipControlService/GetClipURLs"
	ClipControlService_DeleteClip_FullMethodName  = "/foghorn.ClipControlService/DeleteClip"
)

// ClipControlServiceClient is the client API for ClipControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ClipService handles clip creation and management
type ClipControlServiceClient interface {
	// CreateClip creates a new clip from a stream
	CreateClip(ctx context.Context, in *CreateClipRequest, opts ...grpc.CallOption) (*CreateClipResponse, error)
	// GetClips returns all clips for a tenant
	GetClips(ctx context.Context, in *GetClipsRequest, opts ...grpc.CallOption) (*GetClipsResponse, error)
	// GetClip returns a specific clip by hash
	GetClip(ctx context.Context, in *GetClipRequest, opts ...grpc.CallOption) (*ClipInfo, error)
	// GetClipURLs returns viewing URLs for a clip
	GetClipURLs(ctx context.Context, in *GetClipURLsRequest, opts ...grpc.CallOption) (*ClipViewingURLs, error)
	// DeleteClip deletes a clip
	DeleteClip(ctx context.Context, in *DeleteClipRequest, opts ...grpc.CallOption) (*DeleteClipResponse, error)
}

type clipControlServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClipControlServiceClient(cc grpc.ClientConnInterface) ClipControlServiceClient {
	return &clipControlServiceClient{cc}
}

func (c *clipControlServiceClient) CreateClip(ctx context.Context, in *CreateClipRequest, opts ...grpc.CallOption) (*CreateClipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateClipResponse)
	err := c.cc.Invoke(ctx, ClipControlService_CreateClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipControlServiceClient) GetClips(ctx context.Context, in *GetClipsRequest, opts ...grpc.CallOption) (*GetClipsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClipsResponse)
	err := c.cc.Invoke(ctx, ClipControlService_GetClips_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipControlServiceClient) GetClip(ctx context.Context, in *GetClipRequest, opts ...grpc.CallOption) (*ClipInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClipInfo)
	err := c.cc.Invoke(ctx, ClipControlService_GetClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipControlServiceClient) GetClipURLs(ctx context.Context, in *GetClipURLsRequest, opts ...grpc.CallOption) (*ClipViewingURLs, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClipViewingURLs)
	err := c.cc.Invoke(ctx, ClipControlService_GetClipURLs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipControlServiceClient) DeleteClip(ctx context.Context, in *DeleteClipRequest, opts ...grpc.CallOption) (*DeleteClipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteClipResponse)
	err := c.cc.Invoke(ctx, ClipControlService_DeleteClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClipControlServiceServer is the server API for ClipControlService service.
// All implementations must embed UnimplementedClipControlServiceServer
// for forward compatibility.
//
// ClipService handles clip creation and management
type ClipControlServiceServer interface {
	// CreateClip creates a new clip from a stream
	CreateClip(context.Context, *CreateClipRequest) (*CreateClipResponse, error)
	// GetClips returns all clips for a tenant
	GetClips(context.Context, *GetClipsRequest) (*GetClipsResponse, error)
	// GetClip returns a specific clip by hash
	GetClip(context.Context, *GetClipRequest) (*ClipInfo, error)
	// GetClipURLs returns viewing URLs for a clip
	GetClipURLs(context.Context, *GetClipURLsRequest) (*ClipViewingURLs, error)
	// DeleteClip deletes a clip
	DeleteClip(context.Context, *DeleteClipRequest) (*DeleteClipResponse, error)
	mustEmbedUnimplementedClipControlServiceServer()
}

// UnimplementedClipControlServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClipControlServiceServer struct{}

func (UnimplementedClipControlServiceServer) CreateClip(context.Context, *CreateClipRequest) (*CreateClipResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateClip not implemented")
}
func (UnimplementedClipControlServiceServer) GetClips(context.Context, *GetClipsRequest) (*GetClipsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClips not implemented")
}
func (UnimplementedClipControlServiceServer) GetClip(context.Context, *GetClipRequest) (*ClipInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClip not implemented")
}
func (UnimplementedClipControlServiceServer) GetClipURLs(context.Context, *GetClipURLsRequest) (*ClipViewingURLs, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClipURLs not implemented")
}
func (UnimplementedClipControlServiceServer) DeleteClip(context.Context, *DeleteClipRequest) (*DeleteClipResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteClip not implemented")
}
func (UnimplementedClipControlServiceServer) mustEmbedUnimplementedClipControlServiceServer() {}
func (UnimplementedClipControlServiceServer) testEmbeddedByValue()                            {}

// UnsafeClipControlServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClipControlServiceServer will
// result in compilation errors.
type UnsafeClipControlServiceServer interface {
	mustEmbedUnimplementedClipControlServiceServer()
}

func RegisterClipControlServiceServer(s grpc.ServiceRegistrar, srv ClipControlServiceServer) {
	// If the following call panics, it indicates UnimplementedClipControlServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ClipControlService_ServiceDesc, srv)
}

func _ClipControlService_CreateClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipControlServiceServer).CreateClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipControlService_CreateClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipControlServiceServer).CreateClip(ctx, req.(*CreateClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipControlService_GetClips_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClipsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipControlServiceServer).GetClips(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipControlService_GetClips_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipControlServiceServer).GetClips(ctx, req.(*GetClipsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipControlService_GetClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipControlServiceServer).GetClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipControlService_GetClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipControlServiceServer).GetClip(ctx, req.(*GetClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipControlService_GetClipURLs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClipURLsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipControlServiceServer).GetClipURLs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipControlService_GetClipURLs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipControlServiceServer).GetClipURLs(ctx, req.(*GetClipURLsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipControlService_DeleteClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipControlServiceServer).DeleteClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipControlService_DeleteClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipControlServiceServer).DeleteClip(ctx, req.(*DeleteClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClipControlService_ServiceDesc is the grpc.ServiceDesc for ClipControlService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClipControlService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "foghorn.ClipControlService",
	HandlerType: (*ClipControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateClip",
			Handler:    _ClipControlService_CreateClip_Handler,
		},
		{
			MethodName: "GetClips",
			Handler:    _ClipControlService_GetClips_Handler,
		},
		{
			MethodName: "GetClip",
			Handler:    _ClipControlService_GetClip_Handler,
		},
		{
			MethodName: "GetClipURLs",
			Handler:    _ClipControlService_GetClipURLs_Handler,
		},
		{
			MethodName: "DeleteClip",
			Handler:    _ClipControlService_DeleteClip_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "foghorn.proto",
}

const (
	DVRControlService_StartDVR_FullMethodName          = "/foghorn.DVRControlService/StartDVR"
	DVRControlService_StopDVR_FullMethodName           = "/foghorn.DVRControlService/StopDVR"
	DVRControlService_DeleteDVR_FullMethodName         = "/foghorn.DVRControlService/DeleteDVR"
	DVRControlService_GetDVRStatus_FullMethodName      = "/foghorn.DVRControlService/GetDVRStatus"
	DVRControlService_ListDVRRecordings_FullMethodName = "/foghorn.DVRControlService/ListDVRRecordings"
)

// DVRControlServiceClient is the client API for DVRControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DVRControlService handles DVR recording management
type DVRControlServiceClient interface {
	// StartDVR initiates DVR recording for a stream
	StartDVR(ctx context.Context, in *StartDVRRequest, opts ...grpc.CallOption) (*StartDVRResponse, error)
	// StopDVR stops an active DVR recording
	StopDVR(ctx context.Context, in *StopDVRRequest, opts ...grpc.CallOption) (*StopDVRResponse, error)
	// DeleteDVR deletes a DVR recording and its files
	DeleteDVR(ctx context.Context, in *DeleteDVRRequest, opts ...grpc.CallOption) (*DeleteDVRResponse, error)
	// GetDVRStatus returns status of a DVR recording
	GetDVRStatus(ctx context.Context, in *GetDVRStatusRequest, opts ...grpc.CallOption) (*DVRInfo, error)
	// ListDVRRecordings lists all DVR recordings for a tenant
	ListDVRRecordings(ctx context.Context, in *ListDVRRecordingsRequest, opts ...grpc.CallOption) (*ListDVRRecordingsResponse, error)
}

type dVRControlServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDVRControlServiceClient(cc grpc.ClientConnInterface) DVRControlServiceClient {
	return &dVRControlServiceClient{cc}
}

func (c *dVRControlServiceClient) StartDVR(ctx context.Context, in *StartDVRRequest, opts ...grpc.CallOption) (*StartDVRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartDVRResponse)
	err := c.cc.Invoke(ctx, DVRControlService_StartDVR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dVRControlServiceClient) StopDVR(ctx context.Context, in *StopDVRRequest, opts ...grpc.CallOption) (*StopDVRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopDVRResponse)
	err := c.cc.Invoke(ctx, DVRControlService_StopDVR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dVRControlServiceClient) DeleteDVR(ctx context.Context, in *DeleteDVRRequest, opts ...grpc.CallOption) (*DeleteDVRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDVRResponse)
	err := c.cc.Invoke(ctx, DVRControlService_DeleteDVR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dVRControlServiceClient) GetDVRStatus(ctx context.Context, in *GetDVRStatusRequest, opts ...grpc.CallOption) (*DVRInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DVRInfo)
	err := c.cc.Invoke(ctx, DVRControlService_GetDVRStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dVRControlServiceClient) ListDVRRecordings(ctx context.Context, in *ListDVRRecordingsRequest, opts ...grpc.CallOption) (*ListDVRRecordingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDVRRecordingsResponse)
	err := c.cc.Invoke(ctx, DVRControlService_ListDVRRecordings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DVRControlServiceServer is the server API for DVRControlService service.
// All implementations must embed UnimplementedDVRControlServiceServer
// for forward compatibility.
//
// DVRControlService handles DVR recording management
type DVRControlServiceServer interface {
	// StartDVR initiates DVR recording for a stream
	StartDVR(context.Context, *StartDVRRequest) (*StartDVRResponse, error)
	// StopDVR stops an active DVR recording
	StopDVR(context.Context, *StopDVRRequest) (*StopDVRResponse, error)
	// DeleteDVR deletes a DVR recording and its files
	DeleteDVR(context.Context, *DeleteDVRRequest) (*DeleteDVRResponse, error)
	// GetDVRStatus returns status of a DVR recording
	GetDVRStatus(context.Context, *GetDVRStatusRequest) (*DVRInfo, error)
	// ListDVRRecordings lists all DVR recordings for a tenant
	ListDVRRecordings(context.Context, *ListDVRRecordingsRequest) (*ListDVRRecordingsResponse, error)
	mustEmbedUnimplementedDVRControlServiceServer()
}

// UnimplementedDVRControlServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDVRControlServiceServer struct{}

func (UnimplementedDVRControlServiceServer) StartDVR(context.Context, *StartDVRRequest) (*StartDVRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartDVR not implemented")
}
func (UnimplementedDVRControlServiceServer) StopDVR(context.Context, *StopDVRRequest) (*StopDVRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopDVR not implemented")
}
func (UnimplementedDVRControlServiceServer) DeleteDVR(context.Context, *DeleteDVRRequest) (*DeleteDVRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteDVR not implemented")
}
func (UnimplementedDVRControlServiceServer) GetDVRStatus(context.Context, *GetDVRStatusRequest) (*DVRInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDVRStatus not implemented")
}
func (UnimplementedDVRControlServiceServer) ListDVRRecordings(context.Context, *ListDVRRecordingsRequest) (*ListDVRRecordingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDVRRecordings not implemented")
}
func (UnimplementedDVRControlServiceServer) mustEmbedUnimplementedDVRControlServiceServer() {}
func (UnimplementedDVRControlServiceServer) testEmbeddedByValue()                           {}

// UnsafeDVRControlServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DVRControlServiceServer will
// result in compilation errors.
type UnsafeDVRControlServiceServer interface {
	mustEmbedUnimplementedDVRControlServiceServer()
}

func RegisterDVRControlServiceServer(s grpc.ServiceRegistrar, srv DVRControlServiceServer) {
	// If the following call panics, it indicates UnimplementedDVRControlServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DVRControlService_ServiceDesc, srv)
}

func _DVRControlService_StartDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRControlServiceServer).StartDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRControlService_StartDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRControlServiceServer).StartDVR(ctx, req.(*StartDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DVRControlService_StopDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRControlServiceServer).StopDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRControlService_StopDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRControlServiceServer).StopDVR(ctx, req.(*StopDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DVRControlService_DeleteDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRControlServiceServer).DeleteDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRControlService_DeleteDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRControlServiceServer).DeleteDVR(ctx, req.(*DeleteDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DVRControlService_GetDVRStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDVRStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRControlServiceServer).GetDVRStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRControlService_GetDVRStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRControlServiceServer).GetDVRStatus(ctx, req.(*GetDVRStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DVRControlService_ListDVRRecordings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDVRRecordingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRControlServiceServer).ListDVRRecordings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRControlService_ListDVRRecordings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRControlServiceServer).ListDVRRecordings(ctx, req.(*ListDVRRecordingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DVRControlService_ServiceDesc is the grpc.ServiceDesc for DVRControlService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DVRControlService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "foghorn.DVRControlService",
	HandlerType: (*DVRControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartDVR",
			Handler:    _DVRControlService_StartDVR_Handler,
		},
		{
			MethodName: "StopDVR",
			Handler:    _DVRControlService_StopDVR_Handler,
		},
		{
			MethodName: "DeleteDVR",
			Handler:    _DVRControlService_DeleteDVR_Handler,
		},
		{
			MethodName: "GetDVRStatus",
			Handler:    _DVRControlService_GetDVRStatus_Handler,
		},
		{
			MethodName: "ListDVRRecordings",
			Handler:    _DVRControlService_ListDVRRecordings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "foghorn.proto",
}

const (
	ViewerControlService_ResolveViewerEndpoint_FullMethodName = "/foghorn.ViewerControlService/ResolveViewerEndpoint"
	ViewerControlService_GetStreamMeta_FullMethodName         = "/foghorn.ViewerControlService/GetStreamMeta"
)

// ViewerControlServiceClient is the client API for ViewerControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ViewerControlService handles viewer endpoint resolution
type ViewerControlServiceClient interface {
	// ResolveViewerEndpoint resolves the best endpoint(s) for a viewer
	ResolveViewerEndpoint(ctx context.Context, in *ViewerEndpointRequest, opts ...grpc.CallOption) (*ViewerEndpointResponse, error)
	// GetStreamMeta returns MistServer JSON meta for a stream
	GetStreamMeta(ctx context.Context, in *StreamMetaRequest, opts ...grpc.CallOption) (*StreamMetaResponse, error)
}

type viewerControlServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewViewerControlServiceClient(cc grpc.ClientConnInterface) ViewerControlServiceClient {
	return &viewerControlServiceClient{cc}
}

func (c *viewerControlServiceClient) ResolveViewerEndpoint(ctx context.Context, in *ViewerEndpointRequest, opts ...grpc.CallOption) (*ViewerEndpointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ViewerEndpointResponse)
	err := c.cc.Invoke(ctx, ViewerControlService_ResolveViewerEndpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *viewerControlServiceClient) GetStreamMeta(ctx context.Context, in *StreamMetaRequest, opts ...grpc.CallOption) (*StreamMetaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamMetaResponse)
	err := c.cc.Invoke(ctx, ViewerControlService_GetStreamMeta_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ViewerControlServiceServer is the server API for ViewerControlService service.
// All implementations must embed UnimplementedViewerControlServiceServer
// for forward compatibility.
//
// ViewerControlService handles viewer endpoint resolution
type ViewerControlServiceServer interface {
	// ResolveViewerEndpoint resolves the best endpoint(s) for a viewer
	ResolveViewerEndpoint(context.Context, *ViewerEndpointRequest) (*ViewerEndpointResponse, error)
	// GetStreamMeta returns MistServer JSON meta for a stream
	GetStreamMeta(context.Context, *StreamMetaRequest) (*StreamMetaResponse, error)
	mustEmbedUnimplementedViewerControlServiceServer()
}

// UnimplementedViewerControlServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedViewerControlServiceServer struct{}

func (UnimplementedViewerControlServiceServer) ResolveViewerEndpoint(context.Context, *ViewerEndpointRequest) (*ViewerEndpointResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveViewerEndpoint not implemented")
}
func (UnimplementedViewerControlServiceServer) GetStreamMeta(context.Context, *StreamMetaRequest) (*StreamMetaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStreamMeta not implemented")
}
func (UnimplementedViewerControlServiceServer) mustEmbedUnimplementedViewerControlServiceServer() {}
func (UnimplementedViewerControlServiceServer) testEmbeddedByValue()                              {}

// UnsafeViewerControlServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ViewerControlServiceServer will
// result in compilation errors.
type UnsafeViewerControlServiceServer interface {
	mustEmbedUnimplementedViewerControlServiceServer()
}

func RegisterViewerControlServiceServer(s grpc.ServiceRegistrar, srv ViewerControlServiceServer) {
	// If the following call panics, it indicates UnimplementedViewerControlServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ViewerControlService_ServiceDesc, srv)
}

func _ViewerControlService_ResolveViewerEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ViewerEndpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerControlServiceServer).ResolveViewerEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerControlService_ResolveViewerEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerControlServiceServer).ResolveViewerEndpoint(ctx, req.(*ViewerEndpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ViewerControlService_GetStreamMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerControlServiceServer).GetStreamMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerControlService_GetStreamMeta_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerControlServiceServer).GetStreamMeta(ctx, req.(*StreamMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ViewerControlService_ServiceDesc is the grpc.ServiceDesc for ViewerControlService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ViewerControlService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "foghorn.ViewerControlService",
	HandlerType: (*ViewerControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResolveViewerEndpoint",
			Handler:    _ViewerControlService_ResolveViewerEndpoint_Handler,
		},
		{
			MethodName: "GetStreamMeta",
			Handler:    _ViewerControlService_GetStreamMeta_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "foghorn.proto",
}
