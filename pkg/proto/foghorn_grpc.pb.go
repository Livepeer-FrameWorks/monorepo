// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.4
// source: foghorn.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ClipControlService_CreateClip_FullMethodName = "/foghorn.ClipControlService/CreateClip"
	ClipControlService_DeleteClip_FullMethodName = "/foghorn.ClipControlService/DeleteClip"
)

// ClipControlServiceClient is the client API for ClipControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ClipService handles clip creation and management
type ClipControlServiceClient interface {
	// CreateClip creates a new clip from a stream
	CreateClip(ctx context.Context, in *CreateClipRequest, opts ...grpc.CallOption) (*CreateClipResponse, error)
	// DeleteClip deletes a clip
	DeleteClip(ctx context.Context, in *DeleteClipRequest, opts ...grpc.CallOption) (*DeleteClipResponse, error)
}

type clipControlServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClipControlServiceClient(cc grpc.ClientConnInterface) ClipControlServiceClient {
	return &clipControlServiceClient{cc}
}

func (c *clipControlServiceClient) CreateClip(ctx context.Context, in *CreateClipRequest, opts ...grpc.CallOption) (*CreateClipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateClipResponse)
	err := c.cc.Invoke(ctx, ClipControlService_CreateClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipControlServiceClient) DeleteClip(ctx context.Context, in *DeleteClipRequest, opts ...grpc.CallOption) (*DeleteClipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteClipResponse)
	err := c.cc.Invoke(ctx, ClipControlService_DeleteClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClipControlServiceServer is the server API for ClipControlService service.
// All implementations must embed UnimplementedClipControlServiceServer
// for forward compatibility.
//
// ClipService handles clip creation and management
type ClipControlServiceServer interface {
	// CreateClip creates a new clip from a stream
	CreateClip(context.Context, *CreateClipRequest) (*CreateClipResponse, error)
	// DeleteClip deletes a clip
	DeleteClip(context.Context, *DeleteClipRequest) (*DeleteClipResponse, error)
	mustEmbedUnimplementedClipControlServiceServer()
}

// UnimplementedClipControlServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClipControlServiceServer struct{}

func (UnimplementedClipControlServiceServer) CreateClip(context.Context, *CreateClipRequest) (*CreateClipResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateClip not implemented")
}
func (UnimplementedClipControlServiceServer) DeleteClip(context.Context, *DeleteClipRequest) (*DeleteClipResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteClip not implemented")
}
func (UnimplementedClipControlServiceServer) mustEmbedUnimplementedClipControlServiceServer() {}
func (UnimplementedClipControlServiceServer) testEmbeddedByValue()                            {}

// UnsafeClipControlServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClipControlServiceServer will
// result in compilation errors.
type UnsafeClipControlServiceServer interface {
	mustEmbedUnimplementedClipControlServiceServer()
}

func RegisterClipControlServiceServer(s grpc.ServiceRegistrar, srv ClipControlServiceServer) {
	// If the following call panics, it indicates UnimplementedClipControlServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ClipControlService_ServiceDesc, srv)
}

func _ClipControlService_CreateClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipControlServiceServer).CreateClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipControlService_CreateClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipControlServiceServer).CreateClip(ctx, req.(*CreateClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipControlService_DeleteClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipControlServiceServer).DeleteClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipControlService_DeleteClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipControlServiceServer).DeleteClip(ctx, req.(*DeleteClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClipControlService_ServiceDesc is the grpc.ServiceDesc for ClipControlService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClipControlService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "foghorn.ClipControlService",
	HandlerType: (*ClipControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateClip",
			Handler:    _ClipControlService_CreateClip_Handler,
		},
		{
			MethodName: "DeleteClip",
			Handler:    _ClipControlService_DeleteClip_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "foghorn.proto",
}

const (
	DVRControlService_StartDVR_FullMethodName  = "/foghorn.DVRControlService/StartDVR"
	DVRControlService_StopDVR_FullMethodName   = "/foghorn.DVRControlService/StopDVR"
	DVRControlService_DeleteDVR_FullMethodName = "/foghorn.DVRControlService/DeleteDVR"
)

// DVRControlServiceClient is the client API for DVRControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DVRControlService handles DVR recording management
type DVRControlServiceClient interface {
	// StartDVR initiates DVR recording for a stream
	StartDVR(ctx context.Context, in *StartDVRRequest, opts ...grpc.CallOption) (*StartDVRResponse, error)
	// StopDVR stops an active DVR recording
	StopDVR(ctx context.Context, in *StopDVRRequest, opts ...grpc.CallOption) (*StopDVRResponse, error)
	// DeleteDVR deletes a DVR recording and its files
	DeleteDVR(ctx context.Context, in *DeleteDVRRequest, opts ...grpc.CallOption) (*DeleteDVRResponse, error)
}

type dVRControlServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDVRControlServiceClient(cc grpc.ClientConnInterface) DVRControlServiceClient {
	return &dVRControlServiceClient{cc}
}

func (c *dVRControlServiceClient) StartDVR(ctx context.Context, in *StartDVRRequest, opts ...grpc.CallOption) (*StartDVRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartDVRResponse)
	err := c.cc.Invoke(ctx, DVRControlService_StartDVR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dVRControlServiceClient) StopDVR(ctx context.Context, in *StopDVRRequest, opts ...grpc.CallOption) (*StopDVRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopDVRResponse)
	err := c.cc.Invoke(ctx, DVRControlService_StopDVR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dVRControlServiceClient) DeleteDVR(ctx context.Context, in *DeleteDVRRequest, opts ...grpc.CallOption) (*DeleteDVRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDVRResponse)
	err := c.cc.Invoke(ctx, DVRControlService_DeleteDVR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DVRControlServiceServer is the server API for DVRControlService service.
// All implementations must embed UnimplementedDVRControlServiceServer
// for forward compatibility.
//
// DVRControlService handles DVR recording management
type DVRControlServiceServer interface {
	// StartDVR initiates DVR recording for a stream
	StartDVR(context.Context, *StartDVRRequest) (*StartDVRResponse, error)
	// StopDVR stops an active DVR recording
	StopDVR(context.Context, *StopDVRRequest) (*StopDVRResponse, error)
	// DeleteDVR deletes a DVR recording and its files
	DeleteDVR(context.Context, *DeleteDVRRequest) (*DeleteDVRResponse, error)
	mustEmbedUnimplementedDVRControlServiceServer()
}

// UnimplementedDVRControlServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDVRControlServiceServer struct{}

func (UnimplementedDVRControlServiceServer) StartDVR(context.Context, *StartDVRRequest) (*StartDVRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartDVR not implemented")
}
func (UnimplementedDVRControlServiceServer) StopDVR(context.Context, *StopDVRRequest) (*StopDVRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopDVR not implemented")
}
func (UnimplementedDVRControlServiceServer) DeleteDVR(context.Context, *DeleteDVRRequest) (*DeleteDVRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteDVR not implemented")
}
func (UnimplementedDVRControlServiceServer) mustEmbedUnimplementedDVRControlServiceServer() {}
func (UnimplementedDVRControlServiceServer) testEmbeddedByValue()                           {}

// UnsafeDVRControlServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DVRControlServiceServer will
// result in compilation errors.
type UnsafeDVRControlServiceServer interface {
	mustEmbedUnimplementedDVRControlServiceServer()
}

func RegisterDVRControlServiceServer(s grpc.ServiceRegistrar, srv DVRControlServiceServer) {
	// If the following call panics, it indicates UnimplementedDVRControlServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DVRControlService_ServiceDesc, srv)
}

func _DVRControlService_StartDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRControlServiceServer).StartDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRControlService_StartDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRControlServiceServer).StartDVR(ctx, req.(*StartDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DVRControlService_StopDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRControlServiceServer).StopDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRControlService_StopDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRControlServiceServer).StopDVR(ctx, req.(*StopDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DVRControlService_DeleteDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRControlServiceServer).DeleteDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRControlService_DeleteDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRControlServiceServer).DeleteDVR(ctx, req.(*DeleteDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DVRControlService_ServiceDesc is the grpc.ServiceDesc for DVRControlService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DVRControlService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "foghorn.DVRControlService",
	HandlerType: (*DVRControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartDVR",
			Handler:    _DVRControlService_StartDVR_Handler,
		},
		{
			MethodName: "StopDVR",
			Handler:    _DVRControlService_StopDVR_Handler,
		},
		{
			MethodName: "DeleteDVR",
			Handler:    _DVRControlService_DeleteDVR_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "foghorn.proto",
}

const (
	ViewerControlService_ResolveViewerEndpoint_FullMethodName = "/foghorn.ViewerControlService/ResolveViewerEndpoint"
	ViewerControlService_ResolveIngestEndpoint_FullMethodName = "/foghorn.ViewerControlService/ResolveIngestEndpoint"
)

// ViewerControlServiceClient is the client API for ViewerControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ViewerControlService handles viewer and ingest endpoint resolution
type ViewerControlServiceClient interface {
	// ResolveViewerEndpoint resolves the best endpoint(s) for a viewer
	ResolveViewerEndpoint(ctx context.Context, in *ViewerEndpointRequest, opts ...grpc.CallOption) (*ViewerEndpointResponse, error)
	// ResolveIngestEndpoint resolves the best endpoint(s) for StreamCrafter ingest
	ResolveIngestEndpoint(ctx context.Context, in *IngestEndpointRequest, opts ...grpc.CallOption) (*IngestEndpointResponse, error)
}

type viewerControlServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewViewerControlServiceClient(cc grpc.ClientConnInterface) ViewerControlServiceClient {
	return &viewerControlServiceClient{cc}
}

func (c *viewerControlServiceClient) ResolveViewerEndpoint(ctx context.Context, in *ViewerEndpointRequest, opts ...grpc.CallOption) (*ViewerEndpointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ViewerEndpointResponse)
	err := c.cc.Invoke(ctx, ViewerControlService_ResolveViewerEndpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *viewerControlServiceClient) ResolveIngestEndpoint(ctx context.Context, in *IngestEndpointRequest, opts ...grpc.CallOption) (*IngestEndpointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IngestEndpointResponse)
	err := c.cc.Invoke(ctx, ViewerControlService_ResolveIngestEndpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ViewerControlServiceServer is the server API for ViewerControlService service.
// All implementations must embed UnimplementedViewerControlServiceServer
// for forward compatibility.
//
// ViewerControlService handles viewer and ingest endpoint resolution
type ViewerControlServiceServer interface {
	// ResolveViewerEndpoint resolves the best endpoint(s) for a viewer
	ResolveViewerEndpoint(context.Context, *ViewerEndpointRequest) (*ViewerEndpointResponse, error)
	// ResolveIngestEndpoint resolves the best endpoint(s) for StreamCrafter ingest
	ResolveIngestEndpoint(context.Context, *IngestEndpointRequest) (*IngestEndpointResponse, error)
	mustEmbedUnimplementedViewerControlServiceServer()
}

// UnimplementedViewerControlServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedViewerControlServiceServer struct{}

func (UnimplementedViewerControlServiceServer) ResolveViewerEndpoint(context.Context, *ViewerEndpointRequest) (*ViewerEndpointResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveViewerEndpoint not implemented")
}
func (UnimplementedViewerControlServiceServer) ResolveIngestEndpoint(context.Context, *IngestEndpointRequest) (*IngestEndpointResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveIngestEndpoint not implemented")
}
func (UnimplementedViewerControlServiceServer) mustEmbedUnimplementedViewerControlServiceServer() {}
func (UnimplementedViewerControlServiceServer) testEmbeddedByValue()                              {}

// UnsafeViewerControlServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ViewerControlServiceServer will
// result in compilation errors.
type UnsafeViewerControlServiceServer interface {
	mustEmbedUnimplementedViewerControlServiceServer()
}

func RegisterViewerControlServiceServer(s grpc.ServiceRegistrar, srv ViewerControlServiceServer) {
	// If the following call panics, it indicates UnimplementedViewerControlServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ViewerControlService_ServiceDesc, srv)
}

func _ViewerControlService_ResolveViewerEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ViewerEndpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerControlServiceServer).ResolveViewerEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerControlService_ResolveViewerEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerControlServiceServer).ResolveViewerEndpoint(ctx, req.(*ViewerEndpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ViewerControlService_ResolveIngestEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestEndpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerControlServiceServer).ResolveIngestEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerControlService_ResolveIngestEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerControlServiceServer).ResolveIngestEndpoint(ctx, req.(*IngestEndpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ViewerControlService_ServiceDesc is the grpc.ServiceDesc for ViewerControlService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ViewerControlService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "foghorn.ViewerControlService",
	HandlerType: (*ViewerControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResolveViewerEndpoint",
			Handler:    _ViewerControlService_ResolveViewerEndpoint_Handler,
		},
		{
			MethodName: "ResolveIngestEndpoint",
			Handler:    _ViewerControlService_ResolveIngestEndpoint_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "foghorn.proto",
}

const (
	VodControlService_CreateVodUpload_FullMethodName   = "/foghorn.VodControlService/CreateVodUpload"
	VodControlService_CompleteVodUpload_FullMethodName = "/foghorn.VodControlService/CompleteVodUpload"
	VodControlService_AbortVodUpload_FullMethodName    = "/foghorn.VodControlService/AbortVodUpload"
	VodControlService_GetVodAsset_FullMethodName       = "/foghorn.VodControlService/GetVodAsset"
	VodControlService_ListVodAssets_FullMethodName     = "/foghorn.VodControlService/ListVodAssets"
	VodControlService_DeleteVodAsset_FullMethodName    = "/foghorn.VodControlService/DeleteVodAsset"
)

// VodControlServiceClient is the client API for VodControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// VodControlService handles VOD upload management (user-initiated video uploads)
type VodControlServiceClient interface {
	// CreateVodUpload initiates a multipart upload and returns presigned URLs
	CreateVodUpload(ctx context.Context, in *CreateVodUploadRequest, opts ...grpc.CallOption) (*CreateVodUploadResponse, error)
	// CompleteVodUpload finalizes the multipart upload after all parts are uploaded
	CompleteVodUpload(ctx context.Context, in *CompleteVodUploadRequest, opts ...grpc.CallOption) (*CompleteVodUploadResponse, error)
	// AbortVodUpload cancels an in-progress multipart upload
	AbortVodUpload(ctx context.Context, in *AbortVodUploadRequest, opts ...grpc.CallOption) (*AbortVodUploadResponse, error)
	// GetVodAsset returns a single VOD asset by hash
	GetVodAsset(ctx context.Context, in *GetVodAssetRequest, opts ...grpc.CallOption) (*VodAssetInfo, error)
	// ListVodAssets returns paginated list of VOD assets for a tenant
	ListVodAssets(ctx context.Context, in *ListVodAssetsRequest, opts ...grpc.CallOption) (*ListVodAssetsResponse, error)
	// DeleteVodAsset deletes a VOD asset
	DeleteVodAsset(ctx context.Context, in *DeleteVodAssetRequest, opts ...grpc.CallOption) (*DeleteVodAssetResponse, error)
}

type vodControlServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVodControlServiceClient(cc grpc.ClientConnInterface) VodControlServiceClient {
	return &vodControlServiceClient{cc}
}

func (c *vodControlServiceClient) CreateVodUpload(ctx context.Context, in *CreateVodUploadRequest, opts ...grpc.CallOption) (*CreateVodUploadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVodUploadResponse)
	err := c.cc.Invoke(ctx, VodControlService_CreateVodUpload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vodControlServiceClient) CompleteVodUpload(ctx context.Context, in *CompleteVodUploadRequest, opts ...grpc.CallOption) (*CompleteVodUploadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompleteVodUploadResponse)
	err := c.cc.Invoke(ctx, VodControlService_CompleteVodUpload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vodControlServiceClient) AbortVodUpload(ctx context.Context, in *AbortVodUploadRequest, opts ...grpc.CallOption) (*AbortVodUploadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbortVodUploadResponse)
	err := c.cc.Invoke(ctx, VodControlService_AbortVodUpload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vodControlServiceClient) GetVodAsset(ctx context.Context, in *GetVodAssetRequest, opts ...grpc.CallOption) (*VodAssetInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VodAssetInfo)
	err := c.cc.Invoke(ctx, VodControlService_GetVodAsset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vodControlServiceClient) ListVodAssets(ctx context.Context, in *ListVodAssetsRequest, opts ...grpc.CallOption) (*ListVodAssetsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVodAssetsResponse)
	err := c.cc.Invoke(ctx, VodControlService_ListVodAssets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vodControlServiceClient) DeleteVodAsset(ctx context.Context, in *DeleteVodAssetRequest, opts ...grpc.CallOption) (*DeleteVodAssetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteVodAssetResponse)
	err := c.cc.Invoke(ctx, VodControlService_DeleteVodAsset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VodControlServiceServer is the server API for VodControlService service.
// All implementations must embed UnimplementedVodControlServiceServer
// for forward compatibility.
//
// VodControlService handles VOD upload management (user-initiated video uploads)
type VodControlServiceServer interface {
	// CreateVodUpload initiates a multipart upload and returns presigned URLs
	CreateVodUpload(context.Context, *CreateVodUploadRequest) (*CreateVodUploadResponse, error)
	// CompleteVodUpload finalizes the multipart upload after all parts are uploaded
	CompleteVodUpload(context.Context, *CompleteVodUploadRequest) (*CompleteVodUploadResponse, error)
	// AbortVodUpload cancels an in-progress multipart upload
	AbortVodUpload(context.Context, *AbortVodUploadRequest) (*AbortVodUploadResponse, error)
	// GetVodAsset returns a single VOD asset by hash
	GetVodAsset(context.Context, *GetVodAssetRequest) (*VodAssetInfo, error)
	// ListVodAssets returns paginated list of VOD assets for a tenant
	ListVodAssets(context.Context, *ListVodAssetsRequest) (*ListVodAssetsResponse, error)
	// DeleteVodAsset deletes a VOD asset
	DeleteVodAsset(context.Context, *DeleteVodAssetRequest) (*DeleteVodAssetResponse, error)
	mustEmbedUnimplementedVodControlServiceServer()
}

// UnimplementedVodControlServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVodControlServiceServer struct{}

func (UnimplementedVodControlServiceServer) CreateVodUpload(context.Context, *CreateVodUploadRequest) (*CreateVodUploadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateVodUpload not implemented")
}
func (UnimplementedVodControlServiceServer) CompleteVodUpload(context.Context, *CompleteVodUploadRequest) (*CompleteVodUploadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CompleteVodUpload not implemented")
}
func (UnimplementedVodControlServiceServer) AbortVodUpload(context.Context, *AbortVodUploadRequest) (*AbortVodUploadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AbortVodUpload not implemented")
}
func (UnimplementedVodControlServiceServer) GetVodAsset(context.Context, *GetVodAssetRequest) (*VodAssetInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVodAsset not implemented")
}
func (UnimplementedVodControlServiceServer) ListVodAssets(context.Context, *ListVodAssetsRequest) (*ListVodAssetsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListVodAssets not implemented")
}
func (UnimplementedVodControlServiceServer) DeleteVodAsset(context.Context, *DeleteVodAssetRequest) (*DeleteVodAssetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteVodAsset not implemented")
}
func (UnimplementedVodControlServiceServer) mustEmbedUnimplementedVodControlServiceServer() {}
func (UnimplementedVodControlServiceServer) testEmbeddedByValue()                           {}

// UnsafeVodControlServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VodControlServiceServer will
// result in compilation errors.
type UnsafeVodControlServiceServer interface {
	mustEmbedUnimplementedVodControlServiceServer()
}

func RegisterVodControlServiceServer(s grpc.ServiceRegistrar, srv VodControlServiceServer) {
	// If the following call panics, it indicates UnimplementedVodControlServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VodControlService_ServiceDesc, srv)
}

func _VodControlService_CreateVodUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVodUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VodControlServiceServer).CreateVodUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VodControlService_CreateVodUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VodControlServiceServer).CreateVodUpload(ctx, req.(*CreateVodUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VodControlService_CompleteVodUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteVodUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VodControlServiceServer).CompleteVodUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VodControlService_CompleteVodUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VodControlServiceServer).CompleteVodUpload(ctx, req.(*CompleteVodUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VodControlService_AbortVodUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbortVodUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VodControlServiceServer).AbortVodUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VodControlService_AbortVodUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VodControlServiceServer).AbortVodUpload(ctx, req.(*AbortVodUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VodControlService_GetVodAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVodAssetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VodControlServiceServer).GetVodAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VodControlService_GetVodAsset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VodControlServiceServer).GetVodAsset(ctx, req.(*GetVodAssetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VodControlService_ListVodAssets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVodAssetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VodControlServiceServer).ListVodAssets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VodControlService_ListVodAssets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VodControlServiceServer).ListVodAssets(ctx, req.(*ListVodAssetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VodControlService_DeleteVodAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVodAssetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VodControlServiceServer).DeleteVodAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VodControlService_DeleteVodAsset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VodControlServiceServer).DeleteVodAsset(ctx, req.(*DeleteVodAssetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VodControlService_ServiceDesc is the grpc.ServiceDesc for VodControlService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VodControlService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "foghorn.VodControlService",
	HandlerType: (*VodControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVodUpload",
			Handler:    _VodControlService_CreateVodUpload_Handler,
		},
		{
			MethodName: "CompleteVodUpload",
			Handler:    _VodControlService_CompleteVodUpload_Handler,
		},
		{
			MethodName: "AbortVodUpload",
			Handler:    _VodControlService_AbortVodUpload_Handler,
		},
		{
			MethodName: "GetVodAsset",
			Handler:    _VodControlService_GetVodAsset_Handler,
		},
		{
			MethodName: "ListVodAssets",
			Handler:    _VodControlService_ListVodAssets_Handler,
		},
		{
			MethodName: "DeleteVodAsset",
			Handler:    _VodControlService_DeleteVodAsset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "foghorn.proto",
}

const (
	TenantControlService_TerminateTenantStreams_FullMethodName = "/foghorn.TenantControlService/TerminateTenantStreams"
	TenantControlService_InvalidateTenantCache_FullMethodName  = "/foghorn.TenantControlService/InvalidateTenantCache"
)

// TenantControlServiceClient is the client API for TenantControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// TenantControlService handles tenant-level operations called by Purser
type TenantControlServiceClient interface {
	// TerminateTenantStreams stops all active streams for a tenant (called when suspended)
	TerminateTenantStreams(ctx context.Context, in *TerminateTenantStreamsRequest, opts ...grpc.CallOption) (*TerminateTenantStreamsResponse, error)
	// InvalidateTenantCache clears cached suspension status for a tenant (called on reactivation)
	InvalidateTenantCache(ctx context.Context, in *InvalidateTenantCacheRequest, opts ...grpc.CallOption) (*InvalidateTenantCacheResponse, error)
}

type tenantControlServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTenantControlServiceClient(cc grpc.ClientConnInterface) TenantControlServiceClient {
	return &tenantControlServiceClient{cc}
}

func (c *tenantControlServiceClient) TerminateTenantStreams(ctx context.Context, in *TerminateTenantStreamsRequest, opts ...grpc.CallOption) (*TerminateTenantStreamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminateTenantStreamsResponse)
	err := c.cc.Invoke(ctx, TenantControlService_TerminateTenantStreams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantControlServiceClient) InvalidateTenantCache(ctx context.Context, in *InvalidateTenantCacheRequest, opts ...grpc.CallOption) (*InvalidateTenantCacheResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InvalidateTenantCacheResponse)
	err := c.cc.Invoke(ctx, TenantControlService_InvalidateTenantCache_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantControlServiceServer is the server API for TenantControlService service.
// All implementations must embed UnimplementedTenantControlServiceServer
// for forward compatibility.
//
// TenantControlService handles tenant-level operations called by Purser
type TenantControlServiceServer interface {
	// TerminateTenantStreams stops all active streams for a tenant (called when suspended)
	TerminateTenantStreams(context.Context, *TerminateTenantStreamsRequest) (*TerminateTenantStreamsResponse, error)
	// InvalidateTenantCache clears cached suspension status for a tenant (called on reactivation)
	InvalidateTenantCache(context.Context, *InvalidateTenantCacheRequest) (*InvalidateTenantCacheResponse, error)
	mustEmbedUnimplementedTenantControlServiceServer()
}

// UnimplementedTenantControlServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTenantControlServiceServer struct{}

func (UnimplementedTenantControlServiceServer) TerminateTenantStreams(context.Context, *TerminateTenantStreamsRequest) (*TerminateTenantStreamsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TerminateTenantStreams not implemented")
}
func (UnimplementedTenantControlServiceServer) InvalidateTenantCache(context.Context, *InvalidateTenantCacheRequest) (*InvalidateTenantCacheResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InvalidateTenantCache not implemented")
}
func (UnimplementedTenantControlServiceServer) mustEmbedUnimplementedTenantControlServiceServer() {}
func (UnimplementedTenantControlServiceServer) testEmbeddedByValue()                              {}

// UnsafeTenantControlServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TenantControlServiceServer will
// result in compilation errors.
type UnsafeTenantControlServiceServer interface {
	mustEmbedUnimplementedTenantControlServiceServer()
}

func RegisterTenantControlServiceServer(s grpc.ServiceRegistrar, srv TenantControlServiceServer) {
	// If the following call panics, it indicates UnimplementedTenantControlServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TenantControlService_ServiceDesc, srv)
}

func _TenantControlService_TerminateTenantStreams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateTenantStreamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantControlServiceServer).TerminateTenantStreams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantControlService_TerminateTenantStreams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantControlServiceServer).TerminateTenantStreams(ctx, req.(*TerminateTenantStreamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantControlService_InvalidateTenantCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvalidateTenantCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantControlServiceServer).InvalidateTenantCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantControlService_InvalidateTenantCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantControlServiceServer).InvalidateTenantCache(ctx, req.(*InvalidateTenantCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TenantControlService_ServiceDesc is the grpc.ServiceDesc for TenantControlService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TenantControlService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "foghorn.TenantControlService",
	HandlerType: (*TenantControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TerminateTenantStreams",
			Handler:    _TenantControlService_TerminateTenantStreams_Handler,
		},
		{
			MethodName: "InvalidateTenantCache",
			Handler:    _TenantControlService_InvalidateTenantCache_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "foghorn.proto",
}
