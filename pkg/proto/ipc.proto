syntax = "proto3";

package helmsmancontrol;

option go_package = "frameworks/pkg/proto";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

// Coarse geospatial bucket (H3 index + resolution)
message GeoBucket {
  uint64 h3_index = 1;   // H3 cell id encoded as uint64
  uint32 resolution = 2; // H3 resolution (e.g., 5)
}

// Bidirectional control channel between Helmsman (client) and Foghorn (server)
// Helmsman dials Foghorn and sends Register/NodeLifecycleUpdate; Foghorn sends ClipPullRequest

service HelmsmanControl {
  rpc Connect(stream ControlMessage) returns (stream ControlMessage);
  rpc ResolveClipHash(ClipHashRequest) returns (ClipHashResponse);
}

// Service for sending events to Decklog (Foghorn -> Decklog/api_firehose)
// - MistTrigger: media-plane analytics/events
// - ServiceEvent: service-plane telemetry (API usage, messaging, etc.)
// All producers MUST preserve the original payload (no rewriting).
service DecklogService {
  // Unified entrypoint for all events (unary is fine for now).
  rpc SendEvent(MistTrigger) returns (google.protobuf.Empty);
  // Service-plane events (non-media).
  rpc SendServiceEvent(ServiceEvent) returns (google.protobuf.Empty);
}

// ServiceEvent represents service-level telemetry emitted by core services.
message ServiceEvent {
  string event_id = 1;
  string event_type = 2;
  google.protobuf.Timestamp timestamp = 3;
  string source = 4;
  string tenant_id = 5;
  string user_id = 6;
  string resource_type = 7;
  string resource_id = 8;
  oneof payload {
    APIRequestBatch api_request_batch = 20;
    AuthEvent auth_event = 21;
    TenantEvent tenant_event = 22;
    ClusterEvent cluster_event = 23;
    StreamChangeEvent stream_change_event = 24;
    StreamKeyEvent stream_key_event = 25;
    BillingEvent billing_event = 26;
    MessageLifecycleData support_event = 27;
    ArtifactEvent artifact_event = 28;
  }
}

message AuthEvent {
  string user_id = 1;
  string tenant_id = 2;
  string auth_type = 3;
  string wallet_id = 4;
  string token_id = 5;
  string error = 6;
  string ip_bucket = 7;
}

message TenantEvent {
  string tenant_id = 1;
  repeated string changed_fields = 2;
}

message ClusterEvent {
  string cluster_id = 1;
  string tenant_id = 2;
  string invite_id = 3;
  string subscription_id = 4;
  string reason = 5;
}

// StreamChangeEvent signals that a stream's metadata was updated.
// Used by Signalman subscriptions for real-time change notifications.
message StreamChangeEvent {
  string stream_id = 1;
  repeated string changed_fields = 2;
}

message StreamKeyEvent {
  string stream_id = 1;
  string key_id = 2;
}

message BillingEvent {
  string tenant_id = 1;
  string payment_id = 2;
  string subscription_id = 3;
  string invoice_id = 4;
  string topup_id = 5;
  double amount = 6;
  string currency = 7;
  string provider = 8;
  string status = 9;
}

// ArtifactEvent represents audit/lifecycle events for clip/DVR/VOD artifacts.
message ArtifactEvent {
  enum ArtifactType {
    ARTIFACT_TYPE_UNSPECIFIED = 0;
    ARTIFACT_TYPE_CLIP = 1;
    ARTIFACT_TYPE_DVR = 2;
    ARTIFACT_TYPE_VOD = 3;
  }
  ArtifactType artifact_type = 1;
  string artifact_id = 2;          // clip_hash, dvr_hash, or vod_hash
  string stream_id = 3;            // Public stream ID (UUID), when applicable
  string status = 4;               // requested, started, processing, completed, failed, deleted, etc.
  optional int64 started_at = 5;   // Unix timestamp (if available)
  optional int64 completed_at = 6; // Unix timestamp (if available)
  optional int64 expires_at = 7;   // Retention expiration (if available)
}

message ControlMessage {
  string request_id = 1; // Correlates requests/responses
  google.protobuf.Timestamp sent_at = 2;
  oneof payload {
    Register register = 10;
    ClipPullRequest clip_pull_request = 12;
    ClipProgress clip_progress = 13;
    ClipDone clip_done = 14;
    ControlError error = 15;
    Heartbeat heartbeat = 16;
    DVRStartRequest dvr_start_request = 18;
    DVRProgress dvr_progress = 19;
    DVRStopped dvr_stopped = 20;
    DVRStopRequest dvr_stop_request = 21;
    DVRReadyRequest dvr_ready_request = 22;
    DVRReadyResponse dvr_ready_response = 23;
    MistTrigger mist_trigger = 24;
    MistTriggerResponse mist_trigger_response = 25;
    ConfigSeed config_seed = 29;
    ArtifactDeleted artifact_deleted = 30;
    ClipDeleteRequest clip_delete = 31;
    DVRDeleteRequest dvr_delete = 32;
    // Cold storage (S3) operations
    FreezePermissionRequest freeze_permission_request = 40;
    FreezePermissionResponse freeze_permission_response = 41;
    FreezeProgress freeze_progress = 42;
    FreezeComplete freeze_complete = 43;
    DefrostRequest defrost_request = 44;
    DefrostProgress defrost_progress = 45;
    DefrostComplete defrost_complete = 46;
    // Dual-storage sync operations (sync to S3 while keeping local)
    CanDeleteRequest can_delete_request = 47;
    CanDeleteResponse can_delete_response = 48;
    SyncComplete sync_complete = 49;
    // Incremental .dtsh sync (Foghorn -> Helmsman)
    DtshSyncRequest dtsh_sync_request = 50;
    // Transcode job operations (Foghorn <-> Helmsman)
    TranscodeJobRequest transcode_job_request = 60;
    TranscodeJobProgress transcode_job_progress = 61;
    TranscodeJobComplete transcode_job_complete = 62;
    // Session termination (Foghorn -> Helmsman for billing suspension)
    StopSessionsRequest stop_sessions_request = 70;
  }
}

// StopSessionsRequest tells Helmsman to stop all sessions for the given streams
// Used when a tenant is suspended due to insufficient balance
message StopSessionsRequest {
  repeated string stream_names = 1; // Internal stream names to stop
  string tenant_id = 2;             // For logging/audit
  string reason = 3;                // e.g., "insufficient_balance", "suspended"
}

message ArtifactDeleted {
  string clip_hash = 1;
  string file_path = 2;
  string reason = 3; // "cleanup", "expired", "manual"
  string node_id = 4;
  uint64 size_bytes = 5;
}

message Register {
  string node_id = 1;
  repeated string roles = 2; // e.g., ingest, edge, storage, processing
  bool cap_ingest = 3;
  bool cap_edge = 4;
  bool cap_storage = 5;
  bool cap_processing = 6;
  // Storage hints
  string storage_local = 7;
  string storage_bucket = 8;
  string storage_prefix = 9;
  // Edge enrollment token (optional). Sent by Helmsman on first connect for Foghorn to enroll the node with Quartermaster.
  string enrollment_token = 10;
  // Optional stable fingerprint signals to aid node identity resolution.
  // Do not include volatile/process-specific values. Client-provided; server will add peer_ip & Geo.
  NodeFingerprint fingerprint = 11;
  // Hardware specs detected at startup (for load balancing and capacity planning)
  optional int32 cpu_cores = 12;      // Detected CPU cores (runtime.NumCPU)
  optional int32 memory_gb = 13;      // Total RAM in GB
  optional int32 disk_gb = 14;        // Total disk capacity in GB
}

// NodeFingerprint carries stable identity hints from Helmsman.
message NodeFingerprint {
  // Local interface IPs (best-effort). Helps disambiguate nodes behind NAT.
  repeated string local_ipv4 = 1;
  repeated string local_ipv6 = 2;
  // Deterministic aggregate hash of MAC addresses (sorted, lowercase, SHA-256 hex).
  // Avoids exposing raw MACs while remaining stable.
  optional string macs_sha256 = 3;
  // Optional machine-id hash when available (e.g., /etc/machine-id), SHA-256 hex.
  optional string machine_id_sha256 = 4;
}

message ClipPullRequest {
  // Security: Use opaque identifiers, never expose tenant_id on edge nodes
  string clip_hash = 1;           // Opaque identifier for the clip
  string stream_name = 2;         // Stream name for MistServer (no tenant info)
  // Timing (one of):
  optional int64 start_unix = 3;   // seconds
  optional int64 stop_unix = 4;    // seconds
  optional int64 start_ms = 5;     // since stream start
  optional int64 stop_ms = 6;      // since stream start
  optional int64 duration_sec = 7; // seconds
  // Output
  string format = 8;              // mp4 default
  string output_name = 9;         // suggested basename
  // Optional explicit Mist HTTP base (e.g., http://node:8080) to pull from
  string source_base_url = 10;
  // Request tracking
  string request_id = 11;         // Unique request ID for tracking
}

message ClipProgress {
  string request_id = 1;
  uint32 percent = 2;        // 0..100
  string message = 3;
}

message ClipDone {
  string request_id = 1;
  string file_path = 2;     // local path on storage node (if applicable)
  string s3_url = 3;        // s3://bucket/key or https URL (if applicable)
  uint64 size_bytes = 4;
  string status = 5;        // success|failed
  string error = 6;         // filled when failed
}

message ControlError {
  string code = 1;
  string message = 2;
}

message Heartbeat {
  string node_id = 1;
}

message MistTrigger {
  string trigger_type = 1;    // e.g., PUSH_REWRITE, PLAY_REWRITE, VIEWER_CONNECT, STREAM_BUFFER
  string node_id = 3;         // Node that received the trigger
  int64 timestamp = 4;        // When trigger was received
  bool blocking = 5;          // Does this trigger need a response from Foghorn?
  string request_id = 6;      // For correlating responses
  optional string tenant_id = 7; // Tenant context (enriched by Foghorn)
  optional string user_id = 8;   // User context (enriched by Foghorn)
  optional string stream_id = 9; // Public stream ID (enriched by Foghorn)

  // Typed trigger payloads (one of these will be set based on trigger_type)
  oneof trigger_payload {
    PushRewriteTrigger push_rewrite = 10;
    ViewerResolveTrigger play_rewrite = 11;          // formerly DefaultStreamTrigger
    StreamSourceTrigger stream_source = 12;            // VOD source resolution
    PushOutStartTrigger push_out_start = 13;
    PushEndTrigger push_end = 14;
    ViewerConnectTrigger viewer_connect = 15;          // formerly UserNewTrigger
    ViewerDisconnectTrigger viewer_disconnect = 16;    // formerly UserEndTrigger
    StreamBufferTrigger stream_buffer = 17;
    StreamEndTrigger stream_end = 18;
    StreamTrackListTrigger track_list = 19;            // formerly LiveTrackListTrigger
    RecordingCompleteTrigger recording_complete = 21;  // formerly RecordingEndTrigger
    StreamLifecycleUpdate stream_lifecycle_update = 22;
    ClientLifecycleUpdate client_lifecycle_update = 23;
    NodeLifecycleUpdate node_lifecycle_update = 24;
    LoadBalancingData load_balancing_data = 25;
    ClipLifecycleData clip_lifecycle_data = 26;
    DVRLifecycleData dvr_lifecycle_data = 27;
    StorageSnapshot storage_snapshot = 28;
    StorageLifecycleData storage_lifecycle_data = 29;
    RecordingSegmentTrigger recording_segment = 30;
    ProcessBillingEvent process_billing = 31;
    VodLifecycleData vod_lifecycle_data = 32;
    APIRequestBatch api_request_batch = 34;
    MessageLifecycleData message_lifecycle_data = 35;
  }

  optional string cluster_id = 33; // Emitting cluster identifier

  reserved 20;               // Legacy: removed stream_bandwidth field
  reserved "stream_bandwidth";
}

message MistTriggerResponse {
  string request_id = 1;      // Correlates to MistTrigger.request_id
  string response = 2;        // What to return to MistServer (empty string aborts for blocking triggers)
  bool abort = 3;             // Explicit abort flag
}

message StorageSnapshot {
  string node_id = 1;
  int64 timestamp = 2;
  optional string tenant_id = 3; // Node Owner (Supplier)
  optional string location = 4;
  optional NodeCapabilities capabilities = 5;
  repeated TenantStorageUsage usage = 6;
  // hot = node-local cache, cold = S3 (frozen) totals
  optional string storage_scope = 7;
}

message TenantStorageUsage {
  string tenant_id = 1; // Resource Consumer
  uint64 total_bytes = 2;
  uint32 file_count = 3;
  uint64 dvr_bytes = 4;
  uint64 clip_bytes = 5;
  uint64 vod_bytes = 6;
  // Frozen storage breakdown (cold storage in S3)
  uint64 frozen_dvr_bytes = 7;
  uint64 frozen_clip_bytes = 8;
  uint64 frozen_vod_bytes = 9;
}

message ClipHashRequest {
  string clip_hash = 1;
}

message ClipHashResponse {
  string clip_hash = 1;
  string tenant_id = 2;
  string stream_name = 3;
}

// DVR (Digital Video Recording) messages
message DVRStartRequest {
  string dvr_hash = 1;           // Unique DVR identifier (32-char hex) - generated by Foghorn
  string internal_name = 2;      // Stream internal name (same as stream name)
  string source_base_url = 3;    // DTSC source URL to pull from - filled by Foghorn  
  string request_id = 4;         // Unique request ID for tracking
  DVRConfig config = 5;          // Recording configuration
  string tenant_id = 6;          // Tenant ID for the stream
  string user_id = 7;            // User ID for the stream
}

message DVRConfig {
  bool enabled = 1;              // Whether DVR is enabled
  int32 retention_days = 2;      // How long to keep the recording
  string format = 3;             // ts, mp4, etc.
  int32 segment_duration = 4;    // Segment duration in seconds
}

message DVRProgress {
  string request_id = 1;
  string dvr_hash = 2;           // DVR identifier
  string status = 3;             // recording, segments_available, etc.
  int64 started_at = 4;          // Unix timestamp when recording started
  int32 segment_count = 5;       // Number of segments recorded so far
  uint64 size_bytes = 6;         // Total size of recording so far
  string message = 7;            // Optional progress message
}

message DVRStopped {
  string request_id = 1;
  string dvr_hash = 2;           // DVR identifier
  string status = 3;             // completed, failed, terminated
  string error = 4;              // Error message if failed
  int64 started_at = 5;          // Unix timestamp when recording started
  int64 ended_at = 6;            // Unix timestamp when recording ended
  int32 duration_seconds = 7;    // Total duration of the recording
  uint64 size_bytes = 8;         // Total size of the recording
  string manifest_path = 9;      // Path to the m3u8 manifest for playback
}

message DVRStopRequest {
  string dvr_hash = 1;           // Unique DVR identifier to stop (empty = stop all for internal_name)
  string request_id = 2;         // Request ID for tracking
  optional string internal_name = 3;  // Stream internal name (for stopping all DVR recordings for a stream)
}

// ClipDeleteRequest tells Helmsman to delete clip files from storage
message ClipDeleteRequest {
  string clip_hash = 1;          // Clip identifier to delete
  string request_id = 2;         // Request ID for tracking
}

// DVRDeleteRequest tells Helmsman to delete DVR recording files from storage
message DVRDeleteRequest {
  string dvr_hash = 1;           // DVR identifier to delete
  string request_id = 2;         // Request ID for tracking
}

// FreezePermissionRequest is sent by Helmsman to request presigned URLs for freezing.
// Helmsman detects storage pressure but cannot access S3 directly.
message FreezePermissionRequest {
  string request_id = 1;
  string asset_type = 2;         // "clip" or "dvr"
  string asset_hash = 3;         // clip_hash or dvr_hash
  string local_path = 4;         // Local path to the asset
  uint64 size_bytes = 5;         // Size of the asset to freeze
  string node_id = 6;            // Node requesting the freeze
  repeated string filenames = 7; // For DVR: list of relative filenames to upload (e.g., "segments/0_0.ts")
}

// FreezePermissionResponse is sent by Foghorn with presigned URLs for freezing.
// If approved=false, Helmsman should not proceed (asset may be in use, etc.)
message FreezePermissionResponse {
  string request_id = 1;
  string asset_hash = 2;
  bool approved = 3;             // Whether freeze is approved
  string presigned_put_url = 4;  // Presigned PUT URL (only if approved)
  int64 url_expiry_seconds = 5;  // URL expiry time
  string reason = 6;             // Reason if not approved
  // For DVR: map of relative path -> presigned PUT URL
  map<string, string> segment_urls = 7;
}

// Storage location enum for cold storage tracking
enum StorageLocation {
  STORAGE_LOCATION_UNSPECIFIED = 0;
  STORAGE_LOCATION_LOCAL = 1;      // Asset is on local storage only
  STORAGE_LOCATION_S3 = 2;         // Asset is on S3 only (frozen)
  STORAGE_LOCATION_FREEZING = 3;   // Asset is being uploaded to S3
  STORAGE_LOCATION_DEFROSTING = 4; // Asset is being downloaded from S3
}

// FreezeRequest tells Helmsman to upload an asset to S3 cold storage.
// Foghorn generates presigned URLs - Helmsman never sees S3 credentials.
message FreezeRequest {
  string request_id = 1;         // Request ID for tracking
  string asset_type = 2;         // "clip" or "dvr"
  string asset_hash = 3;         // clip_hash or dvr_hash
  string tenant_id = 4;          // Tenant owning the asset
  string internal_name = 5;      // Stream internal name
  string local_path = 6;         // Current local file/directory path
  string presigned_put_url = 7;  // Presigned PUT URL for upload (time-limited, no creds needed)
  bool delete_after_upload = 8;  // Delete local copy after successful upload
  int64 url_expiry_seconds = 9;  // When the presigned URL expires
}

// FreezeProgress reports upload progress for freezing operations
message FreezeProgress {
  string request_id = 1;
  string asset_hash = 2;
  uint32 percent = 3;            // 0..100
  uint64 bytes_uploaded = 4;
  string message = 5;
}

// FreezeComplete indicates freeze operation has finished
message FreezeComplete {
  string request_id = 1;
  string asset_hash = 2;
  string status = 3;             // "success" or "failed"
  string s3_url = 4;             // Full S3 URL (s3://bucket/key)
  uint64 size_bytes = 5;
  string error = 6;              // Error message if failed
}

// DefrostRequest tells Helmsman to download an asset from S3 cold storage.
// Foghorn generates presigned URLs - Helmsman never sees S3 credentials.
message DefrostRequest {
  string request_id = 1;         // Request ID for tracking
  string asset_type = 2;         // "clip" or "dvr"
  string asset_hash = 3;         // clip_hash or dvr_hash
  string tenant_id = 4;          // Tenant owning the asset
  string internal_name = 5;      // Stream internal name
  string presigned_get_url = 6;  // Presigned GET URL for download (time-limited, no creds needed)
  string local_path = 7;         // Target local file/directory path
  int32 timeout_seconds = 8;     // Max wait time for blocking defrost (0 = default 30s)
  bool streaming = 9;            // For DVR: use streaming defrost (HLS live mode)
  int64 url_expiry_seconds = 10; // When the presigned URL expires
  // For DVR streaming defrost: map of segment filename -> presigned URL
  map<string, string> segment_urls = 11;
}

// DefrostProgress reports download progress for defrosting operations
message DefrostProgress {
  string request_id = 1;
  string asset_hash = 2;
  uint32 percent = 3;            // 0..100
  uint64 bytes_downloaded = 4;
  int32 segments_downloaded = 5; // For DVR streaming defrost
  int32 total_segments = 6;      // For DVR streaming defrost
  string message = 7;
}

// DefrostComplete indicates defrost operation has finished
message DefrostComplete {
  string request_id = 1;
  string asset_hash = 2;
  string status = 3;             // "success", "failed", "ready" (for streaming DVR)
  string local_path = 4;         // Local file/directory path
  uint64 size_bytes = 5;
  string error = 6;              // Error message if failed
  string node_id = 7;            // Node that now has a cached copy (for multi-node tracking)
}

// CanDeleteRequest is sent by Helmsman to check if a local asset can be safely deleted.
// Under dual-storage model, deletion is only safe if the asset is synced to S3.
message CanDeleteRequest {
  string asset_hash = 1;         // clip_hash or dvr_hash
  string node_id = 2;            // Node asking to delete
}

// CanDeleteResponse tells Helmsman whether local deletion is safe
message CanDeleteResponse {
  string asset_hash = 1;
  bool safe_to_delete = 2;       // True if asset is synced to S3
  string reason = 3;             // "synced", "sync_pending", "sync_failed", "not_found"
  int64 warm_duration_ms = 4;    // How long asset was cached (for EVICTED lifecycle events)
}

// SyncComplete indicates a sync (upload to S3 while keeping local) has finished.
// Semantically different from FreezeComplete: sync keeps local copy.
message SyncComplete {
  string request_id = 1;
  string asset_hash = 2;
  string status = 3;             // "success" or "failed"
  string s3_url = 4;             // Full S3 URL (s3://bucket/key)
  uint64 size_bytes = 5;
  string error = 6;              // Error message if failed
  string node_id = 7;            // Node that initiated the sync
  bool dtsh_included = 8;        // True if .dtsh index file was included in sync
}

// DtshSyncRequest is sent by Foghorn to Helmsman to request uploading just the .dtsh file.
// This is used when .dtsh appeared after the main asset was already synced to S3.
message DtshSyncRequest {
  string request_id = 1;         // Request ID for tracking
  string asset_type = 2;         // "clip" or "dvr"
  string asset_hash = 3;         // clip_hash or dvr_hash
  string local_path = 4;         // Path to the main asset (append .dtsh for clip, or directory for DVR)
  string presigned_put_url = 5;  // Presigned PUT URL for uploading the .dtsh file
  int64 url_expiry_seconds = 6;  // When the presigned URL expires
  // For DVR: map of .dtsh filename -> presigned URL (since DVR can have multiple .dtsh files)
  map<string, string> dtsh_urls = 7;
}

// StorageLifecycleData is emitted for analytics/observability of storage sync operations
// Dual-storage model: S3 is authoritative backup, local disk is cache
message StorageLifecycleData {
  enum Action {
    ACTION_UNSPECIFIED = 0;
    ACTION_SYNC_STARTED = 1;  // Upload to S3 started (local copy retained)
    ACTION_SYNCED = 2;        // Upload to S3 completed (local copy retained)
    ACTION_EVICTED = 3;       // Local copy deleted (S3 has authoritative copy)
    ACTION_CACHE_STARTED = 4; // Download from S3 started (refilling local cache)
    ACTION_CACHED = 5;        // Downloaded from S3 to local cache (S3 copy retained)
    ACTION_DELETED = 6;       // Asset deleted from both S3 and local (permanent removal)
  }
  Action action = 1;
  string asset_type = 2;         // "clip" or "dvr"
  string asset_hash = 3;         // clip_hash or dvr_hash
  optional string tenant_id = 4;
  optional string internal_name = 5;
  optional string stream_id = 13;      // Enriched by Foghorn (UUID)
  uint64 size_bytes = 6;
  optional string s3_url = 7;
  optional string local_path = 8;
  optional string node_id = 9;
  optional string error = 10;
  optional int64 duration_ms = 11;      // How long the operation took (sync/defrost duration)
  optional int64 warm_duration_ms = 12; // For EVICTED: how long asset was cached before eviction
}

message DVRReadyRequest {
  string dvr_hash = 1;           // Which DVR job we're asking about
  string node_id = 2;            // Which storage node is asking
}

message DVRReadyResponse {
  string dvr_hash = 1;           // DVR identifier
  bool ready = 2;                // Is stream ready for pulling?
  string source_uri = 3;         // Full DTSC URI when ready (e.g., "http://ingest-node:8080/stream_name.dtsc")
  DVRConfig config = 4;          // Potentially updated config based on stream characteristics
  string reason = 5;             // If not ready, why? (e.g., "stream_booting", "stream_unhealthy", "stream_offline")
}

// Typed MistServer trigger messages (matches mist package structures)

message PushRewriteTrigger {
  string push_url = 1;
  string hostname = 2;
  string stream_name = 3;

  // Enrichment fields for analytics (populated by Foghorn)
  optional string protocol = 4;
  optional string encoder = 5;
  optional string stream_settings = 6;
  optional string node_id = 7;
  optional double latitude = 8;          // Node latitude
  optional double longitude = 9;         // Node longitude
  optional string location = 10;         // Node location name

  // Publisher GeoIP enrichment (from hostname IP)
  optional string publisher_country_code = 11;
  optional string publisher_city = 12;
  optional double publisher_latitude = 13;
  optional double publisher_longitude = 14;
  optional GeoBucket publisher_bucket = 15;
  optional GeoBucket node_bucket = 16;
  optional string stream_id = 17; // Enriched by Foghorn (UUID)
}

// ViewerResolveTrigger represents a viewer-side resolve of a playback request.
// This is NOT publisher ingest. It fires when a viewer requests a stream by
// playback ID or artifact hash; enrichment may include geo and node context.
message ViewerResolveTrigger {
  string requested_stream = 2; // playback ID or artifact hash (original request)
  string viewer_host = 3;      // viewer IP/host
  string output_type = 4;      // HLS/DASH/WebRTC
  string request_url = 5;

  // Enrichment (by Foghorn). Do not replace the payload type; enrich in-place.
  optional string node_id = 6;
  optional string country_code = 7;
  optional string city = 8;
  optional double latitude = 9;
  optional double longitude = 10;
  optional GeoBucket client_bucket = 11;
  optional GeoBucket node_bucket = 12;

  // Resolved internal name (UUID format, no live+ prefix) for analytics correlation.
  // This is the canonical stream identifier that matches across all analytics tables.
  optional string resolved_internal_name = 13;

  // Node location name (e.g., "us-east-1", "Frankfurt") - enriched by Foghorn
  optional string node_location = 14;

  // Public stream ID (UUID) for external correlation
  optional string stream_id = 15;
}

message StreamSourceTrigger {
  string stream_name = 1;
  optional string stream_id = 2; // Public stream ID (UUID) if known
}

message PushOutStartTrigger {
  string stream_name = 1;
  string push_target = 2;
  optional string node_id = 3;
  optional string stream_id = 4; // Enriched by Foghorn (UUID)
}

message PushEndTrigger {
  int64 push_id = 1;
  string stream_name = 2;
  string target_uri_before = 3;
  string target_uri_after = 4;
  string log_messages = 5;
  string push_status = 6;
  optional string node_id = 7;
  optional string stream_id = 8; // Enriched by Foghorn (UUID)
}

// ViewerConnectTrigger (formerly USER_NEW) indicates a viewer connection.
message ViewerConnectTrigger {
  string stream_name = 1;
  // host contains the client's connection IP address from MistServer.
  // Used for GeoIP enrichment; geographic data is preserved while
  // raw IP is redacted downstream for privacy.
  string host = 2;
  string connection_id = 3;
  string connector = 4;
  string request_url = 5;
  string session_id = 6;

  // Enrichment fields (populated by Foghorn)
  optional string node_id = 7;
  reserved 8;  // Removed: client_ip was never populated (IP lives in 'host')
  optional string client_country = 9;
  optional string client_city = 10;
  optional double client_latitude = 11;
  optional double client_longitude = 12;
  optional GeoBucket client_bucket = 13;
  optional GeoBucket node_bucket = 14;
  optional string stream_id = 15; // Enriched by Foghorn (UUID)
}

// ViewerDisconnectTrigger (formerly USER_END) indicates a viewer disconnect.
message ViewerDisconnectTrigger {
  string session_id = 1;
  string stream_name = 2;
  string connector = 3;
  string host = 4;
  int64 duration = 5;
  int64 up_bytes = 6;
  int64 down_bytes = 7;
  string tags = 8;
  
  // Enrichment fields for analytics (populated by Foghorn)
  optional string node_id = 9;
  optional string country_code = 10;
  optional string city = 11;
  optional double latitude = 12;
  optional double longitude = 13;
  optional string session_identifier = 14;
  optional uint64 seconds_connected = 15;
  optional GeoBucket client_bucket = 16;
  optional GeoBucket node_bucket = 17;
  optional string stream_id = 18; // Enriched by Foghorn (UUID)
}

message StreamBufferTrigger {
  string stream_name = 1;
  string buffer_state = 2;
  // Fully typed stream details (no more JSON strings)
  repeated StreamTrack tracks = 3;
  // REMOVED: health_score = 4 (derived metric, use raw signals instead)
  optional bool has_issues = 5;
  optional string issues_description = 6;
  optional int32 track_count = 7;
  optional string quality_tier = 8;
  // Top-level health wrapper fields from MistServer (stream-wide summary)
  optional int32 stream_buffer_ms = 9;      // health.buffer (overall buffer in ms)
  optional int32 stream_jitter_ms = 10;     // health.jitter (max jitter across tracks)
  optional string mist_issues = 11;         // health.issues (Mist's issue string, e.g. "HLSnoaudio!")
  optional int32 max_keepaway_ms = 12;      // health.maxkeepaway (max viewer distance from live)
  optional string stream_id = 13;          // Enriched by Foghorn (UUID)
}

message StreamEndTrigger {
  string stream_name = 1;
  optional int64 downloaded_bytes = 2;
  optional int64 uploaded_bytes = 3;
  optional int64 total_viewers = 4;
  optional int64 total_inputs = 5;
  optional int64 total_outputs = 6;
  optional int64 viewer_seconds = 7;
  optional string node_id = 8;
  optional string stream_id = 9;           // Enriched by Foghorn (UUID)
}

// StreamTrackListTrigger (formerly LIVE_TRACK_LIST) provides track inventory.
message StreamTrackListTrigger {
  string stream_name = 1;
  // Fully typed track list (no more JSON strings)
  repeated StreamTrack tracks = 2;
  optional int32 total_tracks = 3;
  optional int32 video_track_count = 4;
  optional int32 audio_track_count = 5;
  optional string quality_tier = 6;
  // Primary video track info
  optional int32 primary_width = 7;
  optional int32 primary_height = 8;
  optional double primary_fps = 9;
  optional int32 primary_video_bitrate = 10;
  optional string primary_video_codec = 11;
  // Primary audio track info
  optional int32 primary_audio_bitrate = 12;
  optional string primary_audio_codec = 13;
  optional int32 primary_audio_channels = 14;
  optional int32 primary_audio_sample_rate = 15;
  optional string stream_id = 16;          // Enriched by Foghorn (UUID)
}

// RecordingCompleteTrigger (formerly RECORDING_END) indicates recorder completion.
message RecordingCompleteTrigger {
  string stream_name = 1;
  string file_path = 2;
  string output_protocol = 3;
  int64 bytes_written = 4;
  int64 seconds_writing = 5;
  int64 time_started = 6;
  int64 time_ended = 7;
  int64 media_duration_ms = 8;
  
  // Enrichment fields for analytics (populated by Foghorn)
  optional string node_id = 9;
  optional string stream_id = 10;       // Enriched by Foghorn (UUID)
}

// RecordingSegmentTrigger (RECORDING_SEGMENT) indicates a new segment has been written.
message RecordingSegmentTrigger {
  string stream_name = 1;
  string file_path = 2;
  int64 duration_ms = 3;
  int64 time_started = 4;
  int64 time_ended = 5;
  optional string stream_id = 6;        // Enriched by Foghorn (UUID)
}

// Analytics event messages for forwarding to Decklog
message StreamLifecycleUpdate {
  string node_id = 1;
  optional string tenant_id = 2;        // Optional - enriched by Foghorn via Commodore lookup
  string internal_name = 3;
  string status = 4;                    // "live", "offline"
  optional string buffer_state = 5;     // "FULL", "EMPTY", "DRY", "RECOVER"
  optional uint64 uploaded_bytes = 6;
  optional uint64 downloaded_bytes = 7;
  optional uint32 total_viewers = 8;
  optional uint32 total_inputs = 9;
  optional uint64 viewer_seconds = 10;
  optional string stream_details = 11;  // JSON health data
  int64 timestamp = 12;

  // Quality metrics (calculated by Helmsman from MistServer data)
  // REMOVED: health_score = 13 (derived metric, use raw signals instead)
  optional bool has_issues = 14;
  optional string issues_description = 15;
  optional int32 track_count = 16;
  optional string quality_tier = 17;    // "2160p", "1440p", "1080p", "720p", "480p", "SD"
  optional int32 primary_width = 18;
  optional int32 primary_height = 19;
  optional float primary_fps = 20;
  optional string primary_codec = 21;
  optional int32 primary_bitrate = 22;

  // Stream timing (populated by Foghorn from state manager)
  optional int64 started_at = 23;       // Unix timestamp when stream went live

  // Packet statistics (from MistServer active_streams API - packsent/packloss/packretrans)
  optional uint64 packets_sent = 24;
  optional uint64 packets_lost = 25;

  // Replication status (true if this is a pull/replicated stream)
  optional bool replicated = 26;

  // Additional packet stat (packretrans from MistServer active_streams API)
  optional uint64 packets_retransmitted = 27;

  // Buffer health metrics (from health blob - top level fields)
  optional uint32 buffer_ms = 28;          // health.buffer - available buffer in ms
  optional uint32 jitter_ms = 29;          // health.jitter - highest jitter across tracks
  optional uint32 max_keepaway_ms = 30;    // health.maxkeepaway - max distance from live point

  // Full track details as JSON (serialized trackDetails array for storage)
  optional string track_details_json = 31;

  // Primary audio track metrics (first audio track found)
  optional uint32 audio_channels = 32;
  optional uint32 audio_sample_rate = 33;
  optional string audio_codec = 34;
  optional uint32 audio_bitrate = 35;

  // Per-track buffer/jitter for primary video track
  optional uint32 video_buffer_ms = 36;
  optional uint32 video_jitter_ms = 37;
  optional string stream_id = 38;          // Enriched by Foghorn (UUID); REQUIRED for analytics joins
}

message ClientLifecycleUpdate {
  string node_id = 1;
  optional string tenant_id = 2;        // Optional - enriched by Foghorn via Commodore lookup
  string internal_name = 3;
  string action = 4;                    // "connect", "disconnect"
  string protocol = 5;
  // host contains the client's connection IP address.
  // Used for GeoIP enrichment before downstream redaction.
  string host = 6;
  optional string session_id = 7;
  optional float connection_time = 8;
  optional float position = 9;
  optional uint64 bandwidth_in_bps = 10;
  optional uint64 bandwidth_out_bps = 11;
  optional uint64 bytes_downloaded = 12;
  optional uint64 bytes_uploaded = 13;
  optional uint64 packets_sent = 14;
  optional uint64 packets_lost = 15;
  optional uint64 packets_retransmitted = 16;
  int64 timestamp = 17;

  // Client geo fields (enriched by Foghorn from 'host' field)
  reserved 18;  // Removed: client_ip was never populated (IP lives in 'host')
  optional string client_country = 19;  // GeoIP enriched country
  optional string client_city = 20;     // GeoIP enriched city  
  optional double client_latitude = 21; // GeoIP enriched latitude
  optional double client_longitude = 22;// GeoIP enriched longitude
  optional string stream_id = 23;       // Enriched by Foghorn (UUID); REQUIRED for analytics joins
}

message NodeLifecycleUpdate {
  string node_id = 1;
  // Resource metrics
  uint32 cpu_tenths = 2;         // 0-1000
  uint64 ram_max = 3;            // MiB
  uint64 ram_current = 4;        // MiB
  uint64 shm_total_bytes = 5;
  uint64 shm_used_bytes = 6;
  uint64 disk_total_bytes = 7;
  uint64 disk_used_bytes = 8;
  uint64 up_speed = 9;           // bytes/sec
  uint64 down_speed = 10;        // bytes/sec
  uint64 bw_limit = 11;          // bytes/sec
  
  // Geo/location
  double latitude = 12;
  double longitude = 13;
  string location = 14;
  uint32 active_streams = 15;
  
  // Extended metrics (matching HTTP payload)
  string base_url = 16;
  bool is_healthy = 17;
  string event_type = 18;
  int64 timestamp = 19;
  
  // Node capabilities
  NodeCapabilities capabilities = 20;
  
  // Storage information
  StorageInfo storage = 21;
  
  // Node limits and usage
  NodeLimits limits = 22;
  
  // Stream metrics
  map<string, StreamData> streams = 23;
  
  // Stored artifacts
  repeated StoredArtifact artifacts = 24;
  
  // MistServer outputs configuration (parsed from koekjes endpoint)
  string outputs_json = 25;
  
  // Enrichment fields added by Foghorn
  optional string tenant_id = 26;

  // Cumulative bandwidth counters (bytes since server start)
  uint64 bandwidth_in_total = 27;   // bw[1] - total bytes received
  uint64 bandwidth_out_total = 28;  // bw[0] - total bytes sent

  // Current active viewer connections
  uint32 connections_current = 29;  // curr[0] - current viewer count

  // Database UUID (enriched by Foghorn via Quartermaster lookup)
  optional string node_uuid = 30;

  // MistServer trigger health statistics (for debugging/monitoring)
  string triggers_json = 40;        // {"STREAM_BUFFER": {count, fails, ms}, ...}

  // Extended connection breakdown from MistServer curr array
  uint32 connections_inputs = 41;    // curr[1] - input connections
  uint32 connections_outgoing = 42;  // curr[2] - outgoing connections
  uint32 connections_cached = 44;    // curr[4] - cached connections
}

// Load balancing specific data (no trigger equivalent - generated by Foghorn routing)
message LoadBalancingData {
  string selected_node = 1;
  double latitude = 2;
  double longitude = 3;
  string status = 4;
  string details = 5;
  uint64 score = 6;
  string client_ip = 7;
  string client_country = 8;
  double node_latitude = 9;
  double node_longitude = 10;
  string node_name = 11;
  optional string selected_node_id = 12;
  optional double routing_distance_km = 13;
  // Enrichment fields added by Foghorn
  optional string tenant_id = 14;           // Infra owner tenant (cluster operator)
  optional string internal_name = 15;
  optional GeoBucket client_bucket = 16;
  optional GeoBucket node_bucket = 17;
  // Dual-tenant attribution (RFC: routing-events-dual-tenant-attribution)
  optional string stream_tenant_id = 18;    // Subject tenant (stream/customer owner)
  optional string cluster_id = 19;          // Emitting cluster identifier
  optional float latency_ms = 20;
  optional string stream_id = 21;           // Public stream ID (UUID); REQUIRED for analytics joins
  optional uint32 candidates_count = 22;    // Number of eligible candidates considered
  optional string event_type = 23;          // "play_rewrite", "grpc_resolve", etc.
  optional string source = 24;              // "http", "grpc", "internal"
}

// Clip lifecycle specific data (separate from ClipProgress/ClipDone control messages)
//
// FOGHORN ENRICHMENT REQUIRED:
// When forwarding clip lifecycle events to Decklog, Foghorn must enrich with:
// - tenant_id, internal_name (already done)
// - start_unix, stop_unix, start_ms, stop_ms, duration_sec from original ClipPullRequest
// These fields must be included in ALL lifecycle stages (REQUESTED, PROGRESS, DONE, FAILED)
// so that Periscope can track clip state without needing to merge events.
message ClipLifecycleData {
  enum Stage {
    STAGE_UNSPECIFIED = 0;
    STAGE_REQUESTED = 1;
    STAGE_QUEUED = 2;
    STAGE_PROGRESS = 3;
    STAGE_DONE = 4;
    STAGE_FAILED = 5;
    STAGE_DELETED = 6;
  }
  Stage stage = 1;
  string clip_hash = 2;
  optional string request_id = 3;
  optional uint32 progress_percent = 4;
  optional string file_path = 5;
  optional string s3_url = 6;
  optional uint64 size_bytes = 7;
  optional string error = 8;
  optional int64 started_at = 9;
  optional int64 completed_at = 10;
  optional string node_id = 11;
  // Enrichment fields added by Foghorn
  optional string tenant_id = 12;
  optional string internal_name = 13;
  // Clip time boundaries (enriched by Foghorn from original ClipPullRequest)
  optional int64 start_unix = 14;
  optional int64 stop_unix = 15;
  optional int64 start_ms = 16;
  optional int64 stop_ms = 17;
  optional int64 duration_sec = 18;
  // Clip creation mode (enriched by Foghorn)
  optional string clip_mode = 19;
  optional int64 expires_at = 20;
  optional string stream_id = 21;      // Public stream ID (UUID)
  optional string user_id = 22;        // User who initiated the clip (if known)
}

// DVR lifecycle specific data (separate from DVR control messages)
//
// FOGHORN ENRICHMENT REQUIRED:
// When forwarding DVR lifecycle events to Decklog, Foghorn must enrich with:
// - tenant_id, internal_name (already done)
// - started_at, ended_at from DVRStartRequest/DVRStopped (time boundaries)
// These fields must be included in ALL lifecycle statuses so that Periscope
// can track DVR state without needing to merge events.
message DVRLifecycleData {
  enum Status {
    STATUS_UNSPECIFIED = 0;
    STATUS_STARTED = 1;
    STATUS_RECORDING = 2;
    STATUS_STOPPED = 3;
    STATUS_FAILED = 4;
    STATUS_DELETED = 5;
  }
  Status status = 1;
  string dvr_hash = 2;
  optional string manifest_path = 3;
  optional int64 started_at = 4;       // Unix timestamp when recording started
  optional int64 ended_at = 5;         // Unix timestamp when recording ended
  optional uint64 size_bytes = 6;
  optional int32 segment_count = 7;
  optional string error = 8;
  optional string node_id = 9;
  // Enrichment fields added by Foghorn
  optional string tenant_id = 10;
  optional string internal_name = 11;
  optional int64 expires_at = 12;
  optional string stream_id = 13;      // Public stream ID (UUID)
  optional string user_id = 14;        // User who initiated the DVR (if known)
}

// VOD lifecycle specific data (for user-uploaded video assets)
//
// VOD uploads differ from clips/DVR:
// - User uploads directly to S3 via presigned URLs (no MistServer involved)
// - Foghorn manages upload state and emits lifecycle events to Decklog
// - Periscope Ingest writes to live_artifacts with content_type='vod'
// - Gateway enriches VOD metadata from Periscope via ArtifactLifecycleLoader
message VodLifecycleData {
  enum Status {
    STATUS_UNSPECIFIED = 0;
    STATUS_REQUESTED = 1;    // Upload session created, presigned URLs generated
    STATUS_UPLOADING = 2;    // Parts being uploaded (optional progress tracking)
    STATUS_PROCESSING = 3;   // Upload complete, validation/transcoding in progress
    STATUS_COMPLETED = 4;    // Asset ready for playback
    STATUS_FAILED = 5;       // Upload or processing failed
    STATUS_DELETED = 6;      // Asset deleted
  }
  Status status = 1;
  string vod_hash = 2;                    // Artifact hash (from Commodore)
  optional string upload_id = 3;          // S3 multipart upload ID
  optional string filename = 4;
  optional string content_type = 5;       // MIME type (video/mp4, etc.)
  optional uint64 size_bytes = 6;         // Expected or actual size
  optional string s3_url = 7;             // Final S3 URL when completed
  optional string file_path = 8;          // Local file path (if applicable)
  optional string error = 9;
  optional int64 started_at = 10;         // When upload started
  optional int64 completed_at = 11;       // When upload/processing completed
  optional string node_id = 12;           // Processing node (if any)
  // Enrichment fields
  optional string tenant_id = 13;
  optional string user_id = 14;
  optional int64 expires_at = 15;         // Retention expiration
  // Media metadata (populated after processing)
  optional int64 duration_ms = 16;
  optional string resolution = 17;        // "1920x1080"
  optional string video_codec = 18;
  optional string audio_codec = 19;
  optional int32 bitrate_kbps = 20;
}

// MessageLifecycleData tracks support messaging events for real-time UI updates
// Emitted by Deckhand when Chatwoot webhook events are received
message MessageLifecycleData {
  enum EventType {
    EVENT_TYPE_UNSPECIFIED = 0;
    EVENT_TYPE_MESSAGE_CREATED = 1;     // New message in conversation
    EVENT_TYPE_CONVERSATION_CREATED = 2; // New conversation started
    EVENT_TYPE_CONVERSATION_UPDATED = 3; // Status changed (resolved, pending)
    EVENT_TYPE_MESSAGE_UPDATED = 4;      // Message edited
  }
  EventType event_type = 1;
  string conversation_id = 2;           // Chatwoot conversation ID
  optional string message_id = 3;       // Chatwoot message ID (for message events)
  optional string content = 4;          // Message content (for message_created)
  optional string sender = 5;           // "USER" or "AGENT"
  optional string status = 6;           // Conversation status: "OPEN", "RESOLVED", "PENDING"
  optional string subject = 7;          // Conversation subject
  int64 timestamp = 8;                  // When event occurred
  optional string tenant_id = 9;        // Tenant context
  optional string user_id = 10;         // User context
}

message NodeCapabilities {
  bool ingest = 1;
  bool edge = 2;
  bool storage = 3;
  bool processing = 4;
  repeated string roles = 5;
}

// Processing configuration sent from Foghorn to Helmsman
// Enables MistProcLivepeer when Gateway is available
message ProcessingConfig {
  bool livepeer_gateway_available = 1;
  string livepeer_gateway_url = 2;      // e.g., "http://livepeer-gateway:8935"
  repeated string gateway_input_codecs = 3;  // ["H264"] - what Gateway accepts
  repeated string local_input_codecs = 4;    // ["H264", "H265", "AV1", "VP9"] - what local MistServer accepts
}

// ProcessBillingEvent tracks transcoding usage for billing purposes
// Emitted by Helmsman when MistServer triggers fire:
// - LIVEPEER_SEGMENT_COMPLETE for Livepeer Gateway transcoding
// - PROCESS_AV_VIRTUAL_SEGMENT_COMPLETE for MistProcAV transcoding
message ProcessBillingEvent {
  string node_id = 1;
  string stream_name = 2;
  string process_type = 3;    // "Livepeer", "AV", "FFmpeg"
  int64 duration_ms = 4;      // Duration in milliseconds (segment duration or since last event)
  int64 timestamp = 5;        // Unix timestamp when event occurred
  optional string tenant_id = 6; // Tenant context (enriched by Foghorn or Helmsman)
  optional string stream_id = 7; // Enriched by Foghorn (UUID)

  // Common fields
  optional string input_codec = 10;
  optional string output_codec = 11;
  optional string track_type = 12;  // "audio" or "video" - KEY FOR BILLING

  // Livepeer-specific (from LIVEPEER_SEGMENT_COMPLETE)
  optional int32 segment_number = 20;
  optional int32 width = 21;          // source width
  optional int32 height = 22;         // source height
  optional int32 rendition_count = 23;
  optional string broadcaster_url = 24;
  optional int64 upload_time_us = 25; // DEPRECATED: use turnaround_ms
  optional string livepeer_session_id = 26;
  optional int64 segment_start_ms = 27;
  optional int64 input_bytes = 28;
  optional int64 output_bytes_total = 29;
  optional int32 attempt_count = 40;
  optional int64 turnaround_ms = 41;
  optional double speed_factor = 42;
  optional string renditions_json = 43;  // JSON array: [{name, bytes}, ...]

  // MistProcAV-specific (from PROCESS_AV_VIRTUAL_SEGMENT_COMPLETE)
  optional int64 input_frames = 30;           // cumulative
  optional int64 output_frames = 31;          // cumulative
  optional int64 decode_us_per_frame = 32;
  optional int64 transform_us_per_frame = 33;
  optional int64 encode_us_per_frame = 34;
  optional bool is_final = 35;
  optional int64 input_frames_delta = 50;     // frames this window
  optional int64 output_frames_delta = 51;    // frames this window
  optional int64 input_bytes_delta = 52;      // bytes this window
  optional int64 output_bytes_delta = 53;     // bytes this window
  optional int32 input_width = 54;
  optional int32 input_height = 55;
  optional int32 output_width = 56;
  optional int32 output_height = 57;
  optional int32 input_fpks = 58;             // frames per 1000s (input)
  optional double output_fps_measured = 59;   // measured output FPS
  optional int32 sample_rate = 60;            // audio sample rate
  optional int32 channels = 61;               // audio channels
  optional int64 source_timestamp_ms = 62;
  optional int64 sink_timestamp_ms = 63;
  optional int64 source_advanced_ms = 64;
  optional int64 sink_advanced_ms = 65;
  optional double rtf_in = 66;                // real-time factor in
  optional double rtf_out = 67;               // real-time factor out
  optional int64 pipeline_lag_ms = 68;
  optional int64 output_bitrate_bps = 69;
}

message StorageInfo {
  string local_path = 1;
  string s3_bucket = 2;
  string s3_prefix = 3;
}

message NodeLimits {
  int32 max_transcodes = 1;
  uint64 storage_capacity_bytes = 2;
  uint64 storage_used_bytes = 3;
}

message StreamData {
  uint64 total = 1;          // Total viewers
  uint32 inputs = 2;         // Input count
  uint64 bytes_up = 3;       // Upload bytes
  uint64 bytes_down = 4;     // Download bytes
  uint32 bandwidth = 5;      // Bandwidth per viewer
  bool replicated = 6;       // True if this is a replicated (pull) stream

  // Packet stats (for QoS monitoring) - MistServer pkts array
  repeated int64 packet_counts = 7;       // [sent, lost, retransmit]

  // Connection totals - MistServer tot array
  repeated int64 total_connections = 8;   // [total_viewers, total_inputs, total_outputs]
}

// Stream track information (replaces JSON parsing)
message StreamTrack {
  string track_name = 1;     // e.g., "video_1", "audio_1", "meta_1"
  string track_type = 2;     // "video", "audio", "meta", "unknown"
  string codec = 3;          // H264, AAC, JSON, etc.
  optional int32 bitrate_kbps = 4;
  optional int64 bitrate_bps = 5;
  optional int32 buffer = 6;
  optional int32 jitter = 7;
  
  // Video-specific fields
  optional int32 width = 8;
  optional int32 height = 9;
  optional double fps = 10;
  optional string resolution = 11;    // e.g., "1920x1080"
  optional bool has_bframes = 12;
  
  // Audio-specific fields
  optional int32 channels = 13;
  optional int32 sample_rate = 14;
  
  // Frame timing metrics (raw from MistServer keys object)
  optional int32 frames_max = 15;
  optional int32 frames_min = 16;
  optional double frame_ms_max = 17;
  optional double frame_ms_min = 18;
  optional double keyframe_ms_max = 19;  // Raw keyframe interval max (from keys.ms_max)
  optional double keyframe_ms_min = 20;  // Raw keyframe interval min (from keys.ms_min)
}

message StoredArtifact {
  // Security: Use opaque identifiers, never expose tenant_id on edge nodes
  string clip_hash = 1;      // Opaque identifier for the clip
  string stream_name = 2;    // Stream name (safe to expose)
  string file_path = 3;      // Local file path on storage node
  string s3_url = 4;         // S3 URL if uploaded to cloud storage
  uint64 size_bytes = 5;     // File size in bytes
  int64 created_at = 6;      // Creation timestamp (Unix seconds)
  string format = 7;         // File format (mp4, webm, etc.)
  bool has_dtsh = 8;         // True if .dtsh index file exists locally
  uint64 access_count = 9;   // Local access count (best-effort, per node)
  int64 last_accessed = 10;  // Last access timestamp (Unix seconds)
}

message StreamProcess {
  string process = 1;
  string codec = 2;
  int64 bitrate = 3;
  string track_select = 4;
  string track_inhibit = 5;
  string restart_type = 6;
  bool inconsequential = 7;
  bool exit_unmask = 8;
  map<string, string> extra = 100;
}

message StreamDef {
  string name = 1;
  bool realtime = 2;
  bool stop_sessions = 3;
  repeated string tags = 4;
  repeated StreamProcess processes = 5;
}

message StreamTemplate {
  string id = 1;
  StreamDef def = 2;
  repeated string roles = 3;
  repeated string caps = 4;
}

message ConfigSeed {
  string node_id = 1;
  double latitude = 2;
  double longitude = 3;
  string location_name = 4;
  // Tenant owning this node (resolved by Foghorn via Quartermaster)
  string tenant_id = 5;
  repeated StreamTemplate templates = 10;
  // Processing configuration (Gateway availability, codec support)
  ProcessingConfig processing = 11;
}

// ==================== Transcode Job Messages ====================

// Transcode profile for ABR ladder generation
message TranscodeProfile {
  string name = 1;           // e.g., "720p", "1080p", "audio_only"
  string codec = 2;          // H264, H265, AAC
  int32 bitrate = 3;         // bps
  int32 width = 4;
  int32 height = 5;
  double fps = 6;
}

// Transcode job request (Foghorn  Helmsman)
message TranscodeJobRequest {
  string job_id = 1;
  string tenant_id = 2;
  string artifact_hash = 3;        // Source artifact
  string source_url = 4;           // Presigned URL for source
  repeated TranscodeProfile profiles = 5;
  bool use_gateway = 6;            // Use Livepeer Gateway if true
  string gateway_url = 7;          // Gateway URL (if use_gateway=true)
}

// Transcode job progress (Helmsman  Foghorn)
message TranscodeJobProgress {
  string job_id = 1;
  int32 percent = 2;               // 0-100
  string status = 3;               // queued, processing, completed, failed
  string message = 4;              // Status message / error
}

// Transcode job completion (Helmsman  Foghorn)
message TranscodeJobComplete {
  string job_id = 1;
  string status = 2;               // success, failed
  string output_artifact_hash = 3; // New artifact hash for output
  string output_s3_url = 4;        // S3 URL of transcoded output
  string error = 5;                // Error message if failed
}

// ==================== API Request Tracking ====================
// Tracks GraphQL API requests for usage analytics (RFC: x402 Agent Access)
// Gateway aggregates in-memory and flushes periodically (not per-request)

message APIRequestBatch {
  int64 timestamp = 1;                         // Flush timestamp (Unix seconds)
  string source_node = 2;                      // Gateway instance ID
  repeated APIRequestAggregate aggregates = 3;
}

message APIRequestAggregate {
  string tenant_id = 1;
  string auth_type = 2;             // jwt, api_token, wallet
  string operation_type = 3;        // query, mutation, subscription
  string operation_name = 4;        // GetStreams, CreateClip, etc. (empty if anonymous)
  uint32 request_count = 5;
  uint32 error_count = 6;
  uint64 total_duration_ms = 7;
  uint32 total_complexity = 8;      // Sum of GraphQL complexity scores
  repeated uint64 user_hashes = 9;  // Hashed user IDs observed in the aggregate window
  repeated uint64 token_hashes = 10; // Hashed API token IDs observed in the aggregate window
}
