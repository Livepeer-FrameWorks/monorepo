syntax = "proto3";

package helmsmancontrol;

option go_package = "frameworks/pkg/proto";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

// Coarse geospatial bucket (H3 index + resolution)
message GeoBucket {
  uint64 h3_index = 1;   // H3 cell id encoded as uint64
  uint32 resolution = 2; // H3 resolution (e.g., 5)
}

// Bidirectional control channel between Helmsman (client) and Foghorn (server)
// Helmsman dials Foghorn and sends Register/NodeLifecycleUpdate; Foghorn sends ClipPullRequest

service HelmsmanControl {
  rpc Connect(stream ControlMessage) returns (stream ControlMessage);
  rpc ResolveClipHash(ClipHashRequest) returns (ClipHashResponse);
}

// Service for sending analytics events to Decklog (Foghorn -> Decklog/api_firehose)
// Unified analytics/event ingress API: one envelope, one RPC.
// All producers MUST send a MistTrigger with the original payload preserved and
// any enrichment added in-place (optional fields). Do NOT rewrite payload types.
service DecklogService {
  // Unified entrypoint for all events (unary is fine for now).
  rpc SendEvent(MistTrigger) returns (google.protobuf.Empty);
}

message ControlMessage {
  string request_id = 1; // Correlates requests/responses
  google.protobuf.Timestamp sent_at = 2;
  oneof payload {
    Register register = 10;
    ClipPullRequest clip_pull_request = 12;
    ClipProgress clip_progress = 13;
    ClipDone clip_done = 14;
    ControlError error = 15;
    Heartbeat heartbeat = 16;
    DVRStartRequest dvr_start_request = 18;
    DVRProgress dvr_progress = 19;
    DVRStopped dvr_stopped = 20;
    DVRStopRequest dvr_stop_request = 21;
    DVRReadyRequest dvr_ready_request = 22;
    DVRReadyResponse dvr_ready_response = 23;
    MistTrigger mist_trigger = 24;
    MistTriggerResponse mist_trigger_response = 25;
    ConfigSeed config_seed = 29;
    ArtifactDeleted artifact_deleted = 30;
  }
}

message ArtifactDeleted {
  string clip_hash = 1;
  string file_path = 2;
  string reason = 3; // "cleanup", "expired", "manual"
  string node_id = 4;
  uint64 size_bytes = 5;
}

message Register {
  string node_id = 1;
  repeated string roles = 2; // e.g., ingest, edge, storage, processing
  bool cap_ingest = 3;
  bool cap_edge = 4;
  bool cap_storage = 5;
  bool cap_processing = 6;
  // Storage hints
  string storage_local = 7;
  string storage_bucket = 8;
  string storage_prefix = 9;
  // Edge enrollment token (optional). Sent by Helmsman on first connect for Foghorn to enroll the node with Quartermaster.
  string enrollment_token = 10;
  // Optional stable fingerprint signals to aid node identity resolution.
  // Do not include volatile/process-specific values. Client-provided; server will add peer_ip & Geo.
  NodeFingerprint fingerprint = 11;
}

// NodeFingerprint carries stable identity hints from Helmsman.
message NodeFingerprint {
  // Local interface IPs (best-effort). Helps disambiguate nodes behind NAT.
  repeated string local_ipv4 = 1;
  repeated string local_ipv6 = 2;
  // Deterministic aggregate hash of MAC addresses (sorted, lowercase, SHA-256 hex).
  // Avoids exposing raw MACs while remaining stable.
  optional string macs_sha256 = 3;
  // Optional machine-id hash when available (e.g., /etc/machine-id), SHA-256 hex.
  optional string machine_id_sha256 = 4;
}

message ClipPullRequest {
  // Security: Use opaque identifiers, never expose tenant_id on edge nodes
  string clip_hash = 1;           // Opaque identifier for the clip
  string stream_name = 2;         // Stream name for MistServer (no tenant info)
  // Timing (one of):
  optional int64 start_unix = 3;   // seconds
  optional int64 stop_unix = 4;    // seconds
  optional int64 start_ms = 5;     // since stream start
  optional int64 stop_ms = 6;      // since stream start
  optional int64 duration_sec = 7; // seconds
  // Output
  string format = 8;              // mp4 default
  string output_name = 9;         // suggested basename
  // Optional explicit Mist HTTP base (e.g., http://node:8080) to pull from
  string source_base_url = 10;
  // Request tracking
  string request_id = 11;         // Unique request ID for tracking
}

message ClipProgress {
  string request_id = 1;
  uint32 percent = 2;        // 0..100
  string message = 3;
}

message ClipDone {
  string request_id = 1;
  string file_path = 2;     // local path on storage node (if applicable)
  string s3_url = 3;        // s3://bucket/key or https URL (if applicable)
  uint64 size_bytes = 4;
  string status = 5;        // success|failed
  string error = 6;         // filled when failed
}

message ControlError {
  string code = 1;
  string message = 2;
}

message Heartbeat {
  string node_id = 1;
}

message MistTrigger {
  string trigger_type = 1;    // e.g., PUSH_REWRITE, PLAY_REWRITE, VIEWER_CONNECT, STREAM_BUFFER
  string node_id = 3;         // Node that received the trigger
  int64 timestamp = 4;        // When trigger was received
  bool blocking = 5;          // Does this trigger need a response from Foghorn?
  string request_id = 6;      // For correlating responses
  optional string tenant_id = 7; // Tenant context (enriched by Foghorn)
  
  // Typed trigger payloads (one of these will be set based on trigger_type)
  oneof trigger_payload {
    PushRewriteTrigger push_rewrite = 10;
    ViewerResolveTrigger play_rewrite = 11;          // formerly DefaultStreamTrigger
    StreamSourceTrigger stream_source = 12;            // VOD source resolution
    PushOutStartTrigger push_out_start = 13;
    PushEndTrigger push_end = 14;
    ViewerConnectTrigger viewer_connect = 15;          // formerly UserNewTrigger
    ViewerDisconnectTrigger viewer_disconnect = 16;    // formerly UserEndTrigger
    StreamBufferTrigger stream_buffer = 17;
    StreamEndTrigger stream_end = 18;
    StreamTrackListTrigger track_list = 19;            // formerly LiveTrackListTrigger
    StreamBandwidthTrigger stream_bandwidth = 20;      // formerly LiveBandwidthTrigger
    RecordingCompleteTrigger recording_complete = 21;  // formerly RecordingEndTrigger
    StreamLifecycleUpdate stream_lifecycle_update = 22;
    ClientLifecycleUpdate client_lifecycle_update = 23;
    NodeLifecycleUpdate node_lifecycle_update = 24;
    LoadBalancingData load_balancing_data = 25;
    ClipLifecycleData clip_lifecycle_data = 26;
    DVRLifecycleData dvr_lifecycle_data = 27;
    StorageSnapshot storage_snapshot = 28;
  }
}

message MistTriggerResponse {
  string request_id = 1;      // Correlates to MistTrigger.request_id
  string response = 2;        // What to return to MistServer (empty string aborts for blocking triggers)
  bool abort = 3;             // Explicit abort flag
}

message StorageSnapshot {
  string node_id = 1;
  int64 timestamp = 2;
  optional string tenant_id = 3; // Node Owner (Supplier)
  optional string location = 4;
  optional NodeCapabilities capabilities = 5;
  
  repeated TenantStorageUsage usage = 6;
}

message TenantStorageUsage {
  string tenant_id = 1; // Resource Consumer
  uint64 total_bytes = 2;
  uint32 file_count = 3;
  uint64 dvr_bytes = 4;
  uint64 clip_bytes = 5;
  uint64 recording_bytes = 6;
}

message ClipHashRequest {
  string clip_hash = 1;
}

message ClipHashResponse {
  string clip_hash = 1;
  string tenant_id = 2;
  string stream_name = 3;
}

// DVR (Digital Video Recording) messages
message DVRStartRequest {
  string dvr_hash = 1;           // Unique DVR identifier (32-char hex) - generated by Foghorn
  string internal_name = 2;      // Stream internal name (same as stream name)
  string source_base_url = 3;    // DTSC source URL to pull from - filled by Foghorn  
  string request_id = 4;         // Unique request ID for tracking
  DVRConfig config = 5;          // Recording configuration
  string tenant_id = 6;          // Tenant ID for the stream
  string user_id = 7;            // User ID for the stream
}

message DVRConfig {
  bool enabled = 1;              // Whether DVR is enabled
  int32 retention_days = 2;      // How long to keep the recording
  string format = 3;             // ts, mp4, etc.
  int32 segment_duration = 4;    // Segment duration in seconds
}

message DVRProgress {
  string request_id = 1;
  string dvr_hash = 2;           // DVR identifier
  string status = 3;             // recording, segments_available, etc.
  int64 started_at = 4;          // Unix timestamp when recording started
  int32 segment_count = 5;       // Number of segments recorded so far
  uint64 size_bytes = 6;         // Total size of recording so far
  string message = 7;            // Optional progress message
}

message DVRStopped {
  string request_id = 1;
  string dvr_hash = 2;           // DVR identifier
  string status = 3;             // completed, failed, terminated
  string error = 4;              // Error message if failed
  int64 started_at = 5;          // Unix timestamp when recording started
  int64 ended_at = 6;            // Unix timestamp when recording ended
  int32 duration_seconds = 7;    // Total duration of the recording
  uint64 size_bytes = 8;         // Total size of the recording
  string manifest_path = 9;      // Path to the m3u8 manifest for playback
}

message DVRStopRequest {
  string dvr_hash = 1;           // Unique DVR identifier to stop (empty = stop all for internal_name)
  string request_id = 2;         // Request ID for tracking
  optional string internal_name = 3;  // Stream internal name (for stopping all DVR recordings for a stream)
}

message DVRReadyRequest {
  string dvr_hash = 1;           // Which DVR job we're asking about
  string node_id = 2;            // Which storage node is asking
}

message DVRReadyResponse {
  string dvr_hash = 1;           // DVR identifier
  bool ready = 2;                // Is stream ready for pulling?
  string source_uri = 3;         // Full DTSC URI when ready (e.g., "http://ingest-node:8080/stream_name.dtsc")
  DVRConfig config = 4;          // Potentially updated config based on stream characteristics
  string reason = 5;             // If not ready, why? (e.g., "stream_booting", "stream_unhealthy", "stream_offline")
}

// Typed MistServer trigger messages (matches mist package structures)

message PushRewriteTrigger {
  string push_url = 1;
  string hostname = 2;
  string stream_name = 3;

  // Enrichment fields for analytics (populated by Foghorn)
  optional string protocol = 4;
  optional string encoder = 5;
  optional string stream_settings = 6;
  optional string node_id = 7;
  optional double latitude = 8;          // Node latitude
  optional double longitude = 9;         // Node longitude
  optional string location = 10;         // Node location name

  // Publisher GeoIP enrichment (from hostname IP)
  optional string publisher_country_code = 11;
  optional string publisher_city = 12;
  optional double publisher_latitude = 13;
  optional double publisher_longitude = 14;
  optional GeoBucket publisher_bucket = 15;
  optional GeoBucket node_bucket = 16;
}

// ViewerResolveTrigger represents a viewer-side resolve of a playback request.
// This is NOT publisher ingest. It fires when a viewer requests a stream by
// playback ID or artifact hash; enrichment may include geo and node context.
message ViewerResolveTrigger {
  string requested_stream = 2; // playback ID or artifact hash (original request)
  string viewer_host = 3;      // viewer IP/host
  string output_type = 4;      // HLS/DASH/WebRTC
  string request_url = 5;

  // Enrichment (by Foghorn). Do not replace the payload type; enrich in-place.
  optional string node_id = 6;
  optional string country_code = 7;
  optional string city = 8;
  optional double latitude = 9;
  optional double longitude = 10;
  optional GeoBucket client_bucket = 11;
  optional GeoBucket node_bucket = 12;

  // Resolved internal name (UUID format, no live+ prefix) for analytics correlation.
  // This is the canonical stream identifier that matches across all analytics tables.
  optional string resolved_internal_name = 13;
}

message StreamSourceTrigger {
  string stream_name = 1;
}

message PushOutStartTrigger {
  string stream_name = 1;
  string push_target = 2;
  optional string node_id = 3;
}

message PushEndTrigger {
  int64 push_id = 1;
  string stream_name = 2;
  string target_uri_before = 3;
  string target_uri_after = 4;
  string log_messages = 5;
  string push_status = 6;
  optional string node_id = 7;
}

// ViewerConnectTrigger (formerly USER_NEW) indicates a viewer connection.
message ViewerConnectTrigger {
  string stream_name = 1;
  string host = 2;
  string connection_id = 3;
  string connector = 4;
  string request_url = 5;
  string session_id = 6;
  
  // Enrichment fields
  optional string node_id = 7;
  optional string client_ip = 8;
  optional string client_country = 9;
  optional string client_city = 10;
  optional double client_latitude = 11;
  optional double client_longitude = 12;
  optional GeoBucket client_bucket = 13;
  optional GeoBucket node_bucket = 14;
}

// ViewerDisconnectTrigger (formerly USER_END) indicates a viewer disconnect.
message ViewerDisconnectTrigger {
  string session_id = 1;
  string stream_name = 2;
  string connector = 3;
  string host = 4;
  int64 duration = 5;
  int64 up_bytes = 6;
  int64 down_bytes = 7;
  string tags = 8;
  
  // Enrichment fields for analytics (populated by Foghorn)
  optional string node_id = 9;
  optional string country_code = 10;
  optional string city = 11;
  optional double latitude = 12;
  optional double longitude = 13;
  optional string session_identifier = 14;
  optional uint64 seconds_connected = 15;
  optional GeoBucket client_bucket = 16;
  optional GeoBucket node_bucket = 17;
}

message StreamBufferTrigger {
  string stream_name = 1;
  string buffer_state = 2;
  // Fully typed stream details (no more JSON strings)
  repeated StreamTrack tracks = 3;
  // REMOVED: health_score = 4 (derived metric, use raw signals instead)
  optional bool has_issues = 5;
  optional string issues_description = 6;
  optional int32 track_count = 7;
  optional string quality_tier = 8;
}

message StreamEndTrigger {
  string stream_name = 1;
  optional int64 downloaded_bytes = 2;
  optional int64 uploaded_bytes = 3;
  optional int64 total_viewers = 4;
  optional int64 total_inputs = 5;
  optional int64 total_outputs = 6;
  optional int64 viewer_seconds = 7;
  optional string node_id = 8;
}

// StreamTrackListTrigger (formerly LIVE_TRACK_LIST) provides track inventory.
message StreamTrackListTrigger {
  string stream_name = 1;
  // Fully typed track list (no more JSON strings)
  repeated StreamTrack tracks = 2;
  optional int32 total_tracks = 3;
  optional int32 video_track_count = 4;
  optional int32 audio_track_count = 5;
  optional string quality_tier = 6;
  // Primary video track info
  optional int32 primary_width = 7;
  optional int32 primary_height = 8;
  optional double primary_fps = 9;
  optional int32 primary_video_bitrate = 10;
  optional string primary_video_codec = 11;
  // Primary audio track info
  optional int32 primary_audio_bitrate = 12;
  optional string primary_audio_codec = 13;
  optional int32 primary_audio_channels = 14;
  optional int32 primary_audio_sample_rate = 15;
}

// StreamBandwidthTrigger (formerly LIVE_BANDWIDTH) provides transport bandwidth.
message StreamBandwidthTrigger {
  string stream_name = 1;
  int64 current_bytes_per_second = 2;
  
  // Enrichment fields for analytics (populated by Foghorn)
  optional bool threshold_exceeded = 3;
  optional uint64 threshold_value = 4;
  optional string node_id = 5;
}

// RecordingCompleteTrigger (formerly RECORDING_END) indicates recorder completion.
message RecordingCompleteTrigger {
  string stream_name = 1;
  string file_path = 2;
  string output_protocol = 3;
  int64 bytes_written = 4;
  int64 seconds_writing = 5;
  int64 time_started = 6;
  int64 time_ended = 7;
  int64 media_duration_ms = 8;
  
  // Enrichment fields for analytics (populated by Foghorn)
  optional string node_id = 9;
}

// Analytics event messages for forwarding to Decklog
message StreamLifecycleUpdate {
  string node_id = 1;
  optional string tenant_id = 2;        // Optional - enriched by Foghorn via Commodore lookup
  string internal_name = 3;
  string status = 4;                    // "live", "offline"
  optional string buffer_state = 5;     // "FULL", "EMPTY", "DRY", "RECOVER"
  optional uint64 uploaded_bytes = 6;
  optional uint64 downloaded_bytes = 7;
  optional uint32 total_viewers = 8;
  optional uint32 total_inputs = 9;
  optional uint64 viewer_seconds = 10;
  optional string stream_details = 11;  // JSON health data
  int64 timestamp = 12;

  // Quality metrics (calculated by Helmsman from MistServer data)
  // REMOVED: health_score = 13 (derived metric, use raw signals instead)
  optional bool has_issues = 14;
  optional string issues_description = 15;
  optional int32 track_count = 16;
  optional string quality_tier = 17;    // "4K", "1080p", "720p", "480p", "SD"
  optional int32 primary_width = 18;
  optional int32 primary_height = 19;
  optional float primary_fps = 20;
  optional string primary_codec = 21;
  optional int32 primary_bitrate = 22;

  // Stream timing (populated by Foghorn from state manager)
  optional int64 started_at = 23;       // Unix timestamp when stream went live
}

message ClientLifecycleUpdate {
  string node_id = 1;
  optional string tenant_id = 2;        // Optional - enriched by Foghorn via Commodore lookup
  string internal_name = 3;
  string action = 4;                    // "connect", "disconnect"
  string protocol = 5;
  string host = 6;
  optional string session_id = 7;
  optional float connection_time = 8;
  optional float position = 9;
  optional uint64 bandwidth_in_bps = 10;
  optional uint64 bandwidth_out_bps = 11;
  optional uint64 bytes_downloaded = 12;
  optional uint64 bytes_uploaded = 13;
  optional uint64 packets_sent = 14;
  optional uint64 packets_lost = 15;
  optional uint64 packets_retransmitted = 16;
  int64 timestamp = 17;
  
  // Client identification and geo fields (client_ip from Helmsman, geo enriched by Foghorn)
  optional string client_ip = 18;       // Client IP address
  optional string client_country = 19;  // GeoIP enriched country
  optional string client_city = 20;     // GeoIP enriched city  
  optional double client_latitude = 21; // GeoIP enriched latitude
  optional double client_longitude = 22;// GeoIP enriched longitude
}

message NodeLifecycleUpdate {
  string node_id = 1;
  // Resource metrics
  uint32 cpu_tenths = 2;         // 0-1000
  uint64 ram_max = 3;            // MiB
  uint64 ram_current = 4;        // MiB
  uint64 shm_total_bytes = 5;
  uint64 shm_used_bytes = 6;
  uint64 disk_total_bytes = 7;
  uint64 disk_used_bytes = 8;
  uint64 up_speed = 9;           // bytes/sec
  uint64 down_speed = 10;        // bytes/sec
  uint64 bw_limit = 11;          // bytes/sec
  
  // Geo/location
  double latitude = 12;
  double longitude = 13;
  string location = 14;
  uint32 active_streams = 15;
  
  // Extended metrics (matching HTTP payload)
  string base_url = 16;
  bool is_healthy = 17;
  string event_type = 18;
  int64 timestamp = 19;
  
  // Node capabilities
  NodeCapabilities capabilities = 20;
  
  // Storage information
  StorageInfo storage = 21;
  
  // Node limits and usage
  NodeLimits limits = 22;
  
  // Stream metrics
  map<string, StreamData> streams = 23;
  
  // Stored artifacts
  repeated StoredArtifact artifacts = 24;
  
  // MistServer outputs configuration (parsed from koekjes endpoint)
  string outputs_json = 25;
  
  // Enrichment fields added by Foghorn
  optional string tenant_id = 26;
}

// Load balancing specific data (no trigger equivalent - generated by Foghorn routing)
message LoadBalancingData {
  string selected_node = 1;
  double latitude = 2;
  double longitude = 3;
  string status = 4;
  string details = 5;
  uint64 score = 6;
  string client_ip = 7;
  string client_country = 8;
  double node_latitude = 9;
  double node_longitude = 10;
  string node_name = 11;
  optional string selected_node_id = 12;
  optional double routing_distance_km = 13;
  // Enrichment fields added by Foghorn
  optional string tenant_id = 14;
  optional string internal_name = 15;
  optional GeoBucket client_bucket = 16;
  optional GeoBucket node_bucket = 17;
}

// Clip lifecycle specific data (separate from ClipProgress/ClipDone control messages)
//
// FOGHORN ENRICHMENT REQUIRED:
// When forwarding clip lifecycle events to Decklog, Foghorn must enrich with:
// - tenant_id, internal_name (already done)
// - start_unix, stop_unix, start_ms, stop_ms, duration_sec from original ClipPullRequest
// These fields must be included in ALL lifecycle stages (REQUESTED, PROGRESS, DONE, FAILED)
// so that Periscope can track clip state without needing to merge events.
message ClipLifecycleData {
  enum Stage {
    STAGE_UNSPECIFIED = 0;
    STAGE_REQUESTED = 1;
    STAGE_QUEUED = 2;
    STAGE_PROGRESS = 3;
    STAGE_DONE = 4;
    STAGE_FAILED = 5;
    STAGE_DELETED = 6;
  }
  Stage stage = 1;
  string clip_hash = 2;
  optional string request_id = 3;
  optional uint32 progress_percent = 4;
  optional string file_path = 5;
  optional string s3_url = 6;
  optional uint64 size_bytes = 7;
  optional string error = 8;
  optional int64 started_at = 9;
  optional int64 completed_at = 10;
  optional string node_id = 11;
  // Enrichment fields added by Foghorn
  optional string tenant_id = 12;
  optional string internal_name = 13;
  // Clip time boundaries (enriched by Foghorn from original ClipPullRequest)
  optional int64 start_unix = 14;
  optional int64 stop_unix = 15;
  optional int64 start_ms = 16;
  optional int64 stop_ms = 17;
  optional int64 duration_sec = 18;
}

// DVR lifecycle specific data (separate from DVR control messages)
//
// FOGHORN ENRICHMENT REQUIRED:
// When forwarding DVR lifecycle events to Decklog, Foghorn must enrich with:
// - tenant_id, internal_name (already done)
// - started_at, ended_at from DVRStartRequest/DVRStopped (time boundaries)
// These fields must be included in ALL lifecycle statuses so that Periscope
// can track DVR state without needing to merge events.
message DVRLifecycleData {
  enum Status {
    STATUS_UNSPECIFIED = 0;
    STATUS_STARTED = 1;
    STATUS_RECORDING = 2;
    STATUS_STOPPED = 3;
    STATUS_FAILED = 4;
    STATUS_DELETED = 5;
  }
  Status status = 1;
  string dvr_hash = 2;
  optional string manifest_path = 3;
  optional int64 started_at = 4;       // Unix timestamp when recording started
  optional int64 ended_at = 5;         // Unix timestamp when recording ended
  optional uint64 size_bytes = 6;
  optional int32 segment_count = 7;
  optional string error = 8;
  optional string node_id = 9;
  // Enrichment fields added by Foghorn
  optional string tenant_id = 10;
  optional string internal_name = 11;
}

message NodeCapabilities {
  bool ingest = 1;
  bool edge = 2;
  bool storage = 3;
  bool processing = 4;
  repeated string roles = 5;
}

message StorageInfo {
  string local_path = 1;
  string s3_bucket = 2;
  string s3_prefix = 3;
}

message NodeLimits {
  int32 max_transcodes = 1;
  uint64 storage_capacity_bytes = 2;
  uint64 storage_used_bytes = 3;
}

message StreamData {
  uint64 total = 1;          // Total viewers
  uint32 inputs = 2;         // Input count
  uint64 bytes_up = 3;       // Upload bytes
  uint64 bytes_down = 4;     // Download bytes
  uint32 bandwidth = 5;      // Bandwidth per viewer
}

// Stream track information (replaces JSON parsing)
message StreamTrack {
  string track_name = 1;     // e.g., "video_1", "audio_1", "meta_1"
  string track_type = 2;     // "video", "audio", "meta", "unknown"
  string codec = 3;          // H264, AAC, JSON, etc.
  optional int32 bitrate_kbps = 4;
  optional int64 bitrate_bps = 5;
  optional int32 buffer = 6;
  optional int32 jitter = 7;
  
  // Video-specific fields
  optional int32 width = 8;
  optional int32 height = 9;
  optional double fps = 10;
  optional string resolution = 11;    // e.g., "1920x1080"
  optional bool has_bframes = 12;
  
  // Audio-specific fields
  optional int32 channels = 13;
  optional int32 sample_rate = 14;
  
  // Frame timing metrics (raw from MistServer keys object)
  optional int32 frames_max = 15;
  optional int32 frames_min = 16;
  optional double frame_ms_max = 17;
  optional double frame_ms_min = 18;
  optional double keyframe_ms_max = 19;  // Raw keyframe interval max (from keys.ms_max)
  optional double keyframe_ms_min = 20;  // Raw keyframe interval min (from keys.ms_min)
}

message StoredArtifact {
  // Security: Use opaque identifiers, never expose tenant_id on edge nodes
  string clip_hash = 1;      // Opaque identifier for the clip
  string stream_name = 2;    // Stream name (safe to expose)
  string file_path = 3;      // Local file path on storage node
  string s3_url = 4;         // S3 URL if uploaded to cloud storage
  uint64 size_bytes = 5;     // File size in bytes
  int64 created_at = 6;      // Creation timestamp (Unix seconds)
  string format = 7;         // File format (mp4, webm, etc.)
}

message StreamProcess {
  string process = 1;
  string codec = 2;
  int64 bitrate = 3;
  string track_select = 4;
  string track_inhibit = 5;
  string restart_type = 6;
  bool inconsequential = 7;
  bool exit_unmask = 8;
  map<string, string> extra = 100;
}

message StreamDef {
  string name = 1;
  bool realtime = 2;
  bool stop_sessions = 3;
  repeated string tags = 4;
  repeated StreamProcess processes = 5;
}

message StreamTemplate {
  string id = 1;
  StreamDef def = 2;
  repeated string roles = 3;
  repeated string caps = 4;
}

message ConfigSeed {
  string node_id = 1;
  double latitude = 2;
  double longitude = 3;
  string location_name = 4;
  // Tenant owning this node (resolved by Foghorn via Quartermaster)
  string tenant_id = 5;
  repeated StreamTemplate templates = 10;
}
