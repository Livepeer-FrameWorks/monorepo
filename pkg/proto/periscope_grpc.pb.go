// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: periscope.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	StreamAnalyticsService_GetStreamAnalytics_FullMethodName     = "/periscope.StreamAnalyticsService/GetStreamAnalytics"
	StreamAnalyticsService_GetStreamEvents_FullMethodName        = "/periscope.StreamAnalyticsService/GetStreamEvents"
	StreamAnalyticsService_GetBufferEvents_FullMethodName        = "/periscope.StreamAnalyticsService/GetBufferEvents"
	StreamAnalyticsService_GetStreamHealthMetrics_FullMethodName = "/periscope.StreamAnalyticsService/GetStreamHealthMetrics"
	StreamAnalyticsService_GetStreamStatus_FullMethodName        = "/periscope.StreamAnalyticsService/GetStreamStatus"
	StreamAnalyticsService_GetStreamsStatus_FullMethodName       = "/periscope.StreamAnalyticsService/GetStreamsStatus"
)

// StreamAnalyticsServiceClient is the client API for StreamAnalyticsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StreamAnalyticsServiceClient interface {
	GetStreamAnalytics(ctx context.Context, in *GetStreamAnalyticsRequest, opts ...grpc.CallOption) (*GetStreamAnalyticsResponse, error)
	GetStreamEvents(ctx context.Context, in *GetStreamEventsRequest, opts ...grpc.CallOption) (*GetStreamEventsResponse, error)
	GetBufferEvents(ctx context.Context, in *GetBufferEventsRequest, opts ...grpc.CallOption) (*GetBufferEventsResponse, error)
	GetStreamHealthMetrics(ctx context.Context, in *GetStreamHealthMetricsRequest, opts ...grpc.CallOption) (*GetStreamHealthMetricsResponse, error)
	// Stream status for Control/Data plane separation
	GetStreamStatus(ctx context.Context, in *GetStreamStatusRequest, opts ...grpc.CallOption) (*StreamStatusResponse, error)
	GetStreamsStatus(ctx context.Context, in *GetStreamsStatusRequest, opts ...grpc.CallOption) (*StreamsStatusResponse, error)
}

type streamAnalyticsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamAnalyticsServiceClient(cc grpc.ClientConnInterface) StreamAnalyticsServiceClient {
	return &streamAnalyticsServiceClient{cc}
}

func (c *streamAnalyticsServiceClient) GetStreamAnalytics(ctx context.Context, in *GetStreamAnalyticsRequest, opts ...grpc.CallOption) (*GetStreamAnalyticsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStreamAnalyticsResponse)
	err := c.cc.Invoke(ctx, StreamAnalyticsService_GetStreamAnalytics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAnalyticsServiceClient) GetStreamEvents(ctx context.Context, in *GetStreamEventsRequest, opts ...grpc.CallOption) (*GetStreamEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStreamEventsResponse)
	err := c.cc.Invoke(ctx, StreamAnalyticsService_GetStreamEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAnalyticsServiceClient) GetBufferEvents(ctx context.Context, in *GetBufferEventsRequest, opts ...grpc.CallOption) (*GetBufferEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBufferEventsResponse)
	err := c.cc.Invoke(ctx, StreamAnalyticsService_GetBufferEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAnalyticsServiceClient) GetStreamHealthMetrics(ctx context.Context, in *GetStreamHealthMetricsRequest, opts ...grpc.CallOption) (*GetStreamHealthMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStreamHealthMetricsResponse)
	err := c.cc.Invoke(ctx, StreamAnalyticsService_GetStreamHealthMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAnalyticsServiceClient) GetStreamStatus(ctx context.Context, in *GetStreamStatusRequest, opts ...grpc.CallOption) (*StreamStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamStatusResponse)
	err := c.cc.Invoke(ctx, StreamAnalyticsService_GetStreamStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamAnalyticsServiceClient) GetStreamsStatus(ctx context.Context, in *GetStreamsStatusRequest, opts ...grpc.CallOption) (*StreamsStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamsStatusResponse)
	err := c.cc.Invoke(ctx, StreamAnalyticsService_GetStreamsStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StreamAnalyticsServiceServer is the server API for StreamAnalyticsService service.
// All implementations must embed UnimplementedStreamAnalyticsServiceServer
// for forward compatibility.
type StreamAnalyticsServiceServer interface {
	GetStreamAnalytics(context.Context, *GetStreamAnalyticsRequest) (*GetStreamAnalyticsResponse, error)
	GetStreamEvents(context.Context, *GetStreamEventsRequest) (*GetStreamEventsResponse, error)
	GetBufferEvents(context.Context, *GetBufferEventsRequest) (*GetBufferEventsResponse, error)
	GetStreamHealthMetrics(context.Context, *GetStreamHealthMetricsRequest) (*GetStreamHealthMetricsResponse, error)
	// Stream status for Control/Data plane separation
	GetStreamStatus(context.Context, *GetStreamStatusRequest) (*StreamStatusResponse, error)
	GetStreamsStatus(context.Context, *GetStreamsStatusRequest) (*StreamsStatusResponse, error)
	mustEmbedUnimplementedStreamAnalyticsServiceServer()
}

// UnimplementedStreamAnalyticsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStreamAnalyticsServiceServer struct{}

func (UnimplementedStreamAnalyticsServiceServer) GetStreamAnalytics(context.Context, *GetStreamAnalyticsRequest) (*GetStreamAnalyticsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStreamAnalytics not implemented")
}
func (UnimplementedStreamAnalyticsServiceServer) GetStreamEvents(context.Context, *GetStreamEventsRequest) (*GetStreamEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStreamEvents not implemented")
}
func (UnimplementedStreamAnalyticsServiceServer) GetBufferEvents(context.Context, *GetBufferEventsRequest) (*GetBufferEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBufferEvents not implemented")
}
func (UnimplementedStreamAnalyticsServiceServer) GetStreamHealthMetrics(context.Context, *GetStreamHealthMetricsRequest) (*GetStreamHealthMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStreamHealthMetrics not implemented")
}
func (UnimplementedStreamAnalyticsServiceServer) GetStreamStatus(context.Context, *GetStreamStatusRequest) (*StreamStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStreamStatus not implemented")
}
func (UnimplementedStreamAnalyticsServiceServer) GetStreamsStatus(context.Context, *GetStreamsStatusRequest) (*StreamsStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStreamsStatus not implemented")
}
func (UnimplementedStreamAnalyticsServiceServer) mustEmbedUnimplementedStreamAnalyticsServiceServer() {
}
func (UnimplementedStreamAnalyticsServiceServer) testEmbeddedByValue() {}

// UnsafeStreamAnalyticsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StreamAnalyticsServiceServer will
// result in compilation errors.
type UnsafeStreamAnalyticsServiceServer interface {
	mustEmbedUnimplementedStreamAnalyticsServiceServer()
}

func RegisterStreamAnalyticsServiceServer(s grpc.ServiceRegistrar, srv StreamAnalyticsServiceServer) {
	// If the following call panics, it indicates UnimplementedStreamAnalyticsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StreamAnalyticsService_ServiceDesc, srv)
}

func _StreamAnalyticsService_GetStreamAnalytics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamAnalyticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAnalyticsServiceServer).GetStreamAnalytics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAnalyticsService_GetStreamAnalytics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAnalyticsServiceServer).GetStreamAnalytics(ctx, req.(*GetStreamAnalyticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAnalyticsService_GetStreamEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAnalyticsServiceServer).GetStreamEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAnalyticsService_GetStreamEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAnalyticsServiceServer).GetStreamEvents(ctx, req.(*GetStreamEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAnalyticsService_GetBufferEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBufferEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAnalyticsServiceServer).GetBufferEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAnalyticsService_GetBufferEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAnalyticsServiceServer).GetBufferEvents(ctx, req.(*GetBufferEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAnalyticsService_GetStreamHealthMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamHealthMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAnalyticsServiceServer).GetStreamHealthMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAnalyticsService_GetStreamHealthMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAnalyticsServiceServer).GetStreamHealthMetrics(ctx, req.(*GetStreamHealthMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAnalyticsService_GetStreamStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAnalyticsServiceServer).GetStreamStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAnalyticsService_GetStreamStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAnalyticsServiceServer).GetStreamStatus(ctx, req.(*GetStreamStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamAnalyticsService_GetStreamsStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamsStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamAnalyticsServiceServer).GetStreamsStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamAnalyticsService_GetStreamsStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamAnalyticsServiceServer).GetStreamsStatus(ctx, req.(*GetStreamsStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StreamAnalyticsService_ServiceDesc is the grpc.ServiceDesc for StreamAnalyticsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StreamAnalyticsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "periscope.StreamAnalyticsService",
	HandlerType: (*StreamAnalyticsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStreamAnalytics",
			Handler:    _StreamAnalyticsService_GetStreamAnalytics_Handler,
		},
		{
			MethodName: "GetStreamEvents",
			Handler:    _StreamAnalyticsService_GetStreamEvents_Handler,
		},
		{
			MethodName: "GetBufferEvents",
			Handler:    _StreamAnalyticsService_GetBufferEvents_Handler,
		},
		{
			MethodName: "GetStreamHealthMetrics",
			Handler:    _StreamAnalyticsService_GetStreamHealthMetrics_Handler,
		},
		{
			MethodName: "GetStreamStatus",
			Handler:    _StreamAnalyticsService_GetStreamStatus_Handler,
		},
		{
			MethodName: "GetStreamsStatus",
			Handler:    _StreamAnalyticsService_GetStreamsStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "periscope.proto",
}

const (
	ViewerAnalyticsService_GetViewerMetrics_FullMethodName          = "/periscope.ViewerAnalyticsService/GetViewerMetrics"
	ViewerAnalyticsService_GetViewerCountTimeSeries_FullMethodName  = "/periscope.ViewerAnalyticsService/GetViewerCountTimeSeries"
	ViewerAnalyticsService_GetGeographicDistribution_FullMethodName = "/periscope.ViewerAnalyticsService/GetGeographicDistribution"
)

// ViewerAnalyticsServiceClient is the client API for ViewerAnalyticsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ViewerAnalyticsServiceClient interface {
	GetViewerMetrics(ctx context.Context, in *GetViewerMetricsRequest, opts ...grpc.CallOption) (*GetViewerMetricsResponse, error)
	GetViewerCountTimeSeries(ctx context.Context, in *GetViewerCountTimeSeriesRequest, opts ...grpc.CallOption) (*GetViewerCountTimeSeriesResponse, error)
	GetGeographicDistribution(ctx context.Context, in *GetGeographicDistributionRequest, opts ...grpc.CallOption) (*GetGeographicDistributionResponse, error)
}

type viewerAnalyticsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewViewerAnalyticsServiceClient(cc grpc.ClientConnInterface) ViewerAnalyticsServiceClient {
	return &viewerAnalyticsServiceClient{cc}
}

func (c *viewerAnalyticsServiceClient) GetViewerMetrics(ctx context.Context, in *GetViewerMetricsRequest, opts ...grpc.CallOption) (*GetViewerMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetViewerMetricsResponse)
	err := c.cc.Invoke(ctx, ViewerAnalyticsService_GetViewerMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *viewerAnalyticsServiceClient) GetViewerCountTimeSeries(ctx context.Context, in *GetViewerCountTimeSeriesRequest, opts ...grpc.CallOption) (*GetViewerCountTimeSeriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetViewerCountTimeSeriesResponse)
	err := c.cc.Invoke(ctx, ViewerAnalyticsService_GetViewerCountTimeSeries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *viewerAnalyticsServiceClient) GetGeographicDistribution(ctx context.Context, in *GetGeographicDistributionRequest, opts ...grpc.CallOption) (*GetGeographicDistributionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGeographicDistributionResponse)
	err := c.cc.Invoke(ctx, ViewerAnalyticsService_GetGeographicDistribution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ViewerAnalyticsServiceServer is the server API for ViewerAnalyticsService service.
// All implementations must embed UnimplementedViewerAnalyticsServiceServer
// for forward compatibility.
type ViewerAnalyticsServiceServer interface {
	GetViewerMetrics(context.Context, *GetViewerMetricsRequest) (*GetViewerMetricsResponse, error)
	GetViewerCountTimeSeries(context.Context, *GetViewerCountTimeSeriesRequest) (*GetViewerCountTimeSeriesResponse, error)
	GetGeographicDistribution(context.Context, *GetGeographicDistributionRequest) (*GetGeographicDistributionResponse, error)
	mustEmbedUnimplementedViewerAnalyticsServiceServer()
}

// UnimplementedViewerAnalyticsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedViewerAnalyticsServiceServer struct{}

func (UnimplementedViewerAnalyticsServiceServer) GetViewerMetrics(context.Context, *GetViewerMetricsRequest) (*GetViewerMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetViewerMetrics not implemented")
}
func (UnimplementedViewerAnalyticsServiceServer) GetViewerCountTimeSeries(context.Context, *GetViewerCountTimeSeriesRequest) (*GetViewerCountTimeSeriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetViewerCountTimeSeries not implemented")
}
func (UnimplementedViewerAnalyticsServiceServer) GetGeographicDistribution(context.Context, *GetGeographicDistributionRequest) (*GetGeographicDistributionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGeographicDistribution not implemented")
}
func (UnimplementedViewerAnalyticsServiceServer) mustEmbedUnimplementedViewerAnalyticsServiceServer() {
}
func (UnimplementedViewerAnalyticsServiceServer) testEmbeddedByValue() {}

// UnsafeViewerAnalyticsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ViewerAnalyticsServiceServer will
// result in compilation errors.
type UnsafeViewerAnalyticsServiceServer interface {
	mustEmbedUnimplementedViewerAnalyticsServiceServer()
}

func RegisterViewerAnalyticsServiceServer(s grpc.ServiceRegistrar, srv ViewerAnalyticsServiceServer) {
	// If the following call panics, it indicates UnimplementedViewerAnalyticsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ViewerAnalyticsService_ServiceDesc, srv)
}

func _ViewerAnalyticsService_GetViewerMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetViewerMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerAnalyticsServiceServer).GetViewerMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerAnalyticsService_GetViewerMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerAnalyticsServiceServer).GetViewerMetrics(ctx, req.(*GetViewerMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ViewerAnalyticsService_GetViewerCountTimeSeries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetViewerCountTimeSeriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerAnalyticsServiceServer).GetViewerCountTimeSeries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerAnalyticsService_GetViewerCountTimeSeries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerAnalyticsServiceServer).GetViewerCountTimeSeries(ctx, req.(*GetViewerCountTimeSeriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ViewerAnalyticsService_GetGeographicDistribution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGeographicDistributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerAnalyticsServiceServer).GetGeographicDistribution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerAnalyticsService_GetGeographicDistribution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerAnalyticsServiceServer).GetGeographicDistribution(ctx, req.(*GetGeographicDistributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ViewerAnalyticsService_ServiceDesc is the grpc.ServiceDesc for ViewerAnalyticsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ViewerAnalyticsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "periscope.ViewerAnalyticsService",
	HandlerType: (*ViewerAnalyticsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetViewerMetrics",
			Handler:    _ViewerAnalyticsService_GetViewerMetrics_Handler,
		},
		{
			MethodName: "GetViewerCountTimeSeries",
			Handler:    _ViewerAnalyticsService_GetViewerCountTimeSeries_Handler,
		},
		{
			MethodName: "GetGeographicDistribution",
			Handler:    _ViewerAnalyticsService_GetGeographicDistribution_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "periscope.proto",
}

const (
	TrackAnalyticsService_GetTrackListEvents_FullMethodName = "/periscope.TrackAnalyticsService/GetTrackListEvents"
)

// TrackAnalyticsServiceClient is the client API for TrackAnalyticsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrackAnalyticsServiceClient interface {
	GetTrackListEvents(ctx context.Context, in *GetTrackListEventsRequest, opts ...grpc.CallOption) (*GetTrackListEventsResponse, error)
}

type trackAnalyticsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTrackAnalyticsServiceClient(cc grpc.ClientConnInterface) TrackAnalyticsServiceClient {
	return &trackAnalyticsServiceClient{cc}
}

func (c *trackAnalyticsServiceClient) GetTrackListEvents(ctx context.Context, in *GetTrackListEventsRequest, opts ...grpc.CallOption) (*GetTrackListEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTrackListEventsResponse)
	err := c.cc.Invoke(ctx, TrackAnalyticsService_GetTrackListEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrackAnalyticsServiceServer is the server API for TrackAnalyticsService service.
// All implementations must embed UnimplementedTrackAnalyticsServiceServer
// for forward compatibility.
type TrackAnalyticsServiceServer interface {
	GetTrackListEvents(context.Context, *GetTrackListEventsRequest) (*GetTrackListEventsResponse, error)
	mustEmbedUnimplementedTrackAnalyticsServiceServer()
}

// UnimplementedTrackAnalyticsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTrackAnalyticsServiceServer struct{}

func (UnimplementedTrackAnalyticsServiceServer) GetTrackListEvents(context.Context, *GetTrackListEventsRequest) (*GetTrackListEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTrackListEvents not implemented")
}
func (UnimplementedTrackAnalyticsServiceServer) mustEmbedUnimplementedTrackAnalyticsServiceServer() {}
func (UnimplementedTrackAnalyticsServiceServer) testEmbeddedByValue()                               {}

// UnsafeTrackAnalyticsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrackAnalyticsServiceServer will
// result in compilation errors.
type UnsafeTrackAnalyticsServiceServer interface {
	mustEmbedUnimplementedTrackAnalyticsServiceServer()
}

func RegisterTrackAnalyticsServiceServer(s grpc.ServiceRegistrar, srv TrackAnalyticsServiceServer) {
	// If the following call panics, it indicates UnimplementedTrackAnalyticsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TrackAnalyticsService_ServiceDesc, srv)
}

func _TrackAnalyticsService_GetTrackListEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTrackListEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrackAnalyticsServiceServer).GetTrackListEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TrackAnalyticsService_GetTrackListEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrackAnalyticsServiceServer).GetTrackListEvents(ctx, req.(*GetTrackListEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TrackAnalyticsService_ServiceDesc is the grpc.ServiceDesc for TrackAnalyticsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TrackAnalyticsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "periscope.TrackAnalyticsService",
	HandlerType: (*TrackAnalyticsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTrackListEvents",
			Handler:    _TrackAnalyticsService_GetTrackListEvents_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "periscope.proto",
}

const (
	ConnectionAnalyticsService_GetConnectionEvents_FullMethodName = "/periscope.ConnectionAnalyticsService/GetConnectionEvents"
)

// ConnectionAnalyticsServiceClient is the client API for ConnectionAnalyticsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConnectionAnalyticsServiceClient interface {
	GetConnectionEvents(ctx context.Context, in *GetConnectionEventsRequest, opts ...grpc.CallOption) (*GetConnectionEventsResponse, error)
}

type connectionAnalyticsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConnectionAnalyticsServiceClient(cc grpc.ClientConnInterface) ConnectionAnalyticsServiceClient {
	return &connectionAnalyticsServiceClient{cc}
}

func (c *connectionAnalyticsServiceClient) GetConnectionEvents(ctx context.Context, in *GetConnectionEventsRequest, opts ...grpc.CallOption) (*GetConnectionEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConnectionEventsResponse)
	err := c.cc.Invoke(ctx, ConnectionAnalyticsService_GetConnectionEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConnectionAnalyticsServiceServer is the server API for ConnectionAnalyticsService service.
// All implementations must embed UnimplementedConnectionAnalyticsServiceServer
// for forward compatibility.
type ConnectionAnalyticsServiceServer interface {
	GetConnectionEvents(context.Context, *GetConnectionEventsRequest) (*GetConnectionEventsResponse, error)
	mustEmbedUnimplementedConnectionAnalyticsServiceServer()
}

// UnimplementedConnectionAnalyticsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConnectionAnalyticsServiceServer struct{}

func (UnimplementedConnectionAnalyticsServiceServer) GetConnectionEvents(context.Context, *GetConnectionEventsRequest) (*GetConnectionEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConnectionEvents not implemented")
}
func (UnimplementedConnectionAnalyticsServiceServer) mustEmbedUnimplementedConnectionAnalyticsServiceServer() {
}
func (UnimplementedConnectionAnalyticsServiceServer) testEmbeddedByValue() {}

// UnsafeConnectionAnalyticsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConnectionAnalyticsServiceServer will
// result in compilation errors.
type UnsafeConnectionAnalyticsServiceServer interface {
	mustEmbedUnimplementedConnectionAnalyticsServiceServer()
}

func RegisterConnectionAnalyticsServiceServer(s grpc.ServiceRegistrar, srv ConnectionAnalyticsServiceServer) {
	// If the following call panics, it indicates UnimplementedConnectionAnalyticsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConnectionAnalyticsService_ServiceDesc, srv)
}

func _ConnectionAnalyticsService_GetConnectionEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConnectionEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionAnalyticsServiceServer).GetConnectionEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionAnalyticsService_GetConnectionEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionAnalyticsServiceServer).GetConnectionEvents(ctx, req.(*GetConnectionEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConnectionAnalyticsService_ServiceDesc is the grpc.ServiceDesc for ConnectionAnalyticsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConnectionAnalyticsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "periscope.ConnectionAnalyticsService",
	HandlerType: (*ConnectionAnalyticsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConnectionEvents",
			Handler:    _ConnectionAnalyticsService_GetConnectionEvents_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "periscope.proto",
}

const (
	NodeAnalyticsService_GetNodeMetrics_FullMethodName   = "/periscope.NodeAnalyticsService/GetNodeMetrics"
	NodeAnalyticsService_GetNodeMetrics1H_FullMethodName = "/periscope.NodeAnalyticsService/GetNodeMetrics1h"
	NodeAnalyticsService_GetLiveNodes_FullMethodName     = "/periscope.NodeAnalyticsService/GetLiveNodes"
)

// NodeAnalyticsServiceClient is the client API for NodeAnalyticsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeAnalyticsServiceClient interface {
	GetNodeMetrics(ctx context.Context, in *GetNodeMetricsRequest, opts ...grpc.CallOption) (*GetNodeMetricsResponse, error)
	GetNodeMetrics1H(ctx context.Context, in *GetNodeMetrics1HRequest, opts ...grpc.CallOption) (*GetNodeMetrics1HResponse, error)
	// Live node state queries (from live_nodes ReplacingMergeTree)
	GetLiveNodes(ctx context.Context, in *GetLiveNodesRequest, opts ...grpc.CallOption) (*GetLiveNodesResponse, error)
}

type nodeAnalyticsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeAnalyticsServiceClient(cc grpc.ClientConnInterface) NodeAnalyticsServiceClient {
	return &nodeAnalyticsServiceClient{cc}
}

func (c *nodeAnalyticsServiceClient) GetNodeMetrics(ctx context.Context, in *GetNodeMetricsRequest, opts ...grpc.CallOption) (*GetNodeMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodeMetricsResponse)
	err := c.cc.Invoke(ctx, NodeAnalyticsService_GetNodeMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeAnalyticsServiceClient) GetNodeMetrics1H(ctx context.Context, in *GetNodeMetrics1HRequest, opts ...grpc.CallOption) (*GetNodeMetrics1HResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodeMetrics1HResponse)
	err := c.cc.Invoke(ctx, NodeAnalyticsService_GetNodeMetrics1H_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeAnalyticsServiceClient) GetLiveNodes(ctx context.Context, in *GetLiveNodesRequest, opts ...grpc.CallOption) (*GetLiveNodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLiveNodesResponse)
	err := c.cc.Invoke(ctx, NodeAnalyticsService_GetLiveNodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeAnalyticsServiceServer is the server API for NodeAnalyticsService service.
// All implementations must embed UnimplementedNodeAnalyticsServiceServer
// for forward compatibility.
type NodeAnalyticsServiceServer interface {
	GetNodeMetrics(context.Context, *GetNodeMetricsRequest) (*GetNodeMetricsResponse, error)
	GetNodeMetrics1H(context.Context, *GetNodeMetrics1HRequest) (*GetNodeMetrics1HResponse, error)
	// Live node state queries (from live_nodes ReplacingMergeTree)
	GetLiveNodes(context.Context, *GetLiveNodesRequest) (*GetLiveNodesResponse, error)
	mustEmbedUnimplementedNodeAnalyticsServiceServer()
}

// UnimplementedNodeAnalyticsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNodeAnalyticsServiceServer struct{}

func (UnimplementedNodeAnalyticsServiceServer) GetNodeMetrics(context.Context, *GetNodeMetricsRequest) (*GetNodeMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeMetrics not implemented")
}
func (UnimplementedNodeAnalyticsServiceServer) GetNodeMetrics1H(context.Context, *GetNodeMetrics1HRequest) (*GetNodeMetrics1HResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeMetrics1H not implemented")
}
func (UnimplementedNodeAnalyticsServiceServer) GetLiveNodes(context.Context, *GetLiveNodesRequest) (*GetLiveNodesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLiveNodes not implemented")
}
func (UnimplementedNodeAnalyticsServiceServer) mustEmbedUnimplementedNodeAnalyticsServiceServer() {}
func (UnimplementedNodeAnalyticsServiceServer) testEmbeddedByValue()                              {}

// UnsafeNodeAnalyticsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeAnalyticsServiceServer will
// result in compilation errors.
type UnsafeNodeAnalyticsServiceServer interface {
	mustEmbedUnimplementedNodeAnalyticsServiceServer()
}

func RegisterNodeAnalyticsServiceServer(s grpc.ServiceRegistrar, srv NodeAnalyticsServiceServer) {
	// If the following call panics, it indicates UnimplementedNodeAnalyticsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NodeAnalyticsService_ServiceDesc, srv)
}

func _NodeAnalyticsService_GetNodeMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeAnalyticsServiceServer).GetNodeMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeAnalyticsService_GetNodeMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeAnalyticsServiceServer).GetNodeMetrics(ctx, req.(*GetNodeMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeAnalyticsService_GetNodeMetrics1H_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeMetrics1HRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeAnalyticsServiceServer).GetNodeMetrics1H(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeAnalyticsService_GetNodeMetrics1H_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeAnalyticsServiceServer).GetNodeMetrics1H(ctx, req.(*GetNodeMetrics1HRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeAnalyticsService_GetLiveNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLiveNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeAnalyticsServiceServer).GetLiveNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeAnalyticsService_GetLiveNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeAnalyticsServiceServer).GetLiveNodes(ctx, req.(*GetLiveNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeAnalyticsService_ServiceDesc is the grpc.ServiceDesc for NodeAnalyticsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeAnalyticsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "periscope.NodeAnalyticsService",
	HandlerType: (*NodeAnalyticsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNodeMetrics",
			Handler:    _NodeAnalyticsService_GetNodeMetrics_Handler,
		},
		{
			MethodName: "GetNodeMetrics1h",
			Handler:    _NodeAnalyticsService_GetNodeMetrics1H_Handler,
		},
		{
			MethodName: "GetLiveNodes",
			Handler:    _NodeAnalyticsService_GetLiveNodes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "periscope.proto",
}

const (
	RoutingAnalyticsService_GetRoutingEvents_FullMethodName = "/periscope.RoutingAnalyticsService/GetRoutingEvents"
)

// RoutingAnalyticsServiceClient is the client API for RoutingAnalyticsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoutingAnalyticsServiceClient interface {
	GetRoutingEvents(ctx context.Context, in *GetRoutingEventsRequest, opts ...grpc.CallOption) (*GetRoutingEventsResponse, error)
}

type routingAnalyticsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRoutingAnalyticsServiceClient(cc grpc.ClientConnInterface) RoutingAnalyticsServiceClient {
	return &routingAnalyticsServiceClient{cc}
}

func (c *routingAnalyticsServiceClient) GetRoutingEvents(ctx context.Context, in *GetRoutingEventsRequest, opts ...grpc.CallOption) (*GetRoutingEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRoutingEventsResponse)
	err := c.cc.Invoke(ctx, RoutingAnalyticsService_GetRoutingEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoutingAnalyticsServiceServer is the server API for RoutingAnalyticsService service.
// All implementations must embed UnimplementedRoutingAnalyticsServiceServer
// for forward compatibility.
type RoutingAnalyticsServiceServer interface {
	GetRoutingEvents(context.Context, *GetRoutingEventsRequest) (*GetRoutingEventsResponse, error)
	mustEmbedUnimplementedRoutingAnalyticsServiceServer()
}

// UnimplementedRoutingAnalyticsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRoutingAnalyticsServiceServer struct{}

func (UnimplementedRoutingAnalyticsServiceServer) GetRoutingEvents(context.Context, *GetRoutingEventsRequest) (*GetRoutingEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRoutingEvents not implemented")
}
func (UnimplementedRoutingAnalyticsServiceServer) mustEmbedUnimplementedRoutingAnalyticsServiceServer() {
}
func (UnimplementedRoutingAnalyticsServiceServer) testEmbeddedByValue() {}

// UnsafeRoutingAnalyticsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoutingAnalyticsServiceServer will
// result in compilation errors.
type UnsafeRoutingAnalyticsServiceServer interface {
	mustEmbedUnimplementedRoutingAnalyticsServiceServer()
}

func RegisterRoutingAnalyticsServiceServer(s grpc.ServiceRegistrar, srv RoutingAnalyticsServiceServer) {
	// If the following call panics, it indicates UnimplementedRoutingAnalyticsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RoutingAnalyticsService_ServiceDesc, srv)
}

func _RoutingAnalyticsService_GetRoutingEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoutingEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingAnalyticsServiceServer).GetRoutingEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutingAnalyticsService_GetRoutingEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingAnalyticsServiceServer).GetRoutingEvents(ctx, req.(*GetRoutingEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RoutingAnalyticsService_ServiceDesc is the grpc.ServiceDesc for RoutingAnalyticsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoutingAnalyticsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "periscope.RoutingAnalyticsService",
	HandlerType: (*RoutingAnalyticsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRoutingEvents",
			Handler:    _RoutingAnalyticsService_GetRoutingEvents_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "periscope.proto",
}

const (
	PlatformAnalyticsService_GetPlatformOverview_FullMethodName = "/periscope.PlatformAnalyticsService/GetPlatformOverview"
)

// PlatformAnalyticsServiceClient is the client API for PlatformAnalyticsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PlatformAnalyticsServiceClient interface {
	GetPlatformOverview(ctx context.Context, in *GetPlatformOverviewRequest, opts ...grpc.CallOption) (*GetPlatformOverviewResponse, error)
}

type platformAnalyticsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPlatformAnalyticsServiceClient(cc grpc.ClientConnInterface) PlatformAnalyticsServiceClient {
	return &platformAnalyticsServiceClient{cc}
}

func (c *platformAnalyticsServiceClient) GetPlatformOverview(ctx context.Context, in *GetPlatformOverviewRequest, opts ...grpc.CallOption) (*GetPlatformOverviewResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPlatformOverviewResponse)
	err := c.cc.Invoke(ctx, PlatformAnalyticsService_GetPlatformOverview_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlatformAnalyticsServiceServer is the server API for PlatformAnalyticsService service.
// All implementations must embed UnimplementedPlatformAnalyticsServiceServer
// for forward compatibility.
type PlatformAnalyticsServiceServer interface {
	GetPlatformOverview(context.Context, *GetPlatformOverviewRequest) (*GetPlatformOverviewResponse, error)
	mustEmbedUnimplementedPlatformAnalyticsServiceServer()
}

// UnimplementedPlatformAnalyticsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPlatformAnalyticsServiceServer struct{}

func (UnimplementedPlatformAnalyticsServiceServer) GetPlatformOverview(context.Context, *GetPlatformOverviewRequest) (*GetPlatformOverviewResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPlatformOverview not implemented")
}
func (UnimplementedPlatformAnalyticsServiceServer) mustEmbedUnimplementedPlatformAnalyticsServiceServer() {
}
func (UnimplementedPlatformAnalyticsServiceServer) testEmbeddedByValue() {}

// UnsafePlatformAnalyticsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PlatformAnalyticsServiceServer will
// result in compilation errors.
type UnsafePlatformAnalyticsServiceServer interface {
	mustEmbedUnimplementedPlatformAnalyticsServiceServer()
}

func RegisterPlatformAnalyticsServiceServer(s grpc.ServiceRegistrar, srv PlatformAnalyticsServiceServer) {
	// If the following call panics, it indicates UnimplementedPlatformAnalyticsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PlatformAnalyticsService_ServiceDesc, srv)
}

func _PlatformAnalyticsService_GetPlatformOverview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlatformOverviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformAnalyticsServiceServer).GetPlatformOverview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlatformAnalyticsService_GetPlatformOverview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformAnalyticsServiceServer).GetPlatformOverview(ctx, req.(*GetPlatformOverviewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PlatformAnalyticsService_ServiceDesc is the grpc.ServiceDesc for PlatformAnalyticsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PlatformAnalyticsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "periscope.PlatformAnalyticsService",
	HandlerType: (*PlatformAnalyticsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPlatformOverview",
			Handler:    _PlatformAnalyticsService_GetPlatformOverview_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "periscope.proto",
}

const (
	ClipAnalyticsService_GetClipEvents_FullMethodName     = "/periscope.ClipAnalyticsService/GetClipEvents"
	ClipAnalyticsService_GetArtifactState_FullMethodName  = "/periscope.ClipAnalyticsService/GetArtifactState"
	ClipAnalyticsService_GetArtifactStates_FullMethodName = "/periscope.ClipAnalyticsService/GetArtifactStates"
)

// ClipAnalyticsServiceClient is the client API for ClipAnalyticsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClipAnalyticsServiceClient interface {
	GetClipEvents(ctx context.Context, in *GetClipEventsRequest, opts ...grpc.CallOption) (*GetClipEventsResponse, error)
	// Artifact state queries (live_artifacts table - current state)
	GetArtifactState(ctx context.Context, in *GetArtifactStateRequest, opts ...grpc.CallOption) (*GetArtifactStateResponse, error)
	GetArtifactStates(ctx context.Context, in *GetArtifactStatesRequest, opts ...grpc.CallOption) (*GetArtifactStatesResponse, error)
}

type clipAnalyticsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClipAnalyticsServiceClient(cc grpc.ClientConnInterface) ClipAnalyticsServiceClient {
	return &clipAnalyticsServiceClient{cc}
}

func (c *clipAnalyticsServiceClient) GetClipEvents(ctx context.Context, in *GetClipEventsRequest, opts ...grpc.CallOption) (*GetClipEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClipEventsResponse)
	err := c.cc.Invoke(ctx, ClipAnalyticsService_GetClipEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipAnalyticsServiceClient) GetArtifactState(ctx context.Context, in *GetArtifactStateRequest, opts ...grpc.CallOption) (*GetArtifactStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetArtifactStateResponse)
	err := c.cc.Invoke(ctx, ClipAnalyticsService_GetArtifactState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipAnalyticsServiceClient) GetArtifactStates(ctx context.Context, in *GetArtifactStatesRequest, opts ...grpc.CallOption) (*GetArtifactStatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetArtifactStatesResponse)
	err := c.cc.Invoke(ctx, ClipAnalyticsService_GetArtifactStates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClipAnalyticsServiceServer is the server API for ClipAnalyticsService service.
// All implementations must embed UnimplementedClipAnalyticsServiceServer
// for forward compatibility.
type ClipAnalyticsServiceServer interface {
	GetClipEvents(context.Context, *GetClipEventsRequest) (*GetClipEventsResponse, error)
	// Artifact state queries (live_artifacts table - current state)
	GetArtifactState(context.Context, *GetArtifactStateRequest) (*GetArtifactStateResponse, error)
	GetArtifactStates(context.Context, *GetArtifactStatesRequest) (*GetArtifactStatesResponse, error)
	mustEmbedUnimplementedClipAnalyticsServiceServer()
}

// UnimplementedClipAnalyticsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClipAnalyticsServiceServer struct{}

func (UnimplementedClipAnalyticsServiceServer) GetClipEvents(context.Context, *GetClipEventsRequest) (*GetClipEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClipEvents not implemented")
}
func (UnimplementedClipAnalyticsServiceServer) GetArtifactState(context.Context, *GetArtifactStateRequest) (*GetArtifactStateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetArtifactState not implemented")
}
func (UnimplementedClipAnalyticsServiceServer) GetArtifactStates(context.Context, *GetArtifactStatesRequest) (*GetArtifactStatesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetArtifactStates not implemented")
}
func (UnimplementedClipAnalyticsServiceServer) mustEmbedUnimplementedClipAnalyticsServiceServer() {}
func (UnimplementedClipAnalyticsServiceServer) testEmbeddedByValue()                              {}

// UnsafeClipAnalyticsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClipAnalyticsServiceServer will
// result in compilation errors.
type UnsafeClipAnalyticsServiceServer interface {
	mustEmbedUnimplementedClipAnalyticsServiceServer()
}

func RegisterClipAnalyticsServiceServer(s grpc.ServiceRegistrar, srv ClipAnalyticsServiceServer) {
	// If the following call panics, it indicates UnimplementedClipAnalyticsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ClipAnalyticsService_ServiceDesc, srv)
}

func _ClipAnalyticsService_GetClipEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClipEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipAnalyticsServiceServer).GetClipEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipAnalyticsService_GetClipEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipAnalyticsServiceServer).GetClipEvents(ctx, req.(*GetClipEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipAnalyticsService_GetArtifactState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArtifactStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipAnalyticsServiceServer).GetArtifactState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipAnalyticsService_GetArtifactState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipAnalyticsServiceServer).GetArtifactState(ctx, req.(*GetArtifactStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipAnalyticsService_GetArtifactStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArtifactStatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipAnalyticsServiceServer).GetArtifactStates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipAnalyticsService_GetArtifactStates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipAnalyticsServiceServer).GetArtifactStates(ctx, req.(*GetArtifactStatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClipAnalyticsService_ServiceDesc is the grpc.ServiceDesc for ClipAnalyticsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClipAnalyticsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "periscope.ClipAnalyticsService",
	HandlerType: (*ClipAnalyticsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClipEvents",
			Handler:    _ClipAnalyticsService_GetClipEvents_Handler,
		},
		{
			MethodName: "GetArtifactState",
			Handler:    _ClipAnalyticsService_GetArtifactState_Handler,
		},
		{
			MethodName: "GetArtifactStates",
			Handler:    _ClipAnalyticsService_GetArtifactStates_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "periscope.proto",
}

const (
	AggregatedAnalyticsService_GetStreamConnectionHourly_FullMethodName = "/periscope.AggregatedAnalyticsService/GetStreamConnectionHourly"
	AggregatedAnalyticsService_GetClientMetrics5M_FullMethodName        = "/periscope.AggregatedAnalyticsService/GetClientMetrics5m"
	AggregatedAnalyticsService_GetQualityTierDaily_FullMethodName       = "/periscope.AggregatedAnalyticsService/GetQualityTierDaily"
	AggregatedAnalyticsService_GetStorageUsage_FullMethodName           = "/periscope.AggregatedAnalyticsService/GetStorageUsage"
	AggregatedAnalyticsService_GetStorageEvents_FullMethodName          = "/periscope.AggregatedAnalyticsService/GetStorageEvents"
	AggregatedAnalyticsService_GetStreamHealth5M_FullMethodName         = "/periscope.AggregatedAnalyticsService/GetStreamHealth5m"
	AggregatedAnalyticsService_GetNodePerformance5M_FullMethodName      = "/periscope.AggregatedAnalyticsService/GetNodePerformance5m"
	AggregatedAnalyticsService_GetViewerHoursHourly_FullMethodName      = "/periscope.AggregatedAnalyticsService/GetViewerHoursHourly"
	AggregatedAnalyticsService_GetViewerGeoHourly_FullMethodName        = "/periscope.AggregatedAnalyticsService/GetViewerGeoHourly"
	AggregatedAnalyticsService_GetTenantDailyStats_FullMethodName       = "/periscope.AggregatedAnalyticsService/GetTenantDailyStats"
	AggregatedAnalyticsService_GetProcessingUsage_FullMethodName        = "/periscope.AggregatedAnalyticsService/GetProcessingUsage"
	AggregatedAnalyticsService_GetRebufferingEvents_FullMethodName      = "/periscope.AggregatedAnalyticsService/GetRebufferingEvents"
	AggregatedAnalyticsService_GetTenantAnalyticsDaily_FullMethodName   = "/periscope.AggregatedAnalyticsService/GetTenantAnalyticsDaily"
	AggregatedAnalyticsService_GetStreamAnalyticsDaily_FullMethodName   = "/periscope.AggregatedAnalyticsService/GetStreamAnalyticsDaily"
)

// AggregatedAnalyticsServiceClient is the client API for AggregatedAnalyticsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service for materialized view analytics
type AggregatedAnalyticsServiceClient interface {
	GetStreamConnectionHourly(ctx context.Context, in *GetStreamConnectionHourlyRequest, opts ...grpc.CallOption) (*GetStreamConnectionHourlyResponse, error)
	GetClientMetrics5M(ctx context.Context, in *GetClientMetrics5MRequest, opts ...grpc.CallOption) (*GetClientMetrics5MResponse, error)
	GetQualityTierDaily(ctx context.Context, in *GetQualityTierDailyRequest, opts ...grpc.CallOption) (*GetQualityTierDailyResponse, error)
	GetStorageUsage(ctx context.Context, in *GetStorageUsageRequest, opts ...grpc.CallOption) (*GetStorageUsageResponse, error)
	GetStorageEvents(ctx context.Context, in *GetStorageEventsRequest, opts ...grpc.CallOption) (*GetStorageEventsResponse, error)
	GetStreamHealth5M(ctx context.Context, in *GetStreamHealth5MRequest, opts ...grpc.CallOption) (*GetStreamHealth5MResponse, error)
	GetNodePerformance5M(ctx context.Context, in *GetNodePerformance5MRequest, opts ...grpc.CallOption) (*GetNodePerformance5MResponse, error)
	GetViewerHoursHourly(ctx context.Context, in *GetViewerHoursHourlyRequest, opts ...grpc.CallOption) (*GetViewerHoursHourlyResponse, error)
	GetViewerGeoHourly(ctx context.Context, in *GetViewerGeoHourlyRequest, opts ...grpc.CallOption) (*GetViewerGeoHourlyResponse, error)
	GetTenantDailyStats(ctx context.Context, in *GetTenantDailyStatsRequest, opts ...grpc.CallOption) (*GetTenantDailyStatsResponse, error)
	GetProcessingUsage(ctx context.Context, in *GetProcessingUsageRequest, opts ...grpc.CallOption) (*GetProcessingUsageResponse, error)
	// Newly exposed tables
	GetRebufferingEvents(ctx context.Context, in *GetRebufferingEventsRequest, opts ...grpc.CallOption) (*GetRebufferingEventsResponse, error)
	GetTenantAnalyticsDaily(ctx context.Context, in *GetTenantAnalyticsDailyRequest, opts ...grpc.CallOption) (*GetTenantAnalyticsDailyResponse, error)
	GetStreamAnalyticsDaily(ctx context.Context, in *GetStreamAnalyticsDailyRequest, opts ...grpc.CallOption) (*GetStreamAnalyticsDailyResponse, error)
}

type aggregatedAnalyticsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAggregatedAnalyticsServiceClient(cc grpc.ClientConnInterface) AggregatedAnalyticsServiceClient {
	return &aggregatedAnalyticsServiceClient{cc}
}

func (c *aggregatedAnalyticsServiceClient) GetStreamConnectionHourly(ctx context.Context, in *GetStreamConnectionHourlyRequest, opts ...grpc.CallOption) (*GetStreamConnectionHourlyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStreamConnectionHourlyResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetStreamConnectionHourly_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetClientMetrics5M(ctx context.Context, in *GetClientMetrics5MRequest, opts ...grpc.CallOption) (*GetClientMetrics5MResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClientMetrics5MResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetClientMetrics5M_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetQualityTierDaily(ctx context.Context, in *GetQualityTierDailyRequest, opts ...grpc.CallOption) (*GetQualityTierDailyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQualityTierDailyResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetQualityTierDaily_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetStorageUsage(ctx context.Context, in *GetStorageUsageRequest, opts ...grpc.CallOption) (*GetStorageUsageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStorageUsageResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetStorageUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetStorageEvents(ctx context.Context, in *GetStorageEventsRequest, opts ...grpc.CallOption) (*GetStorageEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStorageEventsResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetStorageEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetStreamHealth5M(ctx context.Context, in *GetStreamHealth5MRequest, opts ...grpc.CallOption) (*GetStreamHealth5MResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStreamHealth5MResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetStreamHealth5M_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetNodePerformance5M(ctx context.Context, in *GetNodePerformance5MRequest, opts ...grpc.CallOption) (*GetNodePerformance5MResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodePerformance5MResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetNodePerformance5M_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetViewerHoursHourly(ctx context.Context, in *GetViewerHoursHourlyRequest, opts ...grpc.CallOption) (*GetViewerHoursHourlyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetViewerHoursHourlyResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetViewerHoursHourly_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetViewerGeoHourly(ctx context.Context, in *GetViewerGeoHourlyRequest, opts ...grpc.CallOption) (*GetViewerGeoHourlyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetViewerGeoHourlyResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetViewerGeoHourly_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetTenantDailyStats(ctx context.Context, in *GetTenantDailyStatsRequest, opts ...grpc.CallOption) (*GetTenantDailyStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTenantDailyStatsResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetTenantDailyStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetProcessingUsage(ctx context.Context, in *GetProcessingUsageRequest, opts ...grpc.CallOption) (*GetProcessingUsageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProcessingUsageResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetProcessingUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetRebufferingEvents(ctx context.Context, in *GetRebufferingEventsRequest, opts ...grpc.CallOption) (*GetRebufferingEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRebufferingEventsResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetRebufferingEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetTenantAnalyticsDaily(ctx context.Context, in *GetTenantAnalyticsDailyRequest, opts ...grpc.CallOption) (*GetTenantAnalyticsDailyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTenantAnalyticsDailyResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetTenantAnalyticsDaily_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aggregatedAnalyticsServiceClient) GetStreamAnalyticsDaily(ctx context.Context, in *GetStreamAnalyticsDailyRequest, opts ...grpc.CallOption) (*GetStreamAnalyticsDailyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStreamAnalyticsDailyResponse)
	err := c.cc.Invoke(ctx, AggregatedAnalyticsService_GetStreamAnalyticsDaily_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AggregatedAnalyticsServiceServer is the server API for AggregatedAnalyticsService service.
// All implementations must embed UnimplementedAggregatedAnalyticsServiceServer
// for forward compatibility.
//
// Service for materialized view analytics
type AggregatedAnalyticsServiceServer interface {
	GetStreamConnectionHourly(context.Context, *GetStreamConnectionHourlyRequest) (*GetStreamConnectionHourlyResponse, error)
	GetClientMetrics5M(context.Context, *GetClientMetrics5MRequest) (*GetClientMetrics5MResponse, error)
	GetQualityTierDaily(context.Context, *GetQualityTierDailyRequest) (*GetQualityTierDailyResponse, error)
	GetStorageUsage(context.Context, *GetStorageUsageRequest) (*GetStorageUsageResponse, error)
	GetStorageEvents(context.Context, *GetStorageEventsRequest) (*GetStorageEventsResponse, error)
	GetStreamHealth5M(context.Context, *GetStreamHealth5MRequest) (*GetStreamHealth5MResponse, error)
	GetNodePerformance5M(context.Context, *GetNodePerformance5MRequest) (*GetNodePerformance5MResponse, error)
	GetViewerHoursHourly(context.Context, *GetViewerHoursHourlyRequest) (*GetViewerHoursHourlyResponse, error)
	GetViewerGeoHourly(context.Context, *GetViewerGeoHourlyRequest) (*GetViewerGeoHourlyResponse, error)
	GetTenantDailyStats(context.Context, *GetTenantDailyStatsRequest) (*GetTenantDailyStatsResponse, error)
	GetProcessingUsage(context.Context, *GetProcessingUsageRequest) (*GetProcessingUsageResponse, error)
	// Newly exposed tables
	GetRebufferingEvents(context.Context, *GetRebufferingEventsRequest) (*GetRebufferingEventsResponse, error)
	GetTenantAnalyticsDaily(context.Context, *GetTenantAnalyticsDailyRequest) (*GetTenantAnalyticsDailyResponse, error)
	GetStreamAnalyticsDaily(context.Context, *GetStreamAnalyticsDailyRequest) (*GetStreamAnalyticsDailyResponse, error)
	mustEmbedUnimplementedAggregatedAnalyticsServiceServer()
}

// UnimplementedAggregatedAnalyticsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAggregatedAnalyticsServiceServer struct{}

func (UnimplementedAggregatedAnalyticsServiceServer) GetStreamConnectionHourly(context.Context, *GetStreamConnectionHourlyRequest) (*GetStreamConnectionHourlyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStreamConnectionHourly not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetClientMetrics5M(context.Context, *GetClientMetrics5MRequest) (*GetClientMetrics5MResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClientMetrics5M not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetQualityTierDaily(context.Context, *GetQualityTierDailyRequest) (*GetQualityTierDailyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetQualityTierDaily not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetStorageUsage(context.Context, *GetStorageUsageRequest) (*GetStorageUsageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStorageUsage not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetStorageEvents(context.Context, *GetStorageEventsRequest) (*GetStorageEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStorageEvents not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetStreamHealth5M(context.Context, *GetStreamHealth5MRequest) (*GetStreamHealth5MResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStreamHealth5M not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetNodePerformance5M(context.Context, *GetNodePerformance5MRequest) (*GetNodePerformance5MResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodePerformance5M not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetViewerHoursHourly(context.Context, *GetViewerHoursHourlyRequest) (*GetViewerHoursHourlyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetViewerHoursHourly not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetViewerGeoHourly(context.Context, *GetViewerGeoHourlyRequest) (*GetViewerGeoHourlyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetViewerGeoHourly not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetTenantDailyStats(context.Context, *GetTenantDailyStatsRequest) (*GetTenantDailyStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTenantDailyStats not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetProcessingUsage(context.Context, *GetProcessingUsageRequest) (*GetProcessingUsageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProcessingUsage not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetRebufferingEvents(context.Context, *GetRebufferingEventsRequest) (*GetRebufferingEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRebufferingEvents not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetTenantAnalyticsDaily(context.Context, *GetTenantAnalyticsDailyRequest) (*GetTenantAnalyticsDailyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTenantAnalyticsDaily not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) GetStreamAnalyticsDaily(context.Context, *GetStreamAnalyticsDailyRequest) (*GetStreamAnalyticsDailyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStreamAnalyticsDaily not implemented")
}
func (UnimplementedAggregatedAnalyticsServiceServer) mustEmbedUnimplementedAggregatedAnalyticsServiceServer() {
}
func (UnimplementedAggregatedAnalyticsServiceServer) testEmbeddedByValue() {}

// UnsafeAggregatedAnalyticsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AggregatedAnalyticsServiceServer will
// result in compilation errors.
type UnsafeAggregatedAnalyticsServiceServer interface {
	mustEmbedUnimplementedAggregatedAnalyticsServiceServer()
}

func RegisterAggregatedAnalyticsServiceServer(s grpc.ServiceRegistrar, srv AggregatedAnalyticsServiceServer) {
	// If the following call panics, it indicates UnimplementedAggregatedAnalyticsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AggregatedAnalyticsService_ServiceDesc, srv)
}

func _AggregatedAnalyticsService_GetStreamConnectionHourly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamConnectionHourlyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetStreamConnectionHourly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetStreamConnectionHourly_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetStreamConnectionHourly(ctx, req.(*GetStreamConnectionHourlyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetClientMetrics5M_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientMetrics5MRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetClientMetrics5M(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetClientMetrics5M_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetClientMetrics5M(ctx, req.(*GetClientMetrics5MRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetQualityTierDaily_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQualityTierDailyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetQualityTierDaily(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetQualityTierDaily_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetQualityTierDaily(ctx, req.(*GetQualityTierDailyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetStorageUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStorageUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetStorageUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetStorageUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetStorageUsage(ctx, req.(*GetStorageUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetStorageEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStorageEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetStorageEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetStorageEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetStorageEvents(ctx, req.(*GetStorageEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetStreamHealth5M_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamHealth5MRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetStreamHealth5M(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetStreamHealth5M_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetStreamHealth5M(ctx, req.(*GetStreamHealth5MRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetNodePerformance5M_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodePerformance5MRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetNodePerformance5M(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetNodePerformance5M_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetNodePerformance5M(ctx, req.(*GetNodePerformance5MRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetViewerHoursHourly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetViewerHoursHourlyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetViewerHoursHourly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetViewerHoursHourly_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetViewerHoursHourly(ctx, req.(*GetViewerHoursHourlyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetViewerGeoHourly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetViewerGeoHourlyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetViewerGeoHourly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetViewerGeoHourly_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetViewerGeoHourly(ctx, req.(*GetViewerGeoHourlyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetTenantDailyStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTenantDailyStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetTenantDailyStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetTenantDailyStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetTenantDailyStats(ctx, req.(*GetTenantDailyStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetProcessingUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessingUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetProcessingUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetProcessingUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetProcessingUsage(ctx, req.(*GetProcessingUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetRebufferingEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRebufferingEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetRebufferingEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetRebufferingEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetRebufferingEvents(ctx, req.(*GetRebufferingEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetTenantAnalyticsDaily_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTenantAnalyticsDailyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetTenantAnalyticsDaily(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetTenantAnalyticsDaily_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetTenantAnalyticsDaily(ctx, req.(*GetTenantAnalyticsDailyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AggregatedAnalyticsService_GetStreamAnalyticsDaily_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamAnalyticsDailyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AggregatedAnalyticsServiceServer).GetStreamAnalyticsDaily(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AggregatedAnalyticsService_GetStreamAnalyticsDaily_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AggregatedAnalyticsServiceServer).GetStreamAnalyticsDaily(ctx, req.(*GetStreamAnalyticsDailyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AggregatedAnalyticsService_ServiceDesc is the grpc.ServiceDesc for AggregatedAnalyticsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AggregatedAnalyticsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "periscope.AggregatedAnalyticsService",
	HandlerType: (*AggregatedAnalyticsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStreamConnectionHourly",
			Handler:    _AggregatedAnalyticsService_GetStreamConnectionHourly_Handler,
		},
		{
			MethodName: "GetClientMetrics5m",
			Handler:    _AggregatedAnalyticsService_GetClientMetrics5M_Handler,
		},
		{
			MethodName: "GetQualityTierDaily",
			Handler:    _AggregatedAnalyticsService_GetQualityTierDaily_Handler,
		},
		{
			MethodName: "GetStorageUsage",
			Handler:    _AggregatedAnalyticsService_GetStorageUsage_Handler,
		},
		{
			MethodName: "GetStorageEvents",
			Handler:    _AggregatedAnalyticsService_GetStorageEvents_Handler,
		},
		{
			MethodName: "GetStreamHealth5m",
			Handler:    _AggregatedAnalyticsService_GetStreamHealth5M_Handler,
		},
		{
			MethodName: "GetNodePerformance5m",
			Handler:    _AggregatedAnalyticsService_GetNodePerformance5M_Handler,
		},
		{
			MethodName: "GetViewerHoursHourly",
			Handler:    _AggregatedAnalyticsService_GetViewerHoursHourly_Handler,
		},
		{
			MethodName: "GetViewerGeoHourly",
			Handler:    _AggregatedAnalyticsService_GetViewerGeoHourly_Handler,
		},
		{
			MethodName: "GetTenantDailyStats",
			Handler:    _AggregatedAnalyticsService_GetTenantDailyStats_Handler,
		},
		{
			MethodName: "GetProcessingUsage",
			Handler:    _AggregatedAnalyticsService_GetProcessingUsage_Handler,
		},
		{
			MethodName: "GetRebufferingEvents",
			Handler:    _AggregatedAnalyticsService_GetRebufferingEvents_Handler,
		},
		{
			MethodName: "GetTenantAnalyticsDaily",
			Handler:    _AggregatedAnalyticsService_GetTenantAnalyticsDaily_Handler,
		},
		{
			MethodName: "GetStreamAnalyticsDaily",
			Handler:    _AggregatedAnalyticsService_GetStreamAnalyticsDaily_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "periscope.proto",
}
