syntax = "proto3";

package commodore;

option go_package = "frameworks/pkg/proto";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "common.proto";
import "shared.proto";
import "foghorn.proto";
import "purser.proto";

// ============================================================================
// COMMODORE CONTROL PLANE - INTERNAL SERVICE APIs
//
// These are internal service-to-service APIs called by:
// - Foghorn (ValidateStreamKey during PUSH_REWRITE)
// - Decklog (ResolveInternalName for event enrichment)
// - Gateway (user operations proxied through)
//
// Field sources documented inline for verification.
// ============================================================================

// InternalService handles service-to-service lookups (Foghorn, Decklog, etc.)
service InternalService {
  // Called by Foghorn on PUSH_REWRITE to validate stream key
  // Source: pkg/api/commodore/types.go:ValidateStreamKeyResponse
  rpc ValidateStreamKey(ValidateStreamKeyRequest) returns (ValidateStreamKeyResponse);

  // Called by edge nodes to resolve playback ID to internal name
  // Source: pkg/api/commodore/types.go:ResolvePlaybackIDResponse
  rpc ResolvePlaybackID(ResolvePlaybackIDRequest) returns (ResolvePlaybackIDResponse);

  // Called by Decklog/Foghorn to enrich events with tenant context
  // Source: pkg/api/commodore/types.go:InternalNameResponse
  rpc ResolveInternalName(ResolveInternalNameRequest) returns (ResolveInternalNameResponse);

  // Called by Gateway to validate developer API tokens
  // Source: pkg/api/commodore/types.go:ValidateAPITokenResponse
  rpc ValidateAPIToken(ValidateAPITokenRequest) returns (ValidateAPITokenResponse);

  // Called by Foghorn to initiate DVR recording for a stream
  rpc StartDVR(shared.StartDVRRequest) returns (shared.StartDVRResponse);

  // ============================================================================
  // CLIP/DVR REGISTRY (Foghorn → Commodore)
  // Business registry for clips and DVR recordings.
  // See: docs/architecture/CLIP_DVR_REGISTRY.md
  // ============================================================================

  // Register a new clip in the business registry (called by Foghorn during CreateClip)
  rpc RegisterClip(RegisterClipRequest) returns (RegisterClipResponse);

  // Register a new DVR recording in the business registry (called by Foghorn during StartDVR)
  rpc RegisterDVR(RegisterDVRRequest) returns (RegisterDVRResponse);

  // Resolve clip hash to tenant context (for analytics enrichment and playback)
  rpc ResolveClipHash(ResolveClipHashRequest) returns (ResolveClipHashResponse);

  // Resolve DVR hash to tenant context (for analytics enrichment and playback)
  rpc ResolveDVRHash(ResolveDVRHashRequest) returns (ResolveDVRHashResponse);

  // Resolve artifact playback ID to artifact identity (clip/dvr/vod)
  rpc ResolveArtifactPlaybackID(ResolveArtifactPlaybackIDRequest) returns (ResolveArtifactPlaybackIDResponse);

  // Resolve artifact internal routing name to artifact identity (clip/dvr/vod)
  rpc ResolveArtifactInternalName(ResolveArtifactInternalNameRequest) returns (ResolveArtifactInternalNameResponse);

  // Unified identifier resolution - checks streams, clips, and DVR in one call
  // Used by Foghorn for analytics enrichment when local state cache misses
  rpc ResolveIdentifier(ResolveIdentifierRequest) returns (ResolveIdentifierResponse);

  // ============================================================================
  // VOD REGISTRY (Foghorn → Commodore)
  // Business registry for VOD assets. Mirrors clip/DVR pattern.
  // ============================================================================

  // Register a new VOD asset in the business registry (called by Foghorn during CreateVodUpload)
  rpc RegisterVod(RegisterVodRequest) returns (RegisterVodResponse);

  // Resolve VOD hash to tenant context (for analytics enrichment and playback)
  rpc ResolveVodHash(ResolveVodHashRequest) returns (ResolveVodHashResponse);
  // Resolve VOD relay ID (vod_assets.id) to VOD hash + tenant context
  rpc ResolveVodID(ResolveVodIDRequest) returns (ResolveVodIDResponse);

  // ============================================================================
  // WALLET IDENTITY (x402 / Agent Access)
  // Service-to-service call for x402 middleware to lookup/create wallet tenant
  // ============================================================================

  // Lookup or create a tenant/user for a verified wallet address.
  // Called by x402 middleware after verifying ERC-3009 payment signature.
  // If wallet is unknown, creates: tenant (prepaid) + user (email=NULL) + wallet_identity
  rpc GetOrCreateWalletUser(GetOrCreateWalletUserRequest) returns (GetOrCreateWalletUserResponse);

  // ============================================================================
  // TENANT STREAM TERMINATION (Purser → Commodore → Foghorn)
  // Called when a tenant is suspended due to insufficient prepaid balance.
  // Commodore forwards to Foghorn which stops all sessions on affected nodes.
  // ============================================================================
  rpc TerminateTenantStreams(foghorn.TerminateTenantStreamsRequest) returns (foghorn.TerminateTenantStreamsResponse);

  // ============================================================================
  // TENANT CACHE INVALIDATION (Purser → Commodore → Foghorn)
  // Called when a tenant is reactivated after payment.
  // Commodore forwards to Foghorn which clears cached suspension status.
  // ============================================================================
  rpc InvalidateTenantCache(foghorn.InvalidateTenantCacheRequest) returns (foghorn.InvalidateTenantCacheResponse);

  // ============================================================================
  // CROSS-SERVICE: BILLING DATA ACCESS
  // Called by Purser to avoid cross-service database access.
  // ============================================================================

  // Get active user count for a tenant (for billing calculation)
  rpc GetTenantUserCount(GetTenantUserCountRequest) returns (GetTenantUserCountResponse);

  // Get primary user info for a tenant (for billing notifications/invoices)
  rpc GetTenantPrimaryUser(GetTenantPrimaryUserRequest) returns (GetTenantPrimaryUserResponse);
}

// ============================================================================
// STREAM KEY VALIDATION (Foghorn → Commodore)
// Source: pkg/api/commodore/types.go lines 12-19
// ============================================================================

message ValidateStreamKeyRequest {
  string stream_key = 1;
}

// Matches pkg/api/commodore/types.go:ValidateStreamKeyResponse exactly
message ValidateStreamKeyResponse {
  bool valid = 1;                       // json:"valid"
  string user_id = 2;                   // json:"user_id,omitempty"
  string tenant_id = 3;                 // json:"tenant_id,omitempty"
  string internal_name = 4;             // json:"internal_name,omitempty"
  string error = 5;                     // json:"error,omitempty"
  bool is_recording_enabled = 6;        // json:"is_recording_enabled,omitempty"
  string stream_id = 7;                 // Public stream ID (UUID)

  // ===== BILLING MODEL & SUSPENSION =====
  // billing_model: "postpaid" (default) or "prepaid"
  // Used by Foghorn to determine cache TTL (1 min for prepaid, 10 min for postpaid)
  string billing_model = 8;

  // is_suspended: true if tenant is suspended due to negative prepaid balance (< -$10)
  // When true, Foghorn should reject the ingest with error
  bool is_suspended = 9;

  // is_balance_negative: true if prepaid balance <= 0 (but not yet suspended)
  // When true, Foghorn should return 402 for new ingests
  bool is_balance_negative = 10;
}

// ============================================================================
// PLAYBACK ID RESOLUTION (Edge → Commodore)
// Source: pkg/api/commodore/types.go lines 22-27
// ============================================================================

message ResolvePlaybackIDRequest {
  string playback_id = 1;
}

// Matches pkg/api/commodore/types.go:ResolvePlaybackIDResponse exactly
message ResolvePlaybackIDResponse {
  string internal_name = 1;             // json:"internal_name"
  string tenant_id = 2;                 // json:"tenant_id"
  string status = 3;                    // json:"status"
  string playback_id = 4;               // json:"playbook_id" (note: typo in original)
  string stream_id = 5;                 // Public stream ID (UUID)
  string billing_model = 6;             // 'postpaid' or 'prepaid'
  bool is_suspended = 7;                // true if tenant suspended
  bool is_balance_negative = 8;         // true if prepaid balance <= 0
}

// ============================================================================
// INTERNAL NAME RESOLUTION (Decklog → Commodore)
// Source: pkg/api/commodore/types.go lines 249-255
// ============================================================================

message ResolveInternalNameRequest {
  string internal_name = 1;
}

// Matches pkg/api/commodore/types.go:InternalNameResponse exactly
message ResolveInternalNameResponse {
  string internal_name = 1;             // json:"internal_name"
  string tenant_id = 2;                 // json:"tenant_id"
  string user_id = 3;                   // json:"user_id"
  bool is_recording_enabled = 4;        // json:"is_recording_enabled,omitempty"
  string stream_id = 5;                 // Public stream ID (UUID)
}

// ============================================================================
// API TOKEN VALIDATION (Gateway middleware → Commodore)
// Source: pkg/api/commodore/types.go lines 310-318
// ============================================================================

message ValidateAPITokenRequest {
  string token = 1;
}

// Matches pkg/api/commodore/types.go:ValidateAPITokenResponse exactly
message ValidateAPITokenResponse {
  bool valid = 1;                       // json:"valid"
  string user_id = 2;                   // json:"user_id,omitempty"
  string tenant_id = 3;                 // json:"tenant_id,omitempty"
  string email = 4;                     // json:"email,omitempty"
  string role = 5;                      // json:"role,omitempty"
  repeated string permissions = 6;      // json:"permissions,omitempty"
  string token_id = 7;                  // json:"token_id,omitempty"
}

// ============================================================================
// CLIP/DVR BUSINESS REGISTRY (Foghorn → Commodore)
// See: docs/architecture/CLIP_DVR_REGISTRY.md
// ============================================================================

// Register a new clip in the business registry
// Called by Foghorn during CreateClip flow
message RegisterClipRequest {
  string tenant_id = 1;                 // Tenant context (from stream lookup)
  string user_id = 2;                   // User who created the clip
  string stream_id = 3;                 // Source stream UUID
  string title = 4;                     // Optional clip title
  string description = 5;               // Optional clip description
  int64 start_time = 6;                 // Start timestamp (unix ms)
  int64 duration = 7;                   // Duration (ms)
  string clip_mode = 8;                 // absolute, relative, duration, clip_now
  string requested_params = 9;          // Original request JSON for audit
  optional google.protobuf.Timestamp retention_until = 10; // Artifact expiration
}

message RegisterClipResponse {
  string clip_hash = 1;                 // Generated hash (use as artifact_hash in Foghorn)
  string clip_id = 2;                   // Commodore clips table UUID
  string playback_id = 3;              // Public playback key
  string artifact_internal_name = 4;   // Artifact routing name (internal)
}

// Register a new DVR recording in the business registry
// Called by Foghorn during StartDVR flow
message RegisterDVRRequest {
  string tenant_id = 1;                 // Tenant context
  string user_id = 2;                   // User who owns the recording
  string stream_id = 3;                 // Source stream UUID (optional for legacy)
  string internal_name = 4;             // MistServer stream name
  optional google.protobuf.Timestamp retention_until = 5; // Recording expiration
}

message RegisterDVRResponse {
  string dvr_hash = 1;                  // Generated hash (use as artifact_hash in Foghorn)
  string dvr_id = 2;                    // Commodore dvr_recordings table UUID
  string playback_id = 3;              // Public playback key
  string artifact_internal_name = 4;   // Artifact routing name (internal)
  string stream_id = 5;                // Source stream UUID for storage path
}

// Resolve clip hash to tenant context
// Used for analytics enrichment and playback authorization
message ResolveClipHashRequest {
  string clip_hash = 1;
}

message ResolveClipHashResponse {
  bool found = 1;                       // Whether clip was found
  string tenant_id = 2;                 // Tenant context for analytics
  string user_id = 3;                   // Owner for authorization
  string stream_id = 4;                 // Source stream UUID
  string internal_name = 5;             // MistServer stream name (from stream lookup)
  string title = 6;                     // Clip title
  string description = 7;               // Clip description
  int64 start_time = 8;                 // Start timestamp (unix ms)
  int64 duration = 9;                   // Duration (ms)
  string clip_mode = 10;                // How clip was created
  string playback_id = 11;              // Public playback key
  string artifact_internal_name = 12;   // Artifact routing name (internal)
}

// Resolve DVR hash to tenant context
// Used for analytics enrichment and playback authorization
message ResolveDVRHashRequest {
  string dvr_hash = 1;
}

message ResolveDVRHashResponse {
  bool found = 1;                       // Whether DVR was found
  string tenant_id = 2;                 // Tenant context for analytics
  string user_id = 3;                   // Owner for authorization
  string stream_id = 4;                 // Source stream UUID
  string internal_name = 5;             // MistServer stream name
  string playback_id = 6;               // Public playback key
  string artifact_internal_name = 7;    // Artifact routing name (internal)
}

// Unified identifier resolution - single call to check all Commodore registries
// Lookup order: streams (internal_name), streams (playback_id), clips, DVR, VOD
// Used by Foghorn for analytics enrichment when local state cache misses
message ResolveIdentifierRequest {
  string identifier = 1;                // Any identifier: internal_name, playback_id, clip_hash, dvr_hash, vod_hash
}

message ResolveIdentifierResponse {
  bool found = 1;                       // Whether identifier was resolved
  string tenant_id = 2;                 // Tenant context for analytics/billing
  string user_id = 3;                   // Owner (if available)
  string internal_name = 4;             // Canonical stream name (for streams, or parent for clips/DVR)
  string identifier_type = 5;           // "stream", "playback_id", "clip", "dvr", "vod"
  bool is_recording_enabled = 6;        // For streams: whether DVR auto-record is enabled
  string stream_id = 7;                 // Public stream ID (UUID) if applicable
}

// ============================================================================
// VOD BUSINESS REGISTRY (Foghorn → Commodore)
// Mirrors clip/DVR registration pattern - Foghorn calls this to register before storing lifecycle
// ============================================================================

// Register a new VOD asset in the business registry
// Called by Foghorn during CreateVodUpload flow (before storing in foghorn.artifacts)
message RegisterVodRequest {
  string tenant_id = 1;                 // Tenant context
  string user_id = 2;                   // User who initiated upload
  string filename = 3;                  // Original filename (used for hash generation)
  // Optional business metadata (stored in commodore.vod_assets)
  optional string title = 4;
  optional string description = 5;
  optional string content_type = 6;
  optional int64 size_bytes = 7;
}

message RegisterVodResponse {
  string vod_hash = 1;                  // Generated hash (use as artifact_hash in Foghorn)
  string vod_id = 2;                    // Commodore vod_assets table UUID
  string playback_id = 3;              // Public playback key
  string artifact_internal_name = 4;   // Artifact routing name (internal)
}

// Resolve VOD hash to tenant context
// Used for analytics enrichment, playback authorization, and lifecycle operations
message ResolveVodHashRequest {
  string vod_hash = 1;
}

message ResolveVodHashResponse {
  bool found = 1;                       // Whether VOD was found
  string tenant_id = 2;                 // Tenant context for analytics
  string user_id = 3;                   // Owner for authorization
  string filename = 4;                  // Original filename
  string title = 5;                     // VOD title (if set)
  string description = 6;               // VOD description (if set)
  string playback_id = 7;               // Public playback key
  string artifact_internal_name = 8;    // Artifact routing name (internal)
}

// Resolve VOD relay ID (commodore.vod_assets.id) to VOD hash + tenant context
message ResolveVodIDRequest {
  string vod_id = 1;                    // UUID primary key for commodore.vod_assets
}

message ResolveVodIDResponse {
  bool found = 1;
  string tenant_id = 2;
  string user_id = 3;
  string vod_hash = 4;
  string playback_id = 5;
  string artifact_internal_name = 6;
}

// Resolve artifact playback ID to artifact identity
message ResolveArtifactPlaybackIDRequest {
  string playback_id = 1;
}

message ResolveArtifactPlaybackIDResponse {
  bool found = 1;
  string artifact_hash = 2;
  string artifact_internal_name = 3;
  string tenant_id = 4;
  string user_id = 5;
  string stream_id = 6;
  string content_type = 7;              // "clip" | "dvr" | "vod"
}

// Resolve artifact internal name to artifact identity
message ResolveArtifactInternalNameRequest {
  string artifact_internal_name = 1;
}

message ResolveArtifactInternalNameResponse {
  bool found = 1;
  string artifact_hash = 2;
  string artifact_internal_name = 3;
  string tenant_id = 4;
  string user_id = 5;
  string stream_id = 6;
  string content_type = 7;              // "clip" | "dvr" | "vod"
}

// ============================================================================
// WALLET IDENTITY (x402 / Agent Access)
// ============================================================================

// GetOrCreateWalletUserRequest looks up or creates a tenant/user for a wallet address.
// The wallet ownership has already been verified by the caller (via ERC-3009 signature).
message GetOrCreateWalletUserRequest {
  string chain_type = 1;                // "ethereum", "base", "arbitrum"
  string wallet_address = 2;            // 0x-prefixed, will be normalized to checksum format
}

// GetOrCreateWalletUserResponse returns the tenant/user for a wallet.
message GetOrCreateWalletUserResponse {
  string tenant_id = 1;                 // UUID of the tenant
  string user_id = 2;                   // UUID of the user
  bool is_new = 3;                      // true if tenant/user was just created
  string billing_model = 4;             // "prepaid" (always for wallet-created accounts)
  string wallet_address = 5;            // Normalized checksum address
}

// ============================================================================
// CROSS-SERVICE: BILLING DATA ACCESS MESSAGES
// ============================================================================

// Request for tenant user count (for billing calculation)
message GetTenantUserCountRequest {
  string tenant_id = 1;
}

// Response with user counts
message GetTenantUserCountResponse {
  int32 active_count = 1;               // Active users (is_active = true)
  int32 total_count = 2;                // All users (including inactive)
}

// Request for tenant primary user info (for billing notifications)
message GetTenantPrimaryUserRequest {
  string tenant_id = 1;
}

// Response with primary user info (first admin user or first user)
message GetTenantPrimaryUserResponse {
  string user_id = 1;                   // UUID of primary user
  string email = 2;                     // Email address (for billing notifications)
  string name = 3;                      // Display name (first_name + last_name)
}

// ============================================================================
// USER SERVICE (Gateway → Commodore for auth flows)
// ============================================================================

service UserService {
  // Authentication
  rpc Login(LoginRequest) returns (AuthResponse);
  rpc Register(RegisterRequest) returns (RegisterResponse);
  rpc Logout(LogoutRequest) returns (LogoutResponse);
  rpc RefreshToken(RefreshTokenRequest) returns (AuthResponse);

  // Email verification
  rpc VerifyEmail(VerifyEmailRequest) returns (VerifyEmailResponse);
  rpc ResendVerification(ResendVerificationRequest) returns (ResendVerificationResponse);

  // Password reset
  rpc ForgotPassword(ForgotPasswordRequest) returns (ForgotPasswordResponse);
  rpc ResetPassword(ResetPasswordRequest) returns (ResetPasswordResponse);

  // Profile
  rpc GetMe(GetMeRequest) returns (User);
  rpc UpdateMe(UpdateMeRequest) returns (User);
  rpc UpdateNewsletter(UpdateNewsletterRequest) returns (UpdateNewsletterResponse);
  rpc GetNewsletterStatus(GetNewsletterStatusRequest) returns (GetNewsletterStatusResponse);

  // Wallet authentication (x402 / agent access)
  rpc WalletLogin(WalletLoginRequest) returns (AuthResponse);
  rpc WalletLoginWithX402(WalletLoginWithX402Request) returns (WalletLoginWithX402Response);
  rpc LinkWallet(LinkWalletRequest) returns (WalletIdentity);
  rpc UnlinkWallet(UnlinkWalletRequest) returns (UnlinkWalletResponse);
  rpc ListWallets(ListWalletsRequest) returns (ListWalletsResponse);

  // Email linking (for wallet-only users to add email for postpaid upgrade)
  rpc LinkEmail(LinkEmailRequest) returns (LinkEmailResponse);
}

// Matches pkg/api/commodore/types.go:LoginRequest (lines 85-88)
message LoginRequest {
  string email = 1;                     // json:"email"
  string password = 2;                  // json:"password"
  string turnstile_token = 3;           // json:"turnstile_token,omitempty" - Cloudflare Turnstile token
  string phone_number = 4;              // json:"phone_number,omitempty" - Honeypot field (should be empty)
  string human_check = 5;               // json:"human_check,omitempty" - Should be "human" if checkbox clicked
  BehaviorData behavior = 6;            // json:"behavior,omitempty" - Client-side behavioral signals
}

// BehaviorData captures client-side behavioral signals for bot detection
message BehaviorData {
  int64 form_shown_at = 1;              // Timestamp when form was displayed (ms)
  int64 submitted_at = 2;               // Timestamp when form was submitted (ms)
  bool mouse = 3;                       // Whether mouse movement was detected
  bool typed = 4;                       // Whether keyboard input was detected
}

// Matches pkg/api/commodore/types.go:RegisterRequest (lines 90-99)
message RegisterRequest {
  string email = 1;                     // json:"email"
  string password = 2;                  // json:"password"
  string first_name = 3;                // json:"first_name"
  string last_name = 4;                 // json:"last_name"
  string phone_number = 5;              // json:"phone_number,omitempty" - Honeypot field (should be empty)
  string turnstile_token = 6;           // json:"turnstile_token,omitempty" - Cloudflare Turnstile token
  string human_check = 7;               // json:"human_check,omitempty" - Should be "human" if checkbox clicked
  BehaviorData behavior = 8;            // json:"behavior,omitempty" - Client-side behavioral signals
}

// Matches pkg/api/commodore/types.go:AuthResponse (lines 101-105)
message AuthResponse {
  string token = 1;                     // json:"token" - JWT access token
  User user = 2;                        // json:"user"
  google.protobuf.Timestamp expires_at = 3; // json:"expires_at"
  string refresh_token = 4;             // json:"refresh_token" - for session refresh
  bool is_new_user = 5;                 // json:"is_new_user" - true if account was just created (wallet auto-provision)
}

// Matches pkg/api/commodore/types.go:RegisterResponse (lines 108-111)
message RegisterResponse {
  bool success = 1;                     // json:"success"
  string message = 2;                   // json:"message"
}

message GetMeRequest {
  // User context extracted from JWT by middleware
}

message LogoutRequest {
  // Token to invalidate (optional - extracted from Authorization header)
  string token = 1;
}

message LogoutResponse {
  bool success = 1;
  string message = 2;
}

message RefreshTokenRequest {
  string refresh_token = 1;
}

message VerifyEmailRequest {
  string token = 1;
}

message VerifyEmailResponse {
  bool success = 1;
  string message = 2;
}

message ResendVerificationRequest {
  string email = 1;                     // User's email address
  string turnstile_token = 2;           // Optional bot protection
}

message ResendVerificationResponse {
  bool success = 1;
  string message = 2;
}

message ForgotPasswordRequest {
  string email = 1;
}

message ForgotPasswordResponse {
  bool success = 1;
  string message = 2;
}

message ResetPasswordRequest {
  string token = 1;
  string password = 2;
}

message ResetPasswordResponse {
  bool success = 1;
  string message = 2;
}

message UpdateMeRequest {
  optional string first_name = 1;
  optional string last_name = 2;
  optional string phone_number = 3;
}

message UpdateNewsletterRequest {
  bool subscribed = 1;
}

message UpdateNewsletterResponse {
  bool success = 1;
  string message = 2;
}

message GetNewsletterStatusRequest {}

message GetNewsletterStatusResponse {
  bool subscribed = 1;
}

// ============================================================================
// WALLET AUTHENTICATION (x402 / agent access)
// ============================================================================

// WalletLoginRequest authenticates via Ethereum wallet signature
// If the wallet is not linked to any account, creates a new one
message WalletLoginRequest {
  string wallet_address = 1;            // 0x-prefixed Ethereum address
  string message = 2;                   // Message that was signed (includes timestamp + nonce)
  string signature = 3;                 // 0x-prefixed hex signature (65 bytes: R|S|V)
}

// WalletLoginWithX402Request authenticates via x402 payload (EIP-3009)
// Session token is returned on success. If value>0, the payment is settled and credited.
message WalletLoginWithX402Request {
  purser.X402PaymentPayload payment = 1;
  string client_ip = 2;                 // For VAT evidence
  optional string target_tenant_id = 3; // Optional credit target (donations)
}

message WalletLoginWithX402Response {
  AuthResponse auth = 1;
  bool is_auth_only = 2;
  int64 credited_cents = 3;
  int64 new_balance_cents = 4;
  string tx_hash = 5;
  string currency = 6;
  string invoice_number = 7;
  string payer_address = 8;
  string target_tenant_id = 9;
}

// LinkWalletRequest links a wallet to an existing authenticated user
message LinkWalletRequest {
  string wallet_address = 1;            // 0x-prefixed Ethereum address
  string message = 2;                   // Message that was signed
  string signature = 3;                 // Signature proving wallet ownership
}

// UnlinkWalletRequest removes a wallet from a user's account
message UnlinkWalletRequest {
  string wallet_id = 1;                 // UUID of the wallet_identity to unlink
}

message UnlinkWalletResponse {
  bool success = 1;
  string message = 2;
}

// ListWalletsRequest lists wallets linked to the authenticated user
message ListWalletsRequest {}

message ListWalletsResponse {
  repeated WalletIdentity wallets = 1;
}

// WalletIdentity represents a linked wallet
message WalletIdentity {
  string id = 1;                        // UUID
  string wallet_address = 2;            // Normalized checksum address
  google.protobuf.Timestamp created_at = 3;
  optional google.protobuf.Timestamp last_auth_at = 4;
}

// LinkEmailRequest adds an email to a wallet-only account (for postpaid upgrade path)
message LinkEmailRequest {
  string email = 1;                     // Email address to link
  string password = 2;                  // Password to set for the account
}

message LinkEmailResponse {
  bool success = 1;
  string message = 2;                   // e.g., "Verification email sent to..."
  bool verification_sent = 3;           // True if verification email was sent
}

// Matches pkg/models/users.go:User (lines 8-23)
message User {
  string id = 1;                        // json:"id"
  string tenant_id = 2;                 // json:"tenant_id"
  optional string email = 3;            // json:"email,omitempty" - NULL for wallet-only accounts
  // password and password_hash never serialized
  string first_name = 4;                // json:"first_name"
  string last_name = 5;                 // json:"last_name"
  string role = 6;                      // json:"role"
  repeated string permissions = 7;      // json:"permissions"
  bool is_active = 8;                   // json:"is_active"
  bool is_verified = 9;                 // json:"is_verified"
  optional google.protobuf.Timestamp last_login_at = 10; // json:"last_login_at,omitempty"
  google.protobuf.Timestamp created_at = 11; // json:"created_at"
  google.protobuf.Timestamp updated_at = 12; // json:"updated_at"
  repeated WalletIdentity wallets = 13; // Linked wallets (populated on GetMe)
}

// ============================================================================
// STREAM SERVICE (Gateway → Commodore for stream CRUD)
// ============================================================================

service StreamService {
  rpc CreateStream(CreateStreamRequest) returns (CreateStreamResponse);
  rpc GetStream(GetStreamRequest) returns (Stream);
  rpc GetStreamsBatch(GetStreamsBatchRequest) returns (GetStreamsBatchResponse);
  rpc ListStreams(ListStreamsRequest) returns (ListStreamsResponse);
  rpc UpdateStream(UpdateStreamRequest) returns (Stream);
  rpc DeleteStream(DeleteStreamRequest) returns (DeleteStreamResponse);
  rpc RefreshStreamKey(RefreshStreamKeyRequest) returns (RefreshStreamKeyResponse);
}

// Matches pkg/api/commodore/types.go:CreateStreamRequest (lines 114-119)
message CreateStreamRequest {
  string title = 1;                     // json:"title"
  string description = 2;               // json:"description"
  bool is_public = 3;                   // json:"is_public"
  bool is_recording = 4;                // json:"is_recording"
}

// Matches pkg/api/commodore/types.go:CreateStreamResponse (lines 178-185)
message CreateStreamResponse {
  string id = 1;                        // json:"id" (stream_id UUID)
  string stream_key = 2;                // json:"stream_key"
  string playback_id = 3;               // json:"playback_id"
  string title = 4;                     // json:"title"
  string description = 5;               // json:"description"
  string status = 6;                    // json:"status"
}

message GetStreamRequest {
  string stream_id = 1;                 // UUID
}

message GetStreamsBatchRequest {
  repeated string stream_ids = 1;       // UUIDs
}

message GetStreamsBatchResponse {
  repeated Stream streams = 1;
}

// Matches pkg/models/streams.go:Stream (lines 117-139)
message Stream {
  // Note: Internal IDs (ID, TenantID, UserID) are json:"-" so not in proto
  string title = 1;                     // json:"name" - maps to GraphQL 'name'
  string description = 2;               // json:"description"
  string internal_name = 3;             // internal-only Mist identifier
  string stream_key = 4;                // json:"streamKey"
  string playback_id = 5;               // json:"playbackId"
  bool is_live = 6;                     // json:"is_live"
  bool is_recording = 7;                // json:"record"
  bool is_recording_enabled = 8;        // json:"is_recording_enabled"
  string status = 9;                    // json:"status" - enriched from Periscope
  int32 current_viewers = 10;           // json:"current_viewers" - enriched from Periscope
  int32 total_views = 11;               // json:"total_views" - enriched from Periscope
  int32 duration = 12;                  // json:"duration" - enriched from Periscope
  optional google.protobuf.Timestamp started_at = 13;  // json:"started_at,omitempty" - enriched from Periscope
  optional google.protobuf.Timestamp ended_at = 14;    // json:"ended_at,omitempty" - enriched from Periscope
  google.protobuf.Timestamp created_at = 15; // json:"createdAt"
  google.protobuf.Timestamp updated_at = 16; // json:"updatedAt"
  int32 peak_viewers = 17;              // json:"peak_viewers" - enriched from Periscope
  string stream_id = 18;                // public UUID
}

message ListStreamsRequest {
  common.CursorPaginationRequest pagination = 1;
}

// Matches pkg/api/commodore/types.go:StreamsResponse (lines 163-166)
message ListStreamsResponse {
  repeated Stream streams = 1;          // json:"streams"
  common.CursorPaginationResponse pagination = 2;
}

// Matches pkg/api/commodore/types.go:UpdateStreamRequest (lines 121-125)
message UpdateStreamRequest {
  string stream_id = 1;                 // target stream (UUID)
  optional string name = 2;             // json:"name,omitempty"
  optional string description = 3;      // json:"description,omitempty"
  optional bool record = 4;             // json:"record,omitempty"
}

message DeleteStreamRequest {
  string stream_id = 1;
}

// Matches pkg/api/commodore/types.go:StreamDeleteResponse (lines 219-224)
message DeleteStreamResponse {
  string message = 1;                   // json:"message"
  string stream_id = 2;                 // json:"stream_id"
  string stream_title = 3;              // json:"stream_title"
  google.protobuf.Timestamp deleted_at = 4; // json:"deleted_at"
}

// ============================================================================
// STREAM KEY SERVICE (Gateway → Commodore for multi-key management)
// ============================================================================

service StreamKeyService {
  rpc CreateStreamKey(CreateStreamKeyRequest) returns (StreamKeyResponse);
  rpc ListStreamKeys(ListStreamKeysRequest) returns (ListStreamKeysResponse);
  rpc DeactivateStreamKey(DeactivateStreamKeyRequest) returns (google.protobuf.Empty);
}

// Matches pkg/api/commodore/types.go:CreateStreamKeyRequest (lines 337-339)
message CreateStreamKeyRequest {
  string stream_id = 1;                 // target stream
  string key_name = 2;                  // json:"key_name"
}

// Matches pkg/api/commodore/types.go:StreamKey (lines 323-334)
message StreamKey {
  string id = 1;                        // json:"id"
  string tenant_id = 2;                 // json:"tenant_id"
  string user_id = 3;                   // json:"user_id"
  string stream_id = 4;                 // json:"stream_id"
  string key_value = 5;                 // json:"key_value"
  string key_name = 6;                  // json:"key_name"
  bool is_active = 7;                   // json:"is_active"
  optional google.protobuf.Timestamp last_used_at = 8; // json:"last_used_at"
  google.protobuf.Timestamp created_at = 9;  // json:"created_at"
  google.protobuf.Timestamp updated_at = 10; // json:"updated_at"
}

// Matches pkg/api/commodore/types.go:StreamKeyResponse (lines 342-345)
message StreamKeyResponse {
  StreamKey stream_key = 1;             // json:"stream_key"
  string message = 2;                   // json:"message"
}

message ListStreamKeysRequest {
  string stream_id = 1;
  common.CursorPaginationRequest pagination = 2;
}

// Matches pkg/api/commodore/types.go:StreamKeysResponse (lines 348-351)
message ListStreamKeysResponse {
  repeated StreamKey stream_keys = 1;   // json:"stream_keys"
  common.CursorPaginationResponse pagination = 2;
}

message DeactivateStreamKeyRequest {
  string stream_id = 1;
  string key_id = 2;
}

// ============================================================================
// DEVELOPER TOKEN SERVICE (Gateway → Commodore for API token management)
// ============================================================================

service DeveloperService {
  rpc CreateAPIToken(CreateAPITokenRequest) returns (CreateAPITokenResponse);
  rpc ListAPITokens(ListAPITokensRequest) returns (ListAPITokensResponse);
  rpc RevokeAPIToken(RevokeAPITokenRequest) returns (RevokeAPITokenResponse);
}

// From pkg/models/users.go - CreateAPITokenRequest pattern
message CreateAPITokenRequest {
  string token_name = 1;
  repeated string permissions = 2;
  optional google.protobuf.Timestamp expires_at = 3;
}

// Matches pkg/api/commodore/types.go:CreateAPITokenResponse (lines 233-241)
message CreateAPITokenResponse {
  string id = 1;                        // json:"id"
  string token_value = 2;               // json:"token_value"
  string token_name = 3;                // json:"token_name"
  repeated string permissions = 4;      // json:"permissions"
  optional google.protobuf.Timestamp expires_at = 5; // json:"expires_at"
  google.protobuf.Timestamp created_at = 6; // json:"created_at"
  string message = 7;                   // json:"message"
}

message ListAPITokensRequest {
  common.CursorPaginationRequest pagination = 1;
}

// Matches pkg/api/commodore/types.go:APITokenInfo (lines 292-300)
// Also used for GraphQL DeveloperToken type
message APITokenInfo {
  string id = 1;                        // json:"id"
  string token_name = 2;                // json:"token_name"
  optional string token_value = 8;      // json:"token_value" - Only populated on creation, null otherwise
  repeated string permissions = 3;      // json:"permissions"
  string status = 4;                    // json:"status"
  optional google.protobuf.Timestamp last_used_at = 5; // json:"last_used_at"
  optional google.protobuf.Timestamp expires_at = 6;   // json:"expires_at"
  google.protobuf.Timestamp created_at = 7;            // json:"created_at"
}

// Matches pkg/api/commodore/types.go:APITokenListResponse (lines 286-289)
message ListAPITokensResponse {
  repeated APITokenInfo tokens = 1;     // json:"tokens"
  common.CursorPaginationResponse pagination = 2;
}

message RevokeAPITokenRequest {
  string token_id = 1;
}

// Matches pkg/api/commodore/types.go:RevokeAPITokenResponse (lines 303-308)
message RevokeAPITokenResponse {
  string message = 1;                   // json:"message"
  string token_id = 2;                  // json:"token_id"
  string token_name = 3;                // json:"token_name"
  google.protobuf.Timestamp revoked_at = 4; // json:"revoked_at"
}

// ============================================================================
// STREAM KEY REFRESH (Gateway → Commodore)
// ============================================================================

// Add RefreshStreamKey to StreamService
// Note: Added via extension to StreamService definition above

message RefreshStreamKeyRequest {
  string stream_id = 1;                 // Public stream ID (UUID)
}

// Matches pkg/api/commodore/types.go:RefreshKeyResponse (lines 207-213)
message RefreshStreamKeyResponse {
  string message = 1;                   // json:"message"
  string stream_id = 2;                 // json:"stream_id"
  string stream_key = 3;                // json:"stream_key"
  string playback_id = 4;               // json:"playback_id"
  bool old_key_invalidated = 5;         // json:"old_key_invalidated"
}

// ============================================================================
// CLIP SERVICE (Gateway → Commodore → Foghorn proxy)
// Uses shared types from shared.proto
// ============================================================================

service ClipService {
  rpc CreateClip(shared.CreateClipRequest) returns (shared.CreateClipResponse);
  rpc GetClips(shared.GetClipsRequest) returns (shared.GetClipsResponse);
  rpc GetClip(shared.GetClipRequest) returns (shared.ClipInfo);
  rpc DeleteClip(shared.DeleteClipRequest) returns (shared.DeleteClipResponse);
}

// ============================================================================
// DVR SERVICE (Gateway → Commodore → Foghorn proxy)
// Uses shared types from shared.proto
// ============================================================================

service DVRService {
  rpc StopDVR(shared.StopDVRRequest) returns (shared.StopDVRResponse);
  rpc DeleteDVR(shared.DeleteDVRRequest) returns (shared.DeleteDVRResponse);
  rpc ListDVRRequests(shared.ListDVRRecordingsRequest) returns (shared.ListDVRRecordingsResponse);
}

// ============================================================================
// VIEWER ENDPOINT SERVICE (Gateway/Player → Commodore → Foghorn proxy)
// Uses shared types from shared.proto
// ============================================================================

service ViewerService {
  rpc ResolveViewerEndpoint(shared.ViewerEndpointRequest) returns (shared.ViewerEndpointResponse);
  rpc ResolveIngestEndpoint(shared.IngestEndpointRequest) returns (shared.IngestEndpointResponse);
}

// ============================================================================
// VOD SERVICE (Gateway → Commodore → Foghorn proxy)
// User-initiated video uploads (distinct from clips/DVR which are stream-derived)
// Uses shared types from shared.proto
// ============================================================================

service VodService {
  // Initiate multipart upload - returns presigned URLs for direct S3 upload
  rpc CreateVodUpload(shared.CreateVodUploadRequest) returns (shared.CreateVodUploadResponse);
  // Finalize upload after all parts uploaded
  rpc CompleteVodUpload(shared.CompleteVodUploadRequest) returns (shared.CompleteVodUploadResponse);
  // Cancel in-progress upload
  rpc AbortVodUpload(shared.AbortVodUploadRequest) returns (shared.AbortVodUploadResponse);
  // Get single VOD asset
  rpc GetVodAsset(shared.GetVodAssetRequest) returns (shared.VodAssetInfo);
  // List VOD assets with pagination
  rpc ListVodAssets(shared.ListVodAssetsRequest) returns (shared.ListVodAssetsResponse);
  // Delete VOD asset
  rpc DeleteVodAsset(shared.DeleteVodAssetRequest) returns (shared.DeleteVodAssetResponse);
}
