// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.4
// source: ipc.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type IngestErrorCode int32

const (
	IngestErrorCode_INGEST_ERROR_NONE               IngestErrorCode = 0
	IngestErrorCode_INGEST_ERROR_INVALID_STREAM_KEY IngestErrorCode = 1
	IngestErrorCode_INGEST_ERROR_ACCOUNT_SUSPENDED  IngestErrorCode = 2
	IngestErrorCode_INGEST_ERROR_PAYMENT_REQUIRED   IngestErrorCode = 3
	IngestErrorCode_INGEST_ERROR_INTERNAL           IngestErrorCode = 4
	IngestErrorCode_INGEST_ERROR_TIMEOUT            IngestErrorCode = 5
)

// Enum value maps for IngestErrorCode.
var (
	IngestErrorCode_name = map[int32]string{
		0: "INGEST_ERROR_NONE",
		1: "INGEST_ERROR_INVALID_STREAM_KEY",
		2: "INGEST_ERROR_ACCOUNT_SUSPENDED",
		3: "INGEST_ERROR_PAYMENT_REQUIRED",
		4: "INGEST_ERROR_INTERNAL",
		5: "INGEST_ERROR_TIMEOUT",
	}
	IngestErrorCode_value = map[string]int32{
		"INGEST_ERROR_NONE":               0,
		"INGEST_ERROR_INVALID_STREAM_KEY": 1,
		"INGEST_ERROR_ACCOUNT_SUSPENDED":  2,
		"INGEST_ERROR_PAYMENT_REQUIRED":   3,
		"INGEST_ERROR_INTERNAL":           4,
		"INGEST_ERROR_TIMEOUT":            5,
	}
)

func (x IngestErrorCode) Enum() *IngestErrorCode {
	p := new(IngestErrorCode)
	*p = x
	return p
}

func (x IngestErrorCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IngestErrorCode) Descriptor() protoreflect.EnumDescriptor {
	return file_ipc_proto_enumTypes[0].Descriptor()
}

func (IngestErrorCode) Type() protoreflect.EnumType {
	return &file_ipc_proto_enumTypes[0]
}

func (x IngestErrorCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IngestErrorCode.Descriptor instead.
func (IngestErrorCode) EnumDescriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{0}
}

// Storage location enum for cold storage tracking
type StorageLocation int32

const (
	StorageLocation_STORAGE_LOCATION_UNSPECIFIED StorageLocation = 0
	StorageLocation_STORAGE_LOCATION_LOCAL       StorageLocation = 1 // Asset is on local storage only
	StorageLocation_STORAGE_LOCATION_S3          StorageLocation = 2 // Asset is on S3 only (frozen)
	StorageLocation_STORAGE_LOCATION_FREEZING    StorageLocation = 3 // Asset is being uploaded to S3
	StorageLocation_STORAGE_LOCATION_DEFROSTING  StorageLocation = 4 // Asset is being downloaded from S3
)

// Enum value maps for StorageLocation.
var (
	StorageLocation_name = map[int32]string{
		0: "STORAGE_LOCATION_UNSPECIFIED",
		1: "STORAGE_LOCATION_LOCAL",
		2: "STORAGE_LOCATION_S3",
		3: "STORAGE_LOCATION_FREEZING",
		4: "STORAGE_LOCATION_DEFROSTING",
	}
	StorageLocation_value = map[string]int32{
		"STORAGE_LOCATION_UNSPECIFIED": 0,
		"STORAGE_LOCATION_LOCAL":       1,
		"STORAGE_LOCATION_S3":          2,
		"STORAGE_LOCATION_FREEZING":    3,
		"STORAGE_LOCATION_DEFROSTING":  4,
	}
)

func (x StorageLocation) Enum() *StorageLocation {
	p := new(StorageLocation)
	*p = x
	return p
}

func (x StorageLocation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StorageLocation) Descriptor() protoreflect.EnumDescriptor {
	return file_ipc_proto_enumTypes[1].Descriptor()
}

func (StorageLocation) Type() protoreflect.EnumType {
	return &file_ipc_proto_enumTypes[1]
}

func (x StorageLocation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StorageLocation.Descriptor instead.
func (StorageLocation) EnumDescriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{1}
}

type NodeOperationalMode int32

const (
	NodeOperationalMode_NODE_OPERATIONAL_MODE_UNSPECIFIED NodeOperationalMode = 0
	NodeOperationalMode_NODE_OPERATIONAL_MODE_NORMAL      NodeOperationalMode = 1
	NodeOperationalMode_NODE_OPERATIONAL_MODE_DRAINING    NodeOperationalMode = 2
	NodeOperationalMode_NODE_OPERATIONAL_MODE_MAINTENANCE NodeOperationalMode = 3
)

// Enum value maps for NodeOperationalMode.
var (
	NodeOperationalMode_name = map[int32]string{
		0: "NODE_OPERATIONAL_MODE_UNSPECIFIED",
		1: "NODE_OPERATIONAL_MODE_NORMAL",
		2: "NODE_OPERATIONAL_MODE_DRAINING",
		3: "NODE_OPERATIONAL_MODE_MAINTENANCE",
	}
	NodeOperationalMode_value = map[string]int32{
		"NODE_OPERATIONAL_MODE_UNSPECIFIED": 0,
		"NODE_OPERATIONAL_MODE_NORMAL":      1,
		"NODE_OPERATIONAL_MODE_DRAINING":    2,
		"NODE_OPERATIONAL_MODE_MAINTENANCE": 3,
	}
)

func (x NodeOperationalMode) Enum() *NodeOperationalMode {
	p := new(NodeOperationalMode)
	*p = x
	return p
}

func (x NodeOperationalMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeOperationalMode) Descriptor() protoreflect.EnumDescriptor {
	return file_ipc_proto_enumTypes[2].Descriptor()
}

func (NodeOperationalMode) Type() protoreflect.EnumType {
	return &file_ipc_proto_enumTypes[2]
}

func (x NodeOperationalMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeOperationalMode.Descriptor instead.
func (NodeOperationalMode) EnumDescriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{2}
}

type ArtifactEvent_ArtifactType int32

const (
	ArtifactEvent_ARTIFACT_TYPE_UNSPECIFIED ArtifactEvent_ArtifactType = 0
	ArtifactEvent_ARTIFACT_TYPE_CLIP        ArtifactEvent_ArtifactType = 1
	ArtifactEvent_ARTIFACT_TYPE_DVR         ArtifactEvent_ArtifactType = 2
	ArtifactEvent_ARTIFACT_TYPE_VOD         ArtifactEvent_ArtifactType = 3
)

// Enum value maps for ArtifactEvent_ArtifactType.
var (
	ArtifactEvent_ArtifactType_name = map[int32]string{
		0: "ARTIFACT_TYPE_UNSPECIFIED",
		1: "ARTIFACT_TYPE_CLIP",
		2: "ARTIFACT_TYPE_DVR",
		3: "ARTIFACT_TYPE_VOD",
	}
	ArtifactEvent_ArtifactType_value = map[string]int32{
		"ARTIFACT_TYPE_UNSPECIFIED": 0,
		"ARTIFACT_TYPE_CLIP":        1,
		"ARTIFACT_TYPE_DVR":         2,
		"ARTIFACT_TYPE_VOD":         3,
	}
)

func (x ArtifactEvent_ArtifactType) Enum() *ArtifactEvent_ArtifactType {
	p := new(ArtifactEvent_ArtifactType)
	*p = x
	return p
}

func (x ArtifactEvent_ArtifactType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ArtifactEvent_ArtifactType) Descriptor() protoreflect.EnumDescriptor {
	return file_ipc_proto_enumTypes[3].Descriptor()
}

func (ArtifactEvent_ArtifactType) Type() protoreflect.EnumType {
	return &file_ipc_proto_enumTypes[3]
}

func (x ArtifactEvent_ArtifactType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ArtifactEvent_ArtifactType.Descriptor instead.
func (ArtifactEvent_ArtifactType) EnumDescriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{8, 0}
}

type StorageLifecycleData_Action int32

const (
	StorageLifecycleData_ACTION_UNSPECIFIED   StorageLifecycleData_Action = 0
	StorageLifecycleData_ACTION_SYNC_STARTED  StorageLifecycleData_Action = 1 // Upload to S3 started (local copy retained)
	StorageLifecycleData_ACTION_SYNCED        StorageLifecycleData_Action = 2 // Upload to S3 completed (local copy retained)
	StorageLifecycleData_ACTION_EVICTED       StorageLifecycleData_Action = 3 // Local copy deleted (S3 has authoritative copy)
	StorageLifecycleData_ACTION_CACHE_STARTED StorageLifecycleData_Action = 4 // Download from S3 started (refilling local cache)
	StorageLifecycleData_ACTION_CACHED        StorageLifecycleData_Action = 5 // Downloaded from S3 to local cache (S3 copy retained)
	StorageLifecycleData_ACTION_DELETED       StorageLifecycleData_Action = 6 // Asset deleted from both S3 and local (permanent removal)
)

// Enum value maps for StorageLifecycleData_Action.
var (
	StorageLifecycleData_Action_name = map[int32]string{
		0: "ACTION_UNSPECIFIED",
		1: "ACTION_SYNC_STARTED",
		2: "ACTION_SYNCED",
		3: "ACTION_EVICTED",
		4: "ACTION_CACHE_STARTED",
		5: "ACTION_CACHED",
		6: "ACTION_DELETED",
	}
	StorageLifecycleData_Action_value = map[string]int32{
		"ACTION_UNSPECIFIED":   0,
		"ACTION_SYNC_STARTED":  1,
		"ACTION_SYNCED":        2,
		"ACTION_EVICTED":       3,
		"ACTION_CACHE_STARTED": 4,
		"ACTION_CACHED":        5,
		"ACTION_DELETED":       6,
	}
)

func (x StorageLifecycleData_Action) Enum() *StorageLifecycleData_Action {
	p := new(StorageLifecycleData_Action)
	*p = x
	return p
}

func (x StorageLifecycleData_Action) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StorageLifecycleData_Action) Descriptor() protoreflect.EnumDescriptor {
	return file_ipc_proto_enumTypes[4].Descriptor()
}

func (StorageLifecycleData_Action) Type() protoreflect.EnumType {
	return &file_ipc_proto_enumTypes[4]
}

func (x StorageLifecycleData_Action) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StorageLifecycleData_Action.Descriptor instead.
func (StorageLifecycleData_Action) EnumDescriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{45, 0}
}

type ClipLifecycleData_Stage int32

const (
	ClipLifecycleData_STAGE_UNSPECIFIED ClipLifecycleData_Stage = 0
	ClipLifecycleData_STAGE_REQUESTED   ClipLifecycleData_Stage = 1
	ClipLifecycleData_STAGE_QUEUED      ClipLifecycleData_Stage = 2
	ClipLifecycleData_STAGE_PROGRESS    ClipLifecycleData_Stage = 3
	ClipLifecycleData_STAGE_DONE        ClipLifecycleData_Stage = 4
	ClipLifecycleData_STAGE_FAILED      ClipLifecycleData_Stage = 5
	ClipLifecycleData_STAGE_DELETED     ClipLifecycleData_Stage = 6
)

// Enum value maps for ClipLifecycleData_Stage.
var (
	ClipLifecycleData_Stage_name = map[int32]string{
		0: "STAGE_UNSPECIFIED",
		1: "STAGE_REQUESTED",
		2: "STAGE_QUEUED",
		3: "STAGE_PROGRESS",
		4: "STAGE_DONE",
		5: "STAGE_FAILED",
		6: "STAGE_DELETED",
	}
	ClipLifecycleData_Stage_value = map[string]int32{
		"STAGE_UNSPECIFIED": 0,
		"STAGE_REQUESTED":   1,
		"STAGE_QUEUED":      2,
		"STAGE_PROGRESS":    3,
		"STAGE_DONE":        4,
		"STAGE_FAILED":      5,
		"STAGE_DELETED":     6,
	}
)

func (x ClipLifecycleData_Stage) Enum() *ClipLifecycleData_Stage {
	p := new(ClipLifecycleData_Stage)
	*p = x
	return p
}

func (x ClipLifecycleData_Stage) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClipLifecycleData_Stage) Descriptor() protoreflect.EnumDescriptor {
	return file_ipc_proto_enumTypes[5].Descriptor()
}

func (ClipLifecycleData_Stage) Type() protoreflect.EnumType {
	return &file_ipc_proto_enumTypes[5]
}

func (x ClipLifecycleData_Stage) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClipLifecycleData_Stage.Descriptor instead.
func (ClipLifecycleData_Stage) EnumDescriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{64, 0}
}

type DVRLifecycleData_Status int32

const (
	DVRLifecycleData_STATUS_UNSPECIFIED DVRLifecycleData_Status = 0
	DVRLifecycleData_STATUS_STARTED     DVRLifecycleData_Status = 1
	DVRLifecycleData_STATUS_RECORDING   DVRLifecycleData_Status = 2
	DVRLifecycleData_STATUS_STOPPED     DVRLifecycleData_Status = 3
	DVRLifecycleData_STATUS_FAILED      DVRLifecycleData_Status = 4
	DVRLifecycleData_STATUS_DELETED     DVRLifecycleData_Status = 5
)

// Enum value maps for DVRLifecycleData_Status.
var (
	DVRLifecycleData_Status_name = map[int32]string{
		0: "STATUS_UNSPECIFIED",
		1: "STATUS_STARTED",
		2: "STATUS_RECORDING",
		3: "STATUS_STOPPED",
		4: "STATUS_FAILED",
		5: "STATUS_DELETED",
	}
	DVRLifecycleData_Status_value = map[string]int32{
		"STATUS_UNSPECIFIED": 0,
		"STATUS_STARTED":     1,
		"STATUS_RECORDING":   2,
		"STATUS_STOPPED":     3,
		"STATUS_FAILED":      4,
		"STATUS_DELETED":     5,
	}
)

func (x DVRLifecycleData_Status) Enum() *DVRLifecycleData_Status {
	p := new(DVRLifecycleData_Status)
	*p = x
	return p
}

func (x DVRLifecycleData_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DVRLifecycleData_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_ipc_proto_enumTypes[6].Descriptor()
}

func (DVRLifecycleData_Status) Type() protoreflect.EnumType {
	return &file_ipc_proto_enumTypes[6]
}

func (x DVRLifecycleData_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DVRLifecycleData_Status.Descriptor instead.
func (DVRLifecycleData_Status) EnumDescriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{65, 0}
}

type VodLifecycleData_Status int32

const (
	VodLifecycleData_STATUS_UNSPECIFIED VodLifecycleData_Status = 0
	VodLifecycleData_STATUS_REQUESTED   VodLifecycleData_Status = 1 // Upload session created, presigned URLs generated
	VodLifecycleData_STATUS_UPLOADING   VodLifecycleData_Status = 2 // Parts being uploaded (optional progress tracking)
	VodLifecycleData_STATUS_PROCESSING  VodLifecycleData_Status = 3 // Upload complete, validation/transcoding in progress
	VodLifecycleData_STATUS_COMPLETED   VodLifecycleData_Status = 4 // Asset ready for playback
	VodLifecycleData_STATUS_FAILED      VodLifecycleData_Status = 5 // Upload or processing failed
	VodLifecycleData_STATUS_DELETED     VodLifecycleData_Status = 6 // Asset deleted
)

// Enum value maps for VodLifecycleData_Status.
var (
	VodLifecycleData_Status_name = map[int32]string{
		0: "STATUS_UNSPECIFIED",
		1: "STATUS_REQUESTED",
		2: "STATUS_UPLOADING",
		3: "STATUS_PROCESSING",
		4: "STATUS_COMPLETED",
		5: "STATUS_FAILED",
		6: "STATUS_DELETED",
	}
	VodLifecycleData_Status_value = map[string]int32{
		"STATUS_UNSPECIFIED": 0,
		"STATUS_REQUESTED":   1,
		"STATUS_UPLOADING":   2,
		"STATUS_PROCESSING":  3,
		"STATUS_COMPLETED":   4,
		"STATUS_FAILED":      5,
		"STATUS_DELETED":     6,
	}
)

func (x VodLifecycleData_Status) Enum() *VodLifecycleData_Status {
	p := new(VodLifecycleData_Status)
	*p = x
	return p
}

func (x VodLifecycleData_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VodLifecycleData_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_ipc_proto_enumTypes[7].Descriptor()
}

func (VodLifecycleData_Status) Type() protoreflect.EnumType {
	return &file_ipc_proto_enumTypes[7]
}

func (x VodLifecycleData_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VodLifecycleData_Status.Descriptor instead.
func (VodLifecycleData_Status) EnumDescriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{66, 0}
}

type MessageLifecycleData_EventType int32

const (
	MessageLifecycleData_EVENT_TYPE_UNSPECIFIED          MessageLifecycleData_EventType = 0
	MessageLifecycleData_EVENT_TYPE_MESSAGE_CREATED      MessageLifecycleData_EventType = 1 // New message in conversation
	MessageLifecycleData_EVENT_TYPE_CONVERSATION_CREATED MessageLifecycleData_EventType = 2 // New conversation started
	MessageLifecycleData_EVENT_TYPE_CONVERSATION_UPDATED MessageLifecycleData_EventType = 3 // Status changed (resolved, pending)
	MessageLifecycleData_EVENT_TYPE_MESSAGE_UPDATED      MessageLifecycleData_EventType = 4 // Message edited
)

// Enum value maps for MessageLifecycleData_EventType.
var (
	MessageLifecycleData_EventType_name = map[int32]string{
		0: "EVENT_TYPE_UNSPECIFIED",
		1: "EVENT_TYPE_MESSAGE_CREATED",
		2: "EVENT_TYPE_CONVERSATION_CREATED",
		3: "EVENT_TYPE_CONVERSATION_UPDATED",
		4: "EVENT_TYPE_MESSAGE_UPDATED",
	}
	MessageLifecycleData_EventType_value = map[string]int32{
		"EVENT_TYPE_UNSPECIFIED":          0,
		"EVENT_TYPE_MESSAGE_CREATED":      1,
		"EVENT_TYPE_CONVERSATION_CREATED": 2,
		"EVENT_TYPE_CONVERSATION_UPDATED": 3,
		"EVENT_TYPE_MESSAGE_UPDATED":      4,
	}
)

func (x MessageLifecycleData_EventType) Enum() *MessageLifecycleData_EventType {
	p := new(MessageLifecycleData_EventType)
	*p = x
	return p
}

func (x MessageLifecycleData_EventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MessageLifecycleData_EventType) Descriptor() protoreflect.EnumDescriptor {
	return file_ipc_proto_enumTypes[8].Descriptor()
}

func (MessageLifecycleData_EventType) Type() protoreflect.EnumType {
	return &file_ipc_proto_enumTypes[8]
}

func (x MessageLifecycleData_EventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MessageLifecycleData_EventType.Descriptor instead.
func (MessageLifecycleData_EventType) EnumDescriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{67, 0}
}

// Coarse geospatial bucket (H3 index + resolution)
type GeoBucket struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	H3Index       uint64                 `protobuf:"varint,1,opt,name=h3_index,json=h3Index,proto3" json:"h3_index,omitempty"` // H3 cell id encoded as uint64
	Resolution    uint32                 `protobuf:"varint,2,opt,name=resolution,proto3" json:"resolution,omitempty"`          // H3 resolution (e.g., 5)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GeoBucket) Reset() {
	*x = GeoBucket{}
	mi := &file_ipc_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeoBucket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeoBucket) ProtoMessage() {}

func (x *GeoBucket) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeoBucket.ProtoReflect.Descriptor instead.
func (*GeoBucket) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{0}
}

func (x *GeoBucket) GetH3Index() uint64 {
	if x != nil {
		return x.H3Index
	}
	return 0
}

func (x *GeoBucket) GetResolution() uint32 {
	if x != nil {
		return x.Resolution
	}
	return 0
}

// ServiceEvent represents service-level telemetry emitted by core services.
type ServiceEvent struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	EventId      string                 `protobuf:"bytes,1,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	EventType    string                 `protobuf:"bytes,2,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	Timestamp    *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Source       string                 `protobuf:"bytes,4,opt,name=source,proto3" json:"source,omitempty"`
	TenantId     string                 `protobuf:"bytes,5,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	UserId       string                 `protobuf:"bytes,6,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ResourceType string                 `protobuf:"bytes,7,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty"`
	ResourceId   string                 `protobuf:"bytes,8,opt,name=resource_id,json=resourceId,proto3" json:"resource_id,omitempty"`
	// Types that are valid to be assigned to Payload:
	//
	//	*ServiceEvent_ApiRequestBatch
	//	*ServiceEvent_AuthEvent
	//	*ServiceEvent_TenantEvent
	//	*ServiceEvent_ClusterEvent
	//	*ServiceEvent_StreamChangeEvent
	//	*ServiceEvent_StreamKeyEvent
	//	*ServiceEvent_BillingEvent
	//	*ServiceEvent_SupportEvent
	//	*ServiceEvent_ArtifactEvent
	Payload       isServiceEvent_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServiceEvent) Reset() {
	*x = ServiceEvent{}
	mi := &file_ipc_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServiceEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceEvent) ProtoMessage() {}

func (x *ServiceEvent) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServiceEvent.ProtoReflect.Descriptor instead.
func (*ServiceEvent) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{1}
}

func (x *ServiceEvent) GetEventId() string {
	if x != nil {
		return x.EventId
	}
	return ""
}

func (x *ServiceEvent) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *ServiceEvent) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *ServiceEvent) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *ServiceEvent) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *ServiceEvent) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *ServiceEvent) GetResourceType() string {
	if x != nil {
		return x.ResourceType
	}
	return ""
}

func (x *ServiceEvent) GetResourceId() string {
	if x != nil {
		return x.ResourceId
	}
	return ""
}

func (x *ServiceEvent) GetPayload() isServiceEvent_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ServiceEvent) GetApiRequestBatch() *APIRequestBatch {
	if x != nil {
		if x, ok := x.Payload.(*ServiceEvent_ApiRequestBatch); ok {
			return x.ApiRequestBatch
		}
	}
	return nil
}

func (x *ServiceEvent) GetAuthEvent() *AuthEvent {
	if x != nil {
		if x, ok := x.Payload.(*ServiceEvent_AuthEvent); ok {
			return x.AuthEvent
		}
	}
	return nil
}

func (x *ServiceEvent) GetTenantEvent() *TenantEvent {
	if x != nil {
		if x, ok := x.Payload.(*ServiceEvent_TenantEvent); ok {
			return x.TenantEvent
		}
	}
	return nil
}

func (x *ServiceEvent) GetClusterEvent() *ClusterEvent {
	if x != nil {
		if x, ok := x.Payload.(*ServiceEvent_ClusterEvent); ok {
			return x.ClusterEvent
		}
	}
	return nil
}

func (x *ServiceEvent) GetStreamChangeEvent() *StreamChangeEvent {
	if x != nil {
		if x, ok := x.Payload.(*ServiceEvent_StreamChangeEvent); ok {
			return x.StreamChangeEvent
		}
	}
	return nil
}

func (x *ServiceEvent) GetStreamKeyEvent() *StreamKeyEvent {
	if x != nil {
		if x, ok := x.Payload.(*ServiceEvent_StreamKeyEvent); ok {
			return x.StreamKeyEvent
		}
	}
	return nil
}

func (x *ServiceEvent) GetBillingEvent() *BillingEvent {
	if x != nil {
		if x, ok := x.Payload.(*ServiceEvent_BillingEvent); ok {
			return x.BillingEvent
		}
	}
	return nil
}

func (x *ServiceEvent) GetSupportEvent() *MessageLifecycleData {
	if x != nil {
		if x, ok := x.Payload.(*ServiceEvent_SupportEvent); ok {
			return x.SupportEvent
		}
	}
	return nil
}

func (x *ServiceEvent) GetArtifactEvent() *ArtifactEvent {
	if x != nil {
		if x, ok := x.Payload.(*ServiceEvent_ArtifactEvent); ok {
			return x.ArtifactEvent
		}
	}
	return nil
}

type isServiceEvent_Payload interface {
	isServiceEvent_Payload()
}

type ServiceEvent_ApiRequestBatch struct {
	ApiRequestBatch *APIRequestBatch `protobuf:"bytes,20,opt,name=api_request_batch,json=apiRequestBatch,proto3,oneof"`
}

type ServiceEvent_AuthEvent struct {
	AuthEvent *AuthEvent `protobuf:"bytes,21,opt,name=auth_event,json=authEvent,proto3,oneof"`
}

type ServiceEvent_TenantEvent struct {
	TenantEvent *TenantEvent `protobuf:"bytes,22,opt,name=tenant_event,json=tenantEvent,proto3,oneof"`
}

type ServiceEvent_ClusterEvent struct {
	ClusterEvent *ClusterEvent `protobuf:"bytes,23,opt,name=cluster_event,json=clusterEvent,proto3,oneof"`
}

type ServiceEvent_StreamChangeEvent struct {
	StreamChangeEvent *StreamChangeEvent `protobuf:"bytes,24,opt,name=stream_change_event,json=streamChangeEvent,proto3,oneof"`
}

type ServiceEvent_StreamKeyEvent struct {
	StreamKeyEvent *StreamKeyEvent `protobuf:"bytes,25,opt,name=stream_key_event,json=streamKeyEvent,proto3,oneof"`
}

type ServiceEvent_BillingEvent struct {
	BillingEvent *BillingEvent `protobuf:"bytes,26,opt,name=billing_event,json=billingEvent,proto3,oneof"`
}

type ServiceEvent_SupportEvent struct {
	SupportEvent *MessageLifecycleData `protobuf:"bytes,27,opt,name=support_event,json=supportEvent,proto3,oneof"`
}

type ServiceEvent_ArtifactEvent struct {
	ArtifactEvent *ArtifactEvent `protobuf:"bytes,28,opt,name=artifact_event,json=artifactEvent,proto3,oneof"`
}

func (*ServiceEvent_ApiRequestBatch) isServiceEvent_Payload() {}

func (*ServiceEvent_AuthEvent) isServiceEvent_Payload() {}

func (*ServiceEvent_TenantEvent) isServiceEvent_Payload() {}

func (*ServiceEvent_ClusterEvent) isServiceEvent_Payload() {}

func (*ServiceEvent_StreamChangeEvent) isServiceEvent_Payload() {}

func (*ServiceEvent_StreamKeyEvent) isServiceEvent_Payload() {}

func (*ServiceEvent_BillingEvent) isServiceEvent_Payload() {}

func (*ServiceEvent_SupportEvent) isServiceEvent_Payload() {}

func (*ServiceEvent_ArtifactEvent) isServiceEvent_Payload() {}

type AuthEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UserId        string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	TenantId      string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	AuthType      string                 `protobuf:"bytes,3,opt,name=auth_type,json=authType,proto3" json:"auth_type,omitempty"`
	WalletId      string                 `protobuf:"bytes,4,opt,name=wallet_id,json=walletId,proto3" json:"wallet_id,omitempty"`
	TokenId       string                 `protobuf:"bytes,5,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	Error         string                 `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`
	IpBucket      string                 `protobuf:"bytes,7,opt,name=ip_bucket,json=ipBucket,proto3" json:"ip_bucket,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthEvent) Reset() {
	*x = AuthEvent{}
	mi := &file_ipc_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthEvent) ProtoMessage() {}

func (x *AuthEvent) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthEvent.ProtoReflect.Descriptor instead.
func (*AuthEvent) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{2}
}

func (x *AuthEvent) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *AuthEvent) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *AuthEvent) GetAuthType() string {
	if x != nil {
		return x.AuthType
	}
	return ""
}

func (x *AuthEvent) GetWalletId() string {
	if x != nil {
		return x.WalletId
	}
	return ""
}

func (x *AuthEvent) GetTokenId() string {
	if x != nil {
		return x.TokenId
	}
	return ""
}

func (x *AuthEvent) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *AuthEvent) GetIpBucket() string {
	if x != nil {
		return x.IpBucket
	}
	return ""
}

type TenantEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TenantId      string                 `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	ChangedFields []string               `protobuf:"bytes,2,rep,name=changed_fields,json=changedFields,proto3" json:"changed_fields,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TenantEvent) Reset() {
	*x = TenantEvent{}
	mi := &file_ipc_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TenantEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TenantEvent) ProtoMessage() {}

func (x *TenantEvent) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TenantEvent.ProtoReflect.Descriptor instead.
func (*TenantEvent) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{3}
}

func (x *TenantEvent) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *TenantEvent) GetChangedFields() []string {
	if x != nil {
		return x.ChangedFields
	}
	return nil
}

type ClusterEvent struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ClusterId      string                 `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	TenantId       string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	InviteId       string                 `protobuf:"bytes,3,opt,name=invite_id,json=inviteId,proto3" json:"invite_id,omitempty"`
	SubscriptionId string                 `protobuf:"bytes,4,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscription_id,omitempty"`
	Reason         string                 `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ClusterEvent) Reset() {
	*x = ClusterEvent{}
	mi := &file_ipc_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterEvent) ProtoMessage() {}

func (x *ClusterEvent) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterEvent.ProtoReflect.Descriptor instead.
func (*ClusterEvent) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{4}
}

func (x *ClusterEvent) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *ClusterEvent) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *ClusterEvent) GetInviteId() string {
	if x != nil {
		return x.InviteId
	}
	return ""
}

func (x *ClusterEvent) GetSubscriptionId() string {
	if x != nil {
		return x.SubscriptionId
	}
	return ""
}

func (x *ClusterEvent) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// StreamChangeEvent signals that a stream's metadata was updated.
// Used by Signalman subscriptions for real-time change notifications.
type StreamChangeEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StreamId      string                 `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	ChangedFields []string               `protobuf:"bytes,2,rep,name=changed_fields,json=changedFields,proto3" json:"changed_fields,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamChangeEvent) Reset() {
	*x = StreamChangeEvent{}
	mi := &file_ipc_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamChangeEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamChangeEvent) ProtoMessage() {}

func (x *StreamChangeEvent) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamChangeEvent.ProtoReflect.Descriptor instead.
func (*StreamChangeEvent) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{5}
}

func (x *StreamChangeEvent) GetStreamId() string {
	if x != nil {
		return x.StreamId
	}
	return ""
}

func (x *StreamChangeEvent) GetChangedFields() []string {
	if x != nil {
		return x.ChangedFields
	}
	return nil
}

type StreamKeyEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StreamId      string                 `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	KeyId         string                 `protobuf:"bytes,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamKeyEvent) Reset() {
	*x = StreamKeyEvent{}
	mi := &file_ipc_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamKeyEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamKeyEvent) ProtoMessage() {}

func (x *StreamKeyEvent) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamKeyEvent.ProtoReflect.Descriptor instead.
func (*StreamKeyEvent) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{6}
}

func (x *StreamKeyEvent) GetStreamId() string {
	if x != nil {
		return x.StreamId
	}
	return ""
}

func (x *StreamKeyEvent) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

type BillingEvent struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	TenantId       string                 `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	PaymentId      string                 `protobuf:"bytes,2,opt,name=payment_id,json=paymentId,proto3" json:"payment_id,omitempty"`
	SubscriptionId string                 `protobuf:"bytes,3,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscription_id,omitempty"`
	InvoiceId      string                 `protobuf:"bytes,4,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	TopupId        string                 `protobuf:"bytes,5,opt,name=topup_id,json=topupId,proto3" json:"topup_id,omitempty"`
	Amount         float64                `protobuf:"fixed64,6,opt,name=amount,proto3" json:"amount,omitempty"`
	Currency       string                 `protobuf:"bytes,7,opt,name=currency,proto3" json:"currency,omitempty"`
	Provider       string                 `protobuf:"bytes,8,opt,name=provider,proto3" json:"provider,omitempty"`
	Status         string                 `protobuf:"bytes,9,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *BillingEvent) Reset() {
	*x = BillingEvent{}
	mi := &file_ipc_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BillingEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BillingEvent) ProtoMessage() {}

func (x *BillingEvent) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BillingEvent.ProtoReflect.Descriptor instead.
func (*BillingEvent) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{7}
}

func (x *BillingEvent) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *BillingEvent) GetPaymentId() string {
	if x != nil {
		return x.PaymentId
	}
	return ""
}

func (x *BillingEvent) GetSubscriptionId() string {
	if x != nil {
		return x.SubscriptionId
	}
	return ""
}

func (x *BillingEvent) GetInvoiceId() string {
	if x != nil {
		return x.InvoiceId
	}
	return ""
}

func (x *BillingEvent) GetTopupId() string {
	if x != nil {
		return x.TopupId
	}
	return ""
}

func (x *BillingEvent) GetAmount() float64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

func (x *BillingEvent) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

func (x *BillingEvent) GetProvider() string {
	if x != nil {
		return x.Provider
	}
	return ""
}

func (x *BillingEvent) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

// ArtifactEvent represents audit/lifecycle events for clip/DVR/VOD artifacts.
type ArtifactEvent struct {
	state         protoimpl.MessageState     `protogen:"open.v1"`
	ArtifactType  ArtifactEvent_ArtifactType `protobuf:"varint,1,opt,name=artifact_type,json=artifactType,proto3,enum=helmsmancontrol.ArtifactEvent_ArtifactType" json:"artifact_type,omitempty"`
	ArtifactId    string                     `protobuf:"bytes,2,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`           // clip_hash, dvr_hash, or vod_hash
	StreamId      string                     `protobuf:"bytes,3,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`                 // Public stream ID (UUID), when applicable
	Status        string                     `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`                                     // requested, started, processing, completed, failed, deleted, etc.
	StartedAt     *int64                     `protobuf:"varint,5,opt,name=started_at,json=startedAt,proto3,oneof" json:"started_at,omitempty"`       // Unix timestamp (if available)
	CompletedAt   *int64                     `protobuf:"varint,6,opt,name=completed_at,json=completedAt,proto3,oneof" json:"completed_at,omitempty"` // Unix timestamp (if available)
	ExpiresAt     *int64                     `protobuf:"varint,7,opt,name=expires_at,json=expiresAt,proto3,oneof" json:"expires_at,omitempty"`       // Retention expiration (if available)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArtifactEvent) Reset() {
	*x = ArtifactEvent{}
	mi := &file_ipc_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArtifactEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArtifactEvent) ProtoMessage() {}

func (x *ArtifactEvent) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArtifactEvent.ProtoReflect.Descriptor instead.
func (*ArtifactEvent) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{8}
}

func (x *ArtifactEvent) GetArtifactType() ArtifactEvent_ArtifactType {
	if x != nil {
		return x.ArtifactType
	}
	return ArtifactEvent_ARTIFACT_TYPE_UNSPECIFIED
}

func (x *ArtifactEvent) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

func (x *ArtifactEvent) GetStreamId() string {
	if x != nil {
		return x.StreamId
	}
	return ""
}

func (x *ArtifactEvent) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *ArtifactEvent) GetStartedAt() int64 {
	if x != nil && x.StartedAt != nil {
		return *x.StartedAt
	}
	return 0
}

func (x *ArtifactEvent) GetCompletedAt() int64 {
	if x != nil && x.CompletedAt != nil {
		return *x.CompletedAt
	}
	return 0
}

func (x *ArtifactEvent) GetExpiresAt() int64 {
	if x != nil && x.ExpiresAt != nil {
		return *x.ExpiresAt
	}
	return 0
}

type ControlMessage struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	RequestId string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"` // Correlates requests/responses
	SentAt    *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=sent_at,json=sentAt,proto3" json:"sent_at,omitempty"`
	// Types that are valid to be assigned to Payload:
	//
	//	*ControlMessage_Register
	//	*ControlMessage_ClipPullRequest
	//	*ControlMessage_ClipProgress
	//	*ControlMessage_ClipDone
	//	*ControlMessage_Error
	//	*ControlMessage_Heartbeat
	//	*ControlMessage_DvrStartRequest
	//	*ControlMessage_DvrProgress
	//	*ControlMessage_DvrStopped
	//	*ControlMessage_DvrStopRequest
	//	*ControlMessage_DvrReadyRequest
	//	*ControlMessage_DvrReadyResponse
	//	*ControlMessage_MistTrigger
	//	*ControlMessage_MistTriggerResponse
	//	*ControlMessage_ConfigSeed
	//	*ControlMessage_ArtifactDeleted
	//	*ControlMessage_ClipDelete
	//	*ControlMessage_DvrDelete
	//	*ControlMessage_VodDelete
	//	*ControlMessage_FreezePermissionRequest
	//	*ControlMessage_FreezePermissionResponse
	//	*ControlMessage_FreezeProgress
	//	*ControlMessage_FreezeComplete
	//	*ControlMessage_DefrostRequest
	//	*ControlMessage_DefrostProgress
	//	*ControlMessage_DefrostComplete
	//	*ControlMessage_CanDeleteRequest
	//	*ControlMessage_CanDeleteResponse
	//	*ControlMessage_SyncComplete
	//	*ControlMessage_DtshSyncRequest
	//	*ControlMessage_TranscodeJobRequest
	//	*ControlMessage_TranscodeJobProgress
	//	*ControlMessage_TranscodeJobComplete
	//	*ControlMessage_StopSessionsRequest
	Payload       isControlMessage_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControlMessage) Reset() {
	*x = ControlMessage{}
	mi := &file_ipc_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControlMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControlMessage) ProtoMessage() {}

func (x *ControlMessage) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControlMessage.ProtoReflect.Descriptor instead.
func (*ControlMessage) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{9}
}

func (x *ControlMessage) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ControlMessage) GetSentAt() *timestamppb.Timestamp {
	if x != nil {
		return x.SentAt
	}
	return nil
}

func (x *ControlMessage) GetPayload() isControlMessage_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ControlMessage) GetRegister() *Register {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_Register); ok {
			return x.Register
		}
	}
	return nil
}

func (x *ControlMessage) GetClipPullRequest() *ClipPullRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ClipPullRequest); ok {
			return x.ClipPullRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetClipProgress() *ClipProgress {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ClipProgress); ok {
			return x.ClipProgress
		}
	}
	return nil
}

func (x *ControlMessage) GetClipDone() *ClipDone {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ClipDone); ok {
			return x.ClipDone
		}
	}
	return nil
}

func (x *ControlMessage) GetError() *ControlError {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_Error); ok {
			return x.Error
		}
	}
	return nil
}

func (x *ControlMessage) GetHeartbeat() *Heartbeat {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_Heartbeat); ok {
			return x.Heartbeat
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrStartRequest() *DVRStartRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrStartRequest); ok {
			return x.DvrStartRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrProgress() *DVRProgress {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrProgress); ok {
			return x.DvrProgress
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrStopped() *DVRStopped {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrStopped); ok {
			return x.DvrStopped
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrStopRequest() *DVRStopRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrStopRequest); ok {
			return x.DvrStopRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrReadyRequest() *DVRReadyRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrReadyRequest); ok {
			return x.DvrReadyRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrReadyResponse() *DVRReadyResponse {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrReadyResponse); ok {
			return x.DvrReadyResponse
		}
	}
	return nil
}

func (x *ControlMessage) GetMistTrigger() *MistTrigger {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_MistTrigger); ok {
			return x.MistTrigger
		}
	}
	return nil
}

func (x *ControlMessage) GetMistTriggerResponse() *MistTriggerResponse {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_MistTriggerResponse); ok {
			return x.MistTriggerResponse
		}
	}
	return nil
}

func (x *ControlMessage) GetConfigSeed() *ConfigSeed {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ConfigSeed); ok {
			return x.ConfigSeed
		}
	}
	return nil
}

func (x *ControlMessage) GetArtifactDeleted() *ArtifactDeleted {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ArtifactDeleted); ok {
			return x.ArtifactDeleted
		}
	}
	return nil
}

func (x *ControlMessage) GetClipDelete() *ClipDeleteRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ClipDelete); ok {
			return x.ClipDelete
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrDelete() *DVRDeleteRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrDelete); ok {
			return x.DvrDelete
		}
	}
	return nil
}

func (x *ControlMessage) GetVodDelete() *VodDeleteRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_VodDelete); ok {
			return x.VodDelete
		}
	}
	return nil
}

func (x *ControlMessage) GetFreezePermissionRequest() *FreezePermissionRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_FreezePermissionRequest); ok {
			return x.FreezePermissionRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetFreezePermissionResponse() *FreezePermissionResponse {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_FreezePermissionResponse); ok {
			return x.FreezePermissionResponse
		}
	}
	return nil
}

func (x *ControlMessage) GetFreezeProgress() *FreezeProgress {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_FreezeProgress); ok {
			return x.FreezeProgress
		}
	}
	return nil
}

func (x *ControlMessage) GetFreezeComplete() *FreezeComplete {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_FreezeComplete); ok {
			return x.FreezeComplete
		}
	}
	return nil
}

func (x *ControlMessage) GetDefrostRequest() *DefrostRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DefrostRequest); ok {
			return x.DefrostRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetDefrostProgress() *DefrostProgress {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DefrostProgress); ok {
			return x.DefrostProgress
		}
	}
	return nil
}

func (x *ControlMessage) GetDefrostComplete() *DefrostComplete {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DefrostComplete); ok {
			return x.DefrostComplete
		}
	}
	return nil
}

func (x *ControlMessage) GetCanDeleteRequest() *CanDeleteRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_CanDeleteRequest); ok {
			return x.CanDeleteRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetCanDeleteResponse() *CanDeleteResponse {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_CanDeleteResponse); ok {
			return x.CanDeleteResponse
		}
	}
	return nil
}

func (x *ControlMessage) GetSyncComplete() *SyncComplete {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_SyncComplete); ok {
			return x.SyncComplete
		}
	}
	return nil
}

func (x *ControlMessage) GetDtshSyncRequest() *DtshSyncRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DtshSyncRequest); ok {
			return x.DtshSyncRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetTranscodeJobRequest() *TranscodeJobRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_TranscodeJobRequest); ok {
			return x.TranscodeJobRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetTranscodeJobProgress() *TranscodeJobProgress {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_TranscodeJobProgress); ok {
			return x.TranscodeJobProgress
		}
	}
	return nil
}

func (x *ControlMessage) GetTranscodeJobComplete() *TranscodeJobComplete {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_TranscodeJobComplete); ok {
			return x.TranscodeJobComplete
		}
	}
	return nil
}

func (x *ControlMessage) GetStopSessionsRequest() *StopSessionsRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_StopSessionsRequest); ok {
			return x.StopSessionsRequest
		}
	}
	return nil
}

type isControlMessage_Payload interface {
	isControlMessage_Payload()
}

type ControlMessage_Register struct {
	Register *Register `protobuf:"bytes,10,opt,name=register,proto3,oneof"`
}

type ControlMessage_ClipPullRequest struct {
	ClipPullRequest *ClipPullRequest `protobuf:"bytes,12,opt,name=clip_pull_request,json=clipPullRequest,proto3,oneof"`
}

type ControlMessage_ClipProgress struct {
	ClipProgress *ClipProgress `protobuf:"bytes,13,opt,name=clip_progress,json=clipProgress,proto3,oneof"`
}

type ControlMessage_ClipDone struct {
	ClipDone *ClipDone `protobuf:"bytes,14,opt,name=clip_done,json=clipDone,proto3,oneof"`
}

type ControlMessage_Error struct {
	Error *ControlError `protobuf:"bytes,15,opt,name=error,proto3,oneof"`
}

type ControlMessage_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,16,opt,name=heartbeat,proto3,oneof"`
}

type ControlMessage_DvrStartRequest struct {
	DvrStartRequest *DVRStartRequest `protobuf:"bytes,18,opt,name=dvr_start_request,json=dvrStartRequest,proto3,oneof"`
}

type ControlMessage_DvrProgress struct {
	DvrProgress *DVRProgress `protobuf:"bytes,19,opt,name=dvr_progress,json=dvrProgress,proto3,oneof"`
}

type ControlMessage_DvrStopped struct {
	DvrStopped *DVRStopped `protobuf:"bytes,20,opt,name=dvr_stopped,json=dvrStopped,proto3,oneof"`
}

type ControlMessage_DvrStopRequest struct {
	DvrStopRequest *DVRStopRequest `protobuf:"bytes,21,opt,name=dvr_stop_request,json=dvrStopRequest,proto3,oneof"`
}

type ControlMessage_DvrReadyRequest struct {
	DvrReadyRequest *DVRReadyRequest `protobuf:"bytes,22,opt,name=dvr_ready_request,json=dvrReadyRequest,proto3,oneof"`
}

type ControlMessage_DvrReadyResponse struct {
	DvrReadyResponse *DVRReadyResponse `protobuf:"bytes,23,opt,name=dvr_ready_response,json=dvrReadyResponse,proto3,oneof"`
}

type ControlMessage_MistTrigger struct {
	MistTrigger *MistTrigger `protobuf:"bytes,24,opt,name=mist_trigger,json=mistTrigger,proto3,oneof"`
}

type ControlMessage_MistTriggerResponse struct {
	MistTriggerResponse *MistTriggerResponse `protobuf:"bytes,25,opt,name=mist_trigger_response,json=mistTriggerResponse,proto3,oneof"`
}

type ControlMessage_ConfigSeed struct {
	ConfigSeed *ConfigSeed `protobuf:"bytes,29,opt,name=config_seed,json=configSeed,proto3,oneof"`
}

type ControlMessage_ArtifactDeleted struct {
	ArtifactDeleted *ArtifactDeleted `protobuf:"bytes,30,opt,name=artifact_deleted,json=artifactDeleted,proto3,oneof"`
}

type ControlMessage_ClipDelete struct {
	ClipDelete *ClipDeleteRequest `protobuf:"bytes,31,opt,name=clip_delete,json=clipDelete,proto3,oneof"`
}

type ControlMessage_DvrDelete struct {
	DvrDelete *DVRDeleteRequest `protobuf:"bytes,32,opt,name=dvr_delete,json=dvrDelete,proto3,oneof"`
}

type ControlMessage_VodDelete struct {
	VodDelete *VodDeleteRequest `protobuf:"bytes,33,opt,name=vod_delete,json=vodDelete,proto3,oneof"`
}

type ControlMessage_FreezePermissionRequest struct {
	// Cold storage (S3) operations
	FreezePermissionRequest *FreezePermissionRequest `protobuf:"bytes,40,opt,name=freeze_permission_request,json=freezePermissionRequest,proto3,oneof"`
}

type ControlMessage_FreezePermissionResponse struct {
	FreezePermissionResponse *FreezePermissionResponse `protobuf:"bytes,41,opt,name=freeze_permission_response,json=freezePermissionResponse,proto3,oneof"`
}

type ControlMessage_FreezeProgress struct {
	FreezeProgress *FreezeProgress `protobuf:"bytes,42,opt,name=freeze_progress,json=freezeProgress,proto3,oneof"`
}

type ControlMessage_FreezeComplete struct {
	FreezeComplete *FreezeComplete `protobuf:"bytes,43,opt,name=freeze_complete,json=freezeComplete,proto3,oneof"`
}

type ControlMessage_DefrostRequest struct {
	DefrostRequest *DefrostRequest `protobuf:"bytes,44,opt,name=defrost_request,json=defrostRequest,proto3,oneof"`
}

type ControlMessage_DefrostProgress struct {
	DefrostProgress *DefrostProgress `protobuf:"bytes,45,opt,name=defrost_progress,json=defrostProgress,proto3,oneof"`
}

type ControlMessage_DefrostComplete struct {
	DefrostComplete *DefrostComplete `protobuf:"bytes,46,opt,name=defrost_complete,json=defrostComplete,proto3,oneof"`
}

type ControlMessage_CanDeleteRequest struct {
	// Dual-storage sync operations (sync to S3 while keeping local)
	CanDeleteRequest *CanDeleteRequest `protobuf:"bytes,47,opt,name=can_delete_request,json=canDeleteRequest,proto3,oneof"`
}

type ControlMessage_CanDeleteResponse struct {
	CanDeleteResponse *CanDeleteResponse `protobuf:"bytes,48,opt,name=can_delete_response,json=canDeleteResponse,proto3,oneof"`
}

type ControlMessage_SyncComplete struct {
	SyncComplete *SyncComplete `protobuf:"bytes,49,opt,name=sync_complete,json=syncComplete,proto3,oneof"`
}

type ControlMessage_DtshSyncRequest struct {
	// Incremental .dtsh sync (Foghorn -> Helmsman)
	DtshSyncRequest *DtshSyncRequest `protobuf:"bytes,50,opt,name=dtsh_sync_request,json=dtshSyncRequest,proto3,oneof"`
}

type ControlMessage_TranscodeJobRequest struct {
	// Transcode job operations (Foghorn <-> Helmsman)
	TranscodeJobRequest *TranscodeJobRequest `protobuf:"bytes,60,opt,name=transcode_job_request,json=transcodeJobRequest,proto3,oneof"`
}

type ControlMessage_TranscodeJobProgress struct {
	TranscodeJobProgress *TranscodeJobProgress `protobuf:"bytes,61,opt,name=transcode_job_progress,json=transcodeJobProgress,proto3,oneof"`
}

type ControlMessage_TranscodeJobComplete struct {
	TranscodeJobComplete *TranscodeJobComplete `protobuf:"bytes,62,opt,name=transcode_job_complete,json=transcodeJobComplete,proto3,oneof"`
}

type ControlMessage_StopSessionsRequest struct {
	// Session termination (Foghorn -> Helmsman for billing suspension)
	StopSessionsRequest *StopSessionsRequest `protobuf:"bytes,70,opt,name=stop_sessions_request,json=stopSessionsRequest,proto3,oneof"`
}

func (*ControlMessage_Register) isControlMessage_Payload() {}

func (*ControlMessage_ClipPullRequest) isControlMessage_Payload() {}

func (*ControlMessage_ClipProgress) isControlMessage_Payload() {}

func (*ControlMessage_ClipDone) isControlMessage_Payload() {}

func (*ControlMessage_Error) isControlMessage_Payload() {}

func (*ControlMessage_Heartbeat) isControlMessage_Payload() {}

func (*ControlMessage_DvrStartRequest) isControlMessage_Payload() {}

func (*ControlMessage_DvrProgress) isControlMessage_Payload() {}

func (*ControlMessage_DvrStopped) isControlMessage_Payload() {}

func (*ControlMessage_DvrStopRequest) isControlMessage_Payload() {}

func (*ControlMessage_DvrReadyRequest) isControlMessage_Payload() {}

func (*ControlMessage_DvrReadyResponse) isControlMessage_Payload() {}

func (*ControlMessage_MistTrigger) isControlMessage_Payload() {}

func (*ControlMessage_MistTriggerResponse) isControlMessage_Payload() {}

func (*ControlMessage_ConfigSeed) isControlMessage_Payload() {}

func (*ControlMessage_ArtifactDeleted) isControlMessage_Payload() {}

func (*ControlMessage_ClipDelete) isControlMessage_Payload() {}

func (*ControlMessage_DvrDelete) isControlMessage_Payload() {}

func (*ControlMessage_VodDelete) isControlMessage_Payload() {}

func (*ControlMessage_FreezePermissionRequest) isControlMessage_Payload() {}

func (*ControlMessage_FreezePermissionResponse) isControlMessage_Payload() {}

func (*ControlMessage_FreezeProgress) isControlMessage_Payload() {}

func (*ControlMessage_FreezeComplete) isControlMessage_Payload() {}

func (*ControlMessage_DefrostRequest) isControlMessage_Payload() {}

func (*ControlMessage_DefrostProgress) isControlMessage_Payload() {}

func (*ControlMessage_DefrostComplete) isControlMessage_Payload() {}

func (*ControlMessage_CanDeleteRequest) isControlMessage_Payload() {}

func (*ControlMessage_CanDeleteResponse) isControlMessage_Payload() {}

func (*ControlMessage_SyncComplete) isControlMessage_Payload() {}

func (*ControlMessage_DtshSyncRequest) isControlMessage_Payload() {}

func (*ControlMessage_TranscodeJobRequest) isControlMessage_Payload() {}

func (*ControlMessage_TranscodeJobProgress) isControlMessage_Payload() {}

func (*ControlMessage_TranscodeJobComplete) isControlMessage_Payload() {}

func (*ControlMessage_StopSessionsRequest) isControlMessage_Payload() {}

// StopSessionsRequest tells Helmsman to stop all sessions for the given streams
// Used when a tenant is suspended due to insufficient balance
type StopSessionsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StreamNames   []string               `protobuf:"bytes,1,rep,name=stream_names,json=streamNames,proto3" json:"stream_names,omitempty"` // Internal stream names to stop
	TenantId      string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`          // For logging/audit
	Reason        string                 `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`                              // e.g., "insufficient_balance", "suspended"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopSessionsRequest) Reset() {
	*x = StopSessionsRequest{}
	mi := &file_ipc_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopSessionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopSessionsRequest) ProtoMessage() {}

func (x *StopSessionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopSessionsRequest.ProtoReflect.Descriptor instead.
func (*StopSessionsRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{10}
}

func (x *StopSessionsRequest) GetStreamNames() []string {
	if x != nil {
		return x.StreamNames
	}
	return nil
}

func (x *StopSessionsRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *StopSessionsRequest) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type ArtifactDeleted struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClipHash      string                 `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"` // Deprecated: use artifact_hash instead
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	Reason        string                 `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"` // "cleanup", "eviction", "manual"
	NodeId        string                 `protobuf:"bytes,4,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	SizeBytes     uint64                 `protobuf:"varint,5,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	ArtifactHash  string                 `protobuf:"bytes,6,opt,name=artifact_hash,json=artifactHash,proto3" json:"artifact_hash,omitempty"` // Generic artifact hash (clip, dvr, vod)
	ArtifactType  string                 `protobuf:"bytes,7,opt,name=artifact_type,json=artifactType,proto3" json:"artifact_type,omitempty"` // "clip", "dvr", "vod"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArtifactDeleted) Reset() {
	*x = ArtifactDeleted{}
	mi := &file_ipc_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArtifactDeleted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArtifactDeleted) ProtoMessage() {}

func (x *ArtifactDeleted) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArtifactDeleted.ProtoReflect.Descriptor instead.
func (*ArtifactDeleted) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{11}
}

func (x *ArtifactDeleted) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *ArtifactDeleted) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *ArtifactDeleted) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *ArtifactDeleted) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *ArtifactDeleted) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *ArtifactDeleted) GetArtifactHash() string {
	if x != nil {
		return x.ArtifactHash
	}
	return ""
}

func (x *ArtifactDeleted) GetArtifactType() string {
	if x != nil {
		return x.ArtifactType
	}
	return ""
}

type Register struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Roles         []string               `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"` // e.g., ingest, edge, storage, processing
	CapIngest     bool                   `protobuf:"varint,3,opt,name=cap_ingest,json=capIngest,proto3" json:"cap_ingest,omitempty"`
	CapEdge       bool                   `protobuf:"varint,4,opt,name=cap_edge,json=capEdge,proto3" json:"cap_edge,omitempty"`
	CapStorage    bool                   `protobuf:"varint,5,opt,name=cap_storage,json=capStorage,proto3" json:"cap_storage,omitempty"`
	CapProcessing bool                   `protobuf:"varint,6,opt,name=cap_processing,json=capProcessing,proto3" json:"cap_processing,omitempty"`
	// Storage hints
	StorageLocal  string `protobuf:"bytes,7,opt,name=storage_local,json=storageLocal,proto3" json:"storage_local,omitempty"`
	StorageBucket string `protobuf:"bytes,8,opt,name=storage_bucket,json=storageBucket,proto3" json:"storage_bucket,omitempty"`
	StoragePrefix string `protobuf:"bytes,9,opt,name=storage_prefix,json=storagePrefix,proto3" json:"storage_prefix,omitempty"`
	// Edge enrollment token (optional). Sent by Helmsman on first connect for Foghorn to enroll the node with Quartermaster.
	EnrollmentToken string `protobuf:"bytes,10,opt,name=enrollment_token,json=enrollmentToken,proto3" json:"enrollment_token,omitempty"`
	// Optional stable fingerprint signals to aid node identity resolution.
	// Do not include volatile/process-specific values. Client-provided; server will add peer_ip & Geo.
	Fingerprint *NodeFingerprint `protobuf:"bytes,11,opt,name=fingerprint,proto3" json:"fingerprint,omitempty"`
	// Hardware specs detected at startup (for load balancing and capacity planning)
	CpuCores *int32 `protobuf:"varint,12,opt,name=cpu_cores,json=cpuCores,proto3,oneof" json:"cpu_cores,omitempty"` // Detected CPU cores (runtime.NumCPU)
	MemoryGb *int32 `protobuf:"varint,13,opt,name=memory_gb,json=memoryGb,proto3,oneof" json:"memory_gb,omitempty"` // Total RAM in GB
	DiskGb   *int32 `protobuf:"varint,14,opt,name=disk_gb,json=diskGb,proto3,oneof" json:"disk_gb,omitempty"`       // Total disk capacity in GB
	// Requested operational mode (hybrid operators can request drain/maintenance on connect).
	// Foghorn may honor or override based on DB-persisted state.
	RequestedMode NodeOperationalMode `protobuf:"varint,15,opt,name=requested_mode,json=requestedMode,proto3,enum=helmsmancontrol.NodeOperationalMode" json:"requested_mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Register) Reset() {
	*x = Register{}
	mi := &file_ipc_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Register) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Register) ProtoMessage() {}

func (x *Register) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Register.ProtoReflect.Descriptor instead.
func (*Register) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{12}
}

func (x *Register) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *Register) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

func (x *Register) GetCapIngest() bool {
	if x != nil {
		return x.CapIngest
	}
	return false
}

func (x *Register) GetCapEdge() bool {
	if x != nil {
		return x.CapEdge
	}
	return false
}

func (x *Register) GetCapStorage() bool {
	if x != nil {
		return x.CapStorage
	}
	return false
}

func (x *Register) GetCapProcessing() bool {
	if x != nil {
		return x.CapProcessing
	}
	return false
}

func (x *Register) GetStorageLocal() string {
	if x != nil {
		return x.StorageLocal
	}
	return ""
}

func (x *Register) GetStorageBucket() string {
	if x != nil {
		return x.StorageBucket
	}
	return ""
}

func (x *Register) GetStoragePrefix() string {
	if x != nil {
		return x.StoragePrefix
	}
	return ""
}

func (x *Register) GetEnrollmentToken() string {
	if x != nil {
		return x.EnrollmentToken
	}
	return ""
}

func (x *Register) GetFingerprint() *NodeFingerprint {
	if x != nil {
		return x.Fingerprint
	}
	return nil
}

func (x *Register) GetCpuCores() int32 {
	if x != nil && x.CpuCores != nil {
		return *x.CpuCores
	}
	return 0
}

func (x *Register) GetMemoryGb() int32 {
	if x != nil && x.MemoryGb != nil {
		return *x.MemoryGb
	}
	return 0
}

func (x *Register) GetDiskGb() int32 {
	if x != nil && x.DiskGb != nil {
		return *x.DiskGb
	}
	return 0
}

func (x *Register) GetRequestedMode() NodeOperationalMode {
	if x != nil {
		return x.RequestedMode
	}
	return NodeOperationalMode_NODE_OPERATIONAL_MODE_UNSPECIFIED
}

// NodeFingerprint carries stable identity hints from Helmsman.
type NodeFingerprint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Local interface IPs (best-effort). Helps disambiguate nodes behind NAT.
	LocalIpv4 []string `protobuf:"bytes,1,rep,name=local_ipv4,json=localIpv4,proto3" json:"local_ipv4,omitempty"`
	LocalIpv6 []string `protobuf:"bytes,2,rep,name=local_ipv6,json=localIpv6,proto3" json:"local_ipv6,omitempty"`
	// Deterministic aggregate hash of MAC addresses (sorted, lowercase, SHA-256 hex).
	// Avoids exposing raw MACs while remaining stable.
	MacsSha256 *string `protobuf:"bytes,3,opt,name=macs_sha256,json=macsSha256,proto3,oneof" json:"macs_sha256,omitempty"`
	// Optional machine-id hash when available (e.g., /etc/machine-id), SHA-256 hex.
	MachineIdSha256 *string `protobuf:"bytes,4,opt,name=machine_id_sha256,json=machineIdSha256,proto3,oneof" json:"machine_id_sha256,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *NodeFingerprint) Reset() {
	*x = NodeFingerprint{}
	mi := &file_ipc_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeFingerprint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeFingerprint) ProtoMessage() {}

func (x *NodeFingerprint) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeFingerprint.ProtoReflect.Descriptor instead.
func (*NodeFingerprint) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{13}
}

func (x *NodeFingerprint) GetLocalIpv4() []string {
	if x != nil {
		return x.LocalIpv4
	}
	return nil
}

func (x *NodeFingerprint) GetLocalIpv6() []string {
	if x != nil {
		return x.LocalIpv6
	}
	return nil
}

func (x *NodeFingerprint) GetMacsSha256() string {
	if x != nil && x.MacsSha256 != nil {
		return *x.MacsSha256
	}
	return ""
}

func (x *NodeFingerprint) GetMachineIdSha256() string {
	if x != nil && x.MachineIdSha256 != nil {
		return *x.MachineIdSha256
	}
	return ""
}

type ClipPullRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Security: Use opaque identifiers, never expose tenant_id on edge nodes
	ClipHash   string `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`       // Opaque identifier for the clip
	StreamName string `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"` // Stream name for MistServer (no tenant info)
	// Timing (one of):
	StartUnix   *int64 `protobuf:"varint,3,opt,name=start_unix,json=startUnix,proto3,oneof" json:"start_unix,omitempty"`       // seconds
	StopUnix    *int64 `protobuf:"varint,4,opt,name=stop_unix,json=stopUnix,proto3,oneof" json:"stop_unix,omitempty"`          // seconds
	StartMs     *int64 `protobuf:"varint,5,opt,name=start_ms,json=startMs,proto3,oneof" json:"start_ms,omitempty"`             // since stream start
	StopMs      *int64 `protobuf:"varint,6,opt,name=stop_ms,json=stopMs,proto3,oneof" json:"stop_ms,omitempty"`                // since stream start
	DurationSec *int64 `protobuf:"varint,7,opt,name=duration_sec,json=durationSec,proto3,oneof" json:"duration_sec,omitempty"` // seconds
	// Output
	Format     string `protobuf:"bytes,8,opt,name=format,proto3" json:"format,omitempty"`                           // mp4 default
	OutputName string `protobuf:"bytes,9,opt,name=output_name,json=outputName,proto3" json:"output_name,omitempty"` // suggested basename
	// Optional explicit Mist HTTP base (e.g., http://node:8080) to pull from
	SourceBaseUrl string `protobuf:"bytes,10,opt,name=source_base_url,json=sourceBaseUrl,proto3" json:"source_base_url,omitempty"`
	// Request tracking
	RequestId     string `protobuf:"bytes,11,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"` // Unique request ID for tracking
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipPullRequest) Reset() {
	*x = ClipPullRequest{}
	mi := &file_ipc_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipPullRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipPullRequest) ProtoMessage() {}

func (x *ClipPullRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipPullRequest.ProtoReflect.Descriptor instead.
func (*ClipPullRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{14}
}

func (x *ClipPullRequest) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *ClipPullRequest) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *ClipPullRequest) GetStartUnix() int64 {
	if x != nil && x.StartUnix != nil {
		return *x.StartUnix
	}
	return 0
}

func (x *ClipPullRequest) GetStopUnix() int64 {
	if x != nil && x.StopUnix != nil {
		return *x.StopUnix
	}
	return 0
}

func (x *ClipPullRequest) GetStartMs() int64 {
	if x != nil && x.StartMs != nil {
		return *x.StartMs
	}
	return 0
}

func (x *ClipPullRequest) GetStopMs() int64 {
	if x != nil && x.StopMs != nil {
		return *x.StopMs
	}
	return 0
}

func (x *ClipPullRequest) GetDurationSec() int64 {
	if x != nil && x.DurationSec != nil {
		return *x.DurationSec
	}
	return 0
}

func (x *ClipPullRequest) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *ClipPullRequest) GetOutputName() string {
	if x != nil {
		return x.OutputName
	}
	return ""
}

func (x *ClipPullRequest) GetSourceBaseUrl() string {
	if x != nil {
		return x.SourceBaseUrl
	}
	return ""
}

func (x *ClipPullRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

type ClipProgress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Percent       uint32                 `protobuf:"varint,2,opt,name=percent,proto3" json:"percent,omitempty"` // 0..100
	Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipProgress) Reset() {
	*x = ClipProgress{}
	mi := &file_ipc_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipProgress) ProtoMessage() {}

func (x *ClipProgress) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipProgress.ProtoReflect.Descriptor instead.
func (*ClipProgress) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{15}
}

func (x *ClipProgress) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ClipProgress) GetPercent() uint32 {
	if x != nil {
		return x.Percent
	}
	return 0
}

func (x *ClipProgress) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type ClipDone struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"` // local path on storage node (if applicable)
	S3Url         string                 `protobuf:"bytes,3,opt,name=s3_url,json=s3Url,proto3" json:"s3_url,omitempty"`          // s3://bucket/key or https URL (if applicable)
	SizeBytes     uint64                 `protobuf:"varint,4,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Status        string                 `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"` // success|failed
	Error         string                 `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`   // filled when failed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipDone) Reset() {
	*x = ClipDone{}
	mi := &file_ipc_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipDone) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipDone) ProtoMessage() {}

func (x *ClipDone) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipDone.ProtoReflect.Descriptor instead.
func (*ClipDone) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{16}
}

func (x *ClipDone) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ClipDone) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *ClipDone) GetS3Url() string {
	if x != nil {
		return x.S3Url
	}
	return ""
}

func (x *ClipDone) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *ClipDone) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *ClipDone) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ControlError struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          string                 `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControlError) Reset() {
	*x = ControlError{}
	mi := &file_ipc_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControlError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControlError) ProtoMessage() {}

func (x *ControlError) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControlError.ProtoReflect.Descriptor instead.
func (*ControlError) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{17}
}

func (x *ControlError) GetCode() string {
	if x != nil {
		return x.Code
	}
	return ""
}

func (x *ControlError) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type Heartbeat struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Heartbeat) Reset() {
	*x = Heartbeat{}
	mi := &file_ipc_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Heartbeat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Heartbeat) ProtoMessage() {}

func (x *Heartbeat) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Heartbeat.ProtoReflect.Descriptor instead.
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{18}
}

func (x *Heartbeat) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

type MistTrigger struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	TriggerType string                 `protobuf:"bytes,1,opt,name=trigger_type,json=triggerType,proto3" json:"trigger_type,omitempty"` // e.g., PUSH_REWRITE, PLAY_REWRITE, VIEWER_CONNECT, STREAM_BUFFER
	NodeId      string                 `protobuf:"bytes,3,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`                // Node that received the trigger
	Timestamp   int64                  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                       // When trigger was received
	Blocking    bool                   `protobuf:"varint,5,opt,name=blocking,proto3" json:"blocking,omitempty"`                         // Does this trigger need a response from Foghorn?
	RequestId   string                 `protobuf:"bytes,6,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`       // For correlating responses
	TenantId    *string                `protobuf:"bytes,7,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"`    // Tenant context (enriched by Foghorn)
	UserId      *string                `protobuf:"bytes,8,opt,name=user_id,json=userId,proto3,oneof" json:"user_id,omitempty"`          // User context (enriched by Foghorn)
	StreamId    *string                `protobuf:"bytes,9,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"`    // Public stream ID (enriched by Foghorn)
	// Typed trigger payloads (one of these will be set based on trigger_type)
	//
	// Types that are valid to be assigned to TriggerPayload:
	//
	//	*MistTrigger_PushRewrite
	//	*MistTrigger_PlayRewrite
	//	*MistTrigger_StreamSource
	//	*MistTrigger_PushOutStart
	//	*MistTrigger_PushEnd
	//	*MistTrigger_ViewerConnect
	//	*MistTrigger_ViewerDisconnect
	//	*MistTrigger_StreamBuffer
	//	*MistTrigger_StreamEnd
	//	*MistTrigger_TrackList
	//	*MistTrigger_RecordingComplete
	//	*MistTrigger_StreamLifecycleUpdate
	//	*MistTrigger_ClientLifecycleUpdate
	//	*MistTrigger_NodeLifecycleUpdate
	//	*MistTrigger_LoadBalancingData
	//	*MistTrigger_ClipLifecycleData
	//	*MistTrigger_DvrLifecycleData
	//	*MistTrigger_StorageSnapshot
	//	*MistTrigger_StorageLifecycleData
	//	*MistTrigger_RecordingSegment
	//	*MistTrigger_ProcessBilling
	//	*MistTrigger_VodLifecycleData
	//	*MistTrigger_ApiRequestBatch
	//	*MistTrigger_MessageLifecycleData
	TriggerPayload isMistTrigger_TriggerPayload `protobuf_oneof:"trigger_payload"`
	ClusterId      *string                      `protobuf:"bytes,33,opt,name=cluster_id,json=clusterId,proto3,oneof" json:"cluster_id,omitempty"` // Emitting cluster identifier
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *MistTrigger) Reset() {
	*x = MistTrigger{}
	mi := &file_ipc_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MistTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MistTrigger) ProtoMessage() {}

func (x *MistTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MistTrigger.ProtoReflect.Descriptor instead.
func (*MistTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{19}
}

func (x *MistTrigger) GetTriggerType() string {
	if x != nil {
		return x.TriggerType
	}
	return ""
}

func (x *MistTrigger) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *MistTrigger) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *MistTrigger) GetBlocking() bool {
	if x != nil {
		return x.Blocking
	}
	return false
}

func (x *MistTrigger) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *MistTrigger) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *MistTrigger) GetUserId() string {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return ""
}

func (x *MistTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

func (x *MistTrigger) GetTriggerPayload() isMistTrigger_TriggerPayload {
	if x != nil {
		return x.TriggerPayload
	}
	return nil
}

func (x *MistTrigger) GetPushRewrite() *PushRewriteTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_PushRewrite); ok {
			return x.PushRewrite
		}
	}
	return nil
}

func (x *MistTrigger) GetPlayRewrite() *ViewerResolveTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_PlayRewrite); ok {
			return x.PlayRewrite
		}
	}
	return nil
}

func (x *MistTrigger) GetStreamSource() *StreamSourceTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_StreamSource); ok {
			return x.StreamSource
		}
	}
	return nil
}

func (x *MistTrigger) GetPushOutStart() *PushOutStartTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_PushOutStart); ok {
			return x.PushOutStart
		}
	}
	return nil
}

func (x *MistTrigger) GetPushEnd() *PushEndTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_PushEnd); ok {
			return x.PushEnd
		}
	}
	return nil
}

func (x *MistTrigger) GetViewerConnect() *ViewerConnectTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_ViewerConnect); ok {
			return x.ViewerConnect
		}
	}
	return nil
}

func (x *MistTrigger) GetViewerDisconnect() *ViewerDisconnectTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_ViewerDisconnect); ok {
			return x.ViewerDisconnect
		}
	}
	return nil
}

func (x *MistTrigger) GetStreamBuffer() *StreamBufferTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_StreamBuffer); ok {
			return x.StreamBuffer
		}
	}
	return nil
}

func (x *MistTrigger) GetStreamEnd() *StreamEndTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_StreamEnd); ok {
			return x.StreamEnd
		}
	}
	return nil
}

func (x *MistTrigger) GetTrackList() *StreamTrackListTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_TrackList); ok {
			return x.TrackList
		}
	}
	return nil
}

func (x *MistTrigger) GetRecordingComplete() *RecordingCompleteTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_RecordingComplete); ok {
			return x.RecordingComplete
		}
	}
	return nil
}

func (x *MistTrigger) GetStreamLifecycleUpdate() *StreamLifecycleUpdate {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_StreamLifecycleUpdate); ok {
			return x.StreamLifecycleUpdate
		}
	}
	return nil
}

func (x *MistTrigger) GetClientLifecycleUpdate() *ClientLifecycleUpdate {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_ClientLifecycleUpdate); ok {
			return x.ClientLifecycleUpdate
		}
	}
	return nil
}

func (x *MistTrigger) GetNodeLifecycleUpdate() *NodeLifecycleUpdate {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_NodeLifecycleUpdate); ok {
			return x.NodeLifecycleUpdate
		}
	}
	return nil
}

func (x *MistTrigger) GetLoadBalancingData() *LoadBalancingData {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_LoadBalancingData); ok {
			return x.LoadBalancingData
		}
	}
	return nil
}

func (x *MistTrigger) GetClipLifecycleData() *ClipLifecycleData {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_ClipLifecycleData); ok {
			return x.ClipLifecycleData
		}
	}
	return nil
}

func (x *MistTrigger) GetDvrLifecycleData() *DVRLifecycleData {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_DvrLifecycleData); ok {
			return x.DvrLifecycleData
		}
	}
	return nil
}

func (x *MistTrigger) GetStorageSnapshot() *StorageSnapshot {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_StorageSnapshot); ok {
			return x.StorageSnapshot
		}
	}
	return nil
}

func (x *MistTrigger) GetStorageLifecycleData() *StorageLifecycleData {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_StorageLifecycleData); ok {
			return x.StorageLifecycleData
		}
	}
	return nil
}

func (x *MistTrigger) GetRecordingSegment() *RecordingSegmentTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_RecordingSegment); ok {
			return x.RecordingSegment
		}
	}
	return nil
}

func (x *MistTrigger) GetProcessBilling() *ProcessBillingEvent {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_ProcessBilling); ok {
			return x.ProcessBilling
		}
	}
	return nil
}

func (x *MistTrigger) GetVodLifecycleData() *VodLifecycleData {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_VodLifecycleData); ok {
			return x.VodLifecycleData
		}
	}
	return nil
}

func (x *MistTrigger) GetApiRequestBatch() *APIRequestBatch {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_ApiRequestBatch); ok {
			return x.ApiRequestBatch
		}
	}
	return nil
}

func (x *MistTrigger) GetMessageLifecycleData() *MessageLifecycleData {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_MessageLifecycleData); ok {
			return x.MessageLifecycleData
		}
	}
	return nil
}

func (x *MistTrigger) GetClusterId() string {
	if x != nil && x.ClusterId != nil {
		return *x.ClusterId
	}
	return ""
}

type isMistTrigger_TriggerPayload interface {
	isMistTrigger_TriggerPayload()
}

type MistTrigger_PushRewrite struct {
	PushRewrite *PushRewriteTrigger `protobuf:"bytes,10,opt,name=push_rewrite,json=pushRewrite,proto3,oneof"`
}

type MistTrigger_PlayRewrite struct {
	PlayRewrite *ViewerResolveTrigger `protobuf:"bytes,11,opt,name=play_rewrite,json=playRewrite,proto3,oneof"` // formerly DefaultStreamTrigger
}

type MistTrigger_StreamSource struct {
	StreamSource *StreamSourceTrigger `protobuf:"bytes,12,opt,name=stream_source,json=streamSource,proto3,oneof"` // VOD source resolution
}

type MistTrigger_PushOutStart struct {
	PushOutStart *PushOutStartTrigger `protobuf:"bytes,13,opt,name=push_out_start,json=pushOutStart,proto3,oneof"`
}

type MistTrigger_PushEnd struct {
	PushEnd *PushEndTrigger `protobuf:"bytes,14,opt,name=push_end,json=pushEnd,proto3,oneof"`
}

type MistTrigger_ViewerConnect struct {
	ViewerConnect *ViewerConnectTrigger `protobuf:"bytes,15,opt,name=viewer_connect,json=viewerConnect,proto3,oneof"` // formerly UserNewTrigger
}

type MistTrigger_ViewerDisconnect struct {
	ViewerDisconnect *ViewerDisconnectTrigger `protobuf:"bytes,16,opt,name=viewer_disconnect,json=viewerDisconnect,proto3,oneof"` // formerly UserEndTrigger
}

type MistTrigger_StreamBuffer struct {
	StreamBuffer *StreamBufferTrigger `protobuf:"bytes,17,opt,name=stream_buffer,json=streamBuffer,proto3,oneof"`
}

type MistTrigger_StreamEnd struct {
	StreamEnd *StreamEndTrigger `protobuf:"bytes,18,opt,name=stream_end,json=streamEnd,proto3,oneof"`
}

type MistTrigger_TrackList struct {
	TrackList *StreamTrackListTrigger `protobuf:"bytes,19,opt,name=track_list,json=trackList,proto3,oneof"` // formerly LiveTrackListTrigger
}

type MistTrigger_RecordingComplete struct {
	RecordingComplete *RecordingCompleteTrigger `protobuf:"bytes,21,opt,name=recording_complete,json=recordingComplete,proto3,oneof"` // formerly RecordingEndTrigger
}

type MistTrigger_StreamLifecycleUpdate struct {
	StreamLifecycleUpdate *StreamLifecycleUpdate `protobuf:"bytes,22,opt,name=stream_lifecycle_update,json=streamLifecycleUpdate,proto3,oneof"`
}

type MistTrigger_ClientLifecycleUpdate struct {
	ClientLifecycleUpdate *ClientLifecycleUpdate `protobuf:"bytes,23,opt,name=client_lifecycle_update,json=clientLifecycleUpdate,proto3,oneof"`
}

type MistTrigger_NodeLifecycleUpdate struct {
	NodeLifecycleUpdate *NodeLifecycleUpdate `protobuf:"bytes,24,opt,name=node_lifecycle_update,json=nodeLifecycleUpdate,proto3,oneof"`
}

type MistTrigger_LoadBalancingData struct {
	LoadBalancingData *LoadBalancingData `protobuf:"bytes,25,opt,name=load_balancing_data,json=loadBalancingData,proto3,oneof"`
}

type MistTrigger_ClipLifecycleData struct {
	ClipLifecycleData *ClipLifecycleData `protobuf:"bytes,26,opt,name=clip_lifecycle_data,json=clipLifecycleData,proto3,oneof"`
}

type MistTrigger_DvrLifecycleData struct {
	DvrLifecycleData *DVRLifecycleData `protobuf:"bytes,27,opt,name=dvr_lifecycle_data,json=dvrLifecycleData,proto3,oneof"`
}

type MistTrigger_StorageSnapshot struct {
	StorageSnapshot *StorageSnapshot `protobuf:"bytes,28,opt,name=storage_snapshot,json=storageSnapshot,proto3,oneof"`
}

type MistTrigger_StorageLifecycleData struct {
	StorageLifecycleData *StorageLifecycleData `protobuf:"bytes,29,opt,name=storage_lifecycle_data,json=storageLifecycleData,proto3,oneof"`
}

type MistTrigger_RecordingSegment struct {
	RecordingSegment *RecordingSegmentTrigger `protobuf:"bytes,30,opt,name=recording_segment,json=recordingSegment,proto3,oneof"`
}

type MistTrigger_ProcessBilling struct {
	ProcessBilling *ProcessBillingEvent `protobuf:"bytes,31,opt,name=process_billing,json=processBilling,proto3,oneof"`
}

type MistTrigger_VodLifecycleData struct {
	VodLifecycleData *VodLifecycleData `protobuf:"bytes,32,opt,name=vod_lifecycle_data,json=vodLifecycleData,proto3,oneof"`
}

type MistTrigger_ApiRequestBatch struct {
	ApiRequestBatch *APIRequestBatch `protobuf:"bytes,34,opt,name=api_request_batch,json=apiRequestBatch,proto3,oneof"`
}

type MistTrigger_MessageLifecycleData struct {
	MessageLifecycleData *MessageLifecycleData `protobuf:"bytes,35,opt,name=message_lifecycle_data,json=messageLifecycleData,proto3,oneof"`
}

func (*MistTrigger_PushRewrite) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_PlayRewrite) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_StreamSource) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_PushOutStart) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_PushEnd) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_ViewerConnect) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_ViewerDisconnect) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_StreamBuffer) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_StreamEnd) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_TrackList) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_RecordingComplete) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_StreamLifecycleUpdate) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_ClientLifecycleUpdate) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_NodeLifecycleUpdate) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_LoadBalancingData) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_ClipLifecycleData) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_DvrLifecycleData) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_StorageSnapshot) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_StorageLifecycleData) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_RecordingSegment) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_ProcessBilling) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_VodLifecycleData) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_ApiRequestBatch) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_MessageLifecycleData) isMistTrigger_TriggerPayload() {}

type MistTriggerResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"` // Correlates to MistTrigger.request_id
	Response      string                 `protobuf:"bytes,2,opt,name=response,proto3" json:"response,omitempty"`                    // What to return to MistServer (empty string aborts for blocking triggers)
	Abort         bool                   `protobuf:"varint,3,opt,name=abort,proto3" json:"abort,omitempty"`                         // Explicit abort flag
	ErrorCode     IngestErrorCode        `protobuf:"varint,4,opt,name=error_code,json=errorCode,proto3,enum=helmsmancontrol.IngestErrorCode" json:"error_code,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MistTriggerResponse) Reset() {
	*x = MistTriggerResponse{}
	mi := &file_ipc_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MistTriggerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MistTriggerResponse) ProtoMessage() {}

func (x *MistTriggerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MistTriggerResponse.ProtoReflect.Descriptor instead.
func (*MistTriggerResponse) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{20}
}

func (x *MistTriggerResponse) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *MistTriggerResponse) GetResponse() string {
	if x != nil {
		return x.Response
	}
	return ""
}

func (x *MistTriggerResponse) GetAbort() bool {
	if x != nil {
		return x.Abort
	}
	return false
}

func (x *MistTriggerResponse) GetErrorCode() IngestErrorCode {
	if x != nil {
		return x.ErrorCode
	}
	return IngestErrorCode_INGEST_ERROR_NONE
}

type StorageSnapshot struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	NodeId       string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Timestamp    int64                  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TenantId     *string                `protobuf:"bytes,3,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"` // Node Owner (Supplier)
	Location     *string                `protobuf:"bytes,4,opt,name=location,proto3,oneof" json:"location,omitempty"`
	Capabilities *NodeCapabilities      `protobuf:"bytes,5,opt,name=capabilities,proto3,oneof" json:"capabilities,omitempty"`
	Usage        []*TenantStorageUsage  `protobuf:"bytes,6,rep,name=usage,proto3" json:"usage,omitempty"`
	// hot = node-local cache, cold = S3 (frozen) totals
	StorageScope  *string `protobuf:"bytes,7,opt,name=storage_scope,json=storageScope,proto3,oneof" json:"storage_scope,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StorageSnapshot) Reset() {
	*x = StorageSnapshot{}
	mi := &file_ipc_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageSnapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageSnapshot) ProtoMessage() {}

func (x *StorageSnapshot) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageSnapshot.ProtoReflect.Descriptor instead.
func (*StorageSnapshot) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{21}
}

func (x *StorageSnapshot) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *StorageSnapshot) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *StorageSnapshot) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *StorageSnapshot) GetLocation() string {
	if x != nil && x.Location != nil {
		return *x.Location
	}
	return ""
}

func (x *StorageSnapshot) GetCapabilities() *NodeCapabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *StorageSnapshot) GetUsage() []*TenantStorageUsage {
	if x != nil {
		return x.Usage
	}
	return nil
}

func (x *StorageSnapshot) GetStorageScope() string {
	if x != nil && x.StorageScope != nil {
		return *x.StorageScope
	}
	return ""
}

type TenantStorageUsage struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	TenantId   string                 `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"` // Resource Consumer
	TotalBytes uint64                 `protobuf:"varint,2,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	FileCount  uint32                 `protobuf:"varint,3,opt,name=file_count,json=fileCount,proto3" json:"file_count,omitempty"`
	DvrBytes   uint64                 `protobuf:"varint,4,opt,name=dvr_bytes,json=dvrBytes,proto3" json:"dvr_bytes,omitempty"`
	ClipBytes  uint64                 `protobuf:"varint,5,opt,name=clip_bytes,json=clipBytes,proto3" json:"clip_bytes,omitempty"`
	VodBytes   uint64                 `protobuf:"varint,6,opt,name=vod_bytes,json=vodBytes,proto3" json:"vod_bytes,omitempty"`
	// Frozen storage breakdown (cold storage in S3)
	FrozenDvrBytes  uint64 `protobuf:"varint,7,opt,name=frozen_dvr_bytes,json=frozenDvrBytes,proto3" json:"frozen_dvr_bytes,omitempty"`
	FrozenClipBytes uint64 `protobuf:"varint,8,opt,name=frozen_clip_bytes,json=frozenClipBytes,proto3" json:"frozen_clip_bytes,omitempty"`
	FrozenVodBytes  uint64 `protobuf:"varint,9,opt,name=frozen_vod_bytes,json=frozenVodBytes,proto3" json:"frozen_vod_bytes,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TenantStorageUsage) Reset() {
	*x = TenantStorageUsage{}
	mi := &file_ipc_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TenantStorageUsage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TenantStorageUsage) ProtoMessage() {}

func (x *TenantStorageUsage) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TenantStorageUsage.ProtoReflect.Descriptor instead.
func (*TenantStorageUsage) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{22}
}

func (x *TenantStorageUsage) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *TenantStorageUsage) GetTotalBytes() uint64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

func (x *TenantStorageUsage) GetFileCount() uint32 {
	if x != nil {
		return x.FileCount
	}
	return 0
}

func (x *TenantStorageUsage) GetDvrBytes() uint64 {
	if x != nil {
		return x.DvrBytes
	}
	return 0
}

func (x *TenantStorageUsage) GetClipBytes() uint64 {
	if x != nil {
		return x.ClipBytes
	}
	return 0
}

func (x *TenantStorageUsage) GetVodBytes() uint64 {
	if x != nil {
		return x.VodBytes
	}
	return 0
}

func (x *TenantStorageUsage) GetFrozenDvrBytes() uint64 {
	if x != nil {
		return x.FrozenDvrBytes
	}
	return 0
}

func (x *TenantStorageUsage) GetFrozenClipBytes() uint64 {
	if x != nil {
		return x.FrozenClipBytes
	}
	return 0
}

func (x *TenantStorageUsage) GetFrozenVodBytes() uint64 {
	if x != nil {
		return x.FrozenVodBytes
	}
	return 0
}

type ClipHashRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClipHash      string                 `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipHashRequest) Reset() {
	*x = ClipHashRequest{}
	mi := &file_ipc_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipHashRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipHashRequest) ProtoMessage() {}

func (x *ClipHashRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipHashRequest.ProtoReflect.Descriptor instead.
func (*ClipHashRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{23}
}

func (x *ClipHashRequest) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

type ClipHashResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClipHash      string                 `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`
	TenantId      string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	StreamName    string                 `protobuf:"bytes,3,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipHashResponse) Reset() {
	*x = ClipHashResponse{}
	mi := &file_ipc_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipHashResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipHashResponse) ProtoMessage() {}

func (x *ClipHashResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipHashResponse.ProtoReflect.Descriptor instead.
func (*ClipHashResponse) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{24}
}

func (x *ClipHashResponse) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *ClipHashResponse) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *ClipHashResponse) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

// DVR (Digital Video Recording) messages
type DVRStartRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`                     // Unique DVR identifier (32-char hex) - generated by Foghorn
	InternalName  string                 `protobuf:"bytes,2,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`      // Stream internal name (same as stream name)
	SourceBaseUrl string                 `protobuf:"bytes,3,opt,name=source_base_url,json=sourceBaseUrl,proto3" json:"source_base_url,omitempty"` // DTSC source URL to pull from - filled by Foghorn
	RequestId     string                 `protobuf:"bytes,4,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`               // Unique request ID for tracking
	Config        *DVRConfig             `protobuf:"bytes,5,opt,name=config,proto3" json:"config,omitempty"`                                      // Recording configuration
	TenantId      string                 `protobuf:"bytes,6,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`                  // Tenant ID for the stream
	UserId        string                 `protobuf:"bytes,7,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`                        // User ID for the stream
	StreamId      string                 `protobuf:"bytes,8,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`                  // Public stream ID (UUID) - used for storage path
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRStartRequest) Reset() {
	*x = DVRStartRequest{}
	mi := &file_ipc_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRStartRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRStartRequest) ProtoMessage() {}

func (x *DVRStartRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRStartRequest.ProtoReflect.Descriptor instead.
func (*DVRStartRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{25}
}

func (x *DVRStartRequest) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRStartRequest) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *DVRStartRequest) GetSourceBaseUrl() string {
	if x != nil {
		return x.SourceBaseUrl
	}
	return ""
}

func (x *DVRStartRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DVRStartRequest) GetConfig() *DVRConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *DVRStartRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *DVRStartRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *DVRStartRequest) GetStreamId() string {
	if x != nil {
		return x.StreamId
	}
	return ""
}

type DVRConfig struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Enabled         bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`                                        // Whether DVR is enabled
	RetentionDays   int32                  `protobuf:"varint,2,opt,name=retention_days,json=retentionDays,proto3" json:"retention_days,omitempty"`       // How long to keep the recording
	Format          string                 `protobuf:"bytes,3,opt,name=format,proto3" json:"format,omitempty"`                                           // ts, mp4, etc.
	SegmentDuration int32                  `protobuf:"varint,4,opt,name=segment_duration,json=segmentDuration,proto3" json:"segment_duration,omitempty"` // Segment duration in seconds
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DVRConfig) Reset() {
	*x = DVRConfig{}
	mi := &file_ipc_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRConfig) ProtoMessage() {}

func (x *DVRConfig) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRConfig.ProtoReflect.Descriptor instead.
func (*DVRConfig) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{26}
}

func (x *DVRConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *DVRConfig) GetRetentionDays() int32 {
	if x != nil {
		return x.RetentionDays
	}
	return 0
}

func (x *DVRConfig) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *DVRConfig) GetSegmentDuration() int32 {
	if x != nil {
		return x.SegmentDuration
	}
	return 0
}

type DVRProgress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	DvrHash       string                 `protobuf:"bytes,2,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`                 // DVR identifier
	Status        string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`                                  // recording, segments_available, etc.
	StartedAt     int64                  `protobuf:"varint,4,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`          // Unix timestamp when recording started
	SegmentCount  int32                  `protobuf:"varint,5,opt,name=segment_count,json=segmentCount,proto3" json:"segment_count,omitempty"` // Number of segments recorded so far
	SizeBytes     uint64                 `protobuf:"varint,6,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`          // Total size of recording so far
	Message       string                 `protobuf:"bytes,7,opt,name=message,proto3" json:"message,omitempty"`                                // Optional progress message
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRProgress) Reset() {
	*x = DVRProgress{}
	mi := &file_ipc_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRProgress) ProtoMessage() {}

func (x *DVRProgress) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRProgress.ProtoReflect.Descriptor instead.
func (*DVRProgress) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{27}
}

func (x *DVRProgress) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DVRProgress) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRProgress) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *DVRProgress) GetStartedAt() int64 {
	if x != nil {
		return x.StartedAt
	}
	return 0
}

func (x *DVRProgress) GetSegmentCount() int32 {
	if x != nil {
		return x.SegmentCount
	}
	return 0
}

func (x *DVRProgress) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *DVRProgress) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type DVRStopped struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	RequestId       string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	DvrHash         string                 `protobuf:"bytes,2,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`                          // DVR identifier
	Status          string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`                                           // completed, failed, terminated
	Error           string                 `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`                                             // Error message if failed
	StartedAt       int64                  `protobuf:"varint,5,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`                   // Unix timestamp when recording started
	EndedAt         int64                  `protobuf:"varint,6,opt,name=ended_at,json=endedAt,proto3" json:"ended_at,omitempty"`                         // Unix timestamp when recording ended
	DurationSeconds int32                  `protobuf:"varint,7,opt,name=duration_seconds,json=durationSeconds,proto3" json:"duration_seconds,omitempty"` // Total duration of the recording
	SizeBytes       uint64                 `protobuf:"varint,8,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`                   // Total size of the recording
	ManifestPath    string                 `protobuf:"bytes,9,opt,name=manifest_path,json=manifestPath,proto3" json:"manifest_path,omitempty"`           // Path to the m3u8 manifest for playback
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DVRStopped) Reset() {
	*x = DVRStopped{}
	mi := &file_ipc_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRStopped) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRStopped) ProtoMessage() {}

func (x *DVRStopped) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRStopped.ProtoReflect.Descriptor instead.
func (*DVRStopped) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{28}
}

func (x *DVRStopped) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DVRStopped) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRStopped) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *DVRStopped) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *DVRStopped) GetStartedAt() int64 {
	if x != nil {
		return x.StartedAt
	}
	return 0
}

func (x *DVRStopped) GetEndedAt() int64 {
	if x != nil {
		return x.EndedAt
	}
	return 0
}

func (x *DVRStopped) GetDurationSeconds() int32 {
	if x != nil {
		return x.DurationSeconds
	}
	return 0
}

func (x *DVRStopped) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *DVRStopped) GetManifestPath() string {
	if x != nil {
		return x.ManifestPath
	}
	return ""
}

type DVRStopRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`                      // Unique DVR identifier to stop (empty = stop all for internal_name)
	RequestId     string                 `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`                // Request ID for tracking
	InternalName  *string                `protobuf:"bytes,3,opt,name=internal_name,json=internalName,proto3,oneof" json:"internal_name,omitempty"` // Stream internal name (for stopping all DVR recordings for a stream)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRStopRequest) Reset() {
	*x = DVRStopRequest{}
	mi := &file_ipc_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRStopRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRStopRequest) ProtoMessage() {}

func (x *DVRStopRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRStopRequest.ProtoReflect.Descriptor instead.
func (*DVRStopRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{29}
}

func (x *DVRStopRequest) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRStopRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DVRStopRequest) GetInternalName() string {
	if x != nil && x.InternalName != nil {
		return *x.InternalName
	}
	return ""
}

// ClipDeleteRequest tells Helmsman to delete clip files from storage
type ClipDeleteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClipHash      string                 `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`    // Clip identifier to delete
	RequestId     string                 `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"` // Request ID for tracking
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipDeleteRequest) Reset() {
	*x = ClipDeleteRequest{}
	mi := &file_ipc_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipDeleteRequest) ProtoMessage() {}

func (x *ClipDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipDeleteRequest.ProtoReflect.Descriptor instead.
func (*ClipDeleteRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{30}
}

func (x *ClipDeleteRequest) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *ClipDeleteRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

// DVRDeleteRequest tells Helmsman to delete DVR recording files from storage
type DVRDeleteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`       // DVR identifier to delete
	RequestId     string                 `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"` // Request ID for tracking
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRDeleteRequest) Reset() {
	*x = DVRDeleteRequest{}
	mi := &file_ipc_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRDeleteRequest) ProtoMessage() {}

func (x *DVRDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRDeleteRequest.ProtoReflect.Descriptor instead.
func (*DVRDeleteRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{31}
}

func (x *DVRDeleteRequest) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRDeleteRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

// VodDeleteRequest tells Helmsman to delete VOD asset files from storage
type VodDeleteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	VodHash       string                 `protobuf:"bytes,1,opt,name=vod_hash,json=vodHash,proto3" json:"vod_hash,omitempty"`       // VOD artifact hash to delete
	RequestId     string                 `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"` // Request ID for tracking
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VodDeleteRequest) Reset() {
	*x = VodDeleteRequest{}
	mi := &file_ipc_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VodDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VodDeleteRequest) ProtoMessage() {}

func (x *VodDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VodDeleteRequest.ProtoReflect.Descriptor instead.
func (*VodDeleteRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{32}
}

func (x *VodDeleteRequest) GetVodHash() string {
	if x != nil {
		return x.VodHash
	}
	return ""
}

func (x *VodDeleteRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

// FreezePermissionRequest is sent by Helmsman to request presigned URLs for freezing.
// Helmsman detects storage pressure but cannot access S3 directly.
type FreezePermissionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	AssetType     string                 `protobuf:"bytes,2,opt,name=asset_type,json=assetType,proto3" json:"asset_type,omitempty"`  // "clip" or "dvr"
	AssetHash     string                 `protobuf:"bytes,3,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"`  // clip_hash or dvr_hash
	LocalPath     string                 `protobuf:"bytes,4,opt,name=local_path,json=localPath,proto3" json:"local_path,omitempty"`  // Local path to the asset
	SizeBytes     uint64                 `protobuf:"varint,5,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"` // Size of the asset to freeze
	NodeId        string                 `protobuf:"bytes,6,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`           // Node requesting the freeze
	Filenames     []string               `protobuf:"bytes,7,rep,name=filenames,proto3" json:"filenames,omitempty"`                   // For DVR: list of relative filenames to upload (e.g., "segments/0_0.ts")
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FreezePermissionRequest) Reset() {
	*x = FreezePermissionRequest{}
	mi := &file_ipc_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezePermissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezePermissionRequest) ProtoMessage() {}

func (x *FreezePermissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezePermissionRequest.ProtoReflect.Descriptor instead.
func (*FreezePermissionRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{33}
}

func (x *FreezePermissionRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *FreezePermissionRequest) GetAssetType() string {
	if x != nil {
		return x.AssetType
	}
	return ""
}

func (x *FreezePermissionRequest) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *FreezePermissionRequest) GetLocalPath() string {
	if x != nil {
		return x.LocalPath
	}
	return ""
}

func (x *FreezePermissionRequest) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *FreezePermissionRequest) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *FreezePermissionRequest) GetFilenames() []string {
	if x != nil {
		return x.Filenames
	}
	return nil
}

// FreezePermissionResponse is sent by Foghorn with presigned URLs for freezing.
// If approved=false, Helmsman should not proceed (asset may be in use, etc.)
type FreezePermissionResponse struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	RequestId        string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	AssetHash        string                 `protobuf:"bytes,2,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"`
	Approved         bool                   `protobuf:"varint,3,opt,name=approved,proto3" json:"approved,omitempty"`                                           // Whether freeze is approved
	PresignedPutUrl  string                 `protobuf:"bytes,4,opt,name=presigned_put_url,json=presignedPutUrl,proto3" json:"presigned_put_url,omitempty"`     // Presigned PUT URL (only if approved)
	UrlExpirySeconds int64                  `protobuf:"varint,5,opt,name=url_expiry_seconds,json=urlExpirySeconds,proto3" json:"url_expiry_seconds,omitempty"` // URL expiry time
	Reason           string                 `protobuf:"bytes,6,opt,name=reason,proto3" json:"reason,omitempty"`                                                // Reason if not approved
	// For DVR: map of relative path -> presigned PUT URL
	SegmentUrls   map[string]string `protobuf:"bytes,7,rep,name=segment_urls,json=segmentUrls,proto3" json:"segment_urls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FreezePermissionResponse) Reset() {
	*x = FreezePermissionResponse{}
	mi := &file_ipc_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezePermissionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezePermissionResponse) ProtoMessage() {}

func (x *FreezePermissionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezePermissionResponse.ProtoReflect.Descriptor instead.
func (*FreezePermissionResponse) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{34}
}

func (x *FreezePermissionResponse) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *FreezePermissionResponse) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *FreezePermissionResponse) GetApproved() bool {
	if x != nil {
		return x.Approved
	}
	return false
}

func (x *FreezePermissionResponse) GetPresignedPutUrl() string {
	if x != nil {
		return x.PresignedPutUrl
	}
	return ""
}

func (x *FreezePermissionResponse) GetUrlExpirySeconds() int64 {
	if x != nil {
		return x.UrlExpirySeconds
	}
	return 0
}

func (x *FreezePermissionResponse) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *FreezePermissionResponse) GetSegmentUrls() map[string]string {
	if x != nil {
		return x.SegmentUrls
	}
	return nil
}

// FreezeRequest tells Helmsman to upload an asset to S3 cold storage.
// Foghorn generates presigned URLs - Helmsman never sees S3 credentials.
type FreezeRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	RequestId         string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`                            // Request ID for tracking
	AssetType         string                 `protobuf:"bytes,2,opt,name=asset_type,json=assetType,proto3" json:"asset_type,omitempty"`                            // "clip" or "dvr"
	AssetHash         string                 `protobuf:"bytes,3,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"`                            // clip_hash or dvr_hash
	TenantId          string                 `protobuf:"bytes,4,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`                               // Tenant owning the asset
	InternalName      string                 `protobuf:"bytes,5,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`                   // Stream internal name
	LocalPath         string                 `protobuf:"bytes,6,opt,name=local_path,json=localPath,proto3" json:"local_path,omitempty"`                            // Current local file/directory path
	PresignedPutUrl   string                 `protobuf:"bytes,7,opt,name=presigned_put_url,json=presignedPutUrl,proto3" json:"presigned_put_url,omitempty"`        // Presigned PUT URL for upload (time-limited, no creds needed)
	DeleteAfterUpload bool                   `protobuf:"varint,8,opt,name=delete_after_upload,json=deleteAfterUpload,proto3" json:"delete_after_upload,omitempty"` // Delete local copy after successful upload
	UrlExpirySeconds  int64                  `protobuf:"varint,9,opt,name=url_expiry_seconds,json=urlExpirySeconds,proto3" json:"url_expiry_seconds,omitempty"`    // When the presigned URL expires
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *FreezeRequest) Reset() {
	*x = FreezeRequest{}
	mi := &file_ipc_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezeRequest) ProtoMessage() {}

func (x *FreezeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezeRequest.ProtoReflect.Descriptor instead.
func (*FreezeRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{35}
}

func (x *FreezeRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *FreezeRequest) GetAssetType() string {
	if x != nil {
		return x.AssetType
	}
	return ""
}

func (x *FreezeRequest) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *FreezeRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *FreezeRequest) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *FreezeRequest) GetLocalPath() string {
	if x != nil {
		return x.LocalPath
	}
	return ""
}

func (x *FreezeRequest) GetPresignedPutUrl() string {
	if x != nil {
		return x.PresignedPutUrl
	}
	return ""
}

func (x *FreezeRequest) GetDeleteAfterUpload() bool {
	if x != nil {
		return x.DeleteAfterUpload
	}
	return false
}

func (x *FreezeRequest) GetUrlExpirySeconds() int64 {
	if x != nil {
		return x.UrlExpirySeconds
	}
	return 0
}

// FreezeProgress reports upload progress for freezing operations
type FreezeProgress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	AssetHash     string                 `protobuf:"bytes,2,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"`
	Percent       uint32                 `protobuf:"varint,3,opt,name=percent,proto3" json:"percent,omitempty"` // 0..100
	BytesUploaded uint64                 `protobuf:"varint,4,opt,name=bytes_uploaded,json=bytesUploaded,proto3" json:"bytes_uploaded,omitempty"`
	Message       string                 `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FreezeProgress) Reset() {
	*x = FreezeProgress{}
	mi := &file_ipc_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezeProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezeProgress) ProtoMessage() {}

func (x *FreezeProgress) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezeProgress.ProtoReflect.Descriptor instead.
func (*FreezeProgress) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{36}
}

func (x *FreezeProgress) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *FreezeProgress) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *FreezeProgress) GetPercent() uint32 {
	if x != nil {
		return x.Percent
	}
	return 0
}

func (x *FreezeProgress) GetBytesUploaded() uint64 {
	if x != nil {
		return x.BytesUploaded
	}
	return 0
}

func (x *FreezeProgress) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// FreezeComplete indicates freeze operation has finished
type FreezeComplete struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	AssetHash     string                 `protobuf:"bytes,2,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"`
	Status        string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`            // "success" or "failed"
	S3Url         string                 `protobuf:"bytes,4,opt,name=s3_url,json=s3Url,proto3" json:"s3_url,omitempty"` // Full S3 URL (s3://bucket/key)
	SizeBytes     uint64                 `protobuf:"varint,5,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Error         string                 `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"` // Error message if failed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FreezeComplete) Reset() {
	*x = FreezeComplete{}
	mi := &file_ipc_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezeComplete) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezeComplete) ProtoMessage() {}

func (x *FreezeComplete) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezeComplete.ProtoReflect.Descriptor instead.
func (*FreezeComplete) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{37}
}

func (x *FreezeComplete) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *FreezeComplete) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *FreezeComplete) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *FreezeComplete) GetS3Url() string {
	if x != nil {
		return x.S3Url
	}
	return ""
}

func (x *FreezeComplete) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *FreezeComplete) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// DefrostRequest tells Helmsman to download an asset from S3 cold storage.
// Foghorn generates presigned URLs - Helmsman never sees S3 credentials.
type DefrostRequest struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	RequestId        string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`                          // Request ID for tracking
	AssetType        string                 `protobuf:"bytes,2,opt,name=asset_type,json=assetType,proto3" json:"asset_type,omitempty"`                          // "clip" or "dvr"
	AssetHash        string                 `protobuf:"bytes,3,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"`                          // clip_hash or dvr_hash
	TenantId         string                 `protobuf:"bytes,4,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`                             // Tenant owning the asset
	InternalName     string                 `protobuf:"bytes,5,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`                 // Stream internal name
	PresignedGetUrl  string                 `protobuf:"bytes,6,opt,name=presigned_get_url,json=presignedGetUrl,proto3" json:"presigned_get_url,omitempty"`      // Presigned GET URL for download (time-limited, no creds needed)
	LocalPath        string                 `protobuf:"bytes,7,opt,name=local_path,json=localPath,proto3" json:"local_path,omitempty"`                          // Target local file/directory path
	TimeoutSeconds   int32                  `protobuf:"varint,8,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`          // Max wait time for blocking defrost (0 = default 30s)
	Streaming        bool                   `protobuf:"varint,9,opt,name=streaming,proto3" json:"streaming,omitempty"`                                          // For DVR: use streaming defrost (HLS live mode)
	UrlExpirySeconds int64                  `protobuf:"varint,10,opt,name=url_expiry_seconds,json=urlExpirySeconds,proto3" json:"url_expiry_seconds,omitempty"` // When the presigned URL expires
	// For DVR streaming defrost: map of segment filename -> presigned URL
	SegmentUrls   map[string]string `protobuf:"bytes,11,rep,name=segment_urls,json=segmentUrls,proto3" json:"segment_urls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DefrostRequest) Reset() {
	*x = DefrostRequest{}
	mi := &file_ipc_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DefrostRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DefrostRequest) ProtoMessage() {}

func (x *DefrostRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DefrostRequest.ProtoReflect.Descriptor instead.
func (*DefrostRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{38}
}

func (x *DefrostRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DefrostRequest) GetAssetType() string {
	if x != nil {
		return x.AssetType
	}
	return ""
}

func (x *DefrostRequest) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *DefrostRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *DefrostRequest) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *DefrostRequest) GetPresignedGetUrl() string {
	if x != nil {
		return x.PresignedGetUrl
	}
	return ""
}

func (x *DefrostRequest) GetLocalPath() string {
	if x != nil {
		return x.LocalPath
	}
	return ""
}

func (x *DefrostRequest) GetTimeoutSeconds() int32 {
	if x != nil {
		return x.TimeoutSeconds
	}
	return 0
}

func (x *DefrostRequest) GetStreaming() bool {
	if x != nil {
		return x.Streaming
	}
	return false
}

func (x *DefrostRequest) GetUrlExpirySeconds() int64 {
	if x != nil {
		return x.UrlExpirySeconds
	}
	return 0
}

func (x *DefrostRequest) GetSegmentUrls() map[string]string {
	if x != nil {
		return x.SegmentUrls
	}
	return nil
}

// DefrostProgress reports download progress for defrosting operations
type DefrostProgress struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	RequestId          string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	AssetHash          string                 `protobuf:"bytes,2,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"`
	Percent            uint32                 `protobuf:"varint,3,opt,name=percent,proto3" json:"percent,omitempty"` // 0..100
	BytesDownloaded    uint64                 `protobuf:"varint,4,opt,name=bytes_downloaded,json=bytesDownloaded,proto3" json:"bytes_downloaded,omitempty"`
	SegmentsDownloaded int32                  `protobuf:"varint,5,opt,name=segments_downloaded,json=segmentsDownloaded,proto3" json:"segments_downloaded,omitempty"` // For DVR streaming defrost
	TotalSegments      int32                  `protobuf:"varint,6,opt,name=total_segments,json=totalSegments,proto3" json:"total_segments,omitempty"`                // For DVR streaming defrost
	Message            string                 `protobuf:"bytes,7,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *DefrostProgress) Reset() {
	*x = DefrostProgress{}
	mi := &file_ipc_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DefrostProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DefrostProgress) ProtoMessage() {}

func (x *DefrostProgress) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DefrostProgress.ProtoReflect.Descriptor instead.
func (*DefrostProgress) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{39}
}

func (x *DefrostProgress) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DefrostProgress) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *DefrostProgress) GetPercent() uint32 {
	if x != nil {
		return x.Percent
	}
	return 0
}

func (x *DefrostProgress) GetBytesDownloaded() uint64 {
	if x != nil {
		return x.BytesDownloaded
	}
	return 0
}

func (x *DefrostProgress) GetSegmentsDownloaded() int32 {
	if x != nil {
		return x.SegmentsDownloaded
	}
	return 0
}

func (x *DefrostProgress) GetTotalSegments() int32 {
	if x != nil {
		return x.TotalSegments
	}
	return 0
}

func (x *DefrostProgress) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// DefrostComplete indicates defrost operation has finished
type DefrostComplete struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	AssetHash     string                 `protobuf:"bytes,2,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"`
	Status        string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`                        // "success", "failed", "ready" (for streaming DVR)
	LocalPath     string                 `protobuf:"bytes,4,opt,name=local_path,json=localPath,proto3" json:"local_path,omitempty"` // Local file/directory path
	SizeBytes     uint64                 `protobuf:"varint,5,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Error         string                 `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`                 // Error message if failed
	NodeId        string                 `protobuf:"bytes,7,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"` // Node that now has a cached copy (for multi-node tracking)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DefrostComplete) Reset() {
	*x = DefrostComplete{}
	mi := &file_ipc_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DefrostComplete) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DefrostComplete) ProtoMessage() {}

func (x *DefrostComplete) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DefrostComplete.ProtoReflect.Descriptor instead.
func (*DefrostComplete) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{40}
}

func (x *DefrostComplete) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DefrostComplete) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *DefrostComplete) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *DefrostComplete) GetLocalPath() string {
	if x != nil {
		return x.LocalPath
	}
	return ""
}

func (x *DefrostComplete) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *DefrostComplete) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *DefrostComplete) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

// CanDeleteRequest is sent by Helmsman to check if a local asset can be safely deleted.
// Under dual-storage model, deletion is only safe if the asset is synced to S3.
type CanDeleteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	AssetHash     string                 `protobuf:"bytes,1,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"` // clip_hash or dvr_hash
	NodeId        string                 `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`          // Node asking to delete
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CanDeleteRequest) Reset() {
	*x = CanDeleteRequest{}
	mi := &file_ipc_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CanDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CanDeleteRequest) ProtoMessage() {}

func (x *CanDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CanDeleteRequest.ProtoReflect.Descriptor instead.
func (*CanDeleteRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{41}
}

func (x *CanDeleteRequest) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *CanDeleteRequest) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

// CanDeleteResponse tells Helmsman whether local deletion is safe
type CanDeleteResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	AssetHash      string                 `protobuf:"bytes,1,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"`
	SafeToDelete   bool                   `protobuf:"varint,2,opt,name=safe_to_delete,json=safeToDelete,proto3" json:"safe_to_delete,omitempty"`       // True if asset is synced to S3
	Reason         string                 `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`                                          // "synced", "sync_pending", "sync_failed", "not_found"
	WarmDurationMs int64                  `protobuf:"varint,4,opt,name=warm_duration_ms,json=warmDurationMs,proto3" json:"warm_duration_ms,omitempty"` // How long asset was cached (for EVICTED lifecycle events)
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *CanDeleteResponse) Reset() {
	*x = CanDeleteResponse{}
	mi := &file_ipc_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CanDeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CanDeleteResponse) ProtoMessage() {}

func (x *CanDeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CanDeleteResponse.ProtoReflect.Descriptor instead.
func (*CanDeleteResponse) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{42}
}

func (x *CanDeleteResponse) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *CanDeleteResponse) GetSafeToDelete() bool {
	if x != nil {
		return x.SafeToDelete
	}
	return false
}

func (x *CanDeleteResponse) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *CanDeleteResponse) GetWarmDurationMs() int64 {
	if x != nil {
		return x.WarmDurationMs
	}
	return 0
}

// SyncComplete indicates a sync (upload to S3 while keeping local) has finished.
// Semantically different from FreezeComplete: sync keeps local copy.
type SyncComplete struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	AssetHash     string                 `protobuf:"bytes,2,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"`
	Status        string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`            // "success" or "failed"
	S3Url         string                 `protobuf:"bytes,4,opt,name=s3_url,json=s3Url,proto3" json:"s3_url,omitempty"` // Full S3 URL (s3://bucket/key)
	SizeBytes     uint64                 `protobuf:"varint,5,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Error         string                 `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`                                    // Error message if failed
	NodeId        string                 `protobuf:"bytes,7,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`                    // Node that initiated the sync
	DtshIncluded  bool                   `protobuf:"varint,8,opt,name=dtsh_included,json=dtshIncluded,proto3" json:"dtsh_included,omitempty"` // True if .dtsh index file was included in sync
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SyncComplete) Reset() {
	*x = SyncComplete{}
	mi := &file_ipc_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SyncComplete) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SyncComplete) ProtoMessage() {}

func (x *SyncComplete) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SyncComplete.ProtoReflect.Descriptor instead.
func (*SyncComplete) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{43}
}

func (x *SyncComplete) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *SyncComplete) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *SyncComplete) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *SyncComplete) GetS3Url() string {
	if x != nil {
		return x.S3Url
	}
	return ""
}

func (x *SyncComplete) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *SyncComplete) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *SyncComplete) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *SyncComplete) GetDtshIncluded() bool {
	if x != nil {
		return x.DtshIncluded
	}
	return false
}

// DtshSyncRequest is sent by Foghorn to Helmsman to request uploading just the .dtsh file.
// This is used when .dtsh appeared after the main asset was already synced to S3.
type DtshSyncRequest struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	RequestId        string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`                         // Request ID for tracking
	AssetType        string                 `protobuf:"bytes,2,opt,name=asset_type,json=assetType,proto3" json:"asset_type,omitempty"`                         // "clip" or "dvr"
	AssetHash        string                 `protobuf:"bytes,3,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"`                         // clip_hash or dvr_hash
	LocalPath        string                 `protobuf:"bytes,4,opt,name=local_path,json=localPath,proto3" json:"local_path,omitempty"`                         // Path to the main asset (append .dtsh for clip, or directory for DVR)
	PresignedPutUrl  string                 `protobuf:"bytes,5,opt,name=presigned_put_url,json=presignedPutUrl,proto3" json:"presigned_put_url,omitempty"`     // Presigned PUT URL for uploading the .dtsh file
	UrlExpirySeconds int64                  `protobuf:"varint,6,opt,name=url_expiry_seconds,json=urlExpirySeconds,proto3" json:"url_expiry_seconds,omitempty"` // When the presigned URL expires
	// For DVR: map of .dtsh filename -> presigned URL (since DVR can have multiple .dtsh files)
	DtshUrls      map[string]string `protobuf:"bytes,7,rep,name=dtsh_urls,json=dtshUrls,proto3" json:"dtsh_urls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DtshSyncRequest) Reset() {
	*x = DtshSyncRequest{}
	mi := &file_ipc_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DtshSyncRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DtshSyncRequest) ProtoMessage() {}

func (x *DtshSyncRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DtshSyncRequest.ProtoReflect.Descriptor instead.
func (*DtshSyncRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{44}
}

func (x *DtshSyncRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DtshSyncRequest) GetAssetType() string {
	if x != nil {
		return x.AssetType
	}
	return ""
}

func (x *DtshSyncRequest) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *DtshSyncRequest) GetLocalPath() string {
	if x != nil {
		return x.LocalPath
	}
	return ""
}

func (x *DtshSyncRequest) GetPresignedPutUrl() string {
	if x != nil {
		return x.PresignedPutUrl
	}
	return ""
}

func (x *DtshSyncRequest) GetUrlExpirySeconds() int64 {
	if x != nil {
		return x.UrlExpirySeconds
	}
	return 0
}

func (x *DtshSyncRequest) GetDtshUrls() map[string]string {
	if x != nil {
		return x.DtshUrls
	}
	return nil
}

// StorageLifecycleData is emitted for analytics/observability of storage sync operations
// Dual-storage model: S3 is authoritative backup, local disk is cache
type StorageLifecycleData struct {
	state          protoimpl.MessageState      `protogen:"open.v1"`
	Action         StorageLifecycleData_Action `protobuf:"varint,1,opt,name=action,proto3,enum=helmsmancontrol.StorageLifecycleData_Action" json:"action,omitempty"`
	AssetType      string                      `protobuf:"bytes,2,opt,name=asset_type,json=assetType,proto3" json:"asset_type,omitempty"` // "clip" or "dvr"
	AssetHash      string                      `protobuf:"bytes,3,opt,name=asset_hash,json=assetHash,proto3" json:"asset_hash,omitempty"` // clip_hash or dvr_hash
	TenantId       *string                     `protobuf:"bytes,4,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"`
	InternalName   *string                     `protobuf:"bytes,5,opt,name=internal_name,json=internalName,proto3,oneof" json:"internal_name,omitempty"`
	StreamId       *string                     `protobuf:"bytes,13,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Enriched by Foghorn (UUID)
	SizeBytes      uint64                      `protobuf:"varint,6,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	S3Url          *string                     `protobuf:"bytes,7,opt,name=s3_url,json=s3Url,proto3,oneof" json:"s3_url,omitempty"`
	LocalPath      *string                     `protobuf:"bytes,8,opt,name=local_path,json=localPath,proto3,oneof" json:"local_path,omitempty"`
	NodeId         *string                     `protobuf:"bytes,9,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	Error          *string                     `protobuf:"bytes,10,opt,name=error,proto3,oneof" json:"error,omitempty"`
	DurationMs     *int64                      `protobuf:"varint,11,opt,name=duration_ms,json=durationMs,proto3,oneof" json:"duration_ms,omitempty"`               // How long the operation took (sync/defrost duration)
	WarmDurationMs *int64                      `protobuf:"varint,12,opt,name=warm_duration_ms,json=warmDurationMs,proto3,oneof" json:"warm_duration_ms,omitempty"` // For EVICTED: how long asset was cached before eviction
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *StorageLifecycleData) Reset() {
	*x = StorageLifecycleData{}
	mi := &file_ipc_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageLifecycleData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageLifecycleData) ProtoMessage() {}

func (x *StorageLifecycleData) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageLifecycleData.ProtoReflect.Descriptor instead.
func (*StorageLifecycleData) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{45}
}

func (x *StorageLifecycleData) GetAction() StorageLifecycleData_Action {
	if x != nil {
		return x.Action
	}
	return StorageLifecycleData_ACTION_UNSPECIFIED
}

func (x *StorageLifecycleData) GetAssetType() string {
	if x != nil {
		return x.AssetType
	}
	return ""
}

func (x *StorageLifecycleData) GetAssetHash() string {
	if x != nil {
		return x.AssetHash
	}
	return ""
}

func (x *StorageLifecycleData) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *StorageLifecycleData) GetInternalName() string {
	if x != nil && x.InternalName != nil {
		return *x.InternalName
	}
	return ""
}

func (x *StorageLifecycleData) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

func (x *StorageLifecycleData) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *StorageLifecycleData) GetS3Url() string {
	if x != nil && x.S3Url != nil {
		return *x.S3Url
	}
	return ""
}

func (x *StorageLifecycleData) GetLocalPath() string {
	if x != nil && x.LocalPath != nil {
		return *x.LocalPath
	}
	return ""
}

func (x *StorageLifecycleData) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *StorageLifecycleData) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

func (x *StorageLifecycleData) GetDurationMs() int64 {
	if x != nil && x.DurationMs != nil {
		return *x.DurationMs
	}
	return 0
}

func (x *StorageLifecycleData) GetWarmDurationMs() int64 {
	if x != nil && x.WarmDurationMs != nil {
		return *x.WarmDurationMs
	}
	return 0
}

type DVRReadyRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"` // Which DVR job we're asking about
	NodeId        string                 `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`    // Which storage node is asking
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRReadyRequest) Reset() {
	*x = DVRReadyRequest{}
	mi := &file_ipc_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRReadyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRReadyRequest) ProtoMessage() {}

func (x *DVRReadyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRReadyRequest.ProtoReflect.Descriptor instead.
func (*DVRReadyRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{46}
}

func (x *DVRReadyRequest) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRReadyRequest) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

type DVRReadyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`       // DVR identifier
	Ready         bool                   `protobuf:"varint,2,opt,name=ready,proto3" json:"ready,omitempty"`                         // Is stream ready for pulling?
	SourceUri     string                 `protobuf:"bytes,3,opt,name=source_uri,json=sourceUri,proto3" json:"source_uri,omitempty"` // Full DTSC URI when ready (e.g., "http://ingest-node:8080/stream_name.dtsc")
	Config        *DVRConfig             `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`                        // Potentially updated config based on stream characteristics
	Reason        string                 `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`                        // If not ready, why? (e.g., "stream_booting", "stream_unhealthy", "stream_offline")
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRReadyResponse) Reset() {
	*x = DVRReadyResponse{}
	mi := &file_ipc_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRReadyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRReadyResponse) ProtoMessage() {}

func (x *DVRReadyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRReadyResponse.ProtoReflect.Descriptor instead.
func (*DVRReadyResponse) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{47}
}

func (x *DVRReadyResponse) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRReadyResponse) GetReady() bool {
	if x != nil {
		return x.Ready
	}
	return false
}

func (x *DVRReadyResponse) GetSourceUri() string {
	if x != nil {
		return x.SourceUri
	}
	return ""
}

func (x *DVRReadyResponse) GetConfig() *DVRConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *DVRReadyResponse) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type PushRewriteTrigger struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	PushUrl    string                 `protobuf:"bytes,1,opt,name=push_url,json=pushUrl,proto3" json:"push_url,omitempty"`
	Hostname   string                 `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	StreamName string                 `protobuf:"bytes,3,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	// Enrichment fields for analytics (populated by Foghorn)
	Protocol       *string  `protobuf:"bytes,4,opt,name=protocol,proto3,oneof" json:"protocol,omitempty"`
	Encoder        *string  `protobuf:"bytes,5,opt,name=encoder,proto3,oneof" json:"encoder,omitempty"`
	StreamSettings *string  `protobuf:"bytes,6,opt,name=stream_settings,json=streamSettings,proto3,oneof" json:"stream_settings,omitempty"`
	NodeId         *string  `protobuf:"bytes,7,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	Latitude       *float64 `protobuf:"fixed64,8,opt,name=latitude,proto3,oneof" json:"latitude,omitempty"`   // Node latitude
	Longitude      *float64 `protobuf:"fixed64,9,opt,name=longitude,proto3,oneof" json:"longitude,omitempty"` // Node longitude
	Location       *string  `protobuf:"bytes,10,opt,name=location,proto3,oneof" json:"location,omitempty"`    // Node location name
	// Publisher GeoIP enrichment (from hostname IP)
	PublisherCountryCode *string    `protobuf:"bytes,11,opt,name=publisher_country_code,json=publisherCountryCode,proto3,oneof" json:"publisher_country_code,omitempty"`
	PublisherCity        *string    `protobuf:"bytes,12,opt,name=publisher_city,json=publisherCity,proto3,oneof" json:"publisher_city,omitempty"`
	PublisherLatitude    *float64   `protobuf:"fixed64,13,opt,name=publisher_latitude,json=publisherLatitude,proto3,oneof" json:"publisher_latitude,omitempty"`
	PublisherLongitude   *float64   `protobuf:"fixed64,14,opt,name=publisher_longitude,json=publisherLongitude,proto3,oneof" json:"publisher_longitude,omitempty"`
	PublisherBucket      *GeoBucket `protobuf:"bytes,15,opt,name=publisher_bucket,json=publisherBucket,proto3,oneof" json:"publisher_bucket,omitempty"`
	NodeBucket           *GeoBucket `protobuf:"bytes,16,opt,name=node_bucket,json=nodeBucket,proto3,oneof" json:"node_bucket,omitempty"`
	StreamId             *string    `protobuf:"bytes,17,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Enriched by Foghorn (UUID)
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *PushRewriteTrigger) Reset() {
	*x = PushRewriteTrigger{}
	mi := &file_ipc_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PushRewriteTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PushRewriteTrigger) ProtoMessage() {}

func (x *PushRewriteTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PushRewriteTrigger.ProtoReflect.Descriptor instead.
func (*PushRewriteTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{48}
}

func (x *PushRewriteTrigger) GetPushUrl() string {
	if x != nil {
		return x.PushUrl
	}
	return ""
}

func (x *PushRewriteTrigger) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *PushRewriteTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *PushRewriteTrigger) GetProtocol() string {
	if x != nil && x.Protocol != nil {
		return *x.Protocol
	}
	return ""
}

func (x *PushRewriteTrigger) GetEncoder() string {
	if x != nil && x.Encoder != nil {
		return *x.Encoder
	}
	return ""
}

func (x *PushRewriteTrigger) GetStreamSettings() string {
	if x != nil && x.StreamSettings != nil {
		return *x.StreamSettings
	}
	return ""
}

func (x *PushRewriteTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *PushRewriteTrigger) GetLatitude() float64 {
	if x != nil && x.Latitude != nil {
		return *x.Latitude
	}
	return 0
}

func (x *PushRewriteTrigger) GetLongitude() float64 {
	if x != nil && x.Longitude != nil {
		return *x.Longitude
	}
	return 0
}

func (x *PushRewriteTrigger) GetLocation() string {
	if x != nil && x.Location != nil {
		return *x.Location
	}
	return ""
}

func (x *PushRewriteTrigger) GetPublisherCountryCode() string {
	if x != nil && x.PublisherCountryCode != nil {
		return *x.PublisherCountryCode
	}
	return ""
}

func (x *PushRewriteTrigger) GetPublisherCity() string {
	if x != nil && x.PublisherCity != nil {
		return *x.PublisherCity
	}
	return ""
}

func (x *PushRewriteTrigger) GetPublisherLatitude() float64 {
	if x != nil && x.PublisherLatitude != nil {
		return *x.PublisherLatitude
	}
	return 0
}

func (x *PushRewriteTrigger) GetPublisherLongitude() float64 {
	if x != nil && x.PublisherLongitude != nil {
		return *x.PublisherLongitude
	}
	return 0
}

func (x *PushRewriteTrigger) GetPublisherBucket() *GeoBucket {
	if x != nil {
		return x.PublisherBucket
	}
	return nil
}

func (x *PushRewriteTrigger) GetNodeBucket() *GeoBucket {
	if x != nil {
		return x.NodeBucket
	}
	return nil
}

func (x *PushRewriteTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

// ViewerResolveTrigger represents a viewer-side resolve of a playback request.
// This is NOT publisher ingest. It fires when a viewer requests a stream by
// playback ID or artifact hash; enrichment may include geo and node context.
type ViewerResolveTrigger struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	RequestedStream string                 `protobuf:"bytes,2,opt,name=requested_stream,json=requestedStream,proto3" json:"requested_stream,omitempty"` // playback ID or artifact hash (original request)
	ViewerHost      string                 `protobuf:"bytes,3,opt,name=viewer_host,json=viewerHost,proto3" json:"viewer_host,omitempty"`                // viewer IP/host
	OutputType      string                 `protobuf:"bytes,4,opt,name=output_type,json=outputType,proto3" json:"output_type,omitempty"`                // HLS/DASH/WebRTC
	RequestUrl      string                 `protobuf:"bytes,5,opt,name=request_url,json=requestUrl,proto3" json:"request_url,omitempty"`
	// Enrichment (by Foghorn). Do not replace the payload type; enrich in-place.
	NodeId       *string    `protobuf:"bytes,6,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	CountryCode  *string    `protobuf:"bytes,7,opt,name=country_code,json=countryCode,proto3,oneof" json:"country_code,omitempty"`
	City         *string    `protobuf:"bytes,8,opt,name=city,proto3,oneof" json:"city,omitempty"`
	Latitude     *float64   `protobuf:"fixed64,9,opt,name=latitude,proto3,oneof" json:"latitude,omitempty"`
	Longitude    *float64   `protobuf:"fixed64,10,opt,name=longitude,proto3,oneof" json:"longitude,omitempty"`
	ClientBucket *GeoBucket `protobuf:"bytes,11,opt,name=client_bucket,json=clientBucket,proto3,oneof" json:"client_bucket,omitempty"`
	NodeBucket   *GeoBucket `protobuf:"bytes,12,opt,name=node_bucket,json=nodeBucket,proto3,oneof" json:"node_bucket,omitempty"`
	// Resolved internal name (UUID format, no live+ prefix) for analytics correlation.
	// This is the canonical stream identifier that matches across all analytics tables.
	ResolvedInternalName *string `protobuf:"bytes,13,opt,name=resolved_internal_name,json=resolvedInternalName,proto3,oneof" json:"resolved_internal_name,omitempty"`
	// Node location name (e.g., "us-east-1", "Frankfurt") - enriched by Foghorn
	NodeLocation *string `protobuf:"bytes,14,opt,name=node_location,json=nodeLocation,proto3,oneof" json:"node_location,omitempty"`
	// Public stream ID (UUID) for external correlation
	StreamId      *string `protobuf:"bytes,15,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ViewerResolveTrigger) Reset() {
	*x = ViewerResolveTrigger{}
	mi := &file_ipc_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ViewerResolveTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ViewerResolveTrigger) ProtoMessage() {}

func (x *ViewerResolveTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ViewerResolveTrigger.ProtoReflect.Descriptor instead.
func (*ViewerResolveTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{49}
}

func (x *ViewerResolveTrigger) GetRequestedStream() string {
	if x != nil {
		return x.RequestedStream
	}
	return ""
}

func (x *ViewerResolveTrigger) GetViewerHost() string {
	if x != nil {
		return x.ViewerHost
	}
	return ""
}

func (x *ViewerResolveTrigger) GetOutputType() string {
	if x != nil {
		return x.OutputType
	}
	return ""
}

func (x *ViewerResolveTrigger) GetRequestUrl() string {
	if x != nil {
		return x.RequestUrl
	}
	return ""
}

func (x *ViewerResolveTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *ViewerResolveTrigger) GetCountryCode() string {
	if x != nil && x.CountryCode != nil {
		return *x.CountryCode
	}
	return ""
}

func (x *ViewerResolveTrigger) GetCity() string {
	if x != nil && x.City != nil {
		return *x.City
	}
	return ""
}

func (x *ViewerResolveTrigger) GetLatitude() float64 {
	if x != nil && x.Latitude != nil {
		return *x.Latitude
	}
	return 0
}

func (x *ViewerResolveTrigger) GetLongitude() float64 {
	if x != nil && x.Longitude != nil {
		return *x.Longitude
	}
	return 0
}

func (x *ViewerResolveTrigger) GetClientBucket() *GeoBucket {
	if x != nil {
		return x.ClientBucket
	}
	return nil
}

func (x *ViewerResolveTrigger) GetNodeBucket() *GeoBucket {
	if x != nil {
		return x.NodeBucket
	}
	return nil
}

func (x *ViewerResolveTrigger) GetResolvedInternalName() string {
	if x != nil && x.ResolvedInternalName != nil {
		return *x.ResolvedInternalName
	}
	return ""
}

func (x *ViewerResolveTrigger) GetNodeLocation() string {
	if x != nil && x.NodeLocation != nil {
		return *x.NodeLocation
	}
	return ""
}

func (x *ViewerResolveTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

type StreamSourceTrigger struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StreamName    string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	StreamId      *string                `protobuf:"bytes,2,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Public stream ID (UUID) if known
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamSourceTrigger) Reset() {
	*x = StreamSourceTrigger{}
	mi := &file_ipc_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamSourceTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamSourceTrigger) ProtoMessage() {}

func (x *StreamSourceTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamSourceTrigger.ProtoReflect.Descriptor instead.
func (*StreamSourceTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{50}
}

func (x *StreamSourceTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *StreamSourceTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

type PushOutStartTrigger struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StreamName    string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	PushTarget    string                 `protobuf:"bytes,2,opt,name=push_target,json=pushTarget,proto3" json:"push_target,omitempty"`
	NodeId        *string                `protobuf:"bytes,3,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	StreamId      *string                `protobuf:"bytes,4,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Enriched by Foghorn (UUID)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PushOutStartTrigger) Reset() {
	*x = PushOutStartTrigger{}
	mi := &file_ipc_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PushOutStartTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PushOutStartTrigger) ProtoMessage() {}

func (x *PushOutStartTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PushOutStartTrigger.ProtoReflect.Descriptor instead.
func (*PushOutStartTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{51}
}

func (x *PushOutStartTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *PushOutStartTrigger) GetPushTarget() string {
	if x != nil {
		return x.PushTarget
	}
	return ""
}

func (x *PushOutStartTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *PushOutStartTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

type PushEndTrigger struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	PushId          int64                  `protobuf:"varint,1,opt,name=push_id,json=pushId,proto3" json:"push_id,omitempty"`
	StreamName      string                 `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	TargetUriBefore string                 `protobuf:"bytes,3,opt,name=target_uri_before,json=targetUriBefore,proto3" json:"target_uri_before,omitempty"`
	TargetUriAfter  string                 `protobuf:"bytes,4,opt,name=target_uri_after,json=targetUriAfter,proto3" json:"target_uri_after,omitempty"`
	LogMessages     string                 `protobuf:"bytes,5,opt,name=log_messages,json=logMessages,proto3" json:"log_messages,omitempty"`
	PushStatus      string                 `protobuf:"bytes,6,opt,name=push_status,json=pushStatus,proto3" json:"push_status,omitempty"`
	NodeId          *string                `protobuf:"bytes,7,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	StreamId        *string                `protobuf:"bytes,8,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Enriched by Foghorn (UUID)
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PushEndTrigger) Reset() {
	*x = PushEndTrigger{}
	mi := &file_ipc_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PushEndTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PushEndTrigger) ProtoMessage() {}

func (x *PushEndTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PushEndTrigger.ProtoReflect.Descriptor instead.
func (*PushEndTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{52}
}

func (x *PushEndTrigger) GetPushId() int64 {
	if x != nil {
		return x.PushId
	}
	return 0
}

func (x *PushEndTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *PushEndTrigger) GetTargetUriBefore() string {
	if x != nil {
		return x.TargetUriBefore
	}
	return ""
}

func (x *PushEndTrigger) GetTargetUriAfter() string {
	if x != nil {
		return x.TargetUriAfter
	}
	return ""
}

func (x *PushEndTrigger) GetLogMessages() string {
	if x != nil {
		return x.LogMessages
	}
	return ""
}

func (x *PushEndTrigger) GetPushStatus() string {
	if x != nil {
		return x.PushStatus
	}
	return ""
}

func (x *PushEndTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *PushEndTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

// ViewerConnectTrigger (formerly USER_NEW) indicates a viewer connection.
type ViewerConnectTrigger struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	StreamName string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	// host contains the client's connection IP address from MistServer.
	// Used for GeoIP enrichment; geographic data is preserved while
	// raw IP is redacted downstream for privacy.
	Host         string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	ConnectionId string `protobuf:"bytes,3,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	Connector    string `protobuf:"bytes,4,opt,name=connector,proto3" json:"connector,omitempty"`
	RequestUrl   string `protobuf:"bytes,5,opt,name=request_url,json=requestUrl,proto3" json:"request_url,omitempty"`
	SessionId    string `protobuf:"bytes,6,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Enrichment fields (populated by Foghorn)
	NodeId          *string    `protobuf:"bytes,7,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	ClientCountry   *string    `protobuf:"bytes,9,opt,name=client_country,json=clientCountry,proto3,oneof" json:"client_country,omitempty"`
	ClientCity      *string    `protobuf:"bytes,10,opt,name=client_city,json=clientCity,proto3,oneof" json:"client_city,omitempty"`
	ClientLatitude  *float64   `protobuf:"fixed64,11,opt,name=client_latitude,json=clientLatitude,proto3,oneof" json:"client_latitude,omitempty"`
	ClientLongitude *float64   `protobuf:"fixed64,12,opt,name=client_longitude,json=clientLongitude,proto3,oneof" json:"client_longitude,omitempty"`
	ClientBucket    *GeoBucket `protobuf:"bytes,13,opt,name=client_bucket,json=clientBucket,proto3,oneof" json:"client_bucket,omitempty"`
	NodeBucket      *GeoBucket `protobuf:"bytes,14,opt,name=node_bucket,json=nodeBucket,proto3,oneof" json:"node_bucket,omitempty"`
	StreamId        *string    `protobuf:"bytes,15,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Enriched by Foghorn (UUID)
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ViewerConnectTrigger) Reset() {
	*x = ViewerConnectTrigger{}
	mi := &file_ipc_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ViewerConnectTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ViewerConnectTrigger) ProtoMessage() {}

func (x *ViewerConnectTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ViewerConnectTrigger.ProtoReflect.Descriptor instead.
func (*ViewerConnectTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{53}
}

func (x *ViewerConnectTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *ViewerConnectTrigger) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *ViewerConnectTrigger) GetConnectionId() string {
	if x != nil {
		return x.ConnectionId
	}
	return ""
}

func (x *ViewerConnectTrigger) GetConnector() string {
	if x != nil {
		return x.Connector
	}
	return ""
}

func (x *ViewerConnectTrigger) GetRequestUrl() string {
	if x != nil {
		return x.RequestUrl
	}
	return ""
}

func (x *ViewerConnectTrigger) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *ViewerConnectTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *ViewerConnectTrigger) GetClientCountry() string {
	if x != nil && x.ClientCountry != nil {
		return *x.ClientCountry
	}
	return ""
}

func (x *ViewerConnectTrigger) GetClientCity() string {
	if x != nil && x.ClientCity != nil {
		return *x.ClientCity
	}
	return ""
}

func (x *ViewerConnectTrigger) GetClientLatitude() float64 {
	if x != nil && x.ClientLatitude != nil {
		return *x.ClientLatitude
	}
	return 0
}

func (x *ViewerConnectTrigger) GetClientLongitude() float64 {
	if x != nil && x.ClientLongitude != nil {
		return *x.ClientLongitude
	}
	return 0
}

func (x *ViewerConnectTrigger) GetClientBucket() *GeoBucket {
	if x != nil {
		return x.ClientBucket
	}
	return nil
}

func (x *ViewerConnectTrigger) GetNodeBucket() *GeoBucket {
	if x != nil {
		return x.NodeBucket
	}
	return nil
}

func (x *ViewerConnectTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

// ViewerDisconnectTrigger (formerly USER_END) indicates a viewer disconnect.
type ViewerDisconnectTrigger struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	SessionId  string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	StreamName string                 `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	Connector  string                 `protobuf:"bytes,3,opt,name=connector,proto3" json:"connector,omitempty"`
	Host       string                 `protobuf:"bytes,4,opt,name=host,proto3" json:"host,omitempty"`
	Duration   int64                  `protobuf:"varint,5,opt,name=duration,proto3" json:"duration,omitempty"`
	UpBytes    int64                  `protobuf:"varint,6,opt,name=up_bytes,json=upBytes,proto3" json:"up_bytes,omitempty"`
	DownBytes  int64                  `protobuf:"varint,7,opt,name=down_bytes,json=downBytes,proto3" json:"down_bytes,omitempty"`
	Tags       string                 `protobuf:"bytes,8,opt,name=tags,proto3" json:"tags,omitempty"`
	// Enrichment fields for analytics (populated by Foghorn)
	NodeId            *string    `protobuf:"bytes,9,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	CountryCode       *string    `protobuf:"bytes,10,opt,name=country_code,json=countryCode,proto3,oneof" json:"country_code,omitempty"`
	City              *string    `protobuf:"bytes,11,opt,name=city,proto3,oneof" json:"city,omitempty"`
	Latitude          *float64   `protobuf:"fixed64,12,opt,name=latitude,proto3,oneof" json:"latitude,omitempty"`
	Longitude         *float64   `protobuf:"fixed64,13,opt,name=longitude,proto3,oneof" json:"longitude,omitempty"`
	SessionIdentifier *string    `protobuf:"bytes,14,opt,name=session_identifier,json=sessionIdentifier,proto3,oneof" json:"session_identifier,omitempty"`
	SecondsConnected  *uint64    `protobuf:"varint,15,opt,name=seconds_connected,json=secondsConnected,proto3,oneof" json:"seconds_connected,omitempty"`
	ClientBucket      *GeoBucket `protobuf:"bytes,16,opt,name=client_bucket,json=clientBucket,proto3,oneof" json:"client_bucket,omitempty"`
	NodeBucket        *GeoBucket `protobuf:"bytes,17,opt,name=node_bucket,json=nodeBucket,proto3,oneof" json:"node_bucket,omitempty"`
	StreamId          *string    `protobuf:"bytes,18,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Enriched by Foghorn (UUID)
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ViewerDisconnectTrigger) Reset() {
	*x = ViewerDisconnectTrigger{}
	mi := &file_ipc_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ViewerDisconnectTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ViewerDisconnectTrigger) ProtoMessage() {}

func (x *ViewerDisconnectTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ViewerDisconnectTrigger.ProtoReflect.Descriptor instead.
func (*ViewerDisconnectTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{54}
}

func (x *ViewerDisconnectTrigger) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetConnector() string {
	if x != nil {
		return x.Connector
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetDuration() int64 {
	if x != nil {
		return x.Duration
	}
	return 0
}

func (x *ViewerDisconnectTrigger) GetUpBytes() int64 {
	if x != nil {
		return x.UpBytes
	}
	return 0
}

func (x *ViewerDisconnectTrigger) GetDownBytes() int64 {
	if x != nil {
		return x.DownBytes
	}
	return 0
}

func (x *ViewerDisconnectTrigger) GetTags() string {
	if x != nil {
		return x.Tags
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetCountryCode() string {
	if x != nil && x.CountryCode != nil {
		return *x.CountryCode
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetCity() string {
	if x != nil && x.City != nil {
		return *x.City
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetLatitude() float64 {
	if x != nil && x.Latitude != nil {
		return *x.Latitude
	}
	return 0
}

func (x *ViewerDisconnectTrigger) GetLongitude() float64 {
	if x != nil && x.Longitude != nil {
		return *x.Longitude
	}
	return 0
}

func (x *ViewerDisconnectTrigger) GetSessionIdentifier() string {
	if x != nil && x.SessionIdentifier != nil {
		return *x.SessionIdentifier
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetSecondsConnected() uint64 {
	if x != nil && x.SecondsConnected != nil {
		return *x.SecondsConnected
	}
	return 0
}

func (x *ViewerDisconnectTrigger) GetClientBucket() *GeoBucket {
	if x != nil {
		return x.ClientBucket
	}
	return nil
}

func (x *ViewerDisconnectTrigger) GetNodeBucket() *GeoBucket {
	if x != nil {
		return x.NodeBucket
	}
	return nil
}

func (x *ViewerDisconnectTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

type StreamBufferTrigger struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	StreamName  string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	BufferState string                 `protobuf:"bytes,2,opt,name=buffer_state,json=bufferState,proto3" json:"buffer_state,omitempty"`
	// Fully typed stream details (no more JSON strings)
	Tracks []*StreamTrack `protobuf:"bytes,3,rep,name=tracks,proto3" json:"tracks,omitempty"`
	// REMOVED: health_score = 4 (derived metric, use raw signals instead)
	HasIssues         *bool   `protobuf:"varint,5,opt,name=has_issues,json=hasIssues,proto3,oneof" json:"has_issues,omitempty"`
	IssuesDescription *string `protobuf:"bytes,6,opt,name=issues_description,json=issuesDescription,proto3,oneof" json:"issues_description,omitempty"`
	TrackCount        *int32  `protobuf:"varint,7,opt,name=track_count,json=trackCount,proto3,oneof" json:"track_count,omitempty"`
	QualityTier       *string `protobuf:"bytes,8,opt,name=quality_tier,json=qualityTier,proto3,oneof" json:"quality_tier,omitempty"`
	// Top-level health wrapper fields from MistServer (stream-wide summary)
	StreamBufferMs *int32  `protobuf:"varint,9,opt,name=stream_buffer_ms,json=streamBufferMs,proto3,oneof" json:"stream_buffer_ms,omitempty"`  // health.buffer (overall buffer in ms)
	StreamJitterMs *int32  `protobuf:"varint,10,opt,name=stream_jitter_ms,json=streamJitterMs,proto3,oneof" json:"stream_jitter_ms,omitempty"` // health.jitter (max jitter across tracks)
	MistIssues     *string `protobuf:"bytes,11,opt,name=mist_issues,json=mistIssues,proto3,oneof" json:"mist_issues,omitempty"`                // health.issues (Mist's issue string, e.g. "HLSnoaudio!")
	MaxKeepawayMs  *int32  `protobuf:"varint,12,opt,name=max_keepaway_ms,json=maxKeepawayMs,proto3,oneof" json:"max_keepaway_ms,omitempty"`    // health.maxkeepaway (max viewer distance from live)
	StreamId       *string `protobuf:"bytes,13,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"`                      // Enriched by Foghorn (UUID)
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *StreamBufferTrigger) Reset() {
	*x = StreamBufferTrigger{}
	mi := &file_ipc_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamBufferTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamBufferTrigger) ProtoMessage() {}

func (x *StreamBufferTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamBufferTrigger.ProtoReflect.Descriptor instead.
func (*StreamBufferTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{55}
}

func (x *StreamBufferTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *StreamBufferTrigger) GetBufferState() string {
	if x != nil {
		return x.BufferState
	}
	return ""
}

func (x *StreamBufferTrigger) GetTracks() []*StreamTrack {
	if x != nil {
		return x.Tracks
	}
	return nil
}

func (x *StreamBufferTrigger) GetHasIssues() bool {
	if x != nil && x.HasIssues != nil {
		return *x.HasIssues
	}
	return false
}

func (x *StreamBufferTrigger) GetIssuesDescription() string {
	if x != nil && x.IssuesDescription != nil {
		return *x.IssuesDescription
	}
	return ""
}

func (x *StreamBufferTrigger) GetTrackCount() int32 {
	if x != nil && x.TrackCount != nil {
		return *x.TrackCount
	}
	return 0
}

func (x *StreamBufferTrigger) GetQualityTier() string {
	if x != nil && x.QualityTier != nil {
		return *x.QualityTier
	}
	return ""
}

func (x *StreamBufferTrigger) GetStreamBufferMs() int32 {
	if x != nil && x.StreamBufferMs != nil {
		return *x.StreamBufferMs
	}
	return 0
}

func (x *StreamBufferTrigger) GetStreamJitterMs() int32 {
	if x != nil && x.StreamJitterMs != nil {
		return *x.StreamJitterMs
	}
	return 0
}

func (x *StreamBufferTrigger) GetMistIssues() string {
	if x != nil && x.MistIssues != nil {
		return *x.MistIssues
	}
	return ""
}

func (x *StreamBufferTrigger) GetMaxKeepawayMs() int32 {
	if x != nil && x.MaxKeepawayMs != nil {
		return *x.MaxKeepawayMs
	}
	return 0
}

func (x *StreamBufferTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

type StreamEndTrigger struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	StreamName      string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	DownloadedBytes *int64                 `protobuf:"varint,2,opt,name=downloaded_bytes,json=downloadedBytes,proto3,oneof" json:"downloaded_bytes,omitempty"`
	UploadedBytes   *int64                 `protobuf:"varint,3,opt,name=uploaded_bytes,json=uploadedBytes,proto3,oneof" json:"uploaded_bytes,omitempty"`
	TotalViewers    *int64                 `protobuf:"varint,4,opt,name=total_viewers,json=totalViewers,proto3,oneof" json:"total_viewers,omitempty"`
	TotalInputs     *int64                 `protobuf:"varint,5,opt,name=total_inputs,json=totalInputs,proto3,oneof" json:"total_inputs,omitempty"`
	TotalOutputs    *int64                 `protobuf:"varint,6,opt,name=total_outputs,json=totalOutputs,proto3,oneof" json:"total_outputs,omitempty"`
	ViewerSeconds   *int64                 `protobuf:"varint,7,opt,name=viewer_seconds,json=viewerSeconds,proto3,oneof" json:"viewer_seconds,omitempty"`
	NodeId          *string                `protobuf:"bytes,8,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	StreamId        *string                `protobuf:"bytes,9,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Enriched by Foghorn (UUID)
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StreamEndTrigger) Reset() {
	*x = StreamEndTrigger{}
	mi := &file_ipc_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamEndTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamEndTrigger) ProtoMessage() {}

func (x *StreamEndTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamEndTrigger.ProtoReflect.Descriptor instead.
func (*StreamEndTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{56}
}

func (x *StreamEndTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *StreamEndTrigger) GetDownloadedBytes() int64 {
	if x != nil && x.DownloadedBytes != nil {
		return *x.DownloadedBytes
	}
	return 0
}

func (x *StreamEndTrigger) GetUploadedBytes() int64 {
	if x != nil && x.UploadedBytes != nil {
		return *x.UploadedBytes
	}
	return 0
}

func (x *StreamEndTrigger) GetTotalViewers() int64 {
	if x != nil && x.TotalViewers != nil {
		return *x.TotalViewers
	}
	return 0
}

func (x *StreamEndTrigger) GetTotalInputs() int64 {
	if x != nil && x.TotalInputs != nil {
		return *x.TotalInputs
	}
	return 0
}

func (x *StreamEndTrigger) GetTotalOutputs() int64 {
	if x != nil && x.TotalOutputs != nil {
		return *x.TotalOutputs
	}
	return 0
}

func (x *StreamEndTrigger) GetViewerSeconds() int64 {
	if x != nil && x.ViewerSeconds != nil {
		return *x.ViewerSeconds
	}
	return 0
}

func (x *StreamEndTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *StreamEndTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

// StreamTrackListTrigger (formerly LIVE_TRACK_LIST) provides track inventory.
type StreamTrackListTrigger struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	StreamName string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	// Fully typed track list (no more JSON strings)
	Tracks          []*StreamTrack `protobuf:"bytes,2,rep,name=tracks,proto3" json:"tracks,omitempty"`
	TotalTracks     *int32         `protobuf:"varint,3,opt,name=total_tracks,json=totalTracks,proto3,oneof" json:"total_tracks,omitempty"`
	VideoTrackCount *int32         `protobuf:"varint,4,opt,name=video_track_count,json=videoTrackCount,proto3,oneof" json:"video_track_count,omitempty"`
	AudioTrackCount *int32         `protobuf:"varint,5,opt,name=audio_track_count,json=audioTrackCount,proto3,oneof" json:"audio_track_count,omitempty"`
	QualityTier     *string        `protobuf:"bytes,6,opt,name=quality_tier,json=qualityTier,proto3,oneof" json:"quality_tier,omitempty"`
	// Primary video track info
	PrimaryWidth        *int32   `protobuf:"varint,7,opt,name=primary_width,json=primaryWidth,proto3,oneof" json:"primary_width,omitempty"`
	PrimaryHeight       *int32   `protobuf:"varint,8,opt,name=primary_height,json=primaryHeight,proto3,oneof" json:"primary_height,omitempty"`
	PrimaryFps          *float64 `protobuf:"fixed64,9,opt,name=primary_fps,json=primaryFps,proto3,oneof" json:"primary_fps,omitempty"`
	PrimaryVideoBitrate *int32   `protobuf:"varint,10,opt,name=primary_video_bitrate,json=primaryVideoBitrate,proto3,oneof" json:"primary_video_bitrate,omitempty"`
	PrimaryVideoCodec   *string  `protobuf:"bytes,11,opt,name=primary_video_codec,json=primaryVideoCodec,proto3,oneof" json:"primary_video_codec,omitempty"`
	// Primary audio track info
	PrimaryAudioBitrate    *int32  `protobuf:"varint,12,opt,name=primary_audio_bitrate,json=primaryAudioBitrate,proto3,oneof" json:"primary_audio_bitrate,omitempty"`
	PrimaryAudioCodec      *string `protobuf:"bytes,13,opt,name=primary_audio_codec,json=primaryAudioCodec,proto3,oneof" json:"primary_audio_codec,omitempty"`
	PrimaryAudioChannels   *int32  `protobuf:"varint,14,opt,name=primary_audio_channels,json=primaryAudioChannels,proto3,oneof" json:"primary_audio_channels,omitempty"`
	PrimaryAudioSampleRate *int32  `protobuf:"varint,15,opt,name=primary_audio_sample_rate,json=primaryAudioSampleRate,proto3,oneof" json:"primary_audio_sample_rate,omitempty"`
	StreamId               *string `protobuf:"bytes,16,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Enriched by Foghorn (UUID)
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *StreamTrackListTrigger) Reset() {
	*x = StreamTrackListTrigger{}
	mi := &file_ipc_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamTrackListTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamTrackListTrigger) ProtoMessage() {}

func (x *StreamTrackListTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamTrackListTrigger.ProtoReflect.Descriptor instead.
func (*StreamTrackListTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{57}
}

func (x *StreamTrackListTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *StreamTrackListTrigger) GetTracks() []*StreamTrack {
	if x != nil {
		return x.Tracks
	}
	return nil
}

func (x *StreamTrackListTrigger) GetTotalTracks() int32 {
	if x != nil && x.TotalTracks != nil {
		return *x.TotalTracks
	}
	return 0
}

func (x *StreamTrackListTrigger) GetVideoTrackCount() int32 {
	if x != nil && x.VideoTrackCount != nil {
		return *x.VideoTrackCount
	}
	return 0
}

func (x *StreamTrackListTrigger) GetAudioTrackCount() int32 {
	if x != nil && x.AudioTrackCount != nil {
		return *x.AudioTrackCount
	}
	return 0
}

func (x *StreamTrackListTrigger) GetQualityTier() string {
	if x != nil && x.QualityTier != nil {
		return *x.QualityTier
	}
	return ""
}

func (x *StreamTrackListTrigger) GetPrimaryWidth() int32 {
	if x != nil && x.PrimaryWidth != nil {
		return *x.PrimaryWidth
	}
	return 0
}

func (x *StreamTrackListTrigger) GetPrimaryHeight() int32 {
	if x != nil && x.PrimaryHeight != nil {
		return *x.PrimaryHeight
	}
	return 0
}

func (x *StreamTrackListTrigger) GetPrimaryFps() float64 {
	if x != nil && x.PrimaryFps != nil {
		return *x.PrimaryFps
	}
	return 0
}

func (x *StreamTrackListTrigger) GetPrimaryVideoBitrate() int32 {
	if x != nil && x.PrimaryVideoBitrate != nil {
		return *x.PrimaryVideoBitrate
	}
	return 0
}

func (x *StreamTrackListTrigger) GetPrimaryVideoCodec() string {
	if x != nil && x.PrimaryVideoCodec != nil {
		return *x.PrimaryVideoCodec
	}
	return ""
}

func (x *StreamTrackListTrigger) GetPrimaryAudioBitrate() int32 {
	if x != nil && x.PrimaryAudioBitrate != nil {
		return *x.PrimaryAudioBitrate
	}
	return 0
}

func (x *StreamTrackListTrigger) GetPrimaryAudioCodec() string {
	if x != nil && x.PrimaryAudioCodec != nil {
		return *x.PrimaryAudioCodec
	}
	return ""
}

func (x *StreamTrackListTrigger) GetPrimaryAudioChannels() int32 {
	if x != nil && x.PrimaryAudioChannels != nil {
		return *x.PrimaryAudioChannels
	}
	return 0
}

func (x *StreamTrackListTrigger) GetPrimaryAudioSampleRate() int32 {
	if x != nil && x.PrimaryAudioSampleRate != nil {
		return *x.PrimaryAudioSampleRate
	}
	return 0
}

func (x *StreamTrackListTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

// RecordingCompleteTrigger (formerly RECORDING_END) indicates recorder completion.
type RecordingCompleteTrigger struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	StreamName      string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	FilePath        string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	OutputProtocol  string                 `protobuf:"bytes,3,opt,name=output_protocol,json=outputProtocol,proto3" json:"output_protocol,omitempty"`
	BytesWritten    int64                  `protobuf:"varint,4,opt,name=bytes_written,json=bytesWritten,proto3" json:"bytes_written,omitempty"`
	SecondsWriting  int64                  `protobuf:"varint,5,opt,name=seconds_writing,json=secondsWriting,proto3" json:"seconds_writing,omitempty"`
	TimeStarted     int64                  `protobuf:"varint,6,opt,name=time_started,json=timeStarted,proto3" json:"time_started,omitempty"`
	TimeEnded       int64                  `protobuf:"varint,7,opt,name=time_ended,json=timeEnded,proto3" json:"time_ended,omitempty"`
	MediaDurationMs int64                  `protobuf:"varint,8,opt,name=media_duration_ms,json=mediaDurationMs,proto3" json:"media_duration_ms,omitempty"`
	// Enrichment fields for analytics (populated by Foghorn)
	NodeId        *string `protobuf:"bytes,9,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	StreamId      *string `protobuf:"bytes,10,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Enriched by Foghorn (UUID)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RecordingCompleteTrigger) Reset() {
	*x = RecordingCompleteTrigger{}
	mi := &file_ipc_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecordingCompleteTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecordingCompleteTrigger) ProtoMessage() {}

func (x *RecordingCompleteTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecordingCompleteTrigger.ProtoReflect.Descriptor instead.
func (*RecordingCompleteTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{58}
}

func (x *RecordingCompleteTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *RecordingCompleteTrigger) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *RecordingCompleteTrigger) GetOutputProtocol() string {
	if x != nil {
		return x.OutputProtocol
	}
	return ""
}

func (x *RecordingCompleteTrigger) GetBytesWritten() int64 {
	if x != nil {
		return x.BytesWritten
	}
	return 0
}

func (x *RecordingCompleteTrigger) GetSecondsWriting() int64 {
	if x != nil {
		return x.SecondsWriting
	}
	return 0
}

func (x *RecordingCompleteTrigger) GetTimeStarted() int64 {
	if x != nil {
		return x.TimeStarted
	}
	return 0
}

func (x *RecordingCompleteTrigger) GetTimeEnded() int64 {
	if x != nil {
		return x.TimeEnded
	}
	return 0
}

func (x *RecordingCompleteTrigger) GetMediaDurationMs() int64 {
	if x != nil {
		return x.MediaDurationMs
	}
	return 0
}

func (x *RecordingCompleteTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *RecordingCompleteTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

// RecordingSegmentTrigger (RECORDING_SEGMENT) indicates a new segment has been written.
type RecordingSegmentTrigger struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StreamName    string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	DurationMs    int64                  `protobuf:"varint,3,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	TimeStarted   int64                  `protobuf:"varint,4,opt,name=time_started,json=timeStarted,proto3" json:"time_started,omitempty"`
	TimeEnded     int64                  `protobuf:"varint,5,opt,name=time_ended,json=timeEnded,proto3" json:"time_ended,omitempty"`
	StreamId      *string                `protobuf:"bytes,6,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Enriched by Foghorn (UUID)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RecordingSegmentTrigger) Reset() {
	*x = RecordingSegmentTrigger{}
	mi := &file_ipc_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecordingSegmentTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecordingSegmentTrigger) ProtoMessage() {}

func (x *RecordingSegmentTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecordingSegmentTrigger.ProtoReflect.Descriptor instead.
func (*RecordingSegmentTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{59}
}

func (x *RecordingSegmentTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *RecordingSegmentTrigger) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *RecordingSegmentTrigger) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *RecordingSegmentTrigger) GetTimeStarted() int64 {
	if x != nil {
		return x.TimeStarted
	}
	return 0
}

func (x *RecordingSegmentTrigger) GetTimeEnded() int64 {
	if x != nil {
		return x.TimeEnded
	}
	return 0
}

func (x *RecordingSegmentTrigger) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

// Analytics event messages for forwarding to Decklog
type StreamLifecycleUpdate struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	NodeId          string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	TenantId        *string                `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"` // Optional - enriched by Foghorn via Commodore lookup
	InternalName    string                 `protobuf:"bytes,3,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`
	Status          string                 `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`                                    // "live", "offline"
	BufferState     *string                `protobuf:"bytes,5,opt,name=buffer_state,json=bufferState,proto3,oneof" json:"buffer_state,omitempty"` // "FULL", "EMPTY", "DRY", "RECOVER"
	UploadedBytes   *uint64                `protobuf:"varint,6,opt,name=uploaded_bytes,json=uploadedBytes,proto3,oneof" json:"uploaded_bytes,omitempty"`
	DownloadedBytes *uint64                `protobuf:"varint,7,opt,name=downloaded_bytes,json=downloadedBytes,proto3,oneof" json:"downloaded_bytes,omitempty"`
	TotalViewers    *uint32                `protobuf:"varint,8,opt,name=total_viewers,json=totalViewers,proto3,oneof" json:"total_viewers,omitempty"`
	TotalInputs     *uint32                `protobuf:"varint,9,opt,name=total_inputs,json=totalInputs,proto3,oneof" json:"total_inputs,omitempty"`
	ViewerSeconds   *uint64                `protobuf:"varint,10,opt,name=viewer_seconds,json=viewerSeconds,proto3,oneof" json:"viewer_seconds,omitempty"`
	StreamDetails   *string                `protobuf:"bytes,11,opt,name=stream_details,json=streamDetails,proto3,oneof" json:"stream_details,omitempty"` // JSON health data
	Timestamp       int64                  `protobuf:"varint,12,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Quality metrics (calculated by Helmsman from MistServer data)
	// REMOVED: health_score = 13 (derived metric, use raw signals instead)
	HasIssues         *bool    `protobuf:"varint,14,opt,name=has_issues,json=hasIssues,proto3,oneof" json:"has_issues,omitempty"`
	IssuesDescription *string  `protobuf:"bytes,15,opt,name=issues_description,json=issuesDescription,proto3,oneof" json:"issues_description,omitempty"`
	TrackCount        *int32   `protobuf:"varint,16,opt,name=track_count,json=trackCount,proto3,oneof" json:"track_count,omitempty"`
	QualityTier       *string  `protobuf:"bytes,17,opt,name=quality_tier,json=qualityTier,proto3,oneof" json:"quality_tier,omitempty"` // "2160p", "1440p", "1080p", "720p", "480p", "SD"
	PrimaryWidth      *int32   `protobuf:"varint,18,opt,name=primary_width,json=primaryWidth,proto3,oneof" json:"primary_width,omitempty"`
	PrimaryHeight     *int32   `protobuf:"varint,19,opt,name=primary_height,json=primaryHeight,proto3,oneof" json:"primary_height,omitempty"`
	PrimaryFps        *float32 `protobuf:"fixed32,20,opt,name=primary_fps,json=primaryFps,proto3,oneof" json:"primary_fps,omitempty"`
	PrimaryCodec      *string  `protobuf:"bytes,21,opt,name=primary_codec,json=primaryCodec,proto3,oneof" json:"primary_codec,omitempty"`
	PrimaryBitrate    *int32   `protobuf:"varint,22,opt,name=primary_bitrate,json=primaryBitrate,proto3,oneof" json:"primary_bitrate,omitempty"`
	// Stream timing (populated by Foghorn from state manager)
	StartedAt *int64 `protobuf:"varint,23,opt,name=started_at,json=startedAt,proto3,oneof" json:"started_at,omitempty"` // Unix timestamp when stream went live
	// Packet statistics (from MistServer active_streams API - packsent/packloss/packretrans)
	PacketsSent *uint64 `protobuf:"varint,24,opt,name=packets_sent,json=packetsSent,proto3,oneof" json:"packets_sent,omitempty"`
	PacketsLost *uint64 `protobuf:"varint,25,opt,name=packets_lost,json=packetsLost,proto3,oneof" json:"packets_lost,omitempty"`
	// Replication status (true if this is a pull/replicated stream)
	Replicated *bool `protobuf:"varint,26,opt,name=replicated,proto3,oneof" json:"replicated,omitempty"`
	// Additional packet stat (packretrans from MistServer active_streams API)
	PacketsRetransmitted *uint64 `protobuf:"varint,27,opt,name=packets_retransmitted,json=packetsRetransmitted,proto3,oneof" json:"packets_retransmitted,omitempty"`
	// Buffer health metrics (from health blob - top level fields)
	BufferMs      *uint32 `protobuf:"varint,28,opt,name=buffer_ms,json=bufferMs,proto3,oneof" json:"buffer_ms,omitempty"`                  // health.buffer - available buffer in ms
	JitterMs      *uint32 `protobuf:"varint,29,opt,name=jitter_ms,json=jitterMs,proto3,oneof" json:"jitter_ms,omitempty"`                  // health.jitter - highest jitter across tracks
	MaxKeepawayMs *uint32 `protobuf:"varint,30,opt,name=max_keepaway_ms,json=maxKeepawayMs,proto3,oneof" json:"max_keepaway_ms,omitempty"` // health.maxkeepaway - max distance from live point
	// Full track details as JSON (serialized trackDetails array for storage)
	TrackDetailsJson *string `protobuf:"bytes,31,opt,name=track_details_json,json=trackDetailsJson,proto3,oneof" json:"track_details_json,omitempty"`
	// Primary audio track metrics (first audio track found)
	AudioChannels   *uint32 `protobuf:"varint,32,opt,name=audio_channels,json=audioChannels,proto3,oneof" json:"audio_channels,omitempty"`
	AudioSampleRate *uint32 `protobuf:"varint,33,opt,name=audio_sample_rate,json=audioSampleRate,proto3,oneof" json:"audio_sample_rate,omitempty"`
	AudioCodec      *string `protobuf:"bytes,34,opt,name=audio_codec,json=audioCodec,proto3,oneof" json:"audio_codec,omitempty"`
	AudioBitrate    *uint32 `protobuf:"varint,35,opt,name=audio_bitrate,json=audioBitrate,proto3,oneof" json:"audio_bitrate,omitempty"`
	// Per-track buffer/jitter for primary video track
	VideoBufferMs *uint32 `protobuf:"varint,36,opt,name=video_buffer_ms,json=videoBufferMs,proto3,oneof" json:"video_buffer_ms,omitempty"`
	VideoJitterMs *uint32 `protobuf:"varint,37,opt,name=video_jitter_ms,json=videoJitterMs,proto3,oneof" json:"video_jitter_ms,omitempty"`
	StreamId      *string `protobuf:"bytes,38,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Enriched by Foghorn (UUID); REQUIRED for analytics joins
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamLifecycleUpdate) Reset() {
	*x = StreamLifecycleUpdate{}
	mi := &file_ipc_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamLifecycleUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamLifecycleUpdate) ProtoMessage() {}

func (x *StreamLifecycleUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamLifecycleUpdate.ProtoReflect.Descriptor instead.
func (*StreamLifecycleUpdate) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{60}
}

func (x *StreamLifecycleUpdate) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetBufferState() string {
	if x != nil && x.BufferState != nil {
		return *x.BufferState
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetUploadedBytes() uint64 {
	if x != nil && x.UploadedBytes != nil {
		return *x.UploadedBytes
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetDownloadedBytes() uint64 {
	if x != nil && x.DownloadedBytes != nil {
		return *x.DownloadedBytes
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetTotalViewers() uint32 {
	if x != nil && x.TotalViewers != nil {
		return *x.TotalViewers
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetTotalInputs() uint32 {
	if x != nil && x.TotalInputs != nil {
		return *x.TotalInputs
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetViewerSeconds() uint64 {
	if x != nil && x.ViewerSeconds != nil {
		return *x.ViewerSeconds
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetStreamDetails() string {
	if x != nil && x.StreamDetails != nil {
		return *x.StreamDetails
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetHasIssues() bool {
	if x != nil && x.HasIssues != nil {
		return *x.HasIssues
	}
	return false
}

func (x *StreamLifecycleUpdate) GetIssuesDescription() string {
	if x != nil && x.IssuesDescription != nil {
		return *x.IssuesDescription
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetTrackCount() int32 {
	if x != nil && x.TrackCount != nil {
		return *x.TrackCount
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetQualityTier() string {
	if x != nil && x.QualityTier != nil {
		return *x.QualityTier
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetPrimaryWidth() int32 {
	if x != nil && x.PrimaryWidth != nil {
		return *x.PrimaryWidth
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetPrimaryHeight() int32 {
	if x != nil && x.PrimaryHeight != nil {
		return *x.PrimaryHeight
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetPrimaryFps() float32 {
	if x != nil && x.PrimaryFps != nil {
		return *x.PrimaryFps
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetPrimaryCodec() string {
	if x != nil && x.PrimaryCodec != nil {
		return *x.PrimaryCodec
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetPrimaryBitrate() int32 {
	if x != nil && x.PrimaryBitrate != nil {
		return *x.PrimaryBitrate
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetStartedAt() int64 {
	if x != nil && x.StartedAt != nil {
		return *x.StartedAt
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetPacketsSent() uint64 {
	if x != nil && x.PacketsSent != nil {
		return *x.PacketsSent
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetPacketsLost() uint64 {
	if x != nil && x.PacketsLost != nil {
		return *x.PacketsLost
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetReplicated() bool {
	if x != nil && x.Replicated != nil {
		return *x.Replicated
	}
	return false
}

func (x *StreamLifecycleUpdate) GetPacketsRetransmitted() uint64 {
	if x != nil && x.PacketsRetransmitted != nil {
		return *x.PacketsRetransmitted
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetBufferMs() uint32 {
	if x != nil && x.BufferMs != nil {
		return *x.BufferMs
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetJitterMs() uint32 {
	if x != nil && x.JitterMs != nil {
		return *x.JitterMs
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetMaxKeepawayMs() uint32 {
	if x != nil && x.MaxKeepawayMs != nil {
		return *x.MaxKeepawayMs
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetTrackDetailsJson() string {
	if x != nil && x.TrackDetailsJson != nil {
		return *x.TrackDetailsJson
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetAudioChannels() uint32 {
	if x != nil && x.AudioChannels != nil {
		return *x.AudioChannels
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetAudioSampleRate() uint32 {
	if x != nil && x.AudioSampleRate != nil {
		return *x.AudioSampleRate
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetAudioCodec() string {
	if x != nil && x.AudioCodec != nil {
		return *x.AudioCodec
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetAudioBitrate() uint32 {
	if x != nil && x.AudioBitrate != nil {
		return *x.AudioBitrate
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetVideoBufferMs() uint32 {
	if x != nil && x.VideoBufferMs != nil {
		return *x.VideoBufferMs
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetVideoJitterMs() uint32 {
	if x != nil && x.VideoJitterMs != nil {
		return *x.VideoJitterMs
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

type ClientLifecycleUpdate struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	NodeId       string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	TenantId     *string                `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"` // Optional - enriched by Foghorn via Commodore lookup
	InternalName string                 `protobuf:"bytes,3,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`
	Action       string                 `protobuf:"bytes,4,opt,name=action,proto3" json:"action,omitempty"` // "connect", "disconnect"
	Protocol     string                 `protobuf:"bytes,5,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// host contains the client's connection IP address.
	// Used for GeoIP enrichment before downstream redaction.
	Host                 string   `protobuf:"bytes,6,opt,name=host,proto3" json:"host,omitempty"`
	SessionId            *string  `protobuf:"bytes,7,opt,name=session_id,json=sessionId,proto3,oneof" json:"session_id,omitempty"`
	ConnectionTime       *float32 `protobuf:"fixed32,8,opt,name=connection_time,json=connectionTime,proto3,oneof" json:"connection_time,omitempty"`
	Position             *float32 `protobuf:"fixed32,9,opt,name=position,proto3,oneof" json:"position,omitempty"`
	BandwidthInBps       *uint64  `protobuf:"varint,10,opt,name=bandwidth_in_bps,json=bandwidthInBps,proto3,oneof" json:"bandwidth_in_bps,omitempty"`
	BandwidthOutBps      *uint64  `protobuf:"varint,11,opt,name=bandwidth_out_bps,json=bandwidthOutBps,proto3,oneof" json:"bandwidth_out_bps,omitempty"`
	BytesDownloaded      *uint64  `protobuf:"varint,12,opt,name=bytes_downloaded,json=bytesDownloaded,proto3,oneof" json:"bytes_downloaded,omitempty"`
	BytesUploaded        *uint64  `protobuf:"varint,13,opt,name=bytes_uploaded,json=bytesUploaded,proto3,oneof" json:"bytes_uploaded,omitempty"`
	PacketsSent          *uint64  `protobuf:"varint,14,opt,name=packets_sent,json=packetsSent,proto3,oneof" json:"packets_sent,omitempty"`
	PacketsLost          *uint64  `protobuf:"varint,15,opt,name=packets_lost,json=packetsLost,proto3,oneof" json:"packets_lost,omitempty"`
	PacketsRetransmitted *uint64  `protobuf:"varint,16,opt,name=packets_retransmitted,json=packetsRetransmitted,proto3,oneof" json:"packets_retransmitted,omitempty"`
	Timestamp            int64    `protobuf:"varint,17,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ClientCountry        *string  `protobuf:"bytes,19,opt,name=client_country,json=clientCountry,proto3,oneof" json:"client_country,omitempty"`         // GeoIP enriched country
	ClientCity           *string  `protobuf:"bytes,20,opt,name=client_city,json=clientCity,proto3,oneof" json:"client_city,omitempty"`                  // GeoIP enriched city
	ClientLatitude       *float64 `protobuf:"fixed64,21,opt,name=client_latitude,json=clientLatitude,proto3,oneof" json:"client_latitude,omitempty"`    // GeoIP enriched latitude
	ClientLongitude      *float64 `protobuf:"fixed64,22,opt,name=client_longitude,json=clientLongitude,proto3,oneof" json:"client_longitude,omitempty"` // GeoIP enriched longitude
	StreamId             *string  `protobuf:"bytes,23,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"`                        // Enriched by Foghorn (UUID); REQUIRED for analytics joins
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *ClientLifecycleUpdate) Reset() {
	*x = ClientLifecycleUpdate{}
	mi := &file_ipc_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientLifecycleUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientLifecycleUpdate) ProtoMessage() {}

func (x *ClientLifecycleUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientLifecycleUpdate.ProtoReflect.Descriptor instead.
func (*ClientLifecycleUpdate) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{61}
}

func (x *ClientLifecycleUpdate) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetSessionId() string {
	if x != nil && x.SessionId != nil {
		return *x.SessionId
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetConnectionTime() float32 {
	if x != nil && x.ConnectionTime != nil {
		return *x.ConnectionTime
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetPosition() float32 {
	if x != nil && x.Position != nil {
		return *x.Position
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetBandwidthInBps() uint64 {
	if x != nil && x.BandwidthInBps != nil {
		return *x.BandwidthInBps
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetBandwidthOutBps() uint64 {
	if x != nil && x.BandwidthOutBps != nil {
		return *x.BandwidthOutBps
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetBytesDownloaded() uint64 {
	if x != nil && x.BytesDownloaded != nil {
		return *x.BytesDownloaded
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetBytesUploaded() uint64 {
	if x != nil && x.BytesUploaded != nil {
		return *x.BytesUploaded
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetPacketsSent() uint64 {
	if x != nil && x.PacketsSent != nil {
		return *x.PacketsSent
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetPacketsLost() uint64 {
	if x != nil && x.PacketsLost != nil {
		return *x.PacketsLost
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetPacketsRetransmitted() uint64 {
	if x != nil && x.PacketsRetransmitted != nil {
		return *x.PacketsRetransmitted
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetClientCountry() string {
	if x != nil && x.ClientCountry != nil {
		return *x.ClientCountry
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetClientCity() string {
	if x != nil && x.ClientCity != nil {
		return *x.ClientCity
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetClientLatitude() float64 {
	if x != nil && x.ClientLatitude != nil {
		return *x.ClientLatitude
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetClientLongitude() float64 {
	if x != nil && x.ClientLongitude != nil {
		return *x.ClientLongitude
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

type NodeLifecycleUpdate struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	NodeId string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Resource metrics
	CpuTenths      uint32 `protobuf:"varint,2,opt,name=cpu_tenths,json=cpuTenths,proto3" json:"cpu_tenths,omitempty"`    // 0-1000
	RamMax         uint64 `protobuf:"varint,3,opt,name=ram_max,json=ramMax,proto3" json:"ram_max,omitempty"`             // MiB
	RamCurrent     uint64 `protobuf:"varint,4,opt,name=ram_current,json=ramCurrent,proto3" json:"ram_current,omitempty"` // MiB
	ShmTotalBytes  uint64 `protobuf:"varint,5,opt,name=shm_total_bytes,json=shmTotalBytes,proto3" json:"shm_total_bytes,omitempty"`
	ShmUsedBytes   uint64 `protobuf:"varint,6,opt,name=shm_used_bytes,json=shmUsedBytes,proto3" json:"shm_used_bytes,omitempty"`
	DiskTotalBytes uint64 `protobuf:"varint,7,opt,name=disk_total_bytes,json=diskTotalBytes,proto3" json:"disk_total_bytes,omitempty"`
	DiskUsedBytes  uint64 `protobuf:"varint,8,opt,name=disk_used_bytes,json=diskUsedBytes,proto3" json:"disk_used_bytes,omitempty"`
	UpSpeed        uint64 `protobuf:"varint,9,opt,name=up_speed,json=upSpeed,proto3" json:"up_speed,omitempty"`        // bytes/sec
	DownSpeed      uint64 `protobuf:"varint,10,opt,name=down_speed,json=downSpeed,proto3" json:"down_speed,omitempty"` // bytes/sec
	BwLimit        uint64 `protobuf:"varint,11,opt,name=bw_limit,json=bwLimit,proto3" json:"bw_limit,omitempty"`       // bytes/sec
	// Geo/location
	Latitude      float64 `protobuf:"fixed64,12,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude     float64 `protobuf:"fixed64,13,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Location      string  `protobuf:"bytes,14,opt,name=location,proto3" json:"location,omitempty"`
	ActiveStreams uint32  `protobuf:"varint,15,opt,name=active_streams,json=activeStreams,proto3" json:"active_streams,omitempty"`
	// Extended metrics (matching HTTP payload)
	BaseUrl   string `protobuf:"bytes,16,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`
	IsHealthy bool   `protobuf:"varint,17,opt,name=is_healthy,json=isHealthy,proto3" json:"is_healthy,omitempty"`
	EventType string `protobuf:"bytes,18,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	Timestamp int64  `protobuf:"varint,19,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Node capabilities
	Capabilities *NodeCapabilities `protobuf:"bytes,20,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	// Storage information
	Storage *StorageInfo `protobuf:"bytes,21,opt,name=storage,proto3" json:"storage,omitempty"`
	// Node limits and usage
	Limits *NodeLimits `protobuf:"bytes,22,opt,name=limits,proto3" json:"limits,omitempty"`
	// Stream metrics
	Streams map[string]*StreamData `protobuf:"bytes,23,rep,name=streams,proto3" json:"streams,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Stored artifacts
	Artifacts []*StoredArtifact `protobuf:"bytes,24,rep,name=artifacts,proto3" json:"artifacts,omitempty"`
	// MistServer outputs configuration (parsed from koekjes endpoint)
	OutputsJson string `protobuf:"bytes,25,opt,name=outputs_json,json=outputsJson,proto3" json:"outputs_json,omitempty"`
	// Enrichment fields added by Foghorn
	TenantId *string `protobuf:"bytes,26,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"`
	// Cumulative bandwidth counters (bytes since server start)
	BandwidthInTotal  uint64 `protobuf:"varint,27,opt,name=bandwidth_in_total,json=bandwidthInTotal,proto3" json:"bandwidth_in_total,omitempty"`    // bw[1] - total bytes received
	BandwidthOutTotal uint64 `protobuf:"varint,28,opt,name=bandwidth_out_total,json=bandwidthOutTotal,proto3" json:"bandwidth_out_total,omitempty"` // bw[0] - total bytes sent
	// Current active viewer connections
	ConnectionsCurrent uint32 `protobuf:"varint,29,opt,name=connections_current,json=connectionsCurrent,proto3" json:"connections_current,omitempty"` // curr[0] - current viewer count
	// Database UUID (enriched by Foghorn via Quartermaster lookup)
	NodeUuid *string `protobuf:"bytes,30,opt,name=node_uuid,json=nodeUuid,proto3,oneof" json:"node_uuid,omitempty"`
	// MistServer trigger health statistics (for debugging/monitoring)
	TriggersJson string `protobuf:"bytes,40,opt,name=triggers_json,json=triggersJson,proto3" json:"triggers_json,omitempty"` // {"STREAM_BUFFER": {count, fails, ms}, ...}
	// Extended connection breakdown from MistServer curr array
	ConnectionsInputs   uint32 `protobuf:"varint,41,opt,name=connections_inputs,json=connectionsInputs,proto3" json:"connections_inputs,omitempty"`       // curr[1] - input connections
	ConnectionsOutgoing uint32 `protobuf:"varint,42,opt,name=connections_outgoing,json=connectionsOutgoing,proto3" json:"connections_outgoing,omitempty"` // curr[2] - outgoing connections
	// Operational mode (maintenance/draining) provided by Helmsman.
	OperationalMode   NodeOperationalMode `protobuf:"varint,43,opt,name=operational_mode,json=operationalMode,proto3,enum=helmsmancontrol.NodeOperationalMode" json:"operational_mode,omitempty"`
	ConnectionsCached uint32              `protobuf:"varint,44,opt,name=connections_cached,json=connectionsCached,proto3" json:"connections_cached,omitempty"` // curr[4] - cached connections
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *NodeLifecycleUpdate) Reset() {
	*x = NodeLifecycleUpdate{}
	mi := &file_ipc_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeLifecycleUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeLifecycleUpdate) ProtoMessage() {}

func (x *NodeLifecycleUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeLifecycleUpdate.ProtoReflect.Descriptor instead.
func (*NodeLifecycleUpdate) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{62}
}

func (x *NodeLifecycleUpdate) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetCpuTenths() uint32 {
	if x != nil {
		return x.CpuTenths
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetRamMax() uint64 {
	if x != nil {
		return x.RamMax
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetRamCurrent() uint64 {
	if x != nil {
		return x.RamCurrent
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetShmTotalBytes() uint64 {
	if x != nil {
		return x.ShmTotalBytes
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetShmUsedBytes() uint64 {
	if x != nil {
		return x.ShmUsedBytes
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetDiskTotalBytes() uint64 {
	if x != nil {
		return x.DiskTotalBytes
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetDiskUsedBytes() uint64 {
	if x != nil {
		return x.DiskUsedBytes
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetUpSpeed() uint64 {
	if x != nil {
		return x.UpSpeed
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetDownSpeed() uint64 {
	if x != nil {
		return x.DownSpeed
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetBwLimit() uint64 {
	if x != nil {
		return x.BwLimit
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetLatitude() float64 {
	if x != nil {
		return x.Latitude
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetLongitude() float64 {
	if x != nil {
		return x.Longitude
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetLocation() string {
	if x != nil {
		return x.Location
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetActiveStreams() uint32 {
	if x != nil {
		return x.ActiveStreams
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetBaseUrl() string {
	if x != nil {
		return x.BaseUrl
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetIsHealthy() bool {
	if x != nil {
		return x.IsHealthy
	}
	return false
}

func (x *NodeLifecycleUpdate) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetCapabilities() *NodeCapabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *NodeLifecycleUpdate) GetStorage() *StorageInfo {
	if x != nil {
		return x.Storage
	}
	return nil
}

func (x *NodeLifecycleUpdate) GetLimits() *NodeLimits {
	if x != nil {
		return x.Limits
	}
	return nil
}

func (x *NodeLifecycleUpdate) GetStreams() map[string]*StreamData {
	if x != nil {
		return x.Streams
	}
	return nil
}

func (x *NodeLifecycleUpdate) GetArtifacts() []*StoredArtifact {
	if x != nil {
		return x.Artifacts
	}
	return nil
}

func (x *NodeLifecycleUpdate) GetOutputsJson() string {
	if x != nil {
		return x.OutputsJson
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetBandwidthInTotal() uint64 {
	if x != nil {
		return x.BandwidthInTotal
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetBandwidthOutTotal() uint64 {
	if x != nil {
		return x.BandwidthOutTotal
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetConnectionsCurrent() uint32 {
	if x != nil {
		return x.ConnectionsCurrent
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetNodeUuid() string {
	if x != nil && x.NodeUuid != nil {
		return *x.NodeUuid
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetTriggersJson() string {
	if x != nil {
		return x.TriggersJson
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetConnectionsInputs() uint32 {
	if x != nil {
		return x.ConnectionsInputs
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetConnectionsOutgoing() uint32 {
	if x != nil {
		return x.ConnectionsOutgoing
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetOperationalMode() NodeOperationalMode {
	if x != nil {
		return x.OperationalMode
	}
	return NodeOperationalMode_NODE_OPERATIONAL_MODE_UNSPECIFIED
}

func (x *NodeLifecycleUpdate) GetConnectionsCached() uint32 {
	if x != nil {
		return x.ConnectionsCached
	}
	return 0
}

// Load balancing specific data (no trigger equivalent - generated by Foghorn routing)
type LoadBalancingData struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	SelectedNode      string                 `protobuf:"bytes,1,opt,name=selected_node,json=selectedNode,proto3" json:"selected_node,omitempty"`
	Latitude          float64                `protobuf:"fixed64,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude         float64                `protobuf:"fixed64,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Status            string                 `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	Details           string                 `protobuf:"bytes,5,opt,name=details,proto3" json:"details,omitempty"`
	Score             uint64                 `protobuf:"varint,6,opt,name=score,proto3" json:"score,omitempty"`
	ClientIp          string                 `protobuf:"bytes,7,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
	ClientCountry     string                 `protobuf:"bytes,8,opt,name=client_country,json=clientCountry,proto3" json:"client_country,omitempty"`
	NodeLatitude      float64                `protobuf:"fixed64,9,opt,name=node_latitude,json=nodeLatitude,proto3" json:"node_latitude,omitempty"`
	NodeLongitude     float64                `protobuf:"fixed64,10,opt,name=node_longitude,json=nodeLongitude,proto3" json:"node_longitude,omitempty"`
	NodeName          string                 `protobuf:"bytes,11,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	SelectedNodeId    *string                `protobuf:"bytes,12,opt,name=selected_node_id,json=selectedNodeId,proto3,oneof" json:"selected_node_id,omitempty"`
	RoutingDistanceKm *float64               `protobuf:"fixed64,13,opt,name=routing_distance_km,json=routingDistanceKm,proto3,oneof" json:"routing_distance_km,omitempty"`
	// Enrichment fields added by Foghorn
	TenantId     *string    `protobuf:"bytes,14,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"` // Infra owner tenant (cluster operator)
	InternalName *string    `protobuf:"bytes,15,opt,name=internal_name,json=internalName,proto3,oneof" json:"internal_name,omitempty"`
	ClientBucket *GeoBucket `protobuf:"bytes,16,opt,name=client_bucket,json=clientBucket,proto3,oneof" json:"client_bucket,omitempty"`
	NodeBucket   *GeoBucket `protobuf:"bytes,17,opt,name=node_bucket,json=nodeBucket,proto3,oneof" json:"node_bucket,omitempty"`
	// Dual-tenant attribution (RFC: routing-events-dual-tenant-attribution)
	StreamTenantId  *string  `protobuf:"bytes,18,opt,name=stream_tenant_id,json=streamTenantId,proto3,oneof" json:"stream_tenant_id,omitempty"` // Subject tenant (stream/customer owner)
	ClusterId       *string  `protobuf:"bytes,19,opt,name=cluster_id,json=clusterId,proto3,oneof" json:"cluster_id,omitempty"`                  // Emitting cluster identifier
	LatencyMs       *float32 `protobuf:"fixed32,20,opt,name=latency_ms,json=latencyMs,proto3,oneof" json:"latency_ms,omitempty"`
	StreamId        *string  `protobuf:"bytes,21,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"`                       // Public stream ID (UUID); REQUIRED for analytics joins
	CandidatesCount *uint32  `protobuf:"varint,22,opt,name=candidates_count,json=candidatesCount,proto3,oneof" json:"candidates_count,omitempty"` // Number of eligible candidates considered
	EventType       *string  `protobuf:"bytes,23,opt,name=event_type,json=eventType,proto3,oneof" json:"event_type,omitempty"`                    // "play_rewrite", "grpc_resolve", etc.
	Source          *string  `protobuf:"bytes,24,opt,name=source,proto3,oneof" json:"source,omitempty"`                                           // "http", "grpc", "internal"
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *LoadBalancingData) Reset() {
	*x = LoadBalancingData{}
	mi := &file_ipc_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LoadBalancingData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadBalancingData) ProtoMessage() {}

func (x *LoadBalancingData) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadBalancingData.ProtoReflect.Descriptor instead.
func (*LoadBalancingData) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{63}
}

func (x *LoadBalancingData) GetSelectedNode() string {
	if x != nil {
		return x.SelectedNode
	}
	return ""
}

func (x *LoadBalancingData) GetLatitude() float64 {
	if x != nil {
		return x.Latitude
	}
	return 0
}

func (x *LoadBalancingData) GetLongitude() float64 {
	if x != nil {
		return x.Longitude
	}
	return 0
}

func (x *LoadBalancingData) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *LoadBalancingData) GetDetails() string {
	if x != nil {
		return x.Details
	}
	return ""
}

func (x *LoadBalancingData) GetScore() uint64 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *LoadBalancingData) GetClientIp() string {
	if x != nil {
		return x.ClientIp
	}
	return ""
}

func (x *LoadBalancingData) GetClientCountry() string {
	if x != nil {
		return x.ClientCountry
	}
	return ""
}

func (x *LoadBalancingData) GetNodeLatitude() float64 {
	if x != nil {
		return x.NodeLatitude
	}
	return 0
}

func (x *LoadBalancingData) GetNodeLongitude() float64 {
	if x != nil {
		return x.NodeLongitude
	}
	return 0
}

func (x *LoadBalancingData) GetNodeName() string {
	if x != nil {
		return x.NodeName
	}
	return ""
}

func (x *LoadBalancingData) GetSelectedNodeId() string {
	if x != nil && x.SelectedNodeId != nil {
		return *x.SelectedNodeId
	}
	return ""
}

func (x *LoadBalancingData) GetRoutingDistanceKm() float64 {
	if x != nil && x.RoutingDistanceKm != nil {
		return *x.RoutingDistanceKm
	}
	return 0
}

func (x *LoadBalancingData) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *LoadBalancingData) GetInternalName() string {
	if x != nil && x.InternalName != nil {
		return *x.InternalName
	}
	return ""
}

func (x *LoadBalancingData) GetClientBucket() *GeoBucket {
	if x != nil {
		return x.ClientBucket
	}
	return nil
}

func (x *LoadBalancingData) GetNodeBucket() *GeoBucket {
	if x != nil {
		return x.NodeBucket
	}
	return nil
}

func (x *LoadBalancingData) GetStreamTenantId() string {
	if x != nil && x.StreamTenantId != nil {
		return *x.StreamTenantId
	}
	return ""
}

func (x *LoadBalancingData) GetClusterId() string {
	if x != nil && x.ClusterId != nil {
		return *x.ClusterId
	}
	return ""
}

func (x *LoadBalancingData) GetLatencyMs() float32 {
	if x != nil && x.LatencyMs != nil {
		return *x.LatencyMs
	}
	return 0
}

func (x *LoadBalancingData) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

func (x *LoadBalancingData) GetCandidatesCount() uint32 {
	if x != nil && x.CandidatesCount != nil {
		return *x.CandidatesCount
	}
	return 0
}

func (x *LoadBalancingData) GetEventType() string {
	if x != nil && x.EventType != nil {
		return *x.EventType
	}
	return ""
}

func (x *LoadBalancingData) GetSource() string {
	if x != nil && x.Source != nil {
		return *x.Source
	}
	return ""
}

// Clip lifecycle specific data (separate from ClipProgress/ClipDone control messages)
//
// FOGHORN ENRICHMENT REQUIRED:
// When forwarding clip lifecycle events to Decklog, Foghorn must enrich with:
// - tenant_id, internal_name (already done)
// - start_unix, stop_unix, start_ms, stop_ms, duration_sec from original ClipPullRequest
// These fields must be included in ALL lifecycle stages (REQUESTED, PROGRESS, DONE, FAILED)
// so that Periscope can track clip state without needing to merge events.
type ClipLifecycleData struct {
	state           protoimpl.MessageState  `protogen:"open.v1"`
	Stage           ClipLifecycleData_Stage `protobuf:"varint,1,opt,name=stage,proto3,enum=helmsmancontrol.ClipLifecycleData_Stage" json:"stage,omitempty"`
	ClipHash        string                  `protobuf:"bytes,2,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`
	RequestId       *string                 `protobuf:"bytes,3,opt,name=request_id,json=requestId,proto3,oneof" json:"request_id,omitempty"`
	ProgressPercent *uint32                 `protobuf:"varint,4,opt,name=progress_percent,json=progressPercent,proto3,oneof" json:"progress_percent,omitempty"`
	FilePath        *string                 `protobuf:"bytes,5,opt,name=file_path,json=filePath,proto3,oneof" json:"file_path,omitempty"`
	S3Url           *string                 `protobuf:"bytes,6,opt,name=s3_url,json=s3Url,proto3,oneof" json:"s3_url,omitempty"`
	SizeBytes       *uint64                 `protobuf:"varint,7,opt,name=size_bytes,json=sizeBytes,proto3,oneof" json:"size_bytes,omitempty"`
	Error           *string                 `protobuf:"bytes,8,opt,name=error,proto3,oneof" json:"error,omitempty"`
	StartedAt       *int64                  `protobuf:"varint,9,opt,name=started_at,json=startedAt,proto3,oneof" json:"started_at,omitempty"`
	CompletedAt     *int64                  `protobuf:"varint,10,opt,name=completed_at,json=completedAt,proto3,oneof" json:"completed_at,omitempty"`
	NodeId          *string                 `protobuf:"bytes,11,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	// Enrichment fields added by Foghorn
	TenantId     *string `protobuf:"bytes,12,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"`
	InternalName *string `protobuf:"bytes,13,opt,name=internal_name,json=internalName,proto3,oneof" json:"internal_name,omitempty"`
	// Clip time boundaries (enriched by Foghorn from original ClipPullRequest)
	StartUnix   *int64 `protobuf:"varint,14,opt,name=start_unix,json=startUnix,proto3,oneof" json:"start_unix,omitempty"`
	StopUnix    *int64 `protobuf:"varint,15,opt,name=stop_unix,json=stopUnix,proto3,oneof" json:"stop_unix,omitempty"`
	StartMs     *int64 `protobuf:"varint,16,opt,name=start_ms,json=startMs,proto3,oneof" json:"start_ms,omitempty"`
	StopMs      *int64 `protobuf:"varint,17,opt,name=stop_ms,json=stopMs,proto3,oneof" json:"stop_ms,omitempty"`
	DurationSec *int64 `protobuf:"varint,18,opt,name=duration_sec,json=durationSec,proto3,oneof" json:"duration_sec,omitempty"`
	// Clip creation mode (enriched by Foghorn)
	ClipMode      *string `protobuf:"bytes,19,opt,name=clip_mode,json=clipMode,proto3,oneof" json:"clip_mode,omitempty"`
	ExpiresAt     *int64  `protobuf:"varint,20,opt,name=expires_at,json=expiresAt,proto3,oneof" json:"expires_at,omitempty"`
	StreamId      *string `protobuf:"bytes,21,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Public stream ID (UUID)
	UserId        *string `protobuf:"bytes,22,opt,name=user_id,json=userId,proto3,oneof" json:"user_id,omitempty"`       // User who initiated the clip (if known)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipLifecycleData) Reset() {
	*x = ClipLifecycleData{}
	mi := &file_ipc_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipLifecycleData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipLifecycleData) ProtoMessage() {}

func (x *ClipLifecycleData) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipLifecycleData.ProtoReflect.Descriptor instead.
func (*ClipLifecycleData) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{64}
}

func (x *ClipLifecycleData) GetStage() ClipLifecycleData_Stage {
	if x != nil {
		return x.Stage
	}
	return ClipLifecycleData_STAGE_UNSPECIFIED
}

func (x *ClipLifecycleData) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *ClipLifecycleData) GetRequestId() string {
	if x != nil && x.RequestId != nil {
		return *x.RequestId
	}
	return ""
}

func (x *ClipLifecycleData) GetProgressPercent() uint32 {
	if x != nil && x.ProgressPercent != nil {
		return *x.ProgressPercent
	}
	return 0
}

func (x *ClipLifecycleData) GetFilePath() string {
	if x != nil && x.FilePath != nil {
		return *x.FilePath
	}
	return ""
}

func (x *ClipLifecycleData) GetS3Url() string {
	if x != nil && x.S3Url != nil {
		return *x.S3Url
	}
	return ""
}

func (x *ClipLifecycleData) GetSizeBytes() uint64 {
	if x != nil && x.SizeBytes != nil {
		return *x.SizeBytes
	}
	return 0
}

func (x *ClipLifecycleData) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

func (x *ClipLifecycleData) GetStartedAt() int64 {
	if x != nil && x.StartedAt != nil {
		return *x.StartedAt
	}
	return 0
}

func (x *ClipLifecycleData) GetCompletedAt() int64 {
	if x != nil && x.CompletedAt != nil {
		return *x.CompletedAt
	}
	return 0
}

func (x *ClipLifecycleData) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *ClipLifecycleData) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *ClipLifecycleData) GetInternalName() string {
	if x != nil && x.InternalName != nil {
		return *x.InternalName
	}
	return ""
}

func (x *ClipLifecycleData) GetStartUnix() int64 {
	if x != nil && x.StartUnix != nil {
		return *x.StartUnix
	}
	return 0
}

func (x *ClipLifecycleData) GetStopUnix() int64 {
	if x != nil && x.StopUnix != nil {
		return *x.StopUnix
	}
	return 0
}

func (x *ClipLifecycleData) GetStartMs() int64 {
	if x != nil && x.StartMs != nil {
		return *x.StartMs
	}
	return 0
}

func (x *ClipLifecycleData) GetStopMs() int64 {
	if x != nil && x.StopMs != nil {
		return *x.StopMs
	}
	return 0
}

func (x *ClipLifecycleData) GetDurationSec() int64 {
	if x != nil && x.DurationSec != nil {
		return *x.DurationSec
	}
	return 0
}

func (x *ClipLifecycleData) GetClipMode() string {
	if x != nil && x.ClipMode != nil {
		return *x.ClipMode
	}
	return ""
}

func (x *ClipLifecycleData) GetExpiresAt() int64 {
	if x != nil && x.ExpiresAt != nil {
		return *x.ExpiresAt
	}
	return 0
}

func (x *ClipLifecycleData) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

func (x *ClipLifecycleData) GetUserId() string {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return ""
}

// DVR lifecycle specific data (separate from DVR control messages)
//
// FOGHORN ENRICHMENT REQUIRED:
// When forwarding DVR lifecycle events to Decklog, Foghorn must enrich with:
// - tenant_id, internal_name (already done)
// - started_at, ended_at from DVRStartRequest/DVRStopped (time boundaries)
// These fields must be included in ALL lifecycle statuses so that Periscope
// can track DVR state without needing to merge events.
type DVRLifecycleData struct {
	state        protoimpl.MessageState  `protogen:"open.v1"`
	Status       DVRLifecycleData_Status `protobuf:"varint,1,opt,name=status,proto3,enum=helmsmancontrol.DVRLifecycleData_Status" json:"status,omitempty"`
	DvrHash      string                  `protobuf:"bytes,2,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`
	ManifestPath *string                 `protobuf:"bytes,3,opt,name=manifest_path,json=manifestPath,proto3,oneof" json:"manifest_path,omitempty"`
	StartedAt    *int64                  `protobuf:"varint,4,opt,name=started_at,json=startedAt,proto3,oneof" json:"started_at,omitempty"` // Unix timestamp when recording started
	EndedAt      *int64                  `protobuf:"varint,5,opt,name=ended_at,json=endedAt,proto3,oneof" json:"ended_at,omitempty"`       // Unix timestamp when recording ended
	SizeBytes    *uint64                 `protobuf:"varint,6,opt,name=size_bytes,json=sizeBytes,proto3,oneof" json:"size_bytes,omitempty"`
	SegmentCount *int32                  `protobuf:"varint,7,opt,name=segment_count,json=segmentCount,proto3,oneof" json:"segment_count,omitempty"`
	Error        *string                 `protobuf:"bytes,8,opt,name=error,proto3,oneof" json:"error,omitempty"`
	NodeId       *string                 `protobuf:"bytes,9,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	// Enrichment fields added by Foghorn
	TenantId      *string `protobuf:"bytes,10,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"`
	InternalName  *string `protobuf:"bytes,11,opt,name=internal_name,json=internalName,proto3,oneof" json:"internal_name,omitempty"`
	ExpiresAt     *int64  `protobuf:"varint,12,opt,name=expires_at,json=expiresAt,proto3,oneof" json:"expires_at,omitempty"`
	StreamId      *string `protobuf:"bytes,13,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"` // Public stream ID (UUID)
	UserId        *string `protobuf:"bytes,14,opt,name=user_id,json=userId,proto3,oneof" json:"user_id,omitempty"`       // User who initiated the DVR (if known)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRLifecycleData) Reset() {
	*x = DVRLifecycleData{}
	mi := &file_ipc_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRLifecycleData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRLifecycleData) ProtoMessage() {}

func (x *DVRLifecycleData) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRLifecycleData.ProtoReflect.Descriptor instead.
func (*DVRLifecycleData) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{65}
}

func (x *DVRLifecycleData) GetStatus() DVRLifecycleData_Status {
	if x != nil {
		return x.Status
	}
	return DVRLifecycleData_STATUS_UNSPECIFIED
}

func (x *DVRLifecycleData) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRLifecycleData) GetManifestPath() string {
	if x != nil && x.ManifestPath != nil {
		return *x.ManifestPath
	}
	return ""
}

func (x *DVRLifecycleData) GetStartedAt() int64 {
	if x != nil && x.StartedAt != nil {
		return *x.StartedAt
	}
	return 0
}

func (x *DVRLifecycleData) GetEndedAt() int64 {
	if x != nil && x.EndedAt != nil {
		return *x.EndedAt
	}
	return 0
}

func (x *DVRLifecycleData) GetSizeBytes() uint64 {
	if x != nil && x.SizeBytes != nil {
		return *x.SizeBytes
	}
	return 0
}

func (x *DVRLifecycleData) GetSegmentCount() int32 {
	if x != nil && x.SegmentCount != nil {
		return *x.SegmentCount
	}
	return 0
}

func (x *DVRLifecycleData) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

func (x *DVRLifecycleData) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *DVRLifecycleData) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *DVRLifecycleData) GetInternalName() string {
	if x != nil && x.InternalName != nil {
		return *x.InternalName
	}
	return ""
}

func (x *DVRLifecycleData) GetExpiresAt() int64 {
	if x != nil && x.ExpiresAt != nil {
		return *x.ExpiresAt
	}
	return 0
}

func (x *DVRLifecycleData) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

func (x *DVRLifecycleData) GetUserId() string {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return ""
}

// VOD lifecycle specific data (for user-uploaded video assets)
//
// VOD uploads differ from clips/DVR:
// - User uploads directly to S3 via presigned URLs (no MistServer involved)
// - Foghorn manages upload state and emits lifecycle events to Decklog
// - Periscope Ingest writes to live_artifacts with content_type='vod'
// - Gateway enriches VOD metadata from Periscope via ArtifactLifecycleLoader
type VodLifecycleData struct {
	state       protoimpl.MessageState  `protogen:"open.v1"`
	Status      VodLifecycleData_Status `protobuf:"varint,1,opt,name=status,proto3,enum=helmsmancontrol.VodLifecycleData_Status" json:"status,omitempty"`
	VodHash     string                  `protobuf:"bytes,2,opt,name=vod_hash,json=vodHash,proto3" json:"vod_hash,omitempty"`          // Artifact hash (from Commodore)
	UploadId    *string                 `protobuf:"bytes,3,opt,name=upload_id,json=uploadId,proto3,oneof" json:"upload_id,omitempty"` // S3 multipart upload ID
	Filename    *string                 `protobuf:"bytes,4,opt,name=filename,proto3,oneof" json:"filename,omitempty"`
	ContentType *string                 `protobuf:"bytes,5,opt,name=content_type,json=contentType,proto3,oneof" json:"content_type,omitempty"` // MIME type (video/mp4, etc.)
	SizeBytes   *uint64                 `protobuf:"varint,6,opt,name=size_bytes,json=sizeBytes,proto3,oneof" json:"size_bytes,omitempty"`      // Expected or actual size
	S3Url       *string                 `protobuf:"bytes,7,opt,name=s3_url,json=s3Url,proto3,oneof" json:"s3_url,omitempty"`                   // Final S3 URL when completed
	FilePath    *string                 `protobuf:"bytes,8,opt,name=file_path,json=filePath,proto3,oneof" json:"file_path,omitempty"`          // Local file path (if applicable)
	Error       *string                 `protobuf:"bytes,9,opt,name=error,proto3,oneof" json:"error,omitempty"`
	StartedAt   *int64                  `protobuf:"varint,10,opt,name=started_at,json=startedAt,proto3,oneof" json:"started_at,omitempty"`       // When upload started
	CompletedAt *int64                  `protobuf:"varint,11,opt,name=completed_at,json=completedAt,proto3,oneof" json:"completed_at,omitempty"` // When upload/processing completed
	NodeId      *string                 `protobuf:"bytes,12,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`                 // Processing node (if any)
	// Enrichment fields
	TenantId  *string `protobuf:"bytes,13,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"`
	UserId    *string `protobuf:"bytes,14,opt,name=user_id,json=userId,proto3,oneof" json:"user_id,omitempty"`
	ExpiresAt *int64  `protobuf:"varint,15,opt,name=expires_at,json=expiresAt,proto3,oneof" json:"expires_at,omitempty"` // Retention expiration
	// Media metadata (populated after processing)
	DurationMs    *int64  `protobuf:"varint,16,opt,name=duration_ms,json=durationMs,proto3,oneof" json:"duration_ms,omitempty"`
	Resolution    *string `protobuf:"bytes,17,opt,name=resolution,proto3,oneof" json:"resolution,omitempty"` // "1920x1080"
	VideoCodec    *string `protobuf:"bytes,18,opt,name=video_codec,json=videoCodec,proto3,oneof" json:"video_codec,omitempty"`
	AudioCodec    *string `protobuf:"bytes,19,opt,name=audio_codec,json=audioCodec,proto3,oneof" json:"audio_codec,omitempty"`
	BitrateKbps   *int32  `protobuf:"varint,20,opt,name=bitrate_kbps,json=bitrateKbps,proto3,oneof" json:"bitrate_kbps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VodLifecycleData) Reset() {
	*x = VodLifecycleData{}
	mi := &file_ipc_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VodLifecycleData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VodLifecycleData) ProtoMessage() {}

func (x *VodLifecycleData) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VodLifecycleData.ProtoReflect.Descriptor instead.
func (*VodLifecycleData) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{66}
}

func (x *VodLifecycleData) GetStatus() VodLifecycleData_Status {
	if x != nil {
		return x.Status
	}
	return VodLifecycleData_STATUS_UNSPECIFIED
}

func (x *VodLifecycleData) GetVodHash() string {
	if x != nil {
		return x.VodHash
	}
	return ""
}

func (x *VodLifecycleData) GetUploadId() string {
	if x != nil && x.UploadId != nil {
		return *x.UploadId
	}
	return ""
}

func (x *VodLifecycleData) GetFilename() string {
	if x != nil && x.Filename != nil {
		return *x.Filename
	}
	return ""
}

func (x *VodLifecycleData) GetContentType() string {
	if x != nil && x.ContentType != nil {
		return *x.ContentType
	}
	return ""
}

func (x *VodLifecycleData) GetSizeBytes() uint64 {
	if x != nil && x.SizeBytes != nil {
		return *x.SizeBytes
	}
	return 0
}

func (x *VodLifecycleData) GetS3Url() string {
	if x != nil && x.S3Url != nil {
		return *x.S3Url
	}
	return ""
}

func (x *VodLifecycleData) GetFilePath() string {
	if x != nil && x.FilePath != nil {
		return *x.FilePath
	}
	return ""
}

func (x *VodLifecycleData) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

func (x *VodLifecycleData) GetStartedAt() int64 {
	if x != nil && x.StartedAt != nil {
		return *x.StartedAt
	}
	return 0
}

func (x *VodLifecycleData) GetCompletedAt() int64 {
	if x != nil && x.CompletedAt != nil {
		return *x.CompletedAt
	}
	return 0
}

func (x *VodLifecycleData) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *VodLifecycleData) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *VodLifecycleData) GetUserId() string {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return ""
}

func (x *VodLifecycleData) GetExpiresAt() int64 {
	if x != nil && x.ExpiresAt != nil {
		return *x.ExpiresAt
	}
	return 0
}

func (x *VodLifecycleData) GetDurationMs() int64 {
	if x != nil && x.DurationMs != nil {
		return *x.DurationMs
	}
	return 0
}

func (x *VodLifecycleData) GetResolution() string {
	if x != nil && x.Resolution != nil {
		return *x.Resolution
	}
	return ""
}

func (x *VodLifecycleData) GetVideoCodec() string {
	if x != nil && x.VideoCodec != nil {
		return *x.VideoCodec
	}
	return ""
}

func (x *VodLifecycleData) GetAudioCodec() string {
	if x != nil && x.AudioCodec != nil {
		return *x.AudioCodec
	}
	return ""
}

func (x *VodLifecycleData) GetBitrateKbps() int32 {
	if x != nil && x.BitrateKbps != nil {
		return *x.BitrateKbps
	}
	return 0
}

// MessageLifecycleData tracks support messaging events for real-time UI updates
// Emitted by Deckhand when Chatwoot webhook events are received
type MessageLifecycleData struct {
	state          protoimpl.MessageState         `protogen:"open.v1"`
	EventType      MessageLifecycleData_EventType `protobuf:"varint,1,opt,name=event_type,json=eventType,proto3,enum=helmsmancontrol.MessageLifecycleData_EventType" json:"event_type,omitempty"`
	ConversationId string                         `protobuf:"bytes,2,opt,name=conversation_id,json=conversationId,proto3" json:"conversation_id,omitempty"` // Chatwoot conversation ID
	MessageId      *string                        `protobuf:"bytes,3,opt,name=message_id,json=messageId,proto3,oneof" json:"message_id,omitempty"`          // Chatwoot message ID (for message events)
	Content        *string                        `protobuf:"bytes,4,opt,name=content,proto3,oneof" json:"content,omitempty"`                               // Message content (for message_created)
	Sender         *string                        `protobuf:"bytes,5,opt,name=sender,proto3,oneof" json:"sender,omitempty"`                                 // "USER" or "AGENT"
	Status         *string                        `protobuf:"bytes,6,opt,name=status,proto3,oneof" json:"status,omitempty"`                                 // Conversation status: "OPEN", "RESOLVED", "PENDING"
	Subject        *string                        `protobuf:"bytes,7,opt,name=subject,proto3,oneof" json:"subject,omitempty"`                               // Conversation subject
	Timestamp      int64                          `protobuf:"varint,8,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                                // When event occurred
	TenantId       *string                        `protobuf:"bytes,9,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"`             // Tenant context
	UserId         *string                        `protobuf:"bytes,10,opt,name=user_id,json=userId,proto3,oneof" json:"user_id,omitempty"`                  // User context
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *MessageLifecycleData) Reset() {
	*x = MessageLifecycleData{}
	mi := &file_ipc_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MessageLifecycleData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageLifecycleData) ProtoMessage() {}

func (x *MessageLifecycleData) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MessageLifecycleData.ProtoReflect.Descriptor instead.
func (*MessageLifecycleData) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{67}
}

func (x *MessageLifecycleData) GetEventType() MessageLifecycleData_EventType {
	if x != nil {
		return x.EventType
	}
	return MessageLifecycleData_EVENT_TYPE_UNSPECIFIED
}

func (x *MessageLifecycleData) GetConversationId() string {
	if x != nil {
		return x.ConversationId
	}
	return ""
}

func (x *MessageLifecycleData) GetMessageId() string {
	if x != nil && x.MessageId != nil {
		return *x.MessageId
	}
	return ""
}

func (x *MessageLifecycleData) GetContent() string {
	if x != nil && x.Content != nil {
		return *x.Content
	}
	return ""
}

func (x *MessageLifecycleData) GetSender() string {
	if x != nil && x.Sender != nil {
		return *x.Sender
	}
	return ""
}

func (x *MessageLifecycleData) GetStatus() string {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return ""
}

func (x *MessageLifecycleData) GetSubject() string {
	if x != nil && x.Subject != nil {
		return *x.Subject
	}
	return ""
}

func (x *MessageLifecycleData) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *MessageLifecycleData) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *MessageLifecycleData) GetUserId() string {
	if x != nil && x.UserId != nil {
		return *x.UserId
	}
	return ""
}

type NodeCapabilities struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ingest        bool                   `protobuf:"varint,1,opt,name=ingest,proto3" json:"ingest,omitempty"`
	Edge          bool                   `protobuf:"varint,2,opt,name=edge,proto3" json:"edge,omitempty"`
	Storage       bool                   `protobuf:"varint,3,opt,name=storage,proto3" json:"storage,omitempty"`
	Processing    bool                   `protobuf:"varint,4,opt,name=processing,proto3" json:"processing,omitempty"`
	Roles         []string               `protobuf:"bytes,5,rep,name=roles,proto3" json:"roles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeCapabilities) Reset() {
	*x = NodeCapabilities{}
	mi := &file_ipc_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeCapabilities) ProtoMessage() {}

func (x *NodeCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeCapabilities.ProtoReflect.Descriptor instead.
func (*NodeCapabilities) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{68}
}

func (x *NodeCapabilities) GetIngest() bool {
	if x != nil {
		return x.Ingest
	}
	return false
}

func (x *NodeCapabilities) GetEdge() bool {
	if x != nil {
		return x.Edge
	}
	return false
}

func (x *NodeCapabilities) GetStorage() bool {
	if x != nil {
		return x.Storage
	}
	return false
}

func (x *NodeCapabilities) GetProcessing() bool {
	if x != nil {
		return x.Processing
	}
	return false
}

func (x *NodeCapabilities) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

// Processing configuration sent from Foghorn to Helmsman
// Enables MistProcLivepeer when Gateway is available
type ProcessingConfig struct {
	state                    protoimpl.MessageState `protogen:"open.v1"`
	LivepeerGatewayAvailable bool                   `protobuf:"varint,1,opt,name=livepeer_gateway_available,json=livepeerGatewayAvailable,proto3" json:"livepeer_gateway_available,omitempty"`
	LivepeerGatewayUrl       string                 `protobuf:"bytes,2,opt,name=livepeer_gateway_url,json=livepeerGatewayUrl,proto3" json:"livepeer_gateway_url,omitempty"` // e.g., "http://livepeer-gateway:8935"
	GatewayInputCodecs       []string               `protobuf:"bytes,3,rep,name=gateway_input_codecs,json=gatewayInputCodecs,proto3" json:"gateway_input_codecs,omitempty"` // ["H264"] - what Gateway accepts
	LocalInputCodecs         []string               `protobuf:"bytes,4,rep,name=local_input_codecs,json=localInputCodecs,proto3" json:"local_input_codecs,omitempty"`       // ["H264", "H265", "AV1", "VP9"] - what local MistServer accepts
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *ProcessingConfig) Reset() {
	*x = ProcessingConfig{}
	mi := &file_ipc_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProcessingConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProcessingConfig) ProtoMessage() {}

func (x *ProcessingConfig) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProcessingConfig.ProtoReflect.Descriptor instead.
func (*ProcessingConfig) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{69}
}

func (x *ProcessingConfig) GetLivepeerGatewayAvailable() bool {
	if x != nil {
		return x.LivepeerGatewayAvailable
	}
	return false
}

func (x *ProcessingConfig) GetLivepeerGatewayUrl() string {
	if x != nil {
		return x.LivepeerGatewayUrl
	}
	return ""
}

func (x *ProcessingConfig) GetGatewayInputCodecs() []string {
	if x != nil {
		return x.GatewayInputCodecs
	}
	return nil
}

func (x *ProcessingConfig) GetLocalInputCodecs() []string {
	if x != nil {
		return x.LocalInputCodecs
	}
	return nil
}

// ProcessBillingEvent tracks transcoding usage for billing purposes
// Emitted by Helmsman when MistServer triggers fire:
// - LIVEPEER_SEGMENT_COMPLETE for Livepeer Gateway transcoding
// - PROCESS_AV_VIRTUAL_SEGMENT_COMPLETE for MistProcAV transcoding
type ProcessBillingEvent struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	NodeId      string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	StreamName  string                 `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	ProcessType string                 `protobuf:"bytes,3,opt,name=process_type,json=processType,proto3" json:"process_type,omitempty"` // "Livepeer", "AV", "FFmpeg"
	DurationMs  int64                  `protobuf:"varint,4,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`   // Duration in milliseconds (segment duration or since last event)
	Timestamp   int64                  `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                       // Unix timestamp when event occurred
	TenantId    *string                `protobuf:"bytes,6,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"`    // Tenant context (enriched by Foghorn or Helmsman)
	StreamId    *string                `protobuf:"bytes,7,opt,name=stream_id,json=streamId,proto3,oneof" json:"stream_id,omitempty"`    // Enriched by Foghorn (UUID)
	// Common fields
	InputCodec  *string `protobuf:"bytes,10,opt,name=input_codec,json=inputCodec,proto3,oneof" json:"input_codec,omitempty"`
	OutputCodec *string `protobuf:"bytes,11,opt,name=output_codec,json=outputCodec,proto3,oneof" json:"output_codec,omitempty"`
	TrackType   *string `protobuf:"bytes,12,opt,name=track_type,json=trackType,proto3,oneof" json:"track_type,omitempty"` // "audio" or "video" - KEY FOR BILLING
	// Livepeer-specific (from LIVEPEER_SEGMENT_COMPLETE)
	SegmentNumber     *int32   `protobuf:"varint,20,opt,name=segment_number,json=segmentNumber,proto3,oneof" json:"segment_number,omitempty"`
	Width             *int32   `protobuf:"varint,21,opt,name=width,proto3,oneof" json:"width,omitempty"`   // source width
	Height            *int32   `protobuf:"varint,22,opt,name=height,proto3,oneof" json:"height,omitempty"` // source height
	RenditionCount    *int32   `protobuf:"varint,23,opt,name=rendition_count,json=renditionCount,proto3,oneof" json:"rendition_count,omitempty"`
	BroadcasterUrl    *string  `protobuf:"bytes,24,opt,name=broadcaster_url,json=broadcasterUrl,proto3,oneof" json:"broadcaster_url,omitempty"`
	UploadTimeUs      *int64   `protobuf:"varint,25,opt,name=upload_time_us,json=uploadTimeUs,proto3,oneof" json:"upload_time_us,omitempty"` // DEPRECATED: use turnaround_ms
	LivepeerSessionId *string  `protobuf:"bytes,26,opt,name=livepeer_session_id,json=livepeerSessionId,proto3,oneof" json:"livepeer_session_id,omitempty"`
	SegmentStartMs    *int64   `protobuf:"varint,27,opt,name=segment_start_ms,json=segmentStartMs,proto3,oneof" json:"segment_start_ms,omitempty"`
	InputBytes        *int64   `protobuf:"varint,28,opt,name=input_bytes,json=inputBytes,proto3,oneof" json:"input_bytes,omitempty"`
	OutputBytesTotal  *int64   `protobuf:"varint,29,opt,name=output_bytes_total,json=outputBytesTotal,proto3,oneof" json:"output_bytes_total,omitempty"`
	AttemptCount      *int32   `protobuf:"varint,40,opt,name=attempt_count,json=attemptCount,proto3,oneof" json:"attempt_count,omitempty"`
	TurnaroundMs      *int64   `protobuf:"varint,41,opt,name=turnaround_ms,json=turnaroundMs,proto3,oneof" json:"turnaround_ms,omitempty"`
	SpeedFactor       *float64 `protobuf:"fixed64,42,opt,name=speed_factor,json=speedFactor,proto3,oneof" json:"speed_factor,omitempty"`
	RenditionsJson    *string  `protobuf:"bytes,43,opt,name=renditions_json,json=renditionsJson,proto3,oneof" json:"renditions_json,omitempty"` // JSON array: [{name, bytes}, ...]
	// MistProcAV-specific (from PROCESS_AV_VIRTUAL_SEGMENT_COMPLETE)
	InputFrames         *int64   `protobuf:"varint,30,opt,name=input_frames,json=inputFrames,proto3,oneof" json:"input_frames,omitempty"`    // cumulative
	OutputFrames        *int64   `protobuf:"varint,31,opt,name=output_frames,json=outputFrames,proto3,oneof" json:"output_frames,omitempty"` // cumulative
	DecodeUsPerFrame    *int64   `protobuf:"varint,32,opt,name=decode_us_per_frame,json=decodeUsPerFrame,proto3,oneof" json:"decode_us_per_frame,omitempty"`
	TransformUsPerFrame *int64   `protobuf:"varint,33,opt,name=transform_us_per_frame,json=transformUsPerFrame,proto3,oneof" json:"transform_us_per_frame,omitempty"`
	EncodeUsPerFrame    *int64   `protobuf:"varint,34,opt,name=encode_us_per_frame,json=encodeUsPerFrame,proto3,oneof" json:"encode_us_per_frame,omitempty"`
	IsFinal             *bool    `protobuf:"varint,35,opt,name=is_final,json=isFinal,proto3,oneof" json:"is_final,omitempty"`
	InputFramesDelta    *int64   `protobuf:"varint,50,opt,name=input_frames_delta,json=inputFramesDelta,proto3,oneof" json:"input_frames_delta,omitempty"`    // frames this window
	OutputFramesDelta   *int64   `protobuf:"varint,51,opt,name=output_frames_delta,json=outputFramesDelta,proto3,oneof" json:"output_frames_delta,omitempty"` // frames this window
	InputBytesDelta     *int64   `protobuf:"varint,52,opt,name=input_bytes_delta,json=inputBytesDelta,proto3,oneof" json:"input_bytes_delta,omitempty"`       // bytes this window
	OutputBytesDelta    *int64   `protobuf:"varint,53,opt,name=output_bytes_delta,json=outputBytesDelta,proto3,oneof" json:"output_bytes_delta,omitempty"`    // bytes this window
	InputWidth          *int32   `protobuf:"varint,54,opt,name=input_width,json=inputWidth,proto3,oneof" json:"input_width,omitempty"`
	InputHeight         *int32   `protobuf:"varint,55,opt,name=input_height,json=inputHeight,proto3,oneof" json:"input_height,omitempty"`
	OutputWidth         *int32   `protobuf:"varint,56,opt,name=output_width,json=outputWidth,proto3,oneof" json:"output_width,omitempty"`
	OutputHeight        *int32   `protobuf:"varint,57,opt,name=output_height,json=outputHeight,proto3,oneof" json:"output_height,omitempty"`
	InputFpks           *int32   `protobuf:"varint,58,opt,name=input_fpks,json=inputFpks,proto3,oneof" json:"input_fpks,omitempty"`                            // frames per 1000s (input)
	OutputFpsMeasured   *float64 `protobuf:"fixed64,59,opt,name=output_fps_measured,json=outputFpsMeasured,proto3,oneof" json:"output_fps_measured,omitempty"` // measured output FPS
	SampleRate          *int32   `protobuf:"varint,60,opt,name=sample_rate,json=sampleRate,proto3,oneof" json:"sample_rate,omitempty"`                         // audio sample rate
	Channels            *int32   `protobuf:"varint,61,opt,name=channels,proto3,oneof" json:"channels,omitempty"`                                               // audio channels
	SourceTimestampMs   *int64   `protobuf:"varint,62,opt,name=source_timestamp_ms,json=sourceTimestampMs,proto3,oneof" json:"source_timestamp_ms,omitempty"`
	SinkTimestampMs     *int64   `protobuf:"varint,63,opt,name=sink_timestamp_ms,json=sinkTimestampMs,proto3,oneof" json:"sink_timestamp_ms,omitempty"`
	SourceAdvancedMs    *int64   `protobuf:"varint,64,opt,name=source_advanced_ms,json=sourceAdvancedMs,proto3,oneof" json:"source_advanced_ms,omitempty"`
	SinkAdvancedMs      *int64   `protobuf:"varint,65,opt,name=sink_advanced_ms,json=sinkAdvancedMs,proto3,oneof" json:"sink_advanced_ms,omitempty"`
	RtfIn               *float64 `protobuf:"fixed64,66,opt,name=rtf_in,json=rtfIn,proto3,oneof" json:"rtf_in,omitempty"`    // real-time factor in
	RtfOut              *float64 `protobuf:"fixed64,67,opt,name=rtf_out,json=rtfOut,proto3,oneof" json:"rtf_out,omitempty"` // real-time factor out
	PipelineLagMs       *int64   `protobuf:"varint,68,opt,name=pipeline_lag_ms,json=pipelineLagMs,proto3,oneof" json:"pipeline_lag_ms,omitempty"`
	OutputBitrateBps    *int64   `protobuf:"varint,69,opt,name=output_bitrate_bps,json=outputBitrateBps,proto3,oneof" json:"output_bitrate_bps,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ProcessBillingEvent) Reset() {
	*x = ProcessBillingEvent{}
	mi := &file_ipc_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProcessBillingEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProcessBillingEvent) ProtoMessage() {}

func (x *ProcessBillingEvent) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProcessBillingEvent.ProtoReflect.Descriptor instead.
func (*ProcessBillingEvent) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{70}
}

func (x *ProcessBillingEvent) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *ProcessBillingEvent) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *ProcessBillingEvent) GetProcessType() string {
	if x != nil {
		return x.ProcessType
	}
	return ""
}

func (x *ProcessBillingEvent) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *ProcessBillingEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ProcessBillingEvent) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *ProcessBillingEvent) GetStreamId() string {
	if x != nil && x.StreamId != nil {
		return *x.StreamId
	}
	return ""
}

func (x *ProcessBillingEvent) GetInputCodec() string {
	if x != nil && x.InputCodec != nil {
		return *x.InputCodec
	}
	return ""
}

func (x *ProcessBillingEvent) GetOutputCodec() string {
	if x != nil && x.OutputCodec != nil {
		return *x.OutputCodec
	}
	return ""
}

func (x *ProcessBillingEvent) GetTrackType() string {
	if x != nil && x.TrackType != nil {
		return *x.TrackType
	}
	return ""
}

func (x *ProcessBillingEvent) GetSegmentNumber() int32 {
	if x != nil && x.SegmentNumber != nil {
		return *x.SegmentNumber
	}
	return 0
}

func (x *ProcessBillingEvent) GetWidth() int32 {
	if x != nil && x.Width != nil {
		return *x.Width
	}
	return 0
}

func (x *ProcessBillingEvent) GetHeight() int32 {
	if x != nil && x.Height != nil {
		return *x.Height
	}
	return 0
}

func (x *ProcessBillingEvent) GetRenditionCount() int32 {
	if x != nil && x.RenditionCount != nil {
		return *x.RenditionCount
	}
	return 0
}

func (x *ProcessBillingEvent) GetBroadcasterUrl() string {
	if x != nil && x.BroadcasterUrl != nil {
		return *x.BroadcasterUrl
	}
	return ""
}

func (x *ProcessBillingEvent) GetUploadTimeUs() int64 {
	if x != nil && x.UploadTimeUs != nil {
		return *x.UploadTimeUs
	}
	return 0
}

func (x *ProcessBillingEvent) GetLivepeerSessionId() string {
	if x != nil && x.LivepeerSessionId != nil {
		return *x.LivepeerSessionId
	}
	return ""
}

func (x *ProcessBillingEvent) GetSegmentStartMs() int64 {
	if x != nil && x.SegmentStartMs != nil {
		return *x.SegmentStartMs
	}
	return 0
}

func (x *ProcessBillingEvent) GetInputBytes() int64 {
	if x != nil && x.InputBytes != nil {
		return *x.InputBytes
	}
	return 0
}

func (x *ProcessBillingEvent) GetOutputBytesTotal() int64 {
	if x != nil && x.OutputBytesTotal != nil {
		return *x.OutputBytesTotal
	}
	return 0
}

func (x *ProcessBillingEvent) GetAttemptCount() int32 {
	if x != nil && x.AttemptCount != nil {
		return *x.AttemptCount
	}
	return 0
}

func (x *ProcessBillingEvent) GetTurnaroundMs() int64 {
	if x != nil && x.TurnaroundMs != nil {
		return *x.TurnaroundMs
	}
	return 0
}

func (x *ProcessBillingEvent) GetSpeedFactor() float64 {
	if x != nil && x.SpeedFactor != nil {
		return *x.SpeedFactor
	}
	return 0
}

func (x *ProcessBillingEvent) GetRenditionsJson() string {
	if x != nil && x.RenditionsJson != nil {
		return *x.RenditionsJson
	}
	return ""
}

func (x *ProcessBillingEvent) GetInputFrames() int64 {
	if x != nil && x.InputFrames != nil {
		return *x.InputFrames
	}
	return 0
}

func (x *ProcessBillingEvent) GetOutputFrames() int64 {
	if x != nil && x.OutputFrames != nil {
		return *x.OutputFrames
	}
	return 0
}

func (x *ProcessBillingEvent) GetDecodeUsPerFrame() int64 {
	if x != nil && x.DecodeUsPerFrame != nil {
		return *x.DecodeUsPerFrame
	}
	return 0
}

func (x *ProcessBillingEvent) GetTransformUsPerFrame() int64 {
	if x != nil && x.TransformUsPerFrame != nil {
		return *x.TransformUsPerFrame
	}
	return 0
}

func (x *ProcessBillingEvent) GetEncodeUsPerFrame() int64 {
	if x != nil && x.EncodeUsPerFrame != nil {
		return *x.EncodeUsPerFrame
	}
	return 0
}

func (x *ProcessBillingEvent) GetIsFinal() bool {
	if x != nil && x.IsFinal != nil {
		return *x.IsFinal
	}
	return false
}

func (x *ProcessBillingEvent) GetInputFramesDelta() int64 {
	if x != nil && x.InputFramesDelta != nil {
		return *x.InputFramesDelta
	}
	return 0
}

func (x *ProcessBillingEvent) GetOutputFramesDelta() int64 {
	if x != nil && x.OutputFramesDelta != nil {
		return *x.OutputFramesDelta
	}
	return 0
}

func (x *ProcessBillingEvent) GetInputBytesDelta() int64 {
	if x != nil && x.InputBytesDelta != nil {
		return *x.InputBytesDelta
	}
	return 0
}

func (x *ProcessBillingEvent) GetOutputBytesDelta() int64 {
	if x != nil && x.OutputBytesDelta != nil {
		return *x.OutputBytesDelta
	}
	return 0
}

func (x *ProcessBillingEvent) GetInputWidth() int32 {
	if x != nil && x.InputWidth != nil {
		return *x.InputWidth
	}
	return 0
}

func (x *ProcessBillingEvent) GetInputHeight() int32 {
	if x != nil && x.InputHeight != nil {
		return *x.InputHeight
	}
	return 0
}

func (x *ProcessBillingEvent) GetOutputWidth() int32 {
	if x != nil && x.OutputWidth != nil {
		return *x.OutputWidth
	}
	return 0
}

func (x *ProcessBillingEvent) GetOutputHeight() int32 {
	if x != nil && x.OutputHeight != nil {
		return *x.OutputHeight
	}
	return 0
}

func (x *ProcessBillingEvent) GetInputFpks() int32 {
	if x != nil && x.InputFpks != nil {
		return *x.InputFpks
	}
	return 0
}

func (x *ProcessBillingEvent) GetOutputFpsMeasured() float64 {
	if x != nil && x.OutputFpsMeasured != nil {
		return *x.OutputFpsMeasured
	}
	return 0
}

func (x *ProcessBillingEvent) GetSampleRate() int32 {
	if x != nil && x.SampleRate != nil {
		return *x.SampleRate
	}
	return 0
}

func (x *ProcessBillingEvent) GetChannels() int32 {
	if x != nil && x.Channels != nil {
		return *x.Channels
	}
	return 0
}

func (x *ProcessBillingEvent) GetSourceTimestampMs() int64 {
	if x != nil && x.SourceTimestampMs != nil {
		return *x.SourceTimestampMs
	}
	return 0
}

func (x *ProcessBillingEvent) GetSinkTimestampMs() int64 {
	if x != nil && x.SinkTimestampMs != nil {
		return *x.SinkTimestampMs
	}
	return 0
}

func (x *ProcessBillingEvent) GetSourceAdvancedMs() int64 {
	if x != nil && x.SourceAdvancedMs != nil {
		return *x.SourceAdvancedMs
	}
	return 0
}

func (x *ProcessBillingEvent) GetSinkAdvancedMs() int64 {
	if x != nil && x.SinkAdvancedMs != nil {
		return *x.SinkAdvancedMs
	}
	return 0
}

func (x *ProcessBillingEvent) GetRtfIn() float64 {
	if x != nil && x.RtfIn != nil {
		return *x.RtfIn
	}
	return 0
}

func (x *ProcessBillingEvent) GetRtfOut() float64 {
	if x != nil && x.RtfOut != nil {
		return *x.RtfOut
	}
	return 0
}

func (x *ProcessBillingEvent) GetPipelineLagMs() int64 {
	if x != nil && x.PipelineLagMs != nil {
		return *x.PipelineLagMs
	}
	return 0
}

func (x *ProcessBillingEvent) GetOutputBitrateBps() int64 {
	if x != nil && x.OutputBitrateBps != nil {
		return *x.OutputBitrateBps
	}
	return 0
}

type StorageInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	LocalPath     string                 `protobuf:"bytes,1,opt,name=local_path,json=localPath,proto3" json:"local_path,omitempty"`
	S3Bucket      string                 `protobuf:"bytes,2,opt,name=s3_bucket,json=s3Bucket,proto3" json:"s3_bucket,omitempty"`
	S3Prefix      string                 `protobuf:"bytes,3,opt,name=s3_prefix,json=s3Prefix,proto3" json:"s3_prefix,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StorageInfo) Reset() {
	*x = StorageInfo{}
	mi := &file_ipc_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageInfo) ProtoMessage() {}

func (x *StorageInfo) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageInfo.ProtoReflect.Descriptor instead.
func (*StorageInfo) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{71}
}

func (x *StorageInfo) GetLocalPath() string {
	if x != nil {
		return x.LocalPath
	}
	return ""
}

func (x *StorageInfo) GetS3Bucket() string {
	if x != nil {
		return x.S3Bucket
	}
	return ""
}

func (x *StorageInfo) GetS3Prefix() string {
	if x != nil {
		return x.S3Prefix
	}
	return ""
}

type NodeLimits struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	MaxTranscodes        int32                  `protobuf:"varint,1,opt,name=max_transcodes,json=maxTranscodes,proto3" json:"max_transcodes,omitempty"`
	StorageCapacityBytes uint64                 `protobuf:"varint,2,opt,name=storage_capacity_bytes,json=storageCapacityBytes,proto3" json:"storage_capacity_bytes,omitempty"`
	StorageUsedBytes     uint64                 `protobuf:"varint,3,opt,name=storage_used_bytes,json=storageUsedBytes,proto3" json:"storage_used_bytes,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *NodeLimits) Reset() {
	*x = NodeLimits{}
	mi := &file_ipc_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeLimits) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeLimits) ProtoMessage() {}

func (x *NodeLimits) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeLimits.ProtoReflect.Descriptor instead.
func (*NodeLimits) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{72}
}

func (x *NodeLimits) GetMaxTranscodes() int32 {
	if x != nil {
		return x.MaxTranscodes
	}
	return 0
}

func (x *NodeLimits) GetStorageCapacityBytes() uint64 {
	if x != nil {
		return x.StorageCapacityBytes
	}
	return 0
}

func (x *NodeLimits) GetStorageUsedBytes() uint64 {
	if x != nil {
		return x.StorageUsedBytes
	}
	return 0
}

type StreamData struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	Total      uint64                 `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`                          // Total viewers
	Inputs     uint32                 `protobuf:"varint,2,opt,name=inputs,proto3" json:"inputs,omitempty"`                        // Input count
	BytesUp    uint64                 `protobuf:"varint,3,opt,name=bytes_up,json=bytesUp,proto3" json:"bytes_up,omitempty"`       // Upload bytes
	BytesDown  uint64                 `protobuf:"varint,4,opt,name=bytes_down,json=bytesDown,proto3" json:"bytes_down,omitempty"` // Download bytes
	Bandwidth  uint32                 `protobuf:"varint,5,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`                  // Bandwidth per viewer
	Replicated bool                   `protobuf:"varint,6,opt,name=replicated,proto3" json:"replicated,omitempty"`                // True if this is a replicated (pull) stream
	// Packet stats (for QoS monitoring) - MistServer pkts array
	PacketCounts []int64 `protobuf:"varint,7,rep,packed,name=packet_counts,json=packetCounts,proto3" json:"packet_counts,omitempty"` // [sent, lost, retransmit]
	// Connection totals - MistServer tot array
	TotalConnections []int64 `protobuf:"varint,8,rep,packed,name=total_connections,json=totalConnections,proto3" json:"total_connections,omitempty"` // [total_viewers, total_inputs, total_outputs]
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *StreamData) Reset() {
	*x = StreamData{}
	mi := &file_ipc_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamData) ProtoMessage() {}

func (x *StreamData) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamData.ProtoReflect.Descriptor instead.
func (*StreamData) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{73}
}

func (x *StreamData) GetTotal() uint64 {
	if x != nil {
		return x.Total
	}
	return 0
}

func (x *StreamData) GetInputs() uint32 {
	if x != nil {
		return x.Inputs
	}
	return 0
}

func (x *StreamData) GetBytesUp() uint64 {
	if x != nil {
		return x.BytesUp
	}
	return 0
}

func (x *StreamData) GetBytesDown() uint64 {
	if x != nil {
		return x.BytesDown
	}
	return 0
}

func (x *StreamData) GetBandwidth() uint32 {
	if x != nil {
		return x.Bandwidth
	}
	return 0
}

func (x *StreamData) GetReplicated() bool {
	if x != nil {
		return x.Replicated
	}
	return false
}

func (x *StreamData) GetPacketCounts() []int64 {
	if x != nil {
		return x.PacketCounts
	}
	return nil
}

func (x *StreamData) GetTotalConnections() []int64 {
	if x != nil {
		return x.TotalConnections
	}
	return nil
}

// Stream track information (replaces JSON parsing)
type StreamTrack struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	TrackName   string                 `protobuf:"bytes,1,opt,name=track_name,json=trackName,proto3" json:"track_name,omitempty"` // e.g., "video_1", "audio_1", "meta_1"
	TrackType   string                 `protobuf:"bytes,2,opt,name=track_type,json=trackType,proto3" json:"track_type,omitempty"` // "video", "audio", "meta", "unknown"
	Codec       string                 `protobuf:"bytes,3,opt,name=codec,proto3" json:"codec,omitempty"`                          // H264, AAC, JSON, etc.
	BitrateKbps *int32                 `protobuf:"varint,4,opt,name=bitrate_kbps,json=bitrateKbps,proto3,oneof" json:"bitrate_kbps,omitempty"`
	BitrateBps  *int64                 `protobuf:"varint,5,opt,name=bitrate_bps,json=bitrateBps,proto3,oneof" json:"bitrate_bps,omitempty"`
	Buffer      *int32                 `protobuf:"varint,6,opt,name=buffer,proto3,oneof" json:"buffer,omitempty"`
	Jitter      *int32                 `protobuf:"varint,7,opt,name=jitter,proto3,oneof" json:"jitter,omitempty"`
	// Video-specific fields
	Width      *int32   `protobuf:"varint,8,opt,name=width,proto3,oneof" json:"width,omitempty"`
	Height     *int32   `protobuf:"varint,9,opt,name=height,proto3,oneof" json:"height,omitempty"`
	Fps        *float64 `protobuf:"fixed64,10,opt,name=fps,proto3,oneof" json:"fps,omitempty"`
	Resolution *string  `protobuf:"bytes,11,opt,name=resolution,proto3,oneof" json:"resolution,omitempty"` // e.g., "1920x1080"
	HasBframes *bool    `protobuf:"varint,12,opt,name=has_bframes,json=hasBframes,proto3,oneof" json:"has_bframes,omitempty"`
	// Audio-specific fields
	Channels   *int32 `protobuf:"varint,13,opt,name=channels,proto3,oneof" json:"channels,omitempty"`
	SampleRate *int32 `protobuf:"varint,14,opt,name=sample_rate,json=sampleRate,proto3,oneof" json:"sample_rate,omitempty"`
	// Frame timing metrics (raw from MistServer keys object)
	FramesMax     *int32   `protobuf:"varint,15,opt,name=frames_max,json=framesMax,proto3,oneof" json:"frames_max,omitempty"`
	FramesMin     *int32   `protobuf:"varint,16,opt,name=frames_min,json=framesMin,proto3,oneof" json:"frames_min,omitempty"`
	FrameMsMax    *float64 `protobuf:"fixed64,17,opt,name=frame_ms_max,json=frameMsMax,proto3,oneof" json:"frame_ms_max,omitempty"`
	FrameMsMin    *float64 `protobuf:"fixed64,18,opt,name=frame_ms_min,json=frameMsMin,proto3,oneof" json:"frame_ms_min,omitempty"`
	KeyframeMsMax *float64 `protobuf:"fixed64,19,opt,name=keyframe_ms_max,json=keyframeMsMax,proto3,oneof" json:"keyframe_ms_max,omitempty"` // Raw keyframe interval max (from keys.ms_max)
	KeyframeMsMin *float64 `protobuf:"fixed64,20,opt,name=keyframe_ms_min,json=keyframeMsMin,proto3,oneof" json:"keyframe_ms_min,omitempty"` // Raw keyframe interval min (from keys.ms_min)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamTrack) Reset() {
	*x = StreamTrack{}
	mi := &file_ipc_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamTrack) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamTrack) ProtoMessage() {}

func (x *StreamTrack) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamTrack.ProtoReflect.Descriptor instead.
func (*StreamTrack) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{74}
}

func (x *StreamTrack) GetTrackName() string {
	if x != nil {
		return x.TrackName
	}
	return ""
}

func (x *StreamTrack) GetTrackType() string {
	if x != nil {
		return x.TrackType
	}
	return ""
}

func (x *StreamTrack) GetCodec() string {
	if x != nil {
		return x.Codec
	}
	return ""
}

func (x *StreamTrack) GetBitrateKbps() int32 {
	if x != nil && x.BitrateKbps != nil {
		return *x.BitrateKbps
	}
	return 0
}

func (x *StreamTrack) GetBitrateBps() int64 {
	if x != nil && x.BitrateBps != nil {
		return *x.BitrateBps
	}
	return 0
}

func (x *StreamTrack) GetBuffer() int32 {
	if x != nil && x.Buffer != nil {
		return *x.Buffer
	}
	return 0
}

func (x *StreamTrack) GetJitter() int32 {
	if x != nil && x.Jitter != nil {
		return *x.Jitter
	}
	return 0
}

func (x *StreamTrack) GetWidth() int32 {
	if x != nil && x.Width != nil {
		return *x.Width
	}
	return 0
}

func (x *StreamTrack) GetHeight() int32 {
	if x != nil && x.Height != nil {
		return *x.Height
	}
	return 0
}

func (x *StreamTrack) GetFps() float64 {
	if x != nil && x.Fps != nil {
		return *x.Fps
	}
	return 0
}

func (x *StreamTrack) GetResolution() string {
	if x != nil && x.Resolution != nil {
		return *x.Resolution
	}
	return ""
}

func (x *StreamTrack) GetHasBframes() bool {
	if x != nil && x.HasBframes != nil {
		return *x.HasBframes
	}
	return false
}

func (x *StreamTrack) GetChannels() int32 {
	if x != nil && x.Channels != nil {
		return *x.Channels
	}
	return 0
}

func (x *StreamTrack) GetSampleRate() int32 {
	if x != nil && x.SampleRate != nil {
		return *x.SampleRate
	}
	return 0
}

func (x *StreamTrack) GetFramesMax() int32 {
	if x != nil && x.FramesMax != nil {
		return *x.FramesMax
	}
	return 0
}

func (x *StreamTrack) GetFramesMin() int32 {
	if x != nil && x.FramesMin != nil {
		return *x.FramesMin
	}
	return 0
}

func (x *StreamTrack) GetFrameMsMax() float64 {
	if x != nil && x.FrameMsMax != nil {
		return *x.FrameMsMax
	}
	return 0
}

func (x *StreamTrack) GetFrameMsMin() float64 {
	if x != nil && x.FrameMsMin != nil {
		return *x.FrameMsMin
	}
	return 0
}

func (x *StreamTrack) GetKeyframeMsMax() float64 {
	if x != nil && x.KeyframeMsMax != nil {
		return *x.KeyframeMsMax
	}
	return 0
}

func (x *StreamTrack) GetKeyframeMsMin() float64 {
	if x != nil && x.KeyframeMsMin != nil {
		return *x.KeyframeMsMin
	}
	return 0
}

type StoredArtifact struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Security: Use opaque identifiers, never expose tenant_id on edge nodes
	ClipHash      string                     `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`                                                               // Opaque identifier for the clip
	StreamName    string                     `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`                                                         // Stream name (safe to expose)
	FilePath      string                     `protobuf:"bytes,3,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`                                                               // Local file path on storage node
	S3Url         string                     `protobuf:"bytes,4,opt,name=s3_url,json=s3Url,proto3" json:"s3_url,omitempty"`                                                                        // S3 URL if uploaded to cloud storage
	SizeBytes     uint64                     `protobuf:"varint,5,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`                                                           // File size in bytes
	CreatedAt     int64                      `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`                                                           // Creation timestamp (Unix seconds)
	Format        string                     `protobuf:"bytes,7,opt,name=format,proto3" json:"format,omitempty"`                                                                                   // File format (mp4, webm, etc.)
	HasDtsh       bool                       `protobuf:"varint,8,opt,name=has_dtsh,json=hasDtsh,proto3" json:"has_dtsh,omitempty"`                                                                 // True if .dtsh index file exists locally
	AccessCount   uint64                     `protobuf:"varint,9,opt,name=access_count,json=accessCount,proto3" json:"access_count,omitempty"`                                                     // Local access count (best-effort, per node)
	LastAccessed  int64                      `protobuf:"varint,10,opt,name=last_accessed,json=lastAccessed,proto3" json:"last_accessed,omitempty"`                                                 // Last access timestamp (Unix seconds)
	ArtifactType  ArtifactEvent_ArtifactType `protobuf:"varint,11,opt,name=artifact_type,json=artifactType,proto3,enum=helmsmancontrol.ArtifactEvent_ArtifactType" json:"artifact_type,omitempty"` // Explicit artifact type (clip/dvr/vod)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StoredArtifact) Reset() {
	*x = StoredArtifact{}
	mi := &file_ipc_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StoredArtifact) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoredArtifact) ProtoMessage() {}

func (x *StoredArtifact) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StoredArtifact.ProtoReflect.Descriptor instead.
func (*StoredArtifact) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{75}
}

func (x *StoredArtifact) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *StoredArtifact) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *StoredArtifact) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *StoredArtifact) GetS3Url() string {
	if x != nil {
		return x.S3Url
	}
	return ""
}

func (x *StoredArtifact) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *StoredArtifact) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *StoredArtifact) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *StoredArtifact) GetHasDtsh() bool {
	if x != nil {
		return x.HasDtsh
	}
	return false
}

func (x *StoredArtifact) GetAccessCount() uint64 {
	if x != nil {
		return x.AccessCount
	}
	return 0
}

func (x *StoredArtifact) GetLastAccessed() int64 {
	if x != nil {
		return x.LastAccessed
	}
	return 0
}

func (x *StoredArtifact) GetArtifactType() ArtifactEvent_ArtifactType {
	if x != nil {
		return x.ArtifactType
	}
	return ArtifactEvent_ARTIFACT_TYPE_UNSPECIFIED
}

type StreamProcess struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Process         string                 `protobuf:"bytes,1,opt,name=process,proto3" json:"process,omitempty"`
	Codec           string                 `protobuf:"bytes,2,opt,name=codec,proto3" json:"codec,omitempty"`
	Bitrate         int64                  `protobuf:"varint,3,opt,name=bitrate,proto3" json:"bitrate,omitempty"`
	TrackSelect     string                 `protobuf:"bytes,4,opt,name=track_select,json=trackSelect,proto3" json:"track_select,omitempty"`
	TrackInhibit    string                 `protobuf:"bytes,5,opt,name=track_inhibit,json=trackInhibit,proto3" json:"track_inhibit,omitempty"`
	RestartType     string                 `protobuf:"bytes,6,opt,name=restart_type,json=restartType,proto3" json:"restart_type,omitempty"`
	Inconsequential bool                   `protobuf:"varint,7,opt,name=inconsequential,proto3" json:"inconsequential,omitempty"`
	ExitUnmask      bool                   `protobuf:"varint,8,opt,name=exit_unmask,json=exitUnmask,proto3" json:"exit_unmask,omitempty"`
	Extra           map[string]string      `protobuf:"bytes,100,rep,name=extra,proto3" json:"extra,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StreamProcess) Reset() {
	*x = StreamProcess{}
	mi := &file_ipc_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamProcess) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamProcess) ProtoMessage() {}

func (x *StreamProcess) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamProcess.ProtoReflect.Descriptor instead.
func (*StreamProcess) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{76}
}

func (x *StreamProcess) GetProcess() string {
	if x != nil {
		return x.Process
	}
	return ""
}

func (x *StreamProcess) GetCodec() string {
	if x != nil {
		return x.Codec
	}
	return ""
}

func (x *StreamProcess) GetBitrate() int64 {
	if x != nil {
		return x.Bitrate
	}
	return 0
}

func (x *StreamProcess) GetTrackSelect() string {
	if x != nil {
		return x.TrackSelect
	}
	return ""
}

func (x *StreamProcess) GetTrackInhibit() string {
	if x != nil {
		return x.TrackInhibit
	}
	return ""
}

func (x *StreamProcess) GetRestartType() string {
	if x != nil {
		return x.RestartType
	}
	return ""
}

func (x *StreamProcess) GetInconsequential() bool {
	if x != nil {
		return x.Inconsequential
	}
	return false
}

func (x *StreamProcess) GetExitUnmask() bool {
	if x != nil {
		return x.ExitUnmask
	}
	return false
}

func (x *StreamProcess) GetExtra() map[string]string {
	if x != nil {
		return x.Extra
	}
	return nil
}

type StreamDef struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Realtime      bool                   `protobuf:"varint,2,opt,name=realtime,proto3" json:"realtime,omitempty"`
	StopSessions  bool                   `protobuf:"varint,3,opt,name=stop_sessions,json=stopSessions,proto3" json:"stop_sessions,omitempty"`
	Tags          []string               `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty"`
	Processes     []*StreamProcess       `protobuf:"bytes,5,rep,name=processes,proto3" json:"processes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDef) Reset() {
	*x = StreamDef{}
	mi := &file_ipc_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDef) ProtoMessage() {}

func (x *StreamDef) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDef.ProtoReflect.Descriptor instead.
func (*StreamDef) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{77}
}

func (x *StreamDef) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *StreamDef) GetRealtime() bool {
	if x != nil {
		return x.Realtime
	}
	return false
}

func (x *StreamDef) GetStopSessions() bool {
	if x != nil {
		return x.StopSessions
	}
	return false
}

func (x *StreamDef) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *StreamDef) GetProcesses() []*StreamProcess {
	if x != nil {
		return x.Processes
	}
	return nil
}

type StreamTemplate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Def           *StreamDef             `protobuf:"bytes,2,opt,name=def,proto3" json:"def,omitempty"`
	Roles         []string               `protobuf:"bytes,3,rep,name=roles,proto3" json:"roles,omitempty"`
	Caps          []string               `protobuf:"bytes,4,rep,name=caps,proto3" json:"caps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamTemplate) Reset() {
	*x = StreamTemplate{}
	mi := &file_ipc_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamTemplate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamTemplate) ProtoMessage() {}

func (x *StreamTemplate) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamTemplate.ProtoReflect.Descriptor instead.
func (*StreamTemplate) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{78}
}

func (x *StreamTemplate) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *StreamTemplate) GetDef() *StreamDef {
	if x != nil {
		return x.Def
	}
	return nil
}

func (x *StreamTemplate) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

func (x *StreamTemplate) GetCaps() []string {
	if x != nil {
		return x.Caps
	}
	return nil
}

type ConfigSeed struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	NodeId       string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Latitude     float64                `protobuf:"fixed64,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude    float64                `protobuf:"fixed64,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	LocationName string                 `protobuf:"bytes,4,opt,name=location_name,json=locationName,proto3" json:"location_name,omitempty"`
	// Tenant owning this node (resolved by Foghorn via Quartermaster)
	TenantId  string            `protobuf:"bytes,5,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	Templates []*StreamTemplate `protobuf:"bytes,10,rep,name=templates,proto3" json:"templates,omitempty"`
	// Processing configuration (Gateway availability, codec support)
	Processing *ProcessingConfig `protobuf:"bytes,11,opt,name=processing,proto3" json:"processing,omitempty"`
	// Authoritative operational mode set by Foghorn. Helmsman must apply this.
	OperationalMode NodeOperationalMode `protobuf:"varint,12,opt,name=operational_mode,json=operationalMode,proto3,enum=helmsmancontrol.NodeOperationalMode" json:"operational_mode,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ConfigSeed) Reset() {
	*x = ConfigSeed{}
	mi := &file_ipc_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigSeed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigSeed) ProtoMessage() {}

func (x *ConfigSeed) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigSeed.ProtoReflect.Descriptor instead.
func (*ConfigSeed) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{79}
}

func (x *ConfigSeed) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *ConfigSeed) GetLatitude() float64 {
	if x != nil {
		return x.Latitude
	}
	return 0
}

func (x *ConfigSeed) GetLongitude() float64 {
	if x != nil {
		return x.Longitude
	}
	return 0
}

func (x *ConfigSeed) GetLocationName() string {
	if x != nil {
		return x.LocationName
	}
	return ""
}

func (x *ConfigSeed) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *ConfigSeed) GetTemplates() []*StreamTemplate {
	if x != nil {
		return x.Templates
	}
	return nil
}

func (x *ConfigSeed) GetProcessing() *ProcessingConfig {
	if x != nil {
		return x.Processing
	}
	return nil
}

func (x *ConfigSeed) GetOperationalMode() NodeOperationalMode {
	if x != nil {
		return x.OperationalMode
	}
	return NodeOperationalMode_NODE_OPERATIONAL_MODE_UNSPECIFIED
}

// Transcode profile for ABR ladder generation
type TranscodeProfile struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`        // e.g., "720p", "1080p", "audio_only"
	Codec         string                 `protobuf:"bytes,2,opt,name=codec,proto3" json:"codec,omitempty"`      // H264, H265, AAC
	Bitrate       int32                  `protobuf:"varint,3,opt,name=bitrate,proto3" json:"bitrate,omitempty"` // bps
	Width         int32                  `protobuf:"varint,4,opt,name=width,proto3" json:"width,omitempty"`
	Height        int32                  `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
	Fps           float64                `protobuf:"fixed64,6,opt,name=fps,proto3" json:"fps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TranscodeProfile) Reset() {
	*x = TranscodeProfile{}
	mi := &file_ipc_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranscodeProfile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscodeProfile) ProtoMessage() {}

func (x *TranscodeProfile) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscodeProfile.ProtoReflect.Descriptor instead.
func (*TranscodeProfile) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{80}
}

func (x *TranscodeProfile) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TranscodeProfile) GetCodec() string {
	if x != nil {
		return x.Codec
	}
	return ""
}

func (x *TranscodeProfile) GetBitrate() int32 {
	if x != nil {
		return x.Bitrate
	}
	return 0
}

func (x *TranscodeProfile) GetWidth() int32 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *TranscodeProfile) GetHeight() int32 {
	if x != nil {
		return x.Height
	}
	return 0
}

func (x *TranscodeProfile) GetFps() float64 {
	if x != nil {
		return x.Fps
	}
	return 0
}

// Transcode job request (Foghorn  Helmsman)
type TranscodeJobRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	JobId         string                 `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	TenantId      string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	ArtifactHash  string                 `protobuf:"bytes,3,opt,name=artifact_hash,json=artifactHash,proto3" json:"artifact_hash,omitempty"` // Source artifact
	SourceUrl     string                 `protobuf:"bytes,4,opt,name=source_url,json=sourceUrl,proto3" json:"source_url,omitempty"`          // Presigned URL for source
	Profiles      []*TranscodeProfile    `protobuf:"bytes,5,rep,name=profiles,proto3" json:"profiles,omitempty"`
	UseGateway    bool                   `protobuf:"varint,6,opt,name=use_gateway,json=useGateway,proto3" json:"use_gateway,omitempty"` // Use Livepeer Gateway if true
	GatewayUrl    string                 `protobuf:"bytes,7,opt,name=gateway_url,json=gatewayUrl,proto3" json:"gateway_url,omitempty"`  // Gateway URL (if use_gateway=true)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TranscodeJobRequest) Reset() {
	*x = TranscodeJobRequest{}
	mi := &file_ipc_proto_msgTypes[81]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranscodeJobRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscodeJobRequest) ProtoMessage() {}

func (x *TranscodeJobRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[81]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscodeJobRequest.ProtoReflect.Descriptor instead.
func (*TranscodeJobRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{81}
}

func (x *TranscodeJobRequest) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

func (x *TranscodeJobRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *TranscodeJobRequest) GetArtifactHash() string {
	if x != nil {
		return x.ArtifactHash
	}
	return ""
}

func (x *TranscodeJobRequest) GetSourceUrl() string {
	if x != nil {
		return x.SourceUrl
	}
	return ""
}

func (x *TranscodeJobRequest) GetProfiles() []*TranscodeProfile {
	if x != nil {
		return x.Profiles
	}
	return nil
}

func (x *TranscodeJobRequest) GetUseGateway() bool {
	if x != nil {
		return x.UseGateway
	}
	return false
}

func (x *TranscodeJobRequest) GetGatewayUrl() string {
	if x != nil {
		return x.GatewayUrl
	}
	return ""
}

// Transcode job progress (Helmsman  Foghorn)
type TranscodeJobProgress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	JobId         string                 `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Percent       int32                  `protobuf:"varint,2,opt,name=percent,proto3" json:"percent,omitempty"` // 0-100
	Status        string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`    // queued, processing, completed, failed
	Message       string                 `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`  // Status message / error
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TranscodeJobProgress) Reset() {
	*x = TranscodeJobProgress{}
	mi := &file_ipc_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranscodeJobProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscodeJobProgress) ProtoMessage() {}

func (x *TranscodeJobProgress) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscodeJobProgress.ProtoReflect.Descriptor instead.
func (*TranscodeJobProgress) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{82}
}

func (x *TranscodeJobProgress) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

func (x *TranscodeJobProgress) GetPercent() int32 {
	if x != nil {
		return x.Percent
	}
	return 0
}

func (x *TranscodeJobProgress) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *TranscodeJobProgress) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// Transcode job completion (Helmsman  Foghorn)
type TranscodeJobComplete struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	JobId              string                 `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Status             string                 `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`                                                     // success, failed
	OutputArtifactHash string                 `protobuf:"bytes,3,opt,name=output_artifact_hash,json=outputArtifactHash,proto3" json:"output_artifact_hash,omitempty"` // New artifact hash for output
	OutputS3Url        string                 `protobuf:"bytes,4,opt,name=output_s3_url,json=outputS3Url,proto3" json:"output_s3_url,omitempty"`                      // S3 URL of transcoded output
	Error              string                 `protobuf:"bytes,5,opt,name=error,proto3" json:"error,omitempty"`                                                       // Error message if failed
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *TranscodeJobComplete) Reset() {
	*x = TranscodeJobComplete{}
	mi := &file_ipc_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranscodeJobComplete) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranscodeJobComplete) ProtoMessage() {}

func (x *TranscodeJobComplete) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranscodeJobComplete.ProtoReflect.Descriptor instead.
func (*TranscodeJobComplete) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{83}
}

func (x *TranscodeJobComplete) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

func (x *TranscodeJobComplete) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *TranscodeJobComplete) GetOutputArtifactHash() string {
	if x != nil {
		return x.OutputArtifactHash
	}
	return ""
}

func (x *TranscodeJobComplete) GetOutputS3Url() string {
	if x != nil {
		return x.OutputS3Url
	}
	return ""
}

func (x *TranscodeJobComplete) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type APIRequestBatch struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Timestamp     int64                  `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                    // Flush timestamp (Unix seconds)
	SourceNode    string                 `protobuf:"bytes,2,opt,name=source_node,json=sourceNode,proto3" json:"source_node,omitempty"` // Gateway instance ID
	Aggregates    []*APIRequestAggregate `protobuf:"bytes,3,rep,name=aggregates,proto3" json:"aggregates,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *APIRequestBatch) Reset() {
	*x = APIRequestBatch{}
	mi := &file_ipc_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *APIRequestBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*APIRequestBatch) ProtoMessage() {}

func (x *APIRequestBatch) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use APIRequestBatch.ProtoReflect.Descriptor instead.
func (*APIRequestBatch) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{84}
}

func (x *APIRequestBatch) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *APIRequestBatch) GetSourceNode() string {
	if x != nil {
		return x.SourceNode
	}
	return ""
}

func (x *APIRequestBatch) GetAggregates() []*APIRequestAggregate {
	if x != nil {
		return x.Aggregates
	}
	return nil
}

type APIRequestAggregate struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	TenantId        string                 `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	AuthType        string                 `protobuf:"bytes,2,opt,name=auth_type,json=authType,proto3" json:"auth_type,omitempty"`                // jwt, api_token, wallet
	OperationType   string                 `protobuf:"bytes,3,opt,name=operation_type,json=operationType,proto3" json:"operation_type,omitempty"` // query, mutation, subscription
	OperationName   string                 `protobuf:"bytes,4,opt,name=operation_name,json=operationName,proto3" json:"operation_name,omitempty"` // GetStreams, CreateClip, etc. (empty if anonymous)
	RequestCount    uint32                 `protobuf:"varint,5,opt,name=request_count,json=requestCount,proto3" json:"request_count,omitempty"`
	ErrorCount      uint32                 `protobuf:"varint,6,opt,name=error_count,json=errorCount,proto3" json:"error_count,omitempty"`
	TotalDurationMs uint64                 `protobuf:"varint,7,opt,name=total_duration_ms,json=totalDurationMs,proto3" json:"total_duration_ms,omitempty"`
	TotalComplexity uint32                 `protobuf:"varint,8,opt,name=total_complexity,json=totalComplexity,proto3" json:"total_complexity,omitempty"` // Sum of GraphQL complexity scores
	UserHashes      []uint64               `protobuf:"varint,9,rep,packed,name=user_hashes,json=userHashes,proto3" json:"user_hashes,omitempty"`         // Hashed user IDs observed in the aggregate window
	TokenHashes     []uint64               `protobuf:"varint,10,rep,packed,name=token_hashes,json=tokenHashes,proto3" json:"token_hashes,omitempty"`     // Hashed API token IDs observed in the aggregate window
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *APIRequestAggregate) Reset() {
	*x = APIRequestAggregate{}
	mi := &file_ipc_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *APIRequestAggregate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*APIRequestAggregate) ProtoMessage() {}

func (x *APIRequestAggregate) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use APIRequestAggregate.ProtoReflect.Descriptor instead.
func (*APIRequestAggregate) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{85}
}

func (x *APIRequestAggregate) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *APIRequestAggregate) GetAuthType() string {
	if x != nil {
		return x.AuthType
	}
	return ""
}

func (x *APIRequestAggregate) GetOperationType() string {
	if x != nil {
		return x.OperationType
	}
	return ""
}

func (x *APIRequestAggregate) GetOperationName() string {
	if x != nil {
		return x.OperationName
	}
	return ""
}

func (x *APIRequestAggregate) GetRequestCount() uint32 {
	if x != nil {
		return x.RequestCount
	}
	return 0
}

func (x *APIRequestAggregate) GetErrorCount() uint32 {
	if x != nil {
		return x.ErrorCount
	}
	return 0
}

func (x *APIRequestAggregate) GetTotalDurationMs() uint64 {
	if x != nil {
		return x.TotalDurationMs
	}
	return 0
}

func (x *APIRequestAggregate) GetTotalComplexity() uint32 {
	if x != nil {
		return x.TotalComplexity
	}
	return 0
}

func (x *APIRequestAggregate) GetUserHashes() []uint64 {
	if x != nil {
		return x.UserHashes
	}
	return nil
}

func (x *APIRequestAggregate) GetTokenHashes() []uint64 {
	if x != nil {
		return x.TokenHashes
	}
	return nil
}

var File_ipc_proto protoreflect.FileDescriptor

const file_ipc_proto_rawDesc = "" +
	"\n" +
	"\tipc.proto\x12\x0fhelmsmancontrol\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.proto\"F\n" +
	"\tGeoBucket\x12\x19\n" +
	"\bh3_index\x18\x01 \x01(\x04R\ah3Index\x12\x1e\n" +
	"\n" +
	"resolution\x18\x02 \x01(\rR\n" +
	"resolution\"\xb7\a\n" +
	"\fServiceEvent\x12\x19\n" +
	"\bevent_id\x18\x01 \x01(\tR\aeventId\x12\x1d\n" +
	"\n" +
	"event_type\x18\x02 \x01(\tR\teventType\x128\n" +
	"\ttimestamp\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12\x16\n" +
	"\x06source\x18\x04 \x01(\tR\x06source\x12\x1b\n" +
	"\ttenant_id\x18\x05 \x01(\tR\btenantId\x12\x17\n" +
	"\auser_id\x18\x06 \x01(\tR\x06userId\x12#\n" +
	"\rresource_type\x18\a \x01(\tR\fresourceType\x12\x1f\n" +
	"\vresource_id\x18\b \x01(\tR\n" +
	"resourceId\x12N\n" +
	"\x11api_request_batch\x18\x14 \x01(\v2 .helmsmancontrol.APIRequestBatchH\x00R\x0fapiRequestBatch\x12;\n" +
	"\n" +
	"auth_event\x18\x15 \x01(\v2\x1a.helmsmancontrol.AuthEventH\x00R\tauthEvent\x12A\n" +
	"\ftenant_event\x18\x16 \x01(\v2\x1c.helmsmancontrol.TenantEventH\x00R\vtenantEvent\x12D\n" +
	"\rcluster_event\x18\x17 \x01(\v2\x1d.helmsmancontrol.ClusterEventH\x00R\fclusterEvent\x12T\n" +
	"\x13stream_change_event\x18\x18 \x01(\v2\".helmsmancontrol.StreamChangeEventH\x00R\x11streamChangeEvent\x12K\n" +
	"\x10stream_key_event\x18\x19 \x01(\v2\x1f.helmsmancontrol.StreamKeyEventH\x00R\x0estreamKeyEvent\x12D\n" +
	"\rbilling_event\x18\x1a \x01(\v2\x1d.helmsmancontrol.BillingEventH\x00R\fbillingEvent\x12L\n" +
	"\rsupport_event\x18\x1b \x01(\v2%.helmsmancontrol.MessageLifecycleDataH\x00R\fsupportEvent\x12G\n" +
	"\x0eartifact_event\x18\x1c \x01(\v2\x1e.helmsmancontrol.ArtifactEventH\x00R\rartifactEventB\t\n" +
	"\apayload\"\xc9\x01\n" +
	"\tAuthEvent\x12\x17\n" +
	"\auser_id\x18\x01 \x01(\tR\x06userId\x12\x1b\n" +
	"\ttenant_id\x18\x02 \x01(\tR\btenantId\x12\x1b\n" +
	"\tauth_type\x18\x03 \x01(\tR\bauthType\x12\x1b\n" +
	"\twallet_id\x18\x04 \x01(\tR\bwalletId\x12\x19\n" +
	"\btoken_id\x18\x05 \x01(\tR\atokenId\x12\x14\n" +
	"\x05error\x18\x06 \x01(\tR\x05error\x12\x1b\n" +
	"\tip_bucket\x18\a \x01(\tR\bipBucket\"Q\n" +
	"\vTenantEvent\x12\x1b\n" +
	"\ttenant_id\x18\x01 \x01(\tR\btenantId\x12%\n" +
	"\x0echanged_fields\x18\x02 \x03(\tR\rchangedFields\"\xa8\x01\n" +
	"\fClusterEvent\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tR\tclusterId\x12\x1b\n" +
	"\ttenant_id\x18\x02 \x01(\tR\btenantId\x12\x1b\n" +
	"\tinvite_id\x18\x03 \x01(\tR\binviteId\x12'\n" +
	"\x0fsubscription_id\x18\x04 \x01(\tR\x0esubscriptionId\x12\x16\n" +
	"\x06reason\x18\x05 \x01(\tR\x06reason\"W\n" +
	"\x11StreamChangeEvent\x12\x1b\n" +
	"\tstream_id\x18\x01 \x01(\tR\bstreamId\x12%\n" +
	"\x0echanged_fields\x18\x02 \x03(\tR\rchangedFields\"D\n" +
	"\x0eStreamKeyEvent\x12\x1b\n" +
	"\tstream_id\x18\x01 \x01(\tR\bstreamId\x12\x15\n" +
	"\x06key_id\x18\x02 \x01(\tR\x05keyId\"\x95\x02\n" +
	"\fBillingEvent\x12\x1b\n" +
	"\ttenant_id\x18\x01 \x01(\tR\btenantId\x12\x1d\n" +
	"\n" +
	"payment_id\x18\x02 \x01(\tR\tpaymentId\x12'\n" +
	"\x0fsubscription_id\x18\x03 \x01(\tR\x0esubscriptionId\x12\x1d\n" +
	"\n" +
	"invoice_id\x18\x04 \x01(\tR\tinvoiceId\x12\x19\n" +
	"\btopup_id\x18\x05 \x01(\tR\atopupId\x12\x16\n" +
	"\x06amount\x18\x06 \x01(\x01R\x06amount\x12\x1a\n" +
	"\bcurrency\x18\a \x01(\tR\bcurrency\x12\x1a\n" +
	"\bprovider\x18\b \x01(\tR\bprovider\x12\x16\n" +
	"\x06status\x18\t \x01(\tR\x06status\"\xcb\x03\n" +
	"\rArtifactEvent\x12P\n" +
	"\rartifact_type\x18\x01 \x01(\x0e2+.helmsmancontrol.ArtifactEvent.ArtifactTypeR\fartifactType\x12\x1f\n" +
	"\vartifact_id\x18\x02 \x01(\tR\n" +
	"artifactId\x12\x1b\n" +
	"\tstream_id\x18\x03 \x01(\tR\bstreamId\x12\x16\n" +
	"\x06status\x18\x04 \x01(\tR\x06status\x12\"\n" +
	"\n" +
	"started_at\x18\x05 \x01(\x03H\x00R\tstartedAt\x88\x01\x01\x12&\n" +
	"\fcompleted_at\x18\x06 \x01(\x03H\x01R\vcompletedAt\x88\x01\x01\x12\"\n" +
	"\n" +
	"expires_at\x18\a \x01(\x03H\x02R\texpiresAt\x88\x01\x01\"s\n" +
	"\fArtifactType\x12\x1d\n" +
	"\x19ARTIFACT_TYPE_UNSPECIFIED\x10\x00\x12\x16\n" +
	"\x12ARTIFACT_TYPE_CLIP\x10\x01\x12\x15\n" +
	"\x11ARTIFACT_TYPE_DVR\x10\x02\x12\x15\n" +
	"\x11ARTIFACT_TYPE_VOD\x10\x03B\r\n" +
	"\v_started_atB\x0f\n" +
	"\r_completed_atB\r\n" +
	"\v_expires_at\"\xb5\x15\n" +
	"\x0eControlMessage\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x123\n" +
	"\asent_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x06sentAt\x127\n" +
	"\bregister\x18\n" +
	" \x01(\v2\x19.helmsmancontrol.RegisterH\x00R\bregister\x12N\n" +
	"\x11clip_pull_request\x18\f \x01(\v2 .helmsmancontrol.ClipPullRequestH\x00R\x0fclipPullRequest\x12D\n" +
	"\rclip_progress\x18\r \x01(\v2\x1d.helmsmancontrol.ClipProgressH\x00R\fclipProgress\x128\n" +
	"\tclip_done\x18\x0e \x01(\v2\x19.helmsmancontrol.ClipDoneH\x00R\bclipDone\x125\n" +
	"\x05error\x18\x0f \x01(\v2\x1d.helmsmancontrol.ControlErrorH\x00R\x05error\x12:\n" +
	"\theartbeat\x18\x10 \x01(\v2\x1a.helmsmancontrol.HeartbeatH\x00R\theartbeat\x12N\n" +
	"\x11dvr_start_request\x18\x12 \x01(\v2 .helmsmancontrol.DVRStartRequestH\x00R\x0fdvrStartRequest\x12A\n" +
	"\fdvr_progress\x18\x13 \x01(\v2\x1c.helmsmancontrol.DVRProgressH\x00R\vdvrProgress\x12>\n" +
	"\vdvr_stopped\x18\x14 \x01(\v2\x1b.helmsmancontrol.DVRStoppedH\x00R\n" +
	"dvrStopped\x12K\n" +
	"\x10dvr_stop_request\x18\x15 \x01(\v2\x1f.helmsmancontrol.DVRStopRequestH\x00R\x0edvrStopRequest\x12N\n" +
	"\x11dvr_ready_request\x18\x16 \x01(\v2 .helmsmancontrol.DVRReadyRequestH\x00R\x0fdvrReadyRequest\x12Q\n" +
	"\x12dvr_ready_response\x18\x17 \x01(\v2!.helmsmancontrol.DVRReadyResponseH\x00R\x10dvrReadyResponse\x12A\n" +
	"\fmist_trigger\x18\x18 \x01(\v2\x1c.helmsmancontrol.MistTriggerH\x00R\vmistTrigger\x12Z\n" +
	"\x15mist_trigger_response\x18\x19 \x01(\v2$.helmsmancontrol.MistTriggerResponseH\x00R\x13mistTriggerResponse\x12>\n" +
	"\vconfig_seed\x18\x1d \x01(\v2\x1b.helmsmancontrol.ConfigSeedH\x00R\n" +
	"configSeed\x12M\n" +
	"\x10artifact_deleted\x18\x1e \x01(\v2 .helmsmancontrol.ArtifactDeletedH\x00R\x0fartifactDeleted\x12E\n" +
	"\vclip_delete\x18\x1f \x01(\v2\".helmsmancontrol.ClipDeleteRequestH\x00R\n" +
	"clipDelete\x12B\n" +
	"\n" +
	"dvr_delete\x18  \x01(\v2!.helmsmancontrol.DVRDeleteRequestH\x00R\tdvrDelete\x12B\n" +
	"\n" +
	"vod_delete\x18! \x01(\v2!.helmsmancontrol.VodDeleteRequestH\x00R\tvodDelete\x12f\n" +
	"\x19freeze_permission_request\x18( \x01(\v2(.helmsmancontrol.FreezePermissionRequestH\x00R\x17freezePermissionRequest\x12i\n" +
	"\x1afreeze_permission_response\x18) \x01(\v2).helmsmancontrol.FreezePermissionResponseH\x00R\x18freezePermissionResponse\x12J\n" +
	"\x0ffreeze_progress\x18* \x01(\v2\x1f.helmsmancontrol.FreezeProgressH\x00R\x0efreezeProgress\x12J\n" +
	"\x0ffreeze_complete\x18+ \x01(\v2\x1f.helmsmancontrol.FreezeCompleteH\x00R\x0efreezeComplete\x12J\n" +
	"\x0fdefrost_request\x18, \x01(\v2\x1f.helmsmancontrol.DefrostRequestH\x00R\x0edefrostRequest\x12M\n" +
	"\x10defrost_progress\x18- \x01(\v2 .helmsmancontrol.DefrostProgressH\x00R\x0fdefrostProgress\x12M\n" +
	"\x10defrost_complete\x18. \x01(\v2 .helmsmancontrol.DefrostCompleteH\x00R\x0fdefrostComplete\x12Q\n" +
	"\x12can_delete_request\x18/ \x01(\v2!.helmsmancontrol.CanDeleteRequestH\x00R\x10canDeleteRequest\x12T\n" +
	"\x13can_delete_response\x180 \x01(\v2\".helmsmancontrol.CanDeleteResponseH\x00R\x11canDeleteResponse\x12D\n" +
	"\rsync_complete\x181 \x01(\v2\x1d.helmsmancontrol.SyncCompleteH\x00R\fsyncComplete\x12N\n" +
	"\x11dtsh_sync_request\x182 \x01(\v2 .helmsmancontrol.DtshSyncRequestH\x00R\x0fdtshSyncRequest\x12Z\n" +
	"\x15transcode_job_request\x18< \x01(\v2$.helmsmancontrol.TranscodeJobRequestH\x00R\x13transcodeJobRequest\x12]\n" +
	"\x16transcode_job_progress\x18= \x01(\v2%.helmsmancontrol.TranscodeJobProgressH\x00R\x14transcodeJobProgress\x12]\n" +
	"\x16transcode_job_complete\x18> \x01(\v2%.helmsmancontrol.TranscodeJobCompleteH\x00R\x14transcodeJobComplete\x12Z\n" +
	"\x15stop_sessions_request\x18F \x01(\v2$.helmsmancontrol.StopSessionsRequestH\x00R\x13stopSessionsRequestB\t\n" +
	"\apayload\"m\n" +
	"\x13StopSessionsRequest\x12!\n" +
	"\fstream_names\x18\x01 \x03(\tR\vstreamNames\x12\x1b\n" +
	"\ttenant_id\x18\x02 \x01(\tR\btenantId\x12\x16\n" +
	"\x06reason\x18\x03 \x01(\tR\x06reason\"\xe5\x01\n" +
	"\x0fArtifactDeleted\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\x12\x16\n" +
	"\x06reason\x18\x03 \x01(\tR\x06reason\x12\x17\n" +
	"\anode_id\x18\x04 \x01(\tR\x06nodeId\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x05 \x01(\x04R\tsizeBytes\x12#\n" +
	"\rartifact_hash\x18\x06 \x01(\tR\fartifactHash\x12#\n" +
	"\rartifact_type\x18\a \x01(\tR\fartifactType\"\xf4\x04\n" +
	"\bRegister\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x14\n" +
	"\x05roles\x18\x02 \x03(\tR\x05roles\x12\x1d\n" +
	"\n" +
	"cap_ingest\x18\x03 \x01(\bR\tcapIngest\x12\x19\n" +
	"\bcap_edge\x18\x04 \x01(\bR\acapEdge\x12\x1f\n" +
	"\vcap_storage\x18\x05 \x01(\bR\n" +
	"capStorage\x12%\n" +
	"\x0ecap_processing\x18\x06 \x01(\bR\rcapProcessing\x12#\n" +
	"\rstorage_local\x18\a \x01(\tR\fstorageLocal\x12%\n" +
	"\x0estorage_bucket\x18\b \x01(\tR\rstorageBucket\x12%\n" +
	"\x0estorage_prefix\x18\t \x01(\tR\rstoragePrefix\x12)\n" +
	"\x10enrollment_token\x18\n" +
	" \x01(\tR\x0fenrollmentToken\x12B\n" +
	"\vfingerprint\x18\v \x01(\v2 .helmsmancontrol.NodeFingerprintR\vfingerprint\x12 \n" +
	"\tcpu_cores\x18\f \x01(\x05H\x00R\bcpuCores\x88\x01\x01\x12 \n" +
	"\tmemory_gb\x18\r \x01(\x05H\x01R\bmemoryGb\x88\x01\x01\x12\x1c\n" +
	"\adisk_gb\x18\x0e \x01(\x05H\x02R\x06diskGb\x88\x01\x01\x12K\n" +
	"\x0erequested_mode\x18\x0f \x01(\x0e2$.helmsmancontrol.NodeOperationalModeR\rrequestedModeB\f\n" +
	"\n" +
	"_cpu_coresB\f\n" +
	"\n" +
	"_memory_gbB\n" +
	"\n" +
	"\b_disk_gb\"\xcc\x01\n" +
	"\x0fNodeFingerprint\x12\x1d\n" +
	"\n" +
	"local_ipv4\x18\x01 \x03(\tR\tlocalIpv4\x12\x1d\n" +
	"\n" +
	"local_ipv6\x18\x02 \x03(\tR\tlocalIpv6\x12$\n" +
	"\vmacs_sha256\x18\x03 \x01(\tH\x00R\n" +
	"macsSha256\x88\x01\x01\x12/\n" +
	"\x11machine_id_sha256\x18\x04 \x01(\tH\x01R\x0fmachineIdSha256\x88\x01\x01B\x0e\n" +
	"\f_macs_sha256B\x14\n" +
	"\x12_machine_id_sha256\"\xc2\x03\n" +
	"\x0fClipPullRequest\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\x12\x1f\n" +
	"\vstream_name\x18\x02 \x01(\tR\n" +
	"streamName\x12\"\n" +
	"\n" +
	"start_unix\x18\x03 \x01(\x03H\x00R\tstartUnix\x88\x01\x01\x12 \n" +
	"\tstop_unix\x18\x04 \x01(\x03H\x01R\bstopUnix\x88\x01\x01\x12\x1e\n" +
	"\bstart_ms\x18\x05 \x01(\x03H\x02R\astartMs\x88\x01\x01\x12\x1c\n" +
	"\astop_ms\x18\x06 \x01(\x03H\x03R\x06stopMs\x88\x01\x01\x12&\n" +
	"\fduration_sec\x18\a \x01(\x03H\x04R\vdurationSec\x88\x01\x01\x12\x16\n" +
	"\x06format\x18\b \x01(\tR\x06format\x12\x1f\n" +
	"\voutput_name\x18\t \x01(\tR\n" +
	"outputName\x12&\n" +
	"\x0fsource_base_url\x18\n" +
	" \x01(\tR\rsourceBaseUrl\x12\x1d\n" +
	"\n" +
	"request_id\x18\v \x01(\tR\trequestIdB\r\n" +
	"\v_start_unixB\f\n" +
	"\n" +
	"_stop_unixB\v\n" +
	"\t_start_msB\n" +
	"\n" +
	"\b_stop_msB\x0f\n" +
	"\r_duration_sec\"a\n" +
	"\fClipProgress\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x18\n" +
	"\apercent\x18\x02 \x01(\rR\apercent\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"\xaa\x01\n" +
	"\bClipDone\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\x12\x15\n" +
	"\x06s3_url\x18\x03 \x01(\tR\x05s3Url\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x04 \x01(\x04R\tsizeBytes\x12\x16\n" +
	"\x06status\x18\x05 \x01(\tR\x06status\x12\x14\n" +
	"\x05error\x18\x06 \x01(\tR\x05error\"<\n" +
	"\fControlError\x12\x12\n" +
	"\x04code\x18\x01 \x01(\tR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"$\n" +
	"\tHeartbeat\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\"\xd2\x12\n" +
	"\vMistTrigger\x12!\n" +
	"\ftrigger_type\x18\x01 \x01(\tR\vtriggerType\x12\x17\n" +
	"\anode_id\x18\x03 \x01(\tR\x06nodeId\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\x03R\ttimestamp\x12\x1a\n" +
	"\bblocking\x18\x05 \x01(\bR\bblocking\x12\x1d\n" +
	"\n" +
	"request_id\x18\x06 \x01(\tR\trequestId\x12 \n" +
	"\ttenant_id\x18\a \x01(\tH\x01R\btenantId\x88\x01\x01\x12\x1c\n" +
	"\auser_id\x18\b \x01(\tH\x02R\x06userId\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\t \x01(\tH\x03R\bstreamId\x88\x01\x01\x12H\n" +
	"\fpush_rewrite\x18\n" +
	" \x01(\v2#.helmsmancontrol.PushRewriteTriggerH\x00R\vpushRewrite\x12J\n" +
	"\fplay_rewrite\x18\v \x01(\v2%.helmsmancontrol.ViewerResolveTriggerH\x00R\vplayRewrite\x12K\n" +
	"\rstream_source\x18\f \x01(\v2$.helmsmancontrol.StreamSourceTriggerH\x00R\fstreamSource\x12L\n" +
	"\x0epush_out_start\x18\r \x01(\v2$.helmsmancontrol.PushOutStartTriggerH\x00R\fpushOutStart\x12<\n" +
	"\bpush_end\x18\x0e \x01(\v2\x1f.helmsmancontrol.PushEndTriggerH\x00R\apushEnd\x12N\n" +
	"\x0eviewer_connect\x18\x0f \x01(\v2%.helmsmancontrol.ViewerConnectTriggerH\x00R\rviewerConnect\x12W\n" +
	"\x11viewer_disconnect\x18\x10 \x01(\v2(.helmsmancontrol.ViewerDisconnectTriggerH\x00R\x10viewerDisconnect\x12K\n" +
	"\rstream_buffer\x18\x11 \x01(\v2$.helmsmancontrol.StreamBufferTriggerH\x00R\fstreamBuffer\x12B\n" +
	"\n" +
	"stream_end\x18\x12 \x01(\v2!.helmsmancontrol.StreamEndTriggerH\x00R\tstreamEnd\x12H\n" +
	"\n" +
	"track_list\x18\x13 \x01(\v2'.helmsmancontrol.StreamTrackListTriggerH\x00R\ttrackList\x12Z\n" +
	"\x12recording_complete\x18\x15 \x01(\v2).helmsmancontrol.RecordingCompleteTriggerH\x00R\x11recordingComplete\x12`\n" +
	"\x17stream_lifecycle_update\x18\x16 \x01(\v2&.helmsmancontrol.StreamLifecycleUpdateH\x00R\x15streamLifecycleUpdate\x12`\n" +
	"\x17client_lifecycle_update\x18\x17 \x01(\v2&.helmsmancontrol.ClientLifecycleUpdateH\x00R\x15clientLifecycleUpdate\x12Z\n" +
	"\x15node_lifecycle_update\x18\x18 \x01(\v2$.helmsmancontrol.NodeLifecycleUpdateH\x00R\x13nodeLifecycleUpdate\x12T\n" +
	"\x13load_balancing_data\x18\x19 \x01(\v2\".helmsmancontrol.LoadBalancingDataH\x00R\x11loadBalancingData\x12T\n" +
	"\x13clip_lifecycle_data\x18\x1a \x01(\v2\".helmsmancontrol.ClipLifecycleDataH\x00R\x11clipLifecycleData\x12Q\n" +
	"\x12dvr_lifecycle_data\x18\x1b \x01(\v2!.helmsmancontrol.DVRLifecycleDataH\x00R\x10dvrLifecycleData\x12M\n" +
	"\x10storage_snapshot\x18\x1c \x01(\v2 .helmsmancontrol.StorageSnapshotH\x00R\x0fstorageSnapshot\x12]\n" +
	"\x16storage_lifecycle_data\x18\x1d \x01(\v2%.helmsmancontrol.StorageLifecycleDataH\x00R\x14storageLifecycleData\x12W\n" +
	"\x11recording_segment\x18\x1e \x01(\v2(.helmsmancontrol.RecordingSegmentTriggerH\x00R\x10recordingSegment\x12O\n" +
	"\x0fprocess_billing\x18\x1f \x01(\v2$.helmsmancontrol.ProcessBillingEventH\x00R\x0eprocessBilling\x12Q\n" +
	"\x12vod_lifecycle_data\x18  \x01(\v2!.helmsmancontrol.VodLifecycleDataH\x00R\x10vodLifecycleData\x12N\n" +
	"\x11api_request_batch\x18\" \x01(\v2 .helmsmancontrol.APIRequestBatchH\x00R\x0fapiRequestBatch\x12]\n" +
	"\x16message_lifecycle_data\x18# \x01(\v2%.helmsmancontrol.MessageLifecycleDataH\x00R\x14messageLifecycleData\x12\"\n" +
	"\n" +
	"cluster_id\x18! \x01(\tH\x04R\tclusterId\x88\x01\x01B\x11\n" +
	"\x0ftrigger_payloadB\f\n" +
	"\n" +
	"_tenant_idB\n" +
	"\n" +
	"\b_user_idB\f\n" +
	"\n" +
	"_stream_idB\r\n" +
	"\v_cluster_idJ\x04\b\x14\x10\x15R\x10stream_bandwidth\"\xa7\x01\n" +
	"\x13MistTriggerResponse\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1a\n" +
	"\bresponse\x18\x02 \x01(\tR\bresponse\x12\x14\n" +
	"\x05abort\x18\x03 \x01(\bR\x05abort\x12?\n" +
	"\n" +
	"error_code\x18\x04 \x01(\x0e2 .helmsmancontrol.IngestErrorCodeR\terrorCode\"\xfa\x02\n" +
	"\x0fStorageSnapshot\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x12 \n" +
	"\ttenant_id\x18\x03 \x01(\tH\x00R\btenantId\x88\x01\x01\x12\x1f\n" +
	"\blocation\x18\x04 \x01(\tH\x01R\blocation\x88\x01\x01\x12J\n" +
	"\fcapabilities\x18\x05 \x01(\v2!.helmsmancontrol.NodeCapabilitiesH\x02R\fcapabilities\x88\x01\x01\x129\n" +
	"\x05usage\x18\x06 \x03(\v2#.helmsmancontrol.TenantStorageUsageR\x05usage\x12(\n" +
	"\rstorage_scope\x18\a \x01(\tH\x03R\fstorageScope\x88\x01\x01B\f\n" +
	"\n" +
	"_tenant_idB\v\n" +
	"\t_locationB\x0f\n" +
	"\r_capabilitiesB\x10\n" +
	"\x0e_storage_scope\"\xca\x02\n" +
	"\x12TenantStorageUsage\x12\x1b\n" +
	"\ttenant_id\x18\x01 \x01(\tR\btenantId\x12\x1f\n" +
	"\vtotal_bytes\x18\x02 \x01(\x04R\n" +
	"totalBytes\x12\x1d\n" +
	"\n" +
	"file_count\x18\x03 \x01(\rR\tfileCount\x12\x1b\n" +
	"\tdvr_bytes\x18\x04 \x01(\x04R\bdvrBytes\x12\x1d\n" +
	"\n" +
	"clip_bytes\x18\x05 \x01(\x04R\tclipBytes\x12\x1b\n" +
	"\tvod_bytes\x18\x06 \x01(\x04R\bvodBytes\x12(\n" +
	"\x10frozen_dvr_bytes\x18\a \x01(\x04R\x0efrozenDvrBytes\x12*\n" +
	"\x11frozen_clip_bytes\x18\b \x01(\x04R\x0ffrozenClipBytes\x12(\n" +
	"\x10frozen_vod_bytes\x18\t \x01(\x04R\x0efrozenVodBytes\".\n" +
	"\x0fClipHashRequest\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\"m\n" +
	"\x10ClipHashResponse\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\x12\x1b\n" +
	"\ttenant_id\x18\x02 \x01(\tR\btenantId\x12\x1f\n" +
	"\vstream_name\x18\x03 \x01(\tR\n" +
	"streamName\"\x9f\x02\n" +
	"\x0fDVRStartRequest\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12#\n" +
	"\rinternal_name\x18\x02 \x01(\tR\finternalName\x12&\n" +
	"\x0fsource_base_url\x18\x03 \x01(\tR\rsourceBaseUrl\x12\x1d\n" +
	"\n" +
	"request_id\x18\x04 \x01(\tR\trequestId\x122\n" +
	"\x06config\x18\x05 \x01(\v2\x1a.helmsmancontrol.DVRConfigR\x06config\x12\x1b\n" +
	"\ttenant_id\x18\x06 \x01(\tR\btenantId\x12\x17\n" +
	"\auser_id\x18\a \x01(\tR\x06userId\x12\x1b\n" +
	"\tstream_id\x18\b \x01(\tR\bstreamId\"\x8f\x01\n" +
	"\tDVRConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12%\n" +
	"\x0eretention_days\x18\x02 \x01(\x05R\rretentionDays\x12\x16\n" +
	"\x06format\x18\x03 \x01(\tR\x06format\x12)\n" +
	"\x10segment_duration\x18\x04 \x01(\x05R\x0fsegmentDuration\"\xdc\x01\n" +
	"\vDVRProgress\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x19\n" +
	"\bdvr_hash\x18\x02 \x01(\tR\advrHash\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x1d\n" +
	"\n" +
	"started_at\x18\x04 \x01(\x03R\tstartedAt\x12#\n" +
	"\rsegment_count\x18\x05 \x01(\x05R\fsegmentCount\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x06 \x01(\x04R\tsizeBytes\x12\x18\n" +
	"\amessage\x18\a \x01(\tR\amessage\"\x9d\x02\n" +
	"\n" +
	"DVRStopped\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x19\n" +
	"\bdvr_hash\x18\x02 \x01(\tR\advrHash\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x14\n" +
	"\x05error\x18\x04 \x01(\tR\x05error\x12\x1d\n" +
	"\n" +
	"started_at\x18\x05 \x01(\x03R\tstartedAt\x12\x19\n" +
	"\bended_at\x18\x06 \x01(\x03R\aendedAt\x12)\n" +
	"\x10duration_seconds\x18\a \x01(\x05R\x0fdurationSeconds\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\b \x01(\x04R\tsizeBytes\x12#\n" +
	"\rmanifest_path\x18\t \x01(\tR\fmanifestPath\"\x86\x01\n" +
	"\x0eDVRStopRequest\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\tR\trequestId\x12(\n" +
	"\rinternal_name\x18\x03 \x01(\tH\x00R\finternalName\x88\x01\x01B\x10\n" +
	"\x0e_internal_name\"O\n" +
	"\x11ClipDeleteRequest\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\tR\trequestId\"L\n" +
	"\x10DVRDeleteRequest\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\tR\trequestId\"L\n" +
	"\x10VodDeleteRequest\x12\x19\n" +
	"\bvod_hash\x18\x01 \x01(\tR\avodHash\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\tR\trequestId\"\xeb\x01\n" +
	"\x17FreezePermissionRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1d\n" +
	"\n" +
	"asset_type\x18\x02 \x01(\tR\tassetType\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x03 \x01(\tR\tassetHash\x12\x1d\n" +
	"\n" +
	"local_path\x18\x04 \x01(\tR\tlocalPath\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x05 \x01(\x04R\tsizeBytes\x12\x17\n" +
	"\anode_id\x18\x06 \x01(\tR\x06nodeId\x12\x1c\n" +
	"\tfilenames\x18\a \x03(\tR\tfilenames\"\x85\x03\n" +
	"\x18FreezePermissionResponse\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x02 \x01(\tR\tassetHash\x12\x1a\n" +
	"\bapproved\x18\x03 \x01(\bR\bapproved\x12*\n" +
	"\x11presigned_put_url\x18\x04 \x01(\tR\x0fpresignedPutUrl\x12,\n" +
	"\x12url_expiry_seconds\x18\x05 \x01(\x03R\x10urlExpirySeconds\x12\x16\n" +
	"\x06reason\x18\x06 \x01(\tR\x06reason\x12]\n" +
	"\fsegment_urls\x18\a \x03(\v2:.helmsmancontrol.FreezePermissionResponse.SegmentUrlsEntryR\vsegmentUrls\x1a>\n" +
	"\x10SegmentUrlsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xd7\x02\n" +
	"\rFreezeRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1d\n" +
	"\n" +
	"asset_type\x18\x02 \x01(\tR\tassetType\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x03 \x01(\tR\tassetHash\x12\x1b\n" +
	"\ttenant_id\x18\x04 \x01(\tR\btenantId\x12#\n" +
	"\rinternal_name\x18\x05 \x01(\tR\finternalName\x12\x1d\n" +
	"\n" +
	"local_path\x18\x06 \x01(\tR\tlocalPath\x12*\n" +
	"\x11presigned_put_url\x18\a \x01(\tR\x0fpresignedPutUrl\x12.\n" +
	"\x13delete_after_upload\x18\b \x01(\bR\x11deleteAfterUpload\x12,\n" +
	"\x12url_expiry_seconds\x18\t \x01(\x03R\x10urlExpirySeconds\"\xa9\x01\n" +
	"\x0eFreezeProgress\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x02 \x01(\tR\tassetHash\x12\x18\n" +
	"\apercent\x18\x03 \x01(\rR\apercent\x12%\n" +
	"\x0ebytes_uploaded\x18\x04 \x01(\x04R\rbytesUploaded\x12\x18\n" +
	"\amessage\x18\x05 \x01(\tR\amessage\"\xb2\x01\n" +
	"\x0eFreezeComplete\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x02 \x01(\tR\tassetHash\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x15\n" +
	"\x06s3_url\x18\x04 \x01(\tR\x05s3Url\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x05 \x01(\x04R\tsizeBytes\x12\x14\n" +
	"\x05error\x18\x06 \x01(\tR\x05error\"\x84\x04\n" +
	"\x0eDefrostRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1d\n" +
	"\n" +
	"asset_type\x18\x02 \x01(\tR\tassetType\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x03 \x01(\tR\tassetHash\x12\x1b\n" +
	"\ttenant_id\x18\x04 \x01(\tR\btenantId\x12#\n" +
	"\rinternal_name\x18\x05 \x01(\tR\finternalName\x12*\n" +
	"\x11presigned_get_url\x18\x06 \x01(\tR\x0fpresignedGetUrl\x12\x1d\n" +
	"\n" +
	"local_path\x18\a \x01(\tR\tlocalPath\x12'\n" +
	"\x0ftimeout_seconds\x18\b \x01(\x05R\x0etimeoutSeconds\x12\x1c\n" +
	"\tstreaming\x18\t \x01(\bR\tstreaming\x12,\n" +
	"\x12url_expiry_seconds\x18\n" +
	" \x01(\x03R\x10urlExpirySeconds\x12S\n" +
	"\fsegment_urls\x18\v \x03(\v20.helmsmancontrol.DefrostRequest.SegmentUrlsEntryR\vsegmentUrls\x1a>\n" +
	"\x10SegmentUrlsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x86\x02\n" +
	"\x0fDefrostProgress\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x02 \x01(\tR\tassetHash\x12\x18\n" +
	"\apercent\x18\x03 \x01(\rR\apercent\x12)\n" +
	"\x10bytes_downloaded\x18\x04 \x01(\x04R\x0fbytesDownloaded\x12/\n" +
	"\x13segments_downloaded\x18\x05 \x01(\x05R\x12segmentsDownloaded\x12%\n" +
	"\x0etotal_segments\x18\x06 \x01(\x05R\rtotalSegments\x12\x18\n" +
	"\amessage\x18\a \x01(\tR\amessage\"\xd4\x01\n" +
	"\x0fDefrostComplete\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x02 \x01(\tR\tassetHash\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x1d\n" +
	"\n" +
	"local_path\x18\x04 \x01(\tR\tlocalPath\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x05 \x01(\x04R\tsizeBytes\x12\x14\n" +
	"\x05error\x18\x06 \x01(\tR\x05error\x12\x17\n" +
	"\anode_id\x18\a \x01(\tR\x06nodeId\"J\n" +
	"\x10CanDeleteRequest\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x01 \x01(\tR\tassetHash\x12\x17\n" +
	"\anode_id\x18\x02 \x01(\tR\x06nodeId\"\x9a\x01\n" +
	"\x11CanDeleteResponse\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x01 \x01(\tR\tassetHash\x12$\n" +
	"\x0esafe_to_delete\x18\x02 \x01(\bR\fsafeToDelete\x12\x16\n" +
	"\x06reason\x18\x03 \x01(\tR\x06reason\x12(\n" +
	"\x10warm_duration_ms\x18\x04 \x01(\x03R\x0ewarmDurationMs\"\xee\x01\n" +
	"\fSyncComplete\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x02 \x01(\tR\tassetHash\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x15\n" +
	"\x06s3_url\x18\x04 \x01(\tR\x05s3Url\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x05 \x01(\x04R\tsizeBytes\x12\x14\n" +
	"\x05error\x18\x06 \x01(\tR\x05error\x12\x17\n" +
	"\anode_id\x18\a \x01(\tR\x06nodeId\x12#\n" +
	"\rdtsh_included\x18\b \x01(\bR\fdtshIncluded\"\xf1\x02\n" +
	"\x0fDtshSyncRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1d\n" +
	"\n" +
	"asset_type\x18\x02 \x01(\tR\tassetType\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x03 \x01(\tR\tassetHash\x12\x1d\n" +
	"\n" +
	"local_path\x18\x04 \x01(\tR\tlocalPath\x12*\n" +
	"\x11presigned_put_url\x18\x05 \x01(\tR\x0fpresignedPutUrl\x12,\n" +
	"\x12url_expiry_seconds\x18\x06 \x01(\x03R\x10urlExpirySeconds\x12K\n" +
	"\tdtsh_urls\x18\a \x03(\v2..helmsmancontrol.DtshSyncRequest.DtshUrlsEntryR\bdtshUrls\x1a;\n" +
	"\rDtshUrlsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9c\x06\n" +
	"\x14StorageLifecycleData\x12D\n" +
	"\x06action\x18\x01 \x01(\x0e2,.helmsmancontrol.StorageLifecycleData.ActionR\x06action\x12\x1d\n" +
	"\n" +
	"asset_type\x18\x02 \x01(\tR\tassetType\x12\x1d\n" +
	"\n" +
	"asset_hash\x18\x03 \x01(\tR\tassetHash\x12 \n" +
	"\ttenant_id\x18\x04 \x01(\tH\x00R\btenantId\x88\x01\x01\x12(\n" +
	"\rinternal_name\x18\x05 \x01(\tH\x01R\finternalName\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\r \x01(\tH\x02R\bstreamId\x88\x01\x01\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x06 \x01(\x04R\tsizeBytes\x12\x1a\n" +
	"\x06s3_url\x18\a \x01(\tH\x03R\x05s3Url\x88\x01\x01\x12\"\n" +
	"\n" +
	"local_path\x18\b \x01(\tH\x04R\tlocalPath\x88\x01\x01\x12\x1c\n" +
	"\anode_id\x18\t \x01(\tH\x05R\x06nodeId\x88\x01\x01\x12\x19\n" +
	"\x05error\x18\n" +
	" \x01(\tH\x06R\x05error\x88\x01\x01\x12$\n" +
	"\vduration_ms\x18\v \x01(\x03H\aR\n" +
	"durationMs\x88\x01\x01\x12-\n" +
	"\x10warm_duration_ms\x18\f \x01(\x03H\bR\x0ewarmDurationMs\x88\x01\x01\"\xa1\x01\n" +
	"\x06Action\x12\x16\n" +
	"\x12ACTION_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13ACTION_SYNC_STARTED\x10\x01\x12\x11\n" +
	"\rACTION_SYNCED\x10\x02\x12\x12\n" +
	"\x0eACTION_EVICTED\x10\x03\x12\x18\n" +
	"\x14ACTION_CACHE_STARTED\x10\x04\x12\x11\n" +
	"\rACTION_CACHED\x10\x05\x12\x12\n" +
	"\x0eACTION_DELETED\x10\x06B\f\n" +
	"\n" +
	"_tenant_idB\x10\n" +
	"\x0e_internal_nameB\f\n" +
	"\n" +
	"_stream_idB\t\n" +
	"\a_s3_urlB\r\n" +
	"\v_local_pathB\n" +
	"\n" +
	"\b_node_idB\b\n" +
	"\x06_errorB\x0e\n" +
	"\f_duration_msB\x13\n" +
	"\x11_warm_duration_ms\"E\n" +
	"\x0fDVRReadyRequest\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12\x17\n" +
	"\anode_id\x18\x02 \x01(\tR\x06nodeId\"\xae\x01\n" +
	"\x10DVRReadyResponse\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12\x14\n" +
	"\x05ready\x18\x02 \x01(\bR\x05ready\x12\x1d\n" +
	"\n" +
	"source_uri\x18\x03 \x01(\tR\tsourceUri\x122\n" +
	"\x06config\x18\x04 \x01(\v2\x1a.helmsmancontrol.DVRConfigR\x06config\x12\x16\n" +
	"\x06reason\x18\x05 \x01(\tR\x06reason\"\xcf\a\n" +
	"\x12PushRewriteTrigger\x12\x19\n" +
	"\bpush_url\x18\x01 \x01(\tR\apushUrl\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname\x12\x1f\n" +
	"\vstream_name\x18\x03 \x01(\tR\n" +
	"streamName\x12\x1f\n" +
	"\bprotocol\x18\x04 \x01(\tH\x00R\bprotocol\x88\x01\x01\x12\x1d\n" +
	"\aencoder\x18\x05 \x01(\tH\x01R\aencoder\x88\x01\x01\x12,\n" +
	"\x0fstream_settings\x18\x06 \x01(\tH\x02R\x0estreamSettings\x88\x01\x01\x12\x1c\n" +
	"\anode_id\x18\a \x01(\tH\x03R\x06nodeId\x88\x01\x01\x12\x1f\n" +
	"\blatitude\x18\b \x01(\x01H\x04R\blatitude\x88\x01\x01\x12!\n" +
	"\tlongitude\x18\t \x01(\x01H\x05R\tlongitude\x88\x01\x01\x12\x1f\n" +
	"\blocation\x18\n" +
	" \x01(\tH\x06R\blocation\x88\x01\x01\x129\n" +
	"\x16publisher_country_code\x18\v \x01(\tH\aR\x14publisherCountryCode\x88\x01\x01\x12*\n" +
	"\x0epublisher_city\x18\f \x01(\tH\bR\rpublisherCity\x88\x01\x01\x122\n" +
	"\x12publisher_latitude\x18\r \x01(\x01H\tR\x11publisherLatitude\x88\x01\x01\x124\n" +
	"\x13publisher_longitude\x18\x0e \x01(\x01H\n" +
	"R\x12publisherLongitude\x88\x01\x01\x12J\n" +
	"\x10publisher_bucket\x18\x0f \x01(\v2\x1a.helmsmancontrol.GeoBucketH\vR\x0fpublisherBucket\x88\x01\x01\x12@\n" +
	"\vnode_bucket\x18\x10 \x01(\v2\x1a.helmsmancontrol.GeoBucketH\fR\n" +
	"nodeBucket\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\x11 \x01(\tH\rR\bstreamId\x88\x01\x01B\v\n" +
	"\t_protocolB\n" +
	"\n" +
	"\b_encoderB\x12\n" +
	"\x10_stream_settingsB\n" +
	"\n" +
	"\b_node_idB\v\n" +
	"\t_latitudeB\f\n" +
	"\n" +
	"_longitudeB\v\n" +
	"\t_locationB\x19\n" +
	"\x17_publisher_country_codeB\x11\n" +
	"\x0f_publisher_cityB\x15\n" +
	"\x13_publisher_latitudeB\x16\n" +
	"\x14_publisher_longitudeB\x13\n" +
	"\x11_publisher_bucketB\x0e\n" +
	"\f_node_bucketB\f\n" +
	"\n" +
	"_stream_id\"\xf4\x05\n" +
	"\x14ViewerResolveTrigger\x12)\n" +
	"\x10requested_stream\x18\x02 \x01(\tR\x0frequestedStream\x12\x1f\n" +
	"\vviewer_host\x18\x03 \x01(\tR\n" +
	"viewerHost\x12\x1f\n" +
	"\voutput_type\x18\x04 \x01(\tR\n" +
	"outputType\x12\x1f\n" +
	"\vrequest_url\x18\x05 \x01(\tR\n" +
	"requestUrl\x12\x1c\n" +
	"\anode_id\x18\x06 \x01(\tH\x00R\x06nodeId\x88\x01\x01\x12&\n" +
	"\fcountry_code\x18\a \x01(\tH\x01R\vcountryCode\x88\x01\x01\x12\x17\n" +
	"\x04city\x18\b \x01(\tH\x02R\x04city\x88\x01\x01\x12\x1f\n" +
	"\blatitude\x18\t \x01(\x01H\x03R\blatitude\x88\x01\x01\x12!\n" +
	"\tlongitude\x18\n" +
	" \x01(\x01H\x04R\tlongitude\x88\x01\x01\x12D\n" +
	"\rclient_bucket\x18\v \x01(\v2\x1a.helmsmancontrol.GeoBucketH\x05R\fclientBucket\x88\x01\x01\x12@\n" +
	"\vnode_bucket\x18\f \x01(\v2\x1a.helmsmancontrol.GeoBucketH\x06R\n" +
	"nodeBucket\x88\x01\x01\x129\n" +
	"\x16resolved_internal_name\x18\r \x01(\tH\aR\x14resolvedInternalName\x88\x01\x01\x12(\n" +
	"\rnode_location\x18\x0e \x01(\tH\bR\fnodeLocation\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\x0f \x01(\tH\tR\bstreamId\x88\x01\x01B\n" +
	"\n" +
	"\b_node_idB\x0f\n" +
	"\r_country_codeB\a\n" +
	"\x05_cityB\v\n" +
	"\t_latitudeB\f\n" +
	"\n" +
	"_longitudeB\x10\n" +
	"\x0e_client_bucketB\x0e\n" +
	"\f_node_bucketB\x19\n" +
	"\x17_resolved_internal_nameB\x10\n" +
	"\x0e_node_locationB\f\n" +
	"\n" +
	"_stream_id\"f\n" +
	"\x13StreamSourceTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12 \n" +
	"\tstream_id\x18\x02 \x01(\tH\x00R\bstreamId\x88\x01\x01B\f\n" +
	"\n" +
	"_stream_id\"\xb1\x01\n" +
	"\x13PushOutStartTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12\x1f\n" +
	"\vpush_target\x18\x02 \x01(\tR\n" +
	"pushTarget\x12\x1c\n" +
	"\anode_id\x18\x03 \x01(\tH\x00R\x06nodeId\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\x04 \x01(\tH\x01R\bstreamId\x88\x01\x01B\n" +
	"\n" +
	"\b_node_idB\f\n" +
	"\n" +
	"_stream_id\"\xbe\x02\n" +
	"\x0ePushEndTrigger\x12\x17\n" +
	"\apush_id\x18\x01 \x01(\x03R\x06pushId\x12\x1f\n" +
	"\vstream_name\x18\x02 \x01(\tR\n" +
	"streamName\x12*\n" +
	"\x11target_uri_before\x18\x03 \x01(\tR\x0ftargetUriBefore\x12(\n" +
	"\x10target_uri_after\x18\x04 \x01(\tR\x0etargetUriAfter\x12!\n" +
	"\flog_messages\x18\x05 \x01(\tR\vlogMessages\x12\x1f\n" +
	"\vpush_status\x18\x06 \x01(\tR\n" +
	"pushStatus\x12\x1c\n" +
	"\anode_id\x18\a \x01(\tH\x00R\x06nodeId\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\b \x01(\tH\x01R\bstreamId\x88\x01\x01B\n" +
	"\n" +
	"\b_node_idB\f\n" +
	"\n" +
	"_stream_id\"\xd4\x05\n" +
	"\x14ViewerConnectTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12\x12\n" +
	"\x04host\x18\x02 \x01(\tR\x04host\x12#\n" +
	"\rconnection_id\x18\x03 \x01(\tR\fconnectionId\x12\x1c\n" +
	"\tconnector\x18\x04 \x01(\tR\tconnector\x12\x1f\n" +
	"\vrequest_url\x18\x05 \x01(\tR\n" +
	"requestUrl\x12\x1d\n" +
	"\n" +
	"session_id\x18\x06 \x01(\tR\tsessionId\x12\x1c\n" +
	"\anode_id\x18\a \x01(\tH\x00R\x06nodeId\x88\x01\x01\x12*\n" +
	"\x0eclient_country\x18\t \x01(\tH\x01R\rclientCountry\x88\x01\x01\x12$\n" +
	"\vclient_city\x18\n" +
	" \x01(\tH\x02R\n" +
	"clientCity\x88\x01\x01\x12,\n" +
	"\x0fclient_latitude\x18\v \x01(\x01H\x03R\x0eclientLatitude\x88\x01\x01\x12.\n" +
	"\x10client_longitude\x18\f \x01(\x01H\x04R\x0fclientLongitude\x88\x01\x01\x12D\n" +
	"\rclient_bucket\x18\r \x01(\v2\x1a.helmsmancontrol.GeoBucketH\x05R\fclientBucket\x88\x01\x01\x12@\n" +
	"\vnode_bucket\x18\x0e \x01(\v2\x1a.helmsmancontrol.GeoBucketH\x06R\n" +
	"nodeBucket\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\x0f \x01(\tH\aR\bstreamId\x88\x01\x01B\n" +
	"\n" +
	"\b_node_idB\x11\n" +
	"\x0f_client_countryB\x0e\n" +
	"\f_client_cityB\x12\n" +
	"\x10_client_latitudeB\x13\n" +
	"\x11_client_longitudeB\x10\n" +
	"\x0e_client_bucketB\x0e\n" +
	"\f_node_bucketB\f\n" +
	"\n" +
	"_stream_idJ\x04\b\b\x10\t\"\xc6\x06\n" +
	"\x17ViewerDisconnectTrigger\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x1f\n" +
	"\vstream_name\x18\x02 \x01(\tR\n" +
	"streamName\x12\x1c\n" +
	"\tconnector\x18\x03 \x01(\tR\tconnector\x12\x12\n" +
	"\x04host\x18\x04 \x01(\tR\x04host\x12\x1a\n" +
	"\bduration\x18\x05 \x01(\x03R\bduration\x12\x19\n" +
	"\bup_bytes\x18\x06 \x01(\x03R\aupBytes\x12\x1d\n" +
	"\n" +
	"down_bytes\x18\a \x01(\x03R\tdownBytes\x12\x12\n" +
	"\x04tags\x18\b \x01(\tR\x04tags\x12\x1c\n" +
	"\anode_id\x18\t \x01(\tH\x00R\x06nodeId\x88\x01\x01\x12&\n" +
	"\fcountry_code\x18\n" +
	" \x01(\tH\x01R\vcountryCode\x88\x01\x01\x12\x17\n" +
	"\x04city\x18\v \x01(\tH\x02R\x04city\x88\x01\x01\x12\x1f\n" +
	"\blatitude\x18\f \x01(\x01H\x03R\blatitude\x88\x01\x01\x12!\n" +
	"\tlongitude\x18\r \x01(\x01H\x04R\tlongitude\x88\x01\x01\x122\n" +
	"\x12session_identifier\x18\x0e \x01(\tH\x05R\x11sessionIdentifier\x88\x01\x01\x120\n" +
	"\x11seconds_connected\x18\x0f \x01(\x04H\x06R\x10secondsConnected\x88\x01\x01\x12D\n" +
	"\rclient_bucket\x18\x10 \x01(\v2\x1a.helmsmancontrol.GeoBucketH\aR\fclientBucket\x88\x01\x01\x12@\n" +
	"\vnode_bucket\x18\x11 \x01(\v2\x1a.helmsmancontrol.GeoBucketH\bR\n" +
	"nodeBucket\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\x12 \x01(\tH\tR\bstreamId\x88\x01\x01B\n" +
	"\n" +
	"\b_node_idB\x0f\n" +
	"\r_country_codeB\a\n" +
	"\x05_cityB\v\n" +
	"\t_latitudeB\f\n" +
	"\n" +
	"_longitudeB\x15\n" +
	"\x13_session_identifierB\x14\n" +
	"\x12_seconds_connectedB\x10\n" +
	"\x0e_client_bucketB\x0e\n" +
	"\f_node_bucketB\f\n" +
	"\n" +
	"_stream_id\"\xab\x05\n" +
	"\x13StreamBufferTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12!\n" +
	"\fbuffer_state\x18\x02 \x01(\tR\vbufferState\x124\n" +
	"\x06tracks\x18\x03 \x03(\v2\x1c.helmsmancontrol.StreamTrackR\x06tracks\x12\"\n" +
	"\n" +
	"has_issues\x18\x05 \x01(\bH\x00R\thasIssues\x88\x01\x01\x122\n" +
	"\x12issues_description\x18\x06 \x01(\tH\x01R\x11issuesDescription\x88\x01\x01\x12$\n" +
	"\vtrack_count\x18\a \x01(\x05H\x02R\n" +
	"trackCount\x88\x01\x01\x12&\n" +
	"\fquality_tier\x18\b \x01(\tH\x03R\vqualityTier\x88\x01\x01\x12-\n" +
	"\x10stream_buffer_ms\x18\t \x01(\x05H\x04R\x0estreamBufferMs\x88\x01\x01\x12-\n" +
	"\x10stream_jitter_ms\x18\n" +
	" \x01(\x05H\x05R\x0estreamJitterMs\x88\x01\x01\x12$\n" +
	"\vmist_issues\x18\v \x01(\tH\x06R\n" +
	"mistIssues\x88\x01\x01\x12+\n" +
	"\x0fmax_keepaway_ms\x18\f \x01(\x05H\aR\rmaxKeepawayMs\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\r \x01(\tH\bR\bstreamId\x88\x01\x01B\r\n" +
	"\v_has_issuesB\x15\n" +
	"\x13_issues_descriptionB\x0e\n" +
	"\f_track_countB\x0f\n" +
	"\r_quality_tierB\x13\n" +
	"\x11_stream_buffer_msB\x13\n" +
	"\x11_stream_jitter_msB\x0e\n" +
	"\f_mist_issuesB\x12\n" +
	"\x10_max_keepaway_msB\f\n" +
	"\n" +
	"_stream_id\"\x81\x04\n" +
	"\x10StreamEndTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12.\n" +
	"\x10downloaded_bytes\x18\x02 \x01(\x03H\x00R\x0fdownloadedBytes\x88\x01\x01\x12*\n" +
	"\x0euploaded_bytes\x18\x03 \x01(\x03H\x01R\ruploadedBytes\x88\x01\x01\x12(\n" +
	"\rtotal_viewers\x18\x04 \x01(\x03H\x02R\ftotalViewers\x88\x01\x01\x12&\n" +
	"\ftotal_inputs\x18\x05 \x01(\x03H\x03R\vtotalInputs\x88\x01\x01\x12(\n" +
	"\rtotal_outputs\x18\x06 \x01(\x03H\x04R\ftotalOutputs\x88\x01\x01\x12*\n" +
	"\x0eviewer_seconds\x18\a \x01(\x03H\x05R\rviewerSeconds\x88\x01\x01\x12\x1c\n" +
	"\anode_id\x18\b \x01(\tH\x06R\x06nodeId\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\t \x01(\tH\aR\bstreamId\x88\x01\x01B\x13\n" +
	"\x11_downloaded_bytesB\x11\n" +
	"\x0f_uploaded_bytesB\x10\n" +
	"\x0e_total_viewersB\x0f\n" +
	"\r_total_inputsB\x10\n" +
	"\x0e_total_outputsB\x11\n" +
	"\x0f_viewer_secondsB\n" +
	"\n" +
	"\b_node_idB\f\n" +
	"\n" +
	"_stream_id\"\xc4\b\n" +
	"\x16StreamTrackListTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x124\n" +
	"\x06tracks\x18\x02 \x03(\v2\x1c.helmsmancontrol.StreamTrackR\x06tracks\x12&\n" +
	"\ftotal_tracks\x18\x03 \x01(\x05H\x00R\vtotalTracks\x88\x01\x01\x12/\n" +
	"\x11video_track_count\x18\x04 \x01(\x05H\x01R\x0fvideoTrackCount\x88\x01\x01\x12/\n" +
	"\x11audio_track_count\x18\x05 \x01(\x05H\x02R\x0faudioTrackCount\x88\x01\x01\x12&\n" +
	"\fquality_tier\x18\x06 \x01(\tH\x03R\vqualityTier\x88\x01\x01\x12(\n" +
	"\rprimary_width\x18\a \x01(\x05H\x04R\fprimaryWidth\x88\x01\x01\x12*\n" +
	"\x0eprimary_height\x18\b \x01(\x05H\x05R\rprimaryHeight\x88\x01\x01\x12$\n" +
	"\vprimary_fps\x18\t \x01(\x01H\x06R\n" +
	"primaryFps\x88\x01\x01\x127\n" +
	"\x15primary_video_bitrate\x18\n" +
	" \x01(\x05H\aR\x13primaryVideoBitrate\x88\x01\x01\x123\n" +
	"\x13primary_video_codec\x18\v \x01(\tH\bR\x11primaryVideoCodec\x88\x01\x01\x127\n" +
	"\x15primary_audio_bitrate\x18\f \x01(\x05H\tR\x13primaryAudioBitrate\x88\x01\x01\x123\n" +
	"\x13primary_audio_codec\x18\r \x01(\tH\n" +
	"R\x11primaryAudioCodec\x88\x01\x01\x129\n" +
	"\x16primary_audio_channels\x18\x0e \x01(\x05H\vR\x14primaryAudioChannels\x88\x01\x01\x12>\n" +
	"\x19primary_audio_sample_rate\x18\x0f \x01(\x05H\fR\x16primaryAudioSampleRate\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\x10 \x01(\tH\rR\bstreamId\x88\x01\x01B\x0f\n" +
	"\r_total_tracksB\x14\n" +
	"\x12_video_track_countB\x14\n" +
	"\x12_audio_track_countB\x0f\n" +
	"\r_quality_tierB\x10\n" +
	"\x0e_primary_widthB\x11\n" +
	"\x0f_primary_heightB\x0e\n" +
	"\f_primary_fpsB\x18\n" +
	"\x16_primary_video_bitrateB\x16\n" +
	"\x14_primary_video_codecB\x18\n" +
	"\x16_primary_audio_bitrateB\x16\n" +
	"\x14_primary_audio_codecB\x19\n" +
	"\x17_primary_audio_channelsB\x1c\n" +
	"\x1a_primary_audio_sample_rateB\f\n" +
	"\n" +
	"_stream_id\"\x97\x03\n" +
	"\x18RecordingCompleteTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\x12'\n" +
	"\x0foutput_protocol\x18\x03 \x01(\tR\x0eoutputProtocol\x12#\n" +
	"\rbytes_written\x18\x04 \x01(\x03R\fbytesWritten\x12'\n" +
	"\x0fseconds_writing\x18\x05 \x01(\x03R\x0esecondsWriting\x12!\n" +
	"\ftime_started\x18\x06 \x01(\x03R\vtimeStarted\x12\x1d\n" +
	"\n" +
	"time_ended\x18\a \x01(\x03R\ttimeEnded\x12*\n" +
	"\x11media_duration_ms\x18\b \x01(\x03R\x0fmediaDurationMs\x12\x1c\n" +
	"\anode_id\x18\t \x01(\tH\x00R\x06nodeId\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\n" +
	" \x01(\tH\x01R\bstreamId\x88\x01\x01B\n" +
	"\n" +
	"\b_node_idB\f\n" +
	"\n" +
	"_stream_id\"\xea\x01\n" +
	"\x17RecordingSegmentTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\x12\x1f\n" +
	"\vduration_ms\x18\x03 \x01(\x03R\n" +
	"durationMs\x12!\n" +
	"\ftime_started\x18\x04 \x01(\x03R\vtimeStarted\x12\x1d\n" +
	"\n" +
	"time_ended\x18\x05 \x01(\x03R\ttimeEnded\x12 \n" +
	"\tstream_id\x18\x06 \x01(\tH\x00R\bstreamId\x88\x01\x01B\f\n" +
	"\n" +
	"_stream_id\"\xc9\x10\n" +
	"\x15StreamLifecycleUpdate\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12 \n" +
	"\ttenant_id\x18\x02 \x01(\tH\x00R\btenantId\x88\x01\x01\x12#\n" +
	"\rinternal_name\x18\x03 \x01(\tR\finternalName\x12\x16\n" +
	"\x06status\x18\x04 \x01(\tR\x06status\x12&\n" +
	"\fbuffer_state\x18\x05 \x01(\tH\x01R\vbufferState\x88\x01\x01\x12*\n" +
	"\x0euploaded_bytes\x18\x06 \x01(\x04H\x02R\ruploadedBytes\x88\x01\x01\x12.\n" +
	"\x10downloaded_bytes\x18\a \x01(\x04H\x03R\x0fdownloadedBytes\x88\x01\x01\x12(\n" +
	"\rtotal_viewers\x18\b \x01(\rH\x04R\ftotalViewers\x88\x01\x01\x12&\n" +
	"\ftotal_inputs\x18\t \x01(\rH\x05R\vtotalInputs\x88\x01\x01\x12*\n" +
	"\x0eviewer_seconds\x18\n" +
	" \x01(\x04H\x06R\rviewerSeconds\x88\x01\x01\x12*\n" +
	"\x0estream_details\x18\v \x01(\tH\aR\rstreamDetails\x88\x01\x01\x12\x1c\n" +
	"\ttimestamp\x18\f \x01(\x03R\ttimestamp\x12\"\n" +
	"\n" +
	"has_issues\x18\x0e \x01(\bH\bR\thasIssues\x88\x01\x01\x122\n" +
	"\x12issues_description\x18\x0f \x01(\tH\tR\x11issuesDescription\x88\x01\x01\x12$\n" +
	"\vtrack_count\x18\x10 \x01(\x05H\n" +
	"R\n" +
	"trackCount\x88\x01\x01\x12&\n" +
	"\fquality_tier\x18\x11 \x01(\tH\vR\vqualityTier\x88\x01\x01\x12(\n" +
	"\rprimary_width\x18\x12 \x01(\x05H\fR\fprimaryWidth\x88\x01\x01\x12*\n" +
	"\x0eprimary_height\x18\x13 \x01(\x05H\rR\rprimaryHeight\x88\x01\x01\x12$\n" +
	"\vprimary_fps\x18\x14 \x01(\x02H\x0eR\n" +
	"primaryFps\x88\x01\x01\x12(\n" +
	"\rprimary_codec\x18\x15 \x01(\tH\x0fR\fprimaryCodec\x88\x01\x01\x12,\n" +
	"\x0fprimary_bitrate\x18\x16 \x01(\x05H\x10R\x0eprimaryBitrate\x88\x01\x01\x12\"\n" +
	"\n" +
	"started_at\x18\x17 \x01(\x03H\x11R\tstartedAt\x88\x01\x01\x12&\n" +
	"\fpackets_sent\x18\x18 \x01(\x04H\x12R\vpacketsSent\x88\x01\x01\x12&\n" +
	"\fpackets_lost\x18\x19 \x01(\x04H\x13R\vpacketsLost\x88\x01\x01\x12#\n" +
	"\n" +
	"replicated\x18\x1a \x01(\bH\x14R\n" +
	"replicated\x88\x01\x01\x128\n" +
	"\x15packets_retransmitted\x18\x1b \x01(\x04H\x15R\x14packetsRetransmitted\x88\x01\x01\x12 \n" +
	"\tbuffer_ms\x18\x1c \x01(\rH\x16R\bbufferMs\x88\x01\x01\x12 \n" +
	"\tjitter_ms\x18\x1d \x01(\rH\x17R\bjitterMs\x88\x01\x01\x12+\n" +
	"\x0fmax_keepaway_ms\x18\x1e \x01(\rH\x18R\rmaxKeepawayMs\x88\x01\x01\x121\n" +
	"\x12track_details_json\x18\x1f \x01(\tH\x19R\x10trackDetailsJson\x88\x01\x01\x12*\n" +
	"\x0eaudio_channels\x18  \x01(\rH\x1aR\raudioChannels\x88\x01\x01\x12/\n" +
	"\x11audio_sample_rate\x18! \x01(\rH\x1bR\x0faudioSampleRate\x88\x01\x01\x12$\n" +
	"\vaudio_codec\x18\" \x01(\tH\x1cR\n" +
	"audioCodec\x88\x01\x01\x12(\n" +
	"\raudio_bitrate\x18# \x01(\rH\x1dR\faudioBitrate\x88\x01\x01\x12+\n" +
	"\x0fvideo_buffer_ms\x18$ \x01(\rH\x1eR\rvideoBufferMs\x88\x01\x01\x12+\n" +
	"\x0fvideo_jitter_ms\x18% \x01(\rH\x1fR\rvideoJitterMs\x88\x01\x01\x12 \n" +
	"\tstream_id\x18& \x01(\tH R\bstreamId\x88\x01\x01B\f\n" +
	"\n" +
	"_tenant_idB\x0f\n" +
	"\r_buffer_stateB\x11\n" +
	"\x0f_uploaded_bytesB\x13\n" +
	"\x11_downloaded_bytesB\x10\n" +
	"\x0e_total_viewersB\x0f\n" +
	"\r_total_inputsB\x11\n" +
	"\x0f_viewer_secondsB\x11\n" +
	"\x0f_stream_detailsB\r\n" +
	"\v_has_issuesB\x15\n" +
	"\x13_issues_descriptionB\x0e\n" +
	"\f_track_countB\x0f\n" +
	"\r_quality_tierB\x10\n" +
	"\x0e_primary_widthB\x11\n" +
	"\x0f_primary_heightB\x0e\n" +
	"\f_primary_fpsB\x10\n" +
	"\x0e_primary_codecB\x12\n" +
	"\x10_primary_bitrateB\r\n" +
	"\v_started_atB\x0f\n" +
	"\r_packets_sentB\x0f\n" +
	"\r_packets_lostB\r\n" +
	"\v_replicatedB\x18\n" +
	"\x16_packets_retransmittedB\f\n" +
	"\n" +
	"_buffer_msB\f\n" +
	"\n" +
	"_jitter_msB\x12\n" +
	"\x10_max_keepaway_msB\x15\n" +
	"\x13_track_details_jsonB\x11\n" +
	"\x0f_audio_channelsB\x14\n" +
	"\x12_audio_sample_rateB\x0e\n" +
	"\f_audio_codecB\x10\n" +
	"\x0e_audio_bitrateB\x12\n" +
	"\x10_video_buffer_msB\x12\n" +
	"\x10_video_jitter_msB\f\n" +
	"\n" +
	"_stream_id\"\x95\t\n" +
	"\x15ClientLifecycleUpdate\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12 \n" +
	"\ttenant_id\x18\x02 \x01(\tH\x00R\btenantId\x88\x01\x01\x12#\n" +
	"\rinternal_name\x18\x03 \x01(\tR\finternalName\x12\x16\n" +
	"\x06action\x18\x04 \x01(\tR\x06action\x12\x1a\n" +
	"\bprotocol\x18\x05 \x01(\tR\bprotocol\x12\x12\n" +
	"\x04host\x18\x06 \x01(\tR\x04host\x12\"\n" +
	"\n" +
	"session_id\x18\a \x01(\tH\x01R\tsessionId\x88\x01\x01\x12,\n" +
	"\x0fconnection_time\x18\b \x01(\x02H\x02R\x0econnectionTime\x88\x01\x01\x12\x1f\n" +
	"\bposition\x18\t \x01(\x02H\x03R\bposition\x88\x01\x01\x12-\n" +
	"\x10bandwidth_in_bps\x18\n" +
	" \x01(\x04H\x04R\x0ebandwidthInBps\x88\x01\x01\x12/\n" +
	"\x11bandwidth_out_bps\x18\v \x01(\x04H\x05R\x0fbandwidthOutBps\x88\x01\x01\x12.\n" +
	"\x10bytes_downloaded\x18\f \x01(\x04H\x06R\x0fbytesDownloaded\x88\x01\x01\x12*\n" +
	"\x0ebytes_uploaded\x18\r \x01(\x04H\aR\rbytesUploaded\x88\x01\x01\x12&\n" +
	"\fpackets_sent\x18\x0e \x01(\x04H\bR\vpacketsSent\x88\x01\x01\x12&\n" +
	"\fpackets_lost\x18\x0f \x01(\x04H\tR\vpacketsLost\x88\x01\x01\x128\n" +
	"\x15packets_retransmitted\x18\x10 \x01(\x04H\n" +
	"R\x14packetsRetransmitted\x88\x01\x01\x12\x1c\n" +
	"\ttimestamp\x18\x11 \x01(\x03R\ttimestamp\x12*\n" +
	"\x0eclient_country\x18\x13 \x01(\tH\vR\rclientCountry\x88\x01\x01\x12$\n" +
	"\vclient_city\x18\x14 \x01(\tH\fR\n" +
	"clientCity\x88\x01\x01\x12,\n" +
	"\x0fclient_latitude\x18\x15 \x01(\x01H\rR\x0eclientLatitude\x88\x01\x01\x12.\n" +
	"\x10client_longitude\x18\x16 \x01(\x01H\x0eR\x0fclientLongitude\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\x17 \x01(\tH\x0fR\bstreamId\x88\x01\x01B\f\n" +
	"\n" +
	"_tenant_idB\r\n" +
	"\v_session_idB\x12\n" +
	"\x10_connection_timeB\v\n" +
	"\t_positionB\x13\n" +
	"\x11_bandwidth_in_bpsB\x14\n" +
	"\x12_bandwidth_out_bpsB\x13\n" +
	"\x11_bytes_downloadedB\x11\n" +
	"\x0f_bytes_uploadedB\x0f\n" +
	"\r_packets_sentB\x0f\n" +
	"\r_packets_lostB\x18\n" +
	"\x16_packets_retransmittedB\x11\n" +
	"\x0f_client_countryB\x0e\n" +
	"\f_client_cityB\x12\n" +
	"\x10_client_latitudeB\x13\n" +
	"\x11_client_longitudeB\f\n" +
	"\n" +
	"_stream_idJ\x04\b\x12\x10\x13\"\xa2\f\n" +
	"\x13NodeLifecycleUpdate\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1d\n" +
	"\n" +
	"cpu_tenths\x18\x02 \x01(\rR\tcpuTenths\x12\x17\n" +
	"\aram_max\x18\x03 \x01(\x04R\x06ramMax\x12\x1f\n" +
	"\vram_current\x18\x04 \x01(\x04R\n" +
	"ramCurrent\x12&\n" +
	"\x0fshm_total_bytes\x18\x05 \x01(\x04R\rshmTotalBytes\x12$\n" +
	"\x0eshm_used_bytes\x18\x06 \x01(\x04R\fshmUsedBytes\x12(\n" +
	"\x10disk_total_bytes\x18\a \x01(\x04R\x0ediskTotalBytes\x12&\n" +
	"\x0fdisk_used_bytes\x18\b \x01(\x04R\rdiskUsedBytes\x12\x19\n" +
	"\bup_speed\x18\t \x01(\x04R\aupSpeed\x12\x1d\n" +
	"\n" +
	"down_speed\x18\n" +
	" \x01(\x04R\tdownSpeed\x12\x19\n" +
	"\bbw_limit\x18\v \x01(\x04R\abwLimit\x12\x1a\n" +
	"\blatitude\x18\f \x01(\x01R\blatitude\x12\x1c\n" +
	"\tlongitude\x18\r \x01(\x01R\tlongitude\x12\x1a\n" +
	"\blocation\x18\x0e \x01(\tR\blocation\x12%\n" +
	"\x0eactive_streams\x18\x0f \x01(\rR\ractiveStreams\x12\x19\n" +
	"\bbase_url\x18\x10 \x01(\tR\abaseUrl\x12\x1d\n" +
	"\n" +
	"is_healthy\x18\x11 \x01(\bR\tisHealthy\x12\x1d\n" +
	"\n" +
	"event_type\x18\x12 \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x13 \x01(\x03R\ttimestamp\x12E\n" +
	"\fcapabilities\x18\x14 \x01(\v2!.helmsmancontrol.NodeCapabilitiesR\fcapabilities\x126\n" +
	"\astorage\x18\x15 \x01(\v2\x1c.helmsmancontrol.StorageInfoR\astorage\x123\n" +
	"\x06limits\x18\x16 \x01(\v2\x1b.helmsmancontrol.NodeLimitsR\x06limits\x12K\n" +
	"\astreams\x18\x17 \x03(\v21.helmsmancontrol.NodeLifecycleUpdate.StreamsEntryR\astreams\x12=\n" +
	"\tartifacts\x18\x18 \x03(\v2\x1f.helmsmancontrol.StoredArtifactR\tartifacts\x12!\n" +
	"\foutputs_json\x18\x19 \x01(\tR\voutputsJson\x12 \n" +
	"\ttenant_id\x18\x1a \x01(\tH\x00R\btenantId\x88\x01\x01\x12,\n" +
	"\x12bandwidth_in_total\x18\x1b \x01(\x04R\x10bandwidthInTotal\x12.\n" +
	"\x13bandwidth_out_total\x18\x1c \x01(\x04R\x11bandwidthOutTotal\x12/\n" +
	"\x13connections_current\x18\x1d \x01(\rR\x12connectionsCurrent\x12 \n" +
	"\tnode_uuid\x18\x1e \x01(\tH\x01R\bnodeUuid\x88\x01\x01\x12#\n" +
	"\rtriggers_json\x18( \x01(\tR\ftriggersJson\x12-\n" +
	"\x12connections_inputs\x18) \x01(\rR\x11connectionsInputs\x121\n" +
	"\x14connections_outgoing\x18* \x01(\rR\x13connectionsOutgoing\x12O\n" +
	"\x10operational_mode\x18+ \x01(\x0e2$.helmsmancontrol.NodeOperationalModeR\x0foperationalMode\x12-\n" +
	"\x12connections_cached\x18, \x01(\rR\x11connectionsCached\x1aW\n" +
	"\fStreamsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x121\n" +
	"\x05value\x18\x02 \x01(\v2\x1b.helmsmancontrol.StreamDataR\x05value:\x028\x01B\f\n" +
	"\n" +
	"_tenant_idB\f\n" +
	"\n" +
	"_node_uuid\"\x88\t\n" +
	"\x11LoadBalancingData\x12#\n" +
	"\rselected_node\x18\x01 \x01(\tR\fselectedNode\x12\x1a\n" +
	"\blatitude\x18\x02 \x01(\x01R\blatitude\x12\x1c\n" +
	"\tlongitude\x18\x03 \x01(\x01R\tlongitude\x12\x16\n" +
	"\x06status\x18\x04 \x01(\tR\x06status\x12\x18\n" +
	"\adetails\x18\x05 \x01(\tR\adetails\x12\x14\n" +
	"\x05score\x18\x06 \x01(\x04R\x05score\x12\x1b\n" +
	"\tclient_ip\x18\a \x01(\tR\bclientIp\x12%\n" +
	"\x0eclient_country\x18\b \x01(\tR\rclientCountry\x12#\n" +
	"\rnode_latitude\x18\t \x01(\x01R\fnodeLatitude\x12%\n" +
	"\x0enode_longitude\x18\n" +
	" \x01(\x01R\rnodeLongitude\x12\x1b\n" +
	"\tnode_name\x18\v \x01(\tR\bnodeName\x12-\n" +
	"\x10selected_node_id\x18\f \x01(\tH\x00R\x0eselectedNodeId\x88\x01\x01\x123\n" +
	"\x13routing_distance_km\x18\r \x01(\x01H\x01R\x11routingDistanceKm\x88\x01\x01\x12 \n" +
	"\ttenant_id\x18\x0e \x01(\tH\x02R\btenantId\x88\x01\x01\x12(\n" +
	"\rinternal_name\x18\x0f \x01(\tH\x03R\finternalName\x88\x01\x01\x12D\n" +
	"\rclient_bucket\x18\x10 \x01(\v2\x1a.helmsmancontrol.GeoBucketH\x04R\fclientBucket\x88\x01\x01\x12@\n" +
	"\vnode_bucket\x18\x11 \x01(\v2\x1a.helmsmancontrol.GeoBucketH\x05R\n" +
	"nodeBucket\x88\x01\x01\x12-\n" +
	"\x10stream_tenant_id\x18\x12 \x01(\tH\x06R\x0estreamTenantId\x88\x01\x01\x12\"\n" +
	"\n" +
	"cluster_id\x18\x13 \x01(\tH\aR\tclusterId\x88\x01\x01\x12\"\n" +
	"\n" +
	"latency_ms\x18\x14 \x01(\x02H\bR\tlatencyMs\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\x15 \x01(\tH\tR\bstreamId\x88\x01\x01\x12.\n" +
	"\x10candidates_count\x18\x16 \x01(\rH\n" +
	"R\x0fcandidatesCount\x88\x01\x01\x12\"\n" +
	"\n" +
	"event_type\x18\x17 \x01(\tH\vR\teventType\x88\x01\x01\x12\x1b\n" +
	"\x06source\x18\x18 \x01(\tH\fR\x06source\x88\x01\x01B\x13\n" +
	"\x11_selected_node_idB\x16\n" +
	"\x14_routing_distance_kmB\f\n" +
	"\n" +
	"_tenant_idB\x10\n" +
	"\x0e_internal_nameB\x10\n" +
	"\x0e_client_bucketB\x0e\n" +
	"\f_node_bucketB\x13\n" +
	"\x11_stream_tenant_idB\r\n" +
	"\v_cluster_idB\r\n" +
	"\v_latency_msB\f\n" +
	"\n" +
	"_stream_idB\x13\n" +
	"\x11_candidates_countB\r\n" +
	"\v_event_typeB\t\n" +
	"\a_source\"\xda\t\n" +
	"\x11ClipLifecycleData\x12>\n" +
	"\x05stage\x18\x01 \x01(\x0e2(.helmsmancontrol.ClipLifecycleData.StageR\x05stage\x12\x1b\n" +
	"\tclip_hash\x18\x02 \x01(\tR\bclipHash\x12\"\n" +
	"\n" +
	"request_id\x18\x03 \x01(\tH\x00R\trequestId\x88\x01\x01\x12.\n" +
	"\x10progress_percent\x18\x04 \x01(\rH\x01R\x0fprogressPercent\x88\x01\x01\x12 \n" +
	"\tfile_path\x18\x05 \x01(\tH\x02R\bfilePath\x88\x01\x01\x12\x1a\n" +
	"\x06s3_url\x18\x06 \x01(\tH\x03R\x05s3Url\x88\x01\x01\x12\"\n" +
	"\n" +
	"size_bytes\x18\a \x01(\x04H\x04R\tsizeBytes\x88\x01\x01\x12\x19\n" +
	"\x05error\x18\b \x01(\tH\x05R\x05error\x88\x01\x01\x12\"\n" +
	"\n" +
	"started_at\x18\t \x01(\x03H\x06R\tstartedAt\x88\x01\x01\x12&\n" +
	"\fcompleted_at\x18\n" +
	" \x01(\x03H\aR\vcompletedAt\x88\x01\x01\x12\x1c\n" +
	"\anode_id\x18\v \x01(\tH\bR\x06nodeId\x88\x01\x01\x12 \n" +
	"\ttenant_id\x18\f \x01(\tH\tR\btenantId\x88\x01\x01\x12(\n" +
	"\rinternal_name\x18\r \x01(\tH\n" +
	"R\finternalName\x88\x01\x01\x12\"\n" +
	"\n" +
	"start_unix\x18\x0e \x01(\x03H\vR\tstartUnix\x88\x01\x01\x12 \n" +
	"\tstop_unix\x18\x0f \x01(\x03H\fR\bstopUnix\x88\x01\x01\x12\x1e\n" +
	"\bstart_ms\x18\x10 \x01(\x03H\rR\astartMs\x88\x01\x01\x12\x1c\n" +
	"\astop_ms\x18\x11 \x01(\x03H\x0eR\x06stopMs\x88\x01\x01\x12&\n" +
	"\fduration_sec\x18\x12 \x01(\x03H\x0fR\vdurationSec\x88\x01\x01\x12 \n" +
	"\tclip_mode\x18\x13 \x01(\tH\x10R\bclipMode\x88\x01\x01\x12\"\n" +
	"\n" +
	"expires_at\x18\x14 \x01(\x03H\x11R\texpiresAt\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\x15 \x01(\tH\x12R\bstreamId\x88\x01\x01\x12\x1c\n" +
	"\auser_id\x18\x16 \x01(\tH\x13R\x06userId\x88\x01\x01\"\x8e\x01\n" +
	"\x05Stage\x12\x15\n" +
	"\x11STAGE_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fSTAGE_REQUESTED\x10\x01\x12\x10\n" +
	"\fSTAGE_QUEUED\x10\x02\x12\x12\n" +
	"\x0eSTAGE_PROGRESS\x10\x03\x12\x0e\n" +
	"\n" +
	"STAGE_DONE\x10\x04\x12\x10\n" +
	"\fSTAGE_FAILED\x10\x05\x12\x11\n" +
	"\rSTAGE_DELETED\x10\x06B\r\n" +
	"\v_request_idB\x13\n" +
	"\x11_progress_percentB\f\n" +
	"\n" +
	"_file_pathB\t\n" +
	"\a_s3_urlB\r\n" +
	"\v_size_bytesB\b\n" +
	"\x06_errorB\r\n" +
	"\v_started_atB\x0f\n" +
	"\r_completed_atB\n" +
	"\n" +
	"\b_node_idB\f\n" +
	"\n" +
	"_tenant_idB\x10\n" +
	"\x0e_internal_nameB\r\n" +
	"\v_start_unixB\f\n" +
	"\n" +
	"_stop_unixB\v\n" +
	"\t_start_msB\n" +
	"\n" +
	"\b_stop_msB\x0f\n" +
	"\r_duration_secB\f\n" +
	"\n" +
	"_clip_modeB\r\n" +
	"\v_expires_atB\f\n" +
	"\n" +
	"_stream_idB\n" +
	"\n" +
	"\b_user_id\"\xca\x06\n" +
	"\x10DVRLifecycleData\x12@\n" +
	"\x06status\x18\x01 \x01(\x0e2(.helmsmancontrol.DVRLifecycleData.StatusR\x06status\x12\x19\n" +
	"\bdvr_hash\x18\x02 \x01(\tR\advrHash\x12(\n" +
	"\rmanifest_path\x18\x03 \x01(\tH\x00R\fmanifestPath\x88\x01\x01\x12\"\n" +
	"\n" +
	"started_at\x18\x04 \x01(\x03H\x01R\tstartedAt\x88\x01\x01\x12\x1e\n" +
	"\bended_at\x18\x05 \x01(\x03H\x02R\aendedAt\x88\x01\x01\x12\"\n" +
	"\n" +
	"size_bytes\x18\x06 \x01(\x04H\x03R\tsizeBytes\x88\x01\x01\x12(\n" +
	"\rsegment_count\x18\a \x01(\x05H\x04R\fsegmentCount\x88\x01\x01\x12\x19\n" +
	"\x05error\x18\b \x01(\tH\x05R\x05error\x88\x01\x01\x12\x1c\n" +
	"\anode_id\x18\t \x01(\tH\x06R\x06nodeId\x88\x01\x01\x12 \n" +
	"\ttenant_id\x18\n" +
	" \x01(\tH\aR\btenantId\x88\x01\x01\x12(\n" +
	"\rinternal_name\x18\v \x01(\tH\bR\finternalName\x88\x01\x01\x12\"\n" +
	"\n" +
	"expires_at\x18\f \x01(\x03H\tR\texpiresAt\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\r \x01(\tH\n" +
	"R\bstreamId\x88\x01\x01\x12\x1c\n" +
	"\auser_id\x18\x0e \x01(\tH\vR\x06userId\x88\x01\x01\"\x85\x01\n" +
	"\x06Status\x12\x16\n" +
	"\x12STATUS_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eSTATUS_STARTED\x10\x01\x12\x14\n" +
	"\x10STATUS_RECORDING\x10\x02\x12\x12\n" +
	"\x0eSTATUS_STOPPED\x10\x03\x12\x11\n" +
	"\rSTATUS_FAILED\x10\x04\x12\x12\n" +
	"\x0eSTATUS_DELETED\x10\x05B\x10\n" +
	"\x0e_manifest_pathB\r\n" +
	"\v_started_atB\v\n" +
	"\t_ended_atB\r\n" +
	"\v_size_bytesB\x10\n" +
	"\x0e_segment_countB\b\n" +
	"\x06_errorB\n" +
	"\n" +
	"\b_node_idB\f\n" +
	"\n" +
	"_tenant_idB\x10\n" +
	"\x0e_internal_nameB\r\n" +
	"\v_expires_atB\f\n" +
	"\n" +
	"_stream_idB\n" +
	"\n" +
	"\b_user_id\"\x8a\t\n" +
	"\x10VodLifecycleData\x12@\n" +
	"\x06status\x18\x01 \x01(\x0e2(.helmsmancontrol.VodLifecycleData.StatusR\x06status\x12\x19\n" +
	"\bvod_hash\x18\x02 \x01(\tR\avodHash\x12 \n" +
	"\tupload_id\x18\x03 \x01(\tH\x00R\buploadId\x88\x01\x01\x12\x1f\n" +
	"\bfilename\x18\x04 \x01(\tH\x01R\bfilename\x88\x01\x01\x12&\n" +
	"\fcontent_type\x18\x05 \x01(\tH\x02R\vcontentType\x88\x01\x01\x12\"\n" +
	"\n" +
	"size_bytes\x18\x06 \x01(\x04H\x03R\tsizeBytes\x88\x01\x01\x12\x1a\n" +
	"\x06s3_url\x18\a \x01(\tH\x04R\x05s3Url\x88\x01\x01\x12 \n" +
	"\tfile_path\x18\b \x01(\tH\x05R\bfilePath\x88\x01\x01\x12\x19\n" +
	"\x05error\x18\t \x01(\tH\x06R\x05error\x88\x01\x01\x12\"\n" +
	"\n" +
	"started_at\x18\n" +
	" \x01(\x03H\aR\tstartedAt\x88\x01\x01\x12&\n" +
	"\fcompleted_at\x18\v \x01(\x03H\bR\vcompletedAt\x88\x01\x01\x12\x1c\n" +
	"\anode_id\x18\f \x01(\tH\tR\x06nodeId\x88\x01\x01\x12 \n" +
	"\ttenant_id\x18\r \x01(\tH\n" +
	"R\btenantId\x88\x01\x01\x12\x1c\n" +
	"\auser_id\x18\x0e \x01(\tH\vR\x06userId\x88\x01\x01\x12\"\n" +
	"\n" +
	"expires_at\x18\x0f \x01(\x03H\fR\texpiresAt\x88\x01\x01\x12$\n" +
	"\vduration_ms\x18\x10 \x01(\x03H\rR\n" +
	"durationMs\x88\x01\x01\x12#\n" +
	"\n" +
	"resolution\x18\x11 \x01(\tH\x0eR\n" +
	"resolution\x88\x01\x01\x12$\n" +
	"\vvideo_codec\x18\x12 \x01(\tH\x0fR\n" +
	"videoCodec\x88\x01\x01\x12$\n" +
	"\vaudio_codec\x18\x13 \x01(\tH\x10R\n" +
	"audioCodec\x88\x01\x01\x12&\n" +
	"\fbitrate_kbps\x18\x14 \x01(\x05H\x11R\vbitrateKbps\x88\x01\x01\"\xa0\x01\n" +
	"\x06Status\x12\x16\n" +
	"\x12STATUS_UNSPECIFIED\x10\x00\x12\x14\n" +
	"\x10STATUS_REQUESTED\x10\x01\x12\x14\n" +
	"\x10STATUS_UPLOADING\x10\x02\x12\x15\n" +
	"\x11STATUS_PROCESSING\x10\x03\x12\x14\n" +
	"\x10STATUS_COMPLETED\x10\x04\x12\x11\n" +
	"\rSTATUS_FAILED\x10\x05\x12\x12\n" +
	"\x0eSTATUS_DELETED\x10\x06B\f\n" +
	"\n" +
	"_upload_idB\v\n" +
	"\t_filenameB\x0f\n" +
	"\r_content_typeB\r\n" +
	"\v_size_bytesB\t\n" +
	"\a_s3_urlB\f\n" +
	"\n" +
	"_file_pathB\b\n" +
	"\x06_errorB\r\n" +
	"\v_started_atB\x0f\n" +
	"\r_completed_atB\n" +
	"\n" +
	"\b_node_idB\f\n" +
	"\n" +
	"_tenant_idB\n" +
	"\n" +
	"\b_user_idB\r\n" +
	"\v_expires_atB\x0e\n" +
	"\f_duration_msB\r\n" +
	"\v_resolutionB\x0e\n" +
	"\f_video_codecB\x0e\n" +
	"\f_audio_codecB\x0f\n" +
	"\r_bitrate_kbps\"\x94\x05\n" +
	"\x14MessageLifecycleData\x12N\n" +
	"\n" +
	"event_type\x18\x01 \x01(\x0e2/.helmsmancontrol.MessageLifecycleData.EventTypeR\teventType\x12'\n" +
	"\x0fconversation_id\x18\x02 \x01(\tR\x0econversationId\x12\"\n" +
	"\n" +
	"message_id\x18\x03 \x01(\tH\x00R\tmessageId\x88\x01\x01\x12\x1d\n" +
	"\acontent\x18\x04 \x01(\tH\x01R\acontent\x88\x01\x01\x12\x1b\n" +
	"\x06sender\x18\x05 \x01(\tH\x02R\x06sender\x88\x01\x01\x12\x1b\n" +
	"\x06status\x18\x06 \x01(\tH\x03R\x06status\x88\x01\x01\x12\x1d\n" +
	"\asubject\x18\a \x01(\tH\x04R\asubject\x88\x01\x01\x12\x1c\n" +
	"\ttimestamp\x18\b \x01(\x03R\ttimestamp\x12 \n" +
	"\ttenant_id\x18\t \x01(\tH\x05R\btenantId\x88\x01\x01\x12\x1c\n" +
	"\auser_id\x18\n" +
	" \x01(\tH\x06R\x06userId\x88\x01\x01\"\xb1\x01\n" +
	"\tEventType\x12\x1a\n" +
	"\x16EVENT_TYPE_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aEVENT_TYPE_MESSAGE_CREATED\x10\x01\x12#\n" +
	"\x1fEVENT_TYPE_CONVERSATION_CREATED\x10\x02\x12#\n" +
	"\x1fEVENT_TYPE_CONVERSATION_UPDATED\x10\x03\x12\x1e\n" +
	"\x1aEVENT_TYPE_MESSAGE_UPDATED\x10\x04B\r\n" +
	"\v_message_idB\n" +
	"\n" +
	"\b_contentB\t\n" +
	"\a_senderB\t\n" +
	"\a_statusB\n" +
	"\n" +
	"\b_subjectB\f\n" +
	"\n" +
	"_tenant_idB\n" +
	"\n" +
	"\b_user_id\"\x8e\x01\n" +
	"\x10NodeCapabilities\x12\x16\n" +
	"\x06ingest\x18\x01 \x01(\bR\x06ingest\x12\x12\n" +
	"\x04edge\x18\x02 \x01(\bR\x04edge\x12\x18\n" +
	"\astorage\x18\x03 \x01(\bR\astorage\x12\x1e\n" +
	"\n" +
	"processing\x18\x04 \x01(\bR\n" +
	"processing\x12\x14\n" +
	"\x05roles\x18\x05 \x03(\tR\x05roles\"\xe2\x01\n" +
	"\x10ProcessingConfig\x12<\n" +
	"\x1alivepeer_gateway_available\x18\x01 \x01(\bR\x18livepeerGatewayAvailable\x120\n" +
	"\x14livepeer_gateway_url\x18\x02 \x01(\tR\x12livepeerGatewayUrl\x120\n" +
	"\x14gateway_input_codecs\x18\x03 \x03(\tR\x12gatewayInputCodecs\x12,\n" +
	"\x12local_input_codecs\x18\x04 \x03(\tR\x10localInputCodecs\"\x82\x17\n" +
	"\x13ProcessBillingEvent\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1f\n" +
	"\vstream_name\x18\x02 \x01(\tR\n" +
	"streamName\x12!\n" +
	"\fprocess_type\x18\x03 \x01(\tR\vprocessType\x12\x1f\n" +
	"\vduration_ms\x18\x04 \x01(\x03R\n" +
	"durationMs\x12\x1c\n" +
	"\ttimestamp\x18\x05 \x01(\x03R\ttimestamp\x12 \n" +
	"\ttenant_id\x18\x06 \x01(\tH\x00R\btenantId\x88\x01\x01\x12 \n" +
	"\tstream_id\x18\a \x01(\tH\x01R\bstreamId\x88\x01\x01\x12$\n" +
	"\vinput_codec\x18\n" +
	" \x01(\tH\x02R\n" +
	"inputCodec\x88\x01\x01\x12&\n" +
	"\foutput_codec\x18\v \x01(\tH\x03R\voutputCodec\x88\x01\x01\x12\"\n" +
	"\n" +
	"track_type\x18\f \x01(\tH\x04R\ttrackType\x88\x01\x01\x12*\n" +
	"\x0esegment_number\x18\x14 \x01(\x05H\x05R\rsegmentNumber\x88\x01\x01\x12\x19\n" +
	"\x05width\x18\x15 \x01(\x05H\x06R\x05width\x88\x01\x01\x12\x1b\n" +
	"\x06height\x18\x16 \x01(\x05H\aR\x06height\x88\x01\x01\x12,\n" +
	"\x0frendition_count\x18\x17 \x01(\x05H\bR\x0erenditionCount\x88\x01\x01\x12,\n" +
	"\x0fbroadcaster_url\x18\x18 \x01(\tH\tR\x0ebroadcasterUrl\x88\x01\x01\x12)\n" +
	"\x0eupload_time_us\x18\x19 \x01(\x03H\n" +
	"R\fuploadTimeUs\x88\x01\x01\x123\n" +
	"\x13livepeer_session_id\x18\x1a \x01(\tH\vR\x11livepeerSessionId\x88\x01\x01\x12-\n" +
	"\x10segment_start_ms\x18\x1b \x01(\x03H\fR\x0esegmentStartMs\x88\x01\x01\x12$\n" +
	"\vinput_bytes\x18\x1c \x01(\x03H\rR\n" +
	"inputBytes\x88\x01\x01\x121\n" +
	"\x12output_bytes_total\x18\x1d \x01(\x03H\x0eR\x10outputBytesTotal\x88\x01\x01\x12(\n" +
	"\rattempt_count\x18( \x01(\x05H\x0fR\fattemptCount\x88\x01\x01\x12(\n" +
	"\rturnaround_ms\x18) \x01(\x03H\x10R\fturnaroundMs\x88\x01\x01\x12&\n" +
	"\fspeed_factor\x18* \x01(\x01H\x11R\vspeedFactor\x88\x01\x01\x12,\n" +
	"\x0frenditions_json\x18+ \x01(\tH\x12R\x0erenditionsJson\x88\x01\x01\x12&\n" +
	"\finput_frames\x18\x1e \x01(\x03H\x13R\vinputFrames\x88\x01\x01\x12(\n" +
	"\routput_frames\x18\x1f \x01(\x03H\x14R\foutputFrames\x88\x01\x01\x122\n" +
	"\x13decode_us_per_frame\x18  \x01(\x03H\x15R\x10decodeUsPerFrame\x88\x01\x01\x128\n" +
	"\x16transform_us_per_frame\x18! \x01(\x03H\x16R\x13transformUsPerFrame\x88\x01\x01\x122\n" +
	"\x13encode_us_per_frame\x18\" \x01(\x03H\x17R\x10encodeUsPerFrame\x88\x01\x01\x12\x1e\n" +
	"\bis_final\x18# \x01(\bH\x18R\aisFinal\x88\x01\x01\x121\n" +
	"\x12input_frames_delta\x182 \x01(\x03H\x19R\x10inputFramesDelta\x88\x01\x01\x123\n" +
	"\x13output_frames_delta\x183 \x01(\x03H\x1aR\x11outputFramesDelta\x88\x01\x01\x12/\n" +
	"\x11input_bytes_delta\x184 \x01(\x03H\x1bR\x0finputBytesDelta\x88\x01\x01\x121\n" +
	"\x12output_bytes_delta\x185 \x01(\x03H\x1cR\x10outputBytesDelta\x88\x01\x01\x12$\n" +
	"\vinput_width\x186 \x01(\x05H\x1dR\n" +
	"inputWidth\x88\x01\x01\x12&\n" +
	"\finput_height\x187 \x01(\x05H\x1eR\vinputHeight\x88\x01\x01\x12&\n" +
	"\foutput_width\x188 \x01(\x05H\x1fR\voutputWidth\x88\x01\x01\x12(\n" +
	"\routput_height\x189 \x01(\x05H R\foutputHeight\x88\x01\x01\x12\"\n" +
	"\n" +
	"input_fpks\x18: \x01(\x05H!R\tinputFpks\x88\x01\x01\x123\n" +
	"\x13output_fps_measured\x18; \x01(\x01H\"R\x11outputFpsMeasured\x88\x01\x01\x12$\n" +
	"\vsample_rate\x18< \x01(\x05H#R\n" +
	"sampleRate\x88\x01\x01\x12\x1f\n" +
	"\bchannels\x18= \x01(\x05H$R\bchannels\x88\x01\x01\x123\n" +
	"\x13source_timestamp_ms\x18> \x01(\x03H%R\x11sourceTimestampMs\x88\x01\x01\x12/\n" +
	"\x11sink_timestamp_ms\x18? \x01(\x03H&R\x0fsinkTimestampMs\x88\x01\x01\x121\n" +
	"\x12source_advanced_ms\x18@ \x01(\x03H'R\x10sourceAdvancedMs\x88\x01\x01\x12-\n" +
	"\x10sink_advanced_ms\x18A \x01(\x03H(R\x0esinkAdvancedMs\x88\x01\x01\x12\x1a\n" +
	"\x06rtf_in\x18B \x01(\x01H)R\x05rtfIn\x88\x01\x01\x12\x1c\n" +
	"\artf_out\x18C \x01(\x01H*R\x06rtfOut\x88\x01\x01\x12+\n" +
	"\x0fpipeline_lag_ms\x18D \x01(\x03H+R\rpipelineLagMs\x88\x01\x01\x121\n" +
	"\x12output_bitrate_bps\x18E \x01(\x03H,R\x10outputBitrateBps\x88\x01\x01B\f\n" +
	"\n" +
	"_tenant_idB\f\n" +
	"\n" +
	"_stream_idB\x0e\n" +
	"\f_input_codecB\x0f\n" +
	"\r_output_codecB\r\n" +
	"\v_track_typeB\x11\n" +
	"\x0f_segment_numberB\b\n" +
	"\x06_widthB\t\n" +
	"\a_heightB\x12\n" +
	"\x10_rendition_countB\x12\n" +
	"\x10_broadcaster_urlB\x11\n" +
	"\x0f_upload_time_usB\x16\n" +
	"\x14_livepeer_session_idB\x13\n" +
	"\x11_segment_start_msB\x0e\n" +
	"\f_input_bytesB\x15\n" +
	"\x13_output_bytes_totalB\x10\n" +
	"\x0e_attempt_countB\x10\n" +
	"\x0e_turnaround_msB\x0f\n" +
	"\r_speed_factorB\x12\n" +
	"\x10_renditions_jsonB\x0f\n" +
	"\r_input_framesB\x10\n" +
	"\x0e_output_framesB\x16\n" +
	"\x14_decode_us_per_frameB\x19\n" +
	"\x17_transform_us_per_frameB\x16\n" +
	"\x14_encode_us_per_frameB\v\n" +
	"\t_is_finalB\x15\n" +
	"\x13_input_frames_deltaB\x16\n" +
	"\x14_output_frames_deltaB\x14\n" +
	"\x12_input_bytes_deltaB\x15\n" +
	"\x13_output_bytes_deltaB\x0e\n" +
	"\f_input_widthB\x0f\n" +
	"\r_input_heightB\x0f\n" +
	"\r_output_widthB\x10\n" +
	"\x0e_output_heightB\r\n" +
	"\v_input_fpksB\x16\n" +
	"\x14_output_fps_measuredB\x0e\n" +
	"\f_sample_rateB\v\n" +
	"\t_channelsB\x16\n" +
	"\x14_source_timestamp_msB\x14\n" +
	"\x12_sink_timestamp_msB\x15\n" +
	"\x13_source_advanced_msB\x13\n" +
	"\x11_sink_advanced_msB\t\n" +
	"\a_rtf_inB\n" +
	"\n" +
	"\b_rtf_outB\x12\n" +
	"\x10_pipeline_lag_msB\x15\n" +
	"\x13_output_bitrate_bps\"f\n" +
	"\vStorageInfo\x12\x1d\n" +
	"\n" +
	"local_path\x18\x01 \x01(\tR\tlocalPath\x12\x1b\n" +
	"\ts3_bucket\x18\x02 \x01(\tR\bs3Bucket\x12\x1b\n" +
	"\ts3_prefix\x18\x03 \x01(\tR\bs3Prefix\"\x97\x01\n" +
	"\n" +
	"NodeLimits\x12%\n" +
	"\x0emax_transcodes\x18\x01 \x01(\x05R\rmaxTranscodes\x124\n" +
	"\x16storage_capacity_bytes\x18\x02 \x01(\x04R\x14storageCapacityBytes\x12,\n" +
	"\x12storage_used_bytes\x18\x03 \x01(\x04R\x10storageUsedBytes\"\x84\x02\n" +
	"\n" +
	"StreamData\x12\x14\n" +
	"\x05total\x18\x01 \x01(\x04R\x05total\x12\x16\n" +
	"\x06inputs\x18\x02 \x01(\rR\x06inputs\x12\x19\n" +
	"\bbytes_up\x18\x03 \x01(\x04R\abytesUp\x12\x1d\n" +
	"\n" +
	"bytes_down\x18\x04 \x01(\x04R\tbytesDown\x12\x1c\n" +
	"\tbandwidth\x18\x05 \x01(\rR\tbandwidth\x12\x1e\n" +
	"\n" +
	"replicated\x18\x06 \x01(\bR\n" +
	"replicated\x12#\n" +
	"\rpacket_counts\x18\a \x03(\x03R\fpacketCounts\x12+\n" +
	"\x11total_connections\x18\b \x03(\x03R\x10totalConnections\"\xb2\a\n" +
	"\vStreamTrack\x12\x1d\n" +
	"\n" +
	"track_name\x18\x01 \x01(\tR\ttrackName\x12\x1d\n" +
	"\n" +
	"track_type\x18\x02 \x01(\tR\ttrackType\x12\x14\n" +
	"\x05codec\x18\x03 \x01(\tR\x05codec\x12&\n" +
	"\fbitrate_kbps\x18\x04 \x01(\x05H\x00R\vbitrateKbps\x88\x01\x01\x12$\n" +
	"\vbitrate_bps\x18\x05 \x01(\x03H\x01R\n" +
	"bitrateBps\x88\x01\x01\x12\x1b\n" +
	"\x06buffer\x18\x06 \x01(\x05H\x02R\x06buffer\x88\x01\x01\x12\x1b\n" +
	"\x06jitter\x18\a \x01(\x05H\x03R\x06jitter\x88\x01\x01\x12\x19\n" +
	"\x05width\x18\b \x01(\x05H\x04R\x05width\x88\x01\x01\x12\x1b\n" +
	"\x06height\x18\t \x01(\x05H\x05R\x06height\x88\x01\x01\x12\x15\n" +
	"\x03fps\x18\n" +
	" \x01(\x01H\x06R\x03fps\x88\x01\x01\x12#\n" +
	"\n" +
	"resolution\x18\v \x01(\tH\aR\n" +
	"resolution\x88\x01\x01\x12$\n" +
	"\vhas_bframes\x18\f \x01(\bH\bR\n" +
	"hasBframes\x88\x01\x01\x12\x1f\n" +
	"\bchannels\x18\r \x01(\x05H\tR\bchannels\x88\x01\x01\x12$\n" +
	"\vsample_rate\x18\x0e \x01(\x05H\n" +
	"R\n" +
	"sampleRate\x88\x01\x01\x12\"\n" +
	"\n" +
	"frames_max\x18\x0f \x01(\x05H\vR\tframesMax\x88\x01\x01\x12\"\n" +
	"\n" +
	"frames_min\x18\x10 \x01(\x05H\fR\tframesMin\x88\x01\x01\x12%\n" +
	"\fframe_ms_max\x18\x11 \x01(\x01H\rR\n" +
	"frameMsMax\x88\x01\x01\x12%\n" +
	"\fframe_ms_min\x18\x12 \x01(\x01H\x0eR\n" +
	"frameMsMin\x88\x01\x01\x12+\n" +
	"\x0fkeyframe_ms_max\x18\x13 \x01(\x01H\x0fR\rkeyframeMsMax\x88\x01\x01\x12+\n" +
	"\x0fkeyframe_ms_min\x18\x14 \x01(\x01H\x10R\rkeyframeMsMin\x88\x01\x01B\x0f\n" +
	"\r_bitrate_kbpsB\x0e\n" +
	"\f_bitrate_bpsB\t\n" +
	"\a_bufferB\t\n" +
	"\a_jitterB\b\n" +
	"\x06_widthB\t\n" +
	"\a_heightB\x06\n" +
	"\x04_fpsB\r\n" +
	"\v_resolutionB\x0e\n" +
	"\f_has_bframesB\v\n" +
	"\t_channelsB\x0e\n" +
	"\f_sample_rateB\r\n" +
	"\v_frames_maxB\r\n" +
	"\v_frames_minB\x0f\n" +
	"\r_frame_ms_maxB\x0f\n" +
	"\r_frame_ms_minB\x12\n" +
	"\x10_keyframe_ms_maxB\x12\n" +
	"\x10_keyframe_ms_min\"\x8d\x03\n" +
	"\x0eStoredArtifact\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\x12\x1f\n" +
	"\vstream_name\x18\x02 \x01(\tR\n" +
	"streamName\x12\x1b\n" +
	"\tfile_path\x18\x03 \x01(\tR\bfilePath\x12\x15\n" +
	"\x06s3_url\x18\x04 \x01(\tR\x05s3Url\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x05 \x01(\x04R\tsizeBytes\x12\x1d\n" +
	"\n" +
	"created_at\x18\x06 \x01(\x03R\tcreatedAt\x12\x16\n" +
	"\x06format\x18\a \x01(\tR\x06format\x12\x19\n" +
	"\bhas_dtsh\x18\b \x01(\bR\ahasDtsh\x12!\n" +
	"\faccess_count\x18\t \x01(\x04R\vaccessCount\x12#\n" +
	"\rlast_accessed\x18\n" +
	" \x01(\x03R\flastAccessed\x12P\n" +
	"\rartifact_type\x18\v \x01(\x0e2+.helmsmancontrol.ArtifactEvent.ArtifactTypeR\fartifactType\"\x8a\x03\n" +
	"\rStreamProcess\x12\x18\n" +
	"\aprocess\x18\x01 \x01(\tR\aprocess\x12\x14\n" +
	"\x05codec\x18\x02 \x01(\tR\x05codec\x12\x18\n" +
	"\abitrate\x18\x03 \x01(\x03R\abitrate\x12!\n" +
	"\ftrack_select\x18\x04 \x01(\tR\vtrackSelect\x12#\n" +
	"\rtrack_inhibit\x18\x05 \x01(\tR\ftrackInhibit\x12!\n" +
	"\frestart_type\x18\x06 \x01(\tR\vrestartType\x12(\n" +
	"\x0finconsequential\x18\a \x01(\bR\x0finconsequential\x12\x1f\n" +
	"\vexit_unmask\x18\b \x01(\bR\n" +
	"exitUnmask\x12?\n" +
	"\x05extra\x18d \x03(\v2).helmsmancontrol.StreamProcess.ExtraEntryR\x05extra\x1a8\n" +
	"\n" +
	"ExtraEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb2\x01\n" +
	"\tStreamDef\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1a\n" +
	"\brealtime\x18\x02 \x01(\bR\brealtime\x12#\n" +
	"\rstop_sessions\x18\x03 \x01(\bR\fstopSessions\x12\x12\n" +
	"\x04tags\x18\x04 \x03(\tR\x04tags\x12<\n" +
	"\tprocesses\x18\x05 \x03(\v2\x1e.helmsmancontrol.StreamProcessR\tprocesses\"x\n" +
	"\x0eStreamTemplate\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12,\n" +
	"\x03def\x18\x02 \x01(\v2\x1a.helmsmancontrol.StreamDefR\x03def\x12\x14\n" +
	"\x05roles\x18\x03 \x03(\tR\x05roles\x12\x12\n" +
	"\x04caps\x18\x04 \x03(\tR\x04caps\"\xf4\x02\n" +
	"\n" +
	"ConfigSeed\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1a\n" +
	"\blatitude\x18\x02 \x01(\x01R\blatitude\x12\x1c\n" +
	"\tlongitude\x18\x03 \x01(\x01R\tlongitude\x12#\n" +
	"\rlocation_name\x18\x04 \x01(\tR\flocationName\x12\x1b\n" +
	"\ttenant_id\x18\x05 \x01(\tR\btenantId\x12=\n" +
	"\ttemplates\x18\n" +
	" \x03(\v2\x1f.helmsmancontrol.StreamTemplateR\ttemplates\x12A\n" +
	"\n" +
	"processing\x18\v \x01(\v2!.helmsmancontrol.ProcessingConfigR\n" +
	"processing\x12O\n" +
	"\x10operational_mode\x18\f \x01(\x0e2$.helmsmancontrol.NodeOperationalModeR\x0foperationalMode\"\x96\x01\n" +
	"\x10TranscodeProfile\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05codec\x18\x02 \x01(\tR\x05codec\x12\x18\n" +
	"\abitrate\x18\x03 \x01(\x05R\abitrate\x12\x14\n" +
	"\x05width\x18\x04 \x01(\x05R\x05width\x12\x16\n" +
	"\x06height\x18\x05 \x01(\x05R\x06height\x12\x10\n" +
	"\x03fps\x18\x06 \x01(\x01R\x03fps\"\x8e\x02\n" +
	"\x13TranscodeJobRequest\x12\x15\n" +
	"\x06job_id\x18\x01 \x01(\tR\x05jobId\x12\x1b\n" +
	"\ttenant_id\x18\x02 \x01(\tR\btenantId\x12#\n" +
	"\rartifact_hash\x18\x03 \x01(\tR\fartifactHash\x12\x1d\n" +
	"\n" +
	"source_url\x18\x04 \x01(\tR\tsourceUrl\x12=\n" +
	"\bprofiles\x18\x05 \x03(\v2!.helmsmancontrol.TranscodeProfileR\bprofiles\x12\x1f\n" +
	"\vuse_gateway\x18\x06 \x01(\bR\n" +
	"useGateway\x12\x1f\n" +
	"\vgateway_url\x18\a \x01(\tR\n" +
	"gatewayUrl\"y\n" +
	"\x14TranscodeJobProgress\x12\x15\n" +
	"\x06job_id\x18\x01 \x01(\tR\x05jobId\x12\x18\n" +
	"\apercent\x18\x02 \x01(\x05R\apercent\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\"\xb1\x01\n" +
	"\x14TranscodeJobComplete\x12\x15\n" +
	"\x06job_id\x18\x01 \x01(\tR\x05jobId\x12\x16\n" +
	"\x06status\x18\x02 \x01(\tR\x06status\x120\n" +
	"\x14output_artifact_hash\x18\x03 \x01(\tR\x12outputArtifactHash\x12\"\n" +
	"\routput_s3_url\x18\x04 \x01(\tR\voutputS3Url\x12\x14\n" +
	"\x05error\x18\x05 \x01(\tR\x05error\"\x96\x01\n" +
	"\x0fAPIRequestBatch\x12\x1c\n" +
	"\ttimestamp\x18\x01 \x01(\x03R\ttimestamp\x12\x1f\n" +
	"\vsource_node\x18\x02 \x01(\tR\n" +
	"sourceNode\x12D\n" +
	"\n" +
	"aggregates\x18\x03 \x03(\v2$.helmsmancontrol.APIRequestAggregateR\n" +
	"aggregates\"\xfe\x02\n" +
	"\x13APIRequestAggregate\x12\x1b\n" +
	"\ttenant_id\x18\x01 \x01(\tR\btenantId\x12\x1b\n" +
	"\tauth_type\x18\x02 \x01(\tR\bauthType\x12%\n" +
	"\x0eoperation_type\x18\x03 \x01(\tR\roperationType\x12%\n" +
	"\x0eoperation_name\x18\x04 \x01(\tR\roperationName\x12#\n" +
	"\rrequest_count\x18\x05 \x01(\rR\frequestCount\x12\x1f\n" +
	"\verror_count\x18\x06 \x01(\rR\n" +
	"errorCount\x12*\n" +
	"\x11total_duration_ms\x18\a \x01(\x04R\x0ftotalDurationMs\x12)\n" +
	"\x10total_complexity\x18\b \x01(\rR\x0ftotalComplexity\x12\x1f\n" +
	"\vuser_hashes\x18\t \x03(\x04R\n" +
	"userHashes\x12!\n" +
	"\ftoken_hashes\x18\n" +
	" \x03(\x04R\vtokenHashes*\xc9\x01\n" +
	"\x0fIngestErrorCode\x12\x15\n" +
	"\x11INGEST_ERROR_NONE\x10\x00\x12#\n" +
	"\x1fINGEST_ERROR_INVALID_STREAM_KEY\x10\x01\x12\"\n" +
	"\x1eINGEST_ERROR_ACCOUNT_SUSPENDED\x10\x02\x12!\n" +
	"\x1dINGEST_ERROR_PAYMENT_REQUIRED\x10\x03\x12\x19\n" +
	"\x15INGEST_ERROR_INTERNAL\x10\x04\x12\x18\n" +
	"\x14INGEST_ERROR_TIMEOUT\x10\x05*\xa8\x01\n" +
	"\x0fStorageLocation\x12 \n" +
	"\x1cSTORAGE_LOCATION_UNSPECIFIED\x10\x00\x12\x1a\n" +
	"\x16STORAGE_LOCATION_LOCAL\x10\x01\x12\x17\n" +
	"\x13STORAGE_LOCATION_S3\x10\x02\x12\x1d\n" +
	"\x19STORAGE_LOCATION_FREEZING\x10\x03\x12\x1f\n" +
	"\x1bSTORAGE_LOCATION_DEFROSTING\x10\x04*\xa9\x01\n" +
	"\x13NodeOperationalMode\x12%\n" +
	"!NODE_OPERATIONAL_MODE_UNSPECIFIED\x10\x00\x12 \n" +
	"\x1cNODE_OPERATIONAL_MODE_NORMAL\x10\x01\x12\"\n" +
	"\x1eNODE_OPERATIONAL_MODE_DRAINING\x10\x02\x12%\n" +
	"!NODE_OPERATIONAL_MODE_MAINTENANCE\x10\x032\xba\x01\n" +
	"\x0fHelmsmanControl\x12O\n" +
	"\aConnect\x12\x1f.helmsmancontrol.ControlMessage\x1a\x1f.helmsmancontrol.ControlMessage(\x010\x01\x12V\n" +
	"\x0fResolveClipHash\x12 .helmsmancontrol.ClipHashRequest\x1a!.helmsmancontrol.ClipHashResponse2\x9e\x01\n" +
	"\x0eDecklogService\x12A\n" +
	"\tSendEvent\x12\x1c.helmsmancontrol.MistTrigger\x1a\x16.google.protobuf.Empty\x12I\n" +
	"\x10SendServiceEvent\x12\x1d.helmsmancontrol.ServiceEvent\x1a\x16.google.protobuf.EmptyB\x16Z\x14frameworks/pkg/protob\x06proto3"

var (
	file_ipc_proto_rawDescOnce sync.Once
	file_ipc_proto_rawDescData []byte
)

func file_ipc_proto_rawDescGZIP() []byte {
	file_ipc_proto_rawDescOnce.Do(func() {
		file_ipc_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ipc_proto_rawDesc), len(file_ipc_proto_rawDesc)))
	})
	return file_ipc_proto_rawDescData
}

var file_ipc_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_ipc_proto_msgTypes = make([]protoimpl.MessageInfo, 91)
var file_ipc_proto_goTypes = []any{
	(IngestErrorCode)(0),                // 0: helmsmancontrol.IngestErrorCode
	(StorageLocation)(0),                // 1: helmsmancontrol.StorageLocation
	(NodeOperationalMode)(0),            // 2: helmsmancontrol.NodeOperationalMode
	(ArtifactEvent_ArtifactType)(0),     // 3: helmsmancontrol.ArtifactEvent.ArtifactType
	(StorageLifecycleData_Action)(0),    // 4: helmsmancontrol.StorageLifecycleData.Action
	(ClipLifecycleData_Stage)(0),        // 5: helmsmancontrol.ClipLifecycleData.Stage
	(DVRLifecycleData_Status)(0),        // 6: helmsmancontrol.DVRLifecycleData.Status
	(VodLifecycleData_Status)(0),        // 7: helmsmancontrol.VodLifecycleData.Status
	(MessageLifecycleData_EventType)(0), // 8: helmsmancontrol.MessageLifecycleData.EventType
	(*GeoBucket)(nil),                   // 9: helmsmancontrol.GeoBucket
	(*ServiceEvent)(nil),                // 10: helmsmancontrol.ServiceEvent
	(*AuthEvent)(nil),                   // 11: helmsmancontrol.AuthEvent
	(*TenantEvent)(nil),                 // 12: helmsmancontrol.TenantEvent
	(*ClusterEvent)(nil),                // 13: helmsmancontrol.ClusterEvent
	(*StreamChangeEvent)(nil),           // 14: helmsmancontrol.StreamChangeEvent
	(*StreamKeyEvent)(nil),              // 15: helmsmancontrol.StreamKeyEvent
	(*BillingEvent)(nil),                // 16: helmsmancontrol.BillingEvent
	(*ArtifactEvent)(nil),               // 17: helmsmancontrol.ArtifactEvent
	(*ControlMessage)(nil),              // 18: helmsmancontrol.ControlMessage
	(*StopSessionsRequest)(nil),         // 19: helmsmancontrol.StopSessionsRequest
	(*ArtifactDeleted)(nil),             // 20: helmsmancontrol.ArtifactDeleted
	(*Register)(nil),                    // 21: helmsmancontrol.Register
	(*NodeFingerprint)(nil),             // 22: helmsmancontrol.NodeFingerprint
	(*ClipPullRequest)(nil),             // 23: helmsmancontrol.ClipPullRequest
	(*ClipProgress)(nil),                // 24: helmsmancontrol.ClipProgress
	(*ClipDone)(nil),                    // 25: helmsmancontrol.ClipDone
	(*ControlError)(nil),                // 26: helmsmancontrol.ControlError
	(*Heartbeat)(nil),                   // 27: helmsmancontrol.Heartbeat
	(*MistTrigger)(nil),                 // 28: helmsmancontrol.MistTrigger
	(*MistTriggerResponse)(nil),         // 29: helmsmancontrol.MistTriggerResponse
	(*StorageSnapshot)(nil),             // 30: helmsmancontrol.StorageSnapshot
	(*TenantStorageUsage)(nil),          // 31: helmsmancontrol.TenantStorageUsage
	(*ClipHashRequest)(nil),             // 32: helmsmancontrol.ClipHashRequest
	(*ClipHashResponse)(nil),            // 33: helmsmancontrol.ClipHashResponse
	(*DVRStartRequest)(nil),             // 34: helmsmancontrol.DVRStartRequest
	(*DVRConfig)(nil),                   // 35: helmsmancontrol.DVRConfig
	(*DVRProgress)(nil),                 // 36: helmsmancontrol.DVRProgress
	(*DVRStopped)(nil),                  // 37: helmsmancontrol.DVRStopped
	(*DVRStopRequest)(nil),              // 38: helmsmancontrol.DVRStopRequest
	(*ClipDeleteRequest)(nil),           // 39: helmsmancontrol.ClipDeleteRequest
	(*DVRDeleteRequest)(nil),            // 40: helmsmancontrol.DVRDeleteRequest
	(*VodDeleteRequest)(nil),            // 41: helmsmancontrol.VodDeleteRequest
	(*FreezePermissionRequest)(nil),     // 42: helmsmancontrol.FreezePermissionRequest
	(*FreezePermissionResponse)(nil),    // 43: helmsmancontrol.FreezePermissionResponse
	(*FreezeRequest)(nil),               // 44: helmsmancontrol.FreezeRequest
	(*FreezeProgress)(nil),              // 45: helmsmancontrol.FreezeProgress
	(*FreezeComplete)(nil),              // 46: helmsmancontrol.FreezeComplete
	(*DefrostRequest)(nil),              // 47: helmsmancontrol.DefrostRequest
	(*DefrostProgress)(nil),             // 48: helmsmancontrol.DefrostProgress
	(*DefrostComplete)(nil),             // 49: helmsmancontrol.DefrostComplete
	(*CanDeleteRequest)(nil),            // 50: helmsmancontrol.CanDeleteRequest
	(*CanDeleteResponse)(nil),           // 51: helmsmancontrol.CanDeleteResponse
	(*SyncComplete)(nil),                // 52: helmsmancontrol.SyncComplete
	(*DtshSyncRequest)(nil),             // 53: helmsmancontrol.DtshSyncRequest
	(*StorageLifecycleData)(nil),        // 54: helmsmancontrol.StorageLifecycleData
	(*DVRReadyRequest)(nil),             // 55: helmsmancontrol.DVRReadyRequest
	(*DVRReadyResponse)(nil),            // 56: helmsmancontrol.DVRReadyResponse
	(*PushRewriteTrigger)(nil),          // 57: helmsmancontrol.PushRewriteTrigger
	(*ViewerResolveTrigger)(nil),        // 58: helmsmancontrol.ViewerResolveTrigger
	(*StreamSourceTrigger)(nil),         // 59: helmsmancontrol.StreamSourceTrigger
	(*PushOutStartTrigger)(nil),         // 60: helmsmancontrol.PushOutStartTrigger
	(*PushEndTrigger)(nil),              // 61: helmsmancontrol.PushEndTrigger
	(*ViewerConnectTrigger)(nil),        // 62: helmsmancontrol.ViewerConnectTrigger
	(*ViewerDisconnectTrigger)(nil),     // 63: helmsmancontrol.ViewerDisconnectTrigger
	(*StreamBufferTrigger)(nil),         // 64: helmsmancontrol.StreamBufferTrigger
	(*StreamEndTrigger)(nil),            // 65: helmsmancontrol.StreamEndTrigger
	(*StreamTrackListTrigger)(nil),      // 66: helmsmancontrol.StreamTrackListTrigger
	(*RecordingCompleteTrigger)(nil),    // 67: helmsmancontrol.RecordingCompleteTrigger
	(*RecordingSegmentTrigger)(nil),     // 68: helmsmancontrol.RecordingSegmentTrigger
	(*StreamLifecycleUpdate)(nil),       // 69: helmsmancontrol.StreamLifecycleUpdate
	(*ClientLifecycleUpdate)(nil),       // 70: helmsmancontrol.ClientLifecycleUpdate
	(*NodeLifecycleUpdate)(nil),         // 71: helmsmancontrol.NodeLifecycleUpdate
	(*LoadBalancingData)(nil),           // 72: helmsmancontrol.LoadBalancingData
	(*ClipLifecycleData)(nil),           // 73: helmsmancontrol.ClipLifecycleData
	(*DVRLifecycleData)(nil),            // 74: helmsmancontrol.DVRLifecycleData
	(*VodLifecycleData)(nil),            // 75: helmsmancontrol.VodLifecycleData
	(*MessageLifecycleData)(nil),        // 76: helmsmancontrol.MessageLifecycleData
	(*NodeCapabilities)(nil),            // 77: helmsmancontrol.NodeCapabilities
	(*ProcessingConfig)(nil),            // 78: helmsmancontrol.ProcessingConfig
	(*ProcessBillingEvent)(nil),         // 79: helmsmancontrol.ProcessBillingEvent
	(*StorageInfo)(nil),                 // 80: helmsmancontrol.StorageInfo
	(*NodeLimits)(nil),                  // 81: helmsmancontrol.NodeLimits
	(*StreamData)(nil),                  // 82: helmsmancontrol.StreamData
	(*StreamTrack)(nil),                 // 83: helmsmancontrol.StreamTrack
	(*StoredArtifact)(nil),              // 84: helmsmancontrol.StoredArtifact
	(*StreamProcess)(nil),               // 85: helmsmancontrol.StreamProcess
	(*StreamDef)(nil),                   // 86: helmsmancontrol.StreamDef
	(*StreamTemplate)(nil),              // 87: helmsmancontrol.StreamTemplate
	(*ConfigSeed)(nil),                  // 88: helmsmancontrol.ConfigSeed
	(*TranscodeProfile)(nil),            // 89: helmsmancontrol.TranscodeProfile
	(*TranscodeJobRequest)(nil),         // 90: helmsmancontrol.TranscodeJobRequest
	(*TranscodeJobProgress)(nil),        // 91: helmsmancontrol.TranscodeJobProgress
	(*TranscodeJobComplete)(nil),        // 92: helmsmancontrol.TranscodeJobComplete
	(*APIRequestBatch)(nil),             // 93: helmsmancontrol.APIRequestBatch
	(*APIRequestAggregate)(nil),         // 94: helmsmancontrol.APIRequestAggregate
	nil,                                 // 95: helmsmancontrol.FreezePermissionResponse.SegmentUrlsEntry
	nil,                                 // 96: helmsmancontrol.DefrostRequest.SegmentUrlsEntry
	nil,                                 // 97: helmsmancontrol.DtshSyncRequest.DtshUrlsEntry
	nil,                                 // 98: helmsmancontrol.NodeLifecycleUpdate.StreamsEntry
	nil,                                 // 99: helmsmancontrol.StreamProcess.ExtraEntry
	(*timestamppb.Timestamp)(nil),       // 100: google.protobuf.Timestamp
	(*emptypb.Empty)(nil),               // 101: google.protobuf.Empty
}
var file_ipc_proto_depIdxs = []int32{
	100, // 0: helmsmancontrol.ServiceEvent.timestamp:type_name -> google.protobuf.Timestamp
	93,  // 1: helmsmancontrol.ServiceEvent.api_request_batch:type_name -> helmsmancontrol.APIRequestBatch
	11,  // 2: helmsmancontrol.ServiceEvent.auth_event:type_name -> helmsmancontrol.AuthEvent
	12,  // 3: helmsmancontrol.ServiceEvent.tenant_event:type_name -> helmsmancontrol.TenantEvent
	13,  // 4: helmsmancontrol.ServiceEvent.cluster_event:type_name -> helmsmancontrol.ClusterEvent
	14,  // 5: helmsmancontrol.ServiceEvent.stream_change_event:type_name -> helmsmancontrol.StreamChangeEvent
	15,  // 6: helmsmancontrol.ServiceEvent.stream_key_event:type_name -> helmsmancontrol.StreamKeyEvent
	16,  // 7: helmsmancontrol.ServiceEvent.billing_event:type_name -> helmsmancontrol.BillingEvent
	76,  // 8: helmsmancontrol.ServiceEvent.support_event:type_name -> helmsmancontrol.MessageLifecycleData
	17,  // 9: helmsmancontrol.ServiceEvent.artifact_event:type_name -> helmsmancontrol.ArtifactEvent
	3,   // 10: helmsmancontrol.ArtifactEvent.artifact_type:type_name -> helmsmancontrol.ArtifactEvent.ArtifactType
	100, // 11: helmsmancontrol.ControlMessage.sent_at:type_name -> google.protobuf.Timestamp
	21,  // 12: helmsmancontrol.ControlMessage.register:type_name -> helmsmancontrol.Register
	23,  // 13: helmsmancontrol.ControlMessage.clip_pull_request:type_name -> helmsmancontrol.ClipPullRequest
	24,  // 14: helmsmancontrol.ControlMessage.clip_progress:type_name -> helmsmancontrol.ClipProgress
	25,  // 15: helmsmancontrol.ControlMessage.clip_done:type_name -> helmsmancontrol.ClipDone
	26,  // 16: helmsmancontrol.ControlMessage.error:type_name -> helmsmancontrol.ControlError
	27,  // 17: helmsmancontrol.ControlMessage.heartbeat:type_name -> helmsmancontrol.Heartbeat
	34,  // 18: helmsmancontrol.ControlMessage.dvr_start_request:type_name -> helmsmancontrol.DVRStartRequest
	36,  // 19: helmsmancontrol.ControlMessage.dvr_progress:type_name -> helmsmancontrol.DVRProgress
	37,  // 20: helmsmancontrol.ControlMessage.dvr_stopped:type_name -> helmsmancontrol.DVRStopped
	38,  // 21: helmsmancontrol.ControlMessage.dvr_stop_request:type_name -> helmsmancontrol.DVRStopRequest
	55,  // 22: helmsmancontrol.ControlMessage.dvr_ready_request:type_name -> helmsmancontrol.DVRReadyRequest
	56,  // 23: helmsmancontrol.ControlMessage.dvr_ready_response:type_name -> helmsmancontrol.DVRReadyResponse
	28,  // 24: helmsmancontrol.ControlMessage.mist_trigger:type_name -> helmsmancontrol.MistTrigger
	29,  // 25: helmsmancontrol.ControlMessage.mist_trigger_response:type_name -> helmsmancontrol.MistTriggerResponse
	88,  // 26: helmsmancontrol.ControlMessage.config_seed:type_name -> helmsmancontrol.ConfigSeed
	20,  // 27: helmsmancontrol.ControlMessage.artifact_deleted:type_name -> helmsmancontrol.ArtifactDeleted
	39,  // 28: helmsmancontrol.ControlMessage.clip_delete:type_name -> helmsmancontrol.ClipDeleteRequest
	40,  // 29: helmsmancontrol.ControlMessage.dvr_delete:type_name -> helmsmancontrol.DVRDeleteRequest
	41,  // 30: helmsmancontrol.ControlMessage.vod_delete:type_name -> helmsmancontrol.VodDeleteRequest
	42,  // 31: helmsmancontrol.ControlMessage.freeze_permission_request:type_name -> helmsmancontrol.FreezePermissionRequest
	43,  // 32: helmsmancontrol.ControlMessage.freeze_permission_response:type_name -> helmsmancontrol.FreezePermissionResponse
	45,  // 33: helmsmancontrol.ControlMessage.freeze_progress:type_name -> helmsmancontrol.FreezeProgress
	46,  // 34: helmsmancontrol.ControlMessage.freeze_complete:type_name -> helmsmancontrol.FreezeComplete
	47,  // 35: helmsmancontrol.ControlMessage.defrost_request:type_name -> helmsmancontrol.DefrostRequest
	48,  // 36: helmsmancontrol.ControlMessage.defrost_progress:type_name -> helmsmancontrol.DefrostProgress
	49,  // 37: helmsmancontrol.ControlMessage.defrost_complete:type_name -> helmsmancontrol.DefrostComplete
	50,  // 38: helmsmancontrol.ControlMessage.can_delete_request:type_name -> helmsmancontrol.CanDeleteRequest
	51,  // 39: helmsmancontrol.ControlMessage.can_delete_response:type_name -> helmsmancontrol.CanDeleteResponse
	52,  // 40: helmsmancontrol.ControlMessage.sync_complete:type_name -> helmsmancontrol.SyncComplete
	53,  // 41: helmsmancontrol.ControlMessage.dtsh_sync_request:type_name -> helmsmancontrol.DtshSyncRequest
	90,  // 42: helmsmancontrol.ControlMessage.transcode_job_request:type_name -> helmsmancontrol.TranscodeJobRequest
	91,  // 43: helmsmancontrol.ControlMessage.transcode_job_progress:type_name -> helmsmancontrol.TranscodeJobProgress
	92,  // 44: helmsmancontrol.ControlMessage.transcode_job_complete:type_name -> helmsmancontrol.TranscodeJobComplete
	19,  // 45: helmsmancontrol.ControlMessage.stop_sessions_request:type_name -> helmsmancontrol.StopSessionsRequest
	22,  // 46: helmsmancontrol.Register.fingerprint:type_name -> helmsmancontrol.NodeFingerprint
	2,   // 47: helmsmancontrol.Register.requested_mode:type_name -> helmsmancontrol.NodeOperationalMode
	57,  // 48: helmsmancontrol.MistTrigger.push_rewrite:type_name -> helmsmancontrol.PushRewriteTrigger
	58,  // 49: helmsmancontrol.MistTrigger.play_rewrite:type_name -> helmsmancontrol.ViewerResolveTrigger
	59,  // 50: helmsmancontrol.MistTrigger.stream_source:type_name -> helmsmancontrol.StreamSourceTrigger
	60,  // 51: helmsmancontrol.MistTrigger.push_out_start:type_name -> helmsmancontrol.PushOutStartTrigger
	61,  // 52: helmsmancontrol.MistTrigger.push_end:type_name -> helmsmancontrol.PushEndTrigger
	62,  // 53: helmsmancontrol.MistTrigger.viewer_connect:type_name -> helmsmancontrol.ViewerConnectTrigger
	63,  // 54: helmsmancontrol.MistTrigger.viewer_disconnect:type_name -> helmsmancontrol.ViewerDisconnectTrigger
	64,  // 55: helmsmancontrol.MistTrigger.stream_buffer:type_name -> helmsmancontrol.StreamBufferTrigger
	65,  // 56: helmsmancontrol.MistTrigger.stream_end:type_name -> helmsmancontrol.StreamEndTrigger
	66,  // 57: helmsmancontrol.MistTrigger.track_list:type_name -> helmsmancontrol.StreamTrackListTrigger
	67,  // 58: helmsmancontrol.MistTrigger.recording_complete:type_name -> helmsmancontrol.RecordingCompleteTrigger
	69,  // 59: helmsmancontrol.MistTrigger.stream_lifecycle_update:type_name -> helmsmancontrol.StreamLifecycleUpdate
	70,  // 60: helmsmancontrol.MistTrigger.client_lifecycle_update:type_name -> helmsmancontrol.ClientLifecycleUpdate
	71,  // 61: helmsmancontrol.MistTrigger.node_lifecycle_update:type_name -> helmsmancontrol.NodeLifecycleUpdate
	72,  // 62: helmsmancontrol.MistTrigger.load_balancing_data:type_name -> helmsmancontrol.LoadBalancingData
	73,  // 63: helmsmancontrol.MistTrigger.clip_lifecycle_data:type_name -> helmsmancontrol.ClipLifecycleData
	74,  // 64: helmsmancontrol.MistTrigger.dvr_lifecycle_data:type_name -> helmsmancontrol.DVRLifecycleData
	30,  // 65: helmsmancontrol.MistTrigger.storage_snapshot:type_name -> helmsmancontrol.StorageSnapshot
	54,  // 66: helmsmancontrol.MistTrigger.storage_lifecycle_data:type_name -> helmsmancontrol.StorageLifecycleData
	68,  // 67: helmsmancontrol.MistTrigger.recording_segment:type_name -> helmsmancontrol.RecordingSegmentTrigger
	79,  // 68: helmsmancontrol.MistTrigger.process_billing:type_name -> helmsmancontrol.ProcessBillingEvent
	75,  // 69: helmsmancontrol.MistTrigger.vod_lifecycle_data:type_name -> helmsmancontrol.VodLifecycleData
	93,  // 70: helmsmancontrol.MistTrigger.api_request_batch:type_name -> helmsmancontrol.APIRequestBatch
	76,  // 71: helmsmancontrol.MistTrigger.message_lifecycle_data:type_name -> helmsmancontrol.MessageLifecycleData
	0,   // 72: helmsmancontrol.MistTriggerResponse.error_code:type_name -> helmsmancontrol.IngestErrorCode
	77,  // 73: helmsmancontrol.StorageSnapshot.capabilities:type_name -> helmsmancontrol.NodeCapabilities
	31,  // 74: helmsmancontrol.StorageSnapshot.usage:type_name -> helmsmancontrol.TenantStorageUsage
	35,  // 75: helmsmancontrol.DVRStartRequest.config:type_name -> helmsmancontrol.DVRConfig
	95,  // 76: helmsmancontrol.FreezePermissionResponse.segment_urls:type_name -> helmsmancontrol.FreezePermissionResponse.SegmentUrlsEntry
	96,  // 77: helmsmancontrol.DefrostRequest.segment_urls:type_name -> helmsmancontrol.DefrostRequest.SegmentUrlsEntry
	97,  // 78: helmsmancontrol.DtshSyncRequest.dtsh_urls:type_name -> helmsmancontrol.DtshSyncRequest.DtshUrlsEntry
	4,   // 79: helmsmancontrol.StorageLifecycleData.action:type_name -> helmsmancontrol.StorageLifecycleData.Action
	35,  // 80: helmsmancontrol.DVRReadyResponse.config:type_name -> helmsmancontrol.DVRConfig
	9,   // 81: helmsmancontrol.PushRewriteTrigger.publisher_bucket:type_name -> helmsmancontrol.GeoBucket
	9,   // 82: helmsmancontrol.PushRewriteTrigger.node_bucket:type_name -> helmsmancontrol.GeoBucket
	9,   // 83: helmsmancontrol.ViewerResolveTrigger.client_bucket:type_name -> helmsmancontrol.GeoBucket
	9,   // 84: helmsmancontrol.ViewerResolveTrigger.node_bucket:type_name -> helmsmancontrol.GeoBucket
	9,   // 85: helmsmancontrol.ViewerConnectTrigger.client_bucket:type_name -> helmsmancontrol.GeoBucket
	9,   // 86: helmsmancontrol.ViewerConnectTrigger.node_bucket:type_name -> helmsmancontrol.GeoBucket
	9,   // 87: helmsmancontrol.ViewerDisconnectTrigger.client_bucket:type_name -> helmsmancontrol.GeoBucket
	9,   // 88: helmsmancontrol.ViewerDisconnectTrigger.node_bucket:type_name -> helmsmancontrol.GeoBucket
	83,  // 89: helmsmancontrol.StreamBufferTrigger.tracks:type_name -> helmsmancontrol.StreamTrack
	83,  // 90: helmsmancontrol.StreamTrackListTrigger.tracks:type_name -> helmsmancontrol.StreamTrack
	77,  // 91: helmsmancontrol.NodeLifecycleUpdate.capabilities:type_name -> helmsmancontrol.NodeCapabilities
	80,  // 92: helmsmancontrol.NodeLifecycleUpdate.storage:type_name -> helmsmancontrol.StorageInfo
	81,  // 93: helmsmancontrol.NodeLifecycleUpdate.limits:type_name -> helmsmancontrol.NodeLimits
	98,  // 94: helmsmancontrol.NodeLifecycleUpdate.streams:type_name -> helmsmancontrol.NodeLifecycleUpdate.StreamsEntry
	84,  // 95: helmsmancontrol.NodeLifecycleUpdate.artifacts:type_name -> helmsmancontrol.StoredArtifact
	2,   // 96: helmsmancontrol.NodeLifecycleUpdate.operational_mode:type_name -> helmsmancontrol.NodeOperationalMode
	9,   // 97: helmsmancontrol.LoadBalancingData.client_bucket:type_name -> helmsmancontrol.GeoBucket
	9,   // 98: helmsmancontrol.LoadBalancingData.node_bucket:type_name -> helmsmancontrol.GeoBucket
	5,   // 99: helmsmancontrol.ClipLifecycleData.stage:type_name -> helmsmancontrol.ClipLifecycleData.Stage
	6,   // 100: helmsmancontrol.DVRLifecycleData.status:type_name -> helmsmancontrol.DVRLifecycleData.Status
	7,   // 101: helmsmancontrol.VodLifecycleData.status:type_name -> helmsmancontrol.VodLifecycleData.Status
	8,   // 102: helmsmancontrol.MessageLifecycleData.event_type:type_name -> helmsmancontrol.MessageLifecycleData.EventType
	3,   // 103: helmsmancontrol.StoredArtifact.artifact_type:type_name -> helmsmancontrol.ArtifactEvent.ArtifactType
	99,  // 104: helmsmancontrol.StreamProcess.extra:type_name -> helmsmancontrol.StreamProcess.ExtraEntry
	85,  // 105: helmsmancontrol.StreamDef.processes:type_name -> helmsmancontrol.StreamProcess
	86,  // 106: helmsmancontrol.StreamTemplate.def:type_name -> helmsmancontrol.StreamDef
	87,  // 107: helmsmancontrol.ConfigSeed.templates:type_name -> helmsmancontrol.StreamTemplate
	78,  // 108: helmsmancontrol.ConfigSeed.processing:type_name -> helmsmancontrol.ProcessingConfig
	2,   // 109: helmsmancontrol.ConfigSeed.operational_mode:type_name -> helmsmancontrol.NodeOperationalMode
	89,  // 110: helmsmancontrol.TranscodeJobRequest.profiles:type_name -> helmsmancontrol.TranscodeProfile
	94,  // 111: helmsmancontrol.APIRequestBatch.aggregates:type_name -> helmsmancontrol.APIRequestAggregate
	82,  // 112: helmsmancontrol.NodeLifecycleUpdate.StreamsEntry.value:type_name -> helmsmancontrol.StreamData
	18,  // 113: helmsmancontrol.HelmsmanControl.Connect:input_type -> helmsmancontrol.ControlMessage
	32,  // 114: helmsmancontrol.HelmsmanControl.ResolveClipHash:input_type -> helmsmancontrol.ClipHashRequest
	28,  // 115: helmsmancontrol.DecklogService.SendEvent:input_type -> helmsmancontrol.MistTrigger
	10,  // 116: helmsmancontrol.DecklogService.SendServiceEvent:input_type -> helmsmancontrol.ServiceEvent
	18,  // 117: helmsmancontrol.HelmsmanControl.Connect:output_type -> helmsmancontrol.ControlMessage
	33,  // 118: helmsmancontrol.HelmsmanControl.ResolveClipHash:output_type -> helmsmancontrol.ClipHashResponse
	101, // 119: helmsmancontrol.DecklogService.SendEvent:output_type -> google.protobuf.Empty
	101, // 120: helmsmancontrol.DecklogService.SendServiceEvent:output_type -> google.protobuf.Empty
	117, // [117:121] is the sub-list for method output_type
	113, // [113:117] is the sub-list for method input_type
	113, // [113:113] is the sub-list for extension type_name
	113, // [113:113] is the sub-list for extension extendee
	0,   // [0:113] is the sub-list for field type_name
}

func init() { file_ipc_proto_init() }
func file_ipc_proto_init() {
	if File_ipc_proto != nil {
		return
	}
	file_ipc_proto_msgTypes[1].OneofWrappers = []any{
		(*ServiceEvent_ApiRequestBatch)(nil),
		(*ServiceEvent_AuthEvent)(nil),
		(*ServiceEvent_TenantEvent)(nil),
		(*ServiceEvent_ClusterEvent)(nil),
		(*ServiceEvent_StreamChangeEvent)(nil),
		(*ServiceEvent_StreamKeyEvent)(nil),
		(*ServiceEvent_BillingEvent)(nil),
		(*ServiceEvent_SupportEvent)(nil),
		(*ServiceEvent_ArtifactEvent)(nil),
	}
	file_ipc_proto_msgTypes[8].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[9].OneofWrappers = []any{
		(*ControlMessage_Register)(nil),
		(*ControlMessage_ClipPullRequest)(nil),
		(*ControlMessage_ClipProgress)(nil),
		(*ControlMessage_ClipDone)(nil),
		(*ControlMessage_Error)(nil),
		(*ControlMessage_Heartbeat)(nil),
		(*ControlMessage_DvrStartRequest)(nil),
		(*ControlMessage_DvrProgress)(nil),
		(*ControlMessage_DvrStopped)(nil),
		(*ControlMessage_DvrStopRequest)(nil),
		(*ControlMessage_DvrReadyRequest)(nil),
		(*ControlMessage_DvrReadyResponse)(nil),
		(*ControlMessage_MistTrigger)(nil),
		(*ControlMessage_MistTriggerResponse)(nil),
		(*ControlMessage_ConfigSeed)(nil),
		(*ControlMessage_ArtifactDeleted)(nil),
		(*ControlMessage_ClipDelete)(nil),
		(*ControlMessage_DvrDelete)(nil),
		(*ControlMessage_VodDelete)(nil),
		(*ControlMessage_FreezePermissionRequest)(nil),
		(*ControlMessage_FreezePermissionResponse)(nil),
		(*ControlMessage_FreezeProgress)(nil),
		(*ControlMessage_FreezeComplete)(nil),
		(*ControlMessage_DefrostRequest)(nil),
		(*ControlMessage_DefrostProgress)(nil),
		(*ControlMessage_DefrostComplete)(nil),
		(*ControlMessage_CanDeleteRequest)(nil),
		(*ControlMessage_CanDeleteResponse)(nil),
		(*ControlMessage_SyncComplete)(nil),
		(*ControlMessage_DtshSyncRequest)(nil),
		(*ControlMessage_TranscodeJobRequest)(nil),
		(*ControlMessage_TranscodeJobProgress)(nil),
		(*ControlMessage_TranscodeJobComplete)(nil),
		(*ControlMessage_StopSessionsRequest)(nil),
	}
	file_ipc_proto_msgTypes[12].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[13].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[14].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[19].OneofWrappers = []any{
		(*MistTrigger_PushRewrite)(nil),
		(*MistTrigger_PlayRewrite)(nil),
		(*MistTrigger_StreamSource)(nil),
		(*MistTrigger_PushOutStart)(nil),
		(*MistTrigger_PushEnd)(nil),
		(*MistTrigger_ViewerConnect)(nil),
		(*MistTrigger_ViewerDisconnect)(nil),
		(*MistTrigger_StreamBuffer)(nil),
		(*MistTrigger_StreamEnd)(nil),
		(*MistTrigger_TrackList)(nil),
		(*MistTrigger_RecordingComplete)(nil),
		(*MistTrigger_StreamLifecycleUpdate)(nil),
		(*MistTrigger_ClientLifecycleUpdate)(nil),
		(*MistTrigger_NodeLifecycleUpdate)(nil),
		(*MistTrigger_LoadBalancingData)(nil),
		(*MistTrigger_ClipLifecycleData)(nil),
		(*MistTrigger_DvrLifecycleData)(nil),
		(*MistTrigger_StorageSnapshot)(nil),
		(*MistTrigger_StorageLifecycleData)(nil),
		(*MistTrigger_RecordingSegment)(nil),
		(*MistTrigger_ProcessBilling)(nil),
		(*MistTrigger_VodLifecycleData)(nil),
		(*MistTrigger_ApiRequestBatch)(nil),
		(*MistTrigger_MessageLifecycleData)(nil),
	}
	file_ipc_proto_msgTypes[21].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[29].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[45].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[48].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[49].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[50].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[51].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[52].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[53].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[54].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[55].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[56].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[57].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[58].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[59].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[60].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[61].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[62].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[63].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[64].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[65].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[66].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[67].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[70].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[74].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_ipc_proto_rawDesc), len(file_ipc_proto_rawDesc)),
			NumEnums:      9,
			NumMessages:   91,
			NumExtensions: 0,
			NumServices:   2,
		},
		GoTypes:           file_ipc_proto_goTypes,
		DependencyIndexes: file_ipc_proto_depIdxs,
		EnumInfos:         file_ipc_proto_enumTypes,
		MessageInfos:      file_ipc_proto_msgTypes,
	}.Build()
	File_ipc_proto = out.File
	file_ipc_proto_goTypes = nil
	file_ipc_proto_depIdxs = nil
}
