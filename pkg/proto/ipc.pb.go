// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.32.0
// source: ipc.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ClipLifecycleData_Stage int32

const (
	ClipLifecycleData_STAGE_UNSPECIFIED ClipLifecycleData_Stage = 0
	ClipLifecycleData_STAGE_REQUESTED   ClipLifecycleData_Stage = 1
	ClipLifecycleData_STAGE_QUEUED      ClipLifecycleData_Stage = 2
	ClipLifecycleData_STAGE_PROGRESS    ClipLifecycleData_Stage = 3
	ClipLifecycleData_STAGE_DONE        ClipLifecycleData_Stage = 4
	ClipLifecycleData_STAGE_FAILED      ClipLifecycleData_Stage = 5
)

// Enum value maps for ClipLifecycleData_Stage.
var (
	ClipLifecycleData_Stage_name = map[int32]string{
		0: "STAGE_UNSPECIFIED",
		1: "STAGE_REQUESTED",
		2: "STAGE_QUEUED",
		3: "STAGE_PROGRESS",
		4: "STAGE_DONE",
		5: "STAGE_FAILED",
	}
	ClipLifecycleData_Stage_value = map[string]int32{
		"STAGE_UNSPECIFIED": 0,
		"STAGE_REQUESTED":   1,
		"STAGE_QUEUED":      2,
		"STAGE_PROGRESS":    3,
		"STAGE_DONE":        4,
		"STAGE_FAILED":      5,
	}
)

func (x ClipLifecycleData_Stage) Enum() *ClipLifecycleData_Stage {
	p := new(ClipLifecycleData_Stage)
	*p = x
	return p
}

func (x ClipLifecycleData_Stage) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClipLifecycleData_Stage) Descriptor() protoreflect.EnumDescriptor {
	return file_ipc_proto_enumTypes[0].Descriptor()
}

func (ClipLifecycleData_Stage) Type() protoreflect.EnumType {
	return &file_ipc_proto_enumTypes[0]
}

func (x ClipLifecycleData_Stage) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClipLifecycleData_Stage.Descriptor instead.
func (ClipLifecycleData_Stage) EnumDescriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{35, 0}
}

type DVRLifecycleData_Status int32

const (
	DVRLifecycleData_STATUS_UNSPECIFIED DVRLifecycleData_Status = 0
	DVRLifecycleData_STATUS_STARTED     DVRLifecycleData_Status = 1
	DVRLifecycleData_STATUS_RECORDING   DVRLifecycleData_Status = 2
	DVRLifecycleData_STATUS_STOPPED     DVRLifecycleData_Status = 3
	DVRLifecycleData_STATUS_FAILED      DVRLifecycleData_Status = 4
)

// Enum value maps for DVRLifecycleData_Status.
var (
	DVRLifecycleData_Status_name = map[int32]string{
		0: "STATUS_UNSPECIFIED",
		1: "STATUS_STARTED",
		2: "STATUS_RECORDING",
		3: "STATUS_STOPPED",
		4: "STATUS_FAILED",
	}
	DVRLifecycleData_Status_value = map[string]int32{
		"STATUS_UNSPECIFIED": 0,
		"STATUS_STARTED":     1,
		"STATUS_RECORDING":   2,
		"STATUS_STOPPED":     3,
		"STATUS_FAILED":      4,
	}
)

func (x DVRLifecycleData_Status) Enum() *DVRLifecycleData_Status {
	p := new(DVRLifecycleData_Status)
	*p = x
	return p
}

func (x DVRLifecycleData_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DVRLifecycleData_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_ipc_proto_enumTypes[1].Descriptor()
}

func (DVRLifecycleData_Status) Type() protoreflect.EnumType {
	return &file_ipc_proto_enumTypes[1]
}

func (x DVRLifecycleData_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DVRLifecycleData_Status.Descriptor instead.
func (DVRLifecycleData_Status) EnumDescriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{36, 0}
}

type ControlMessage struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	RequestId string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"` // Correlates requests/responses
	SentAt    *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=sent_at,json=sentAt,proto3" json:"sent_at,omitempty"`
	// Types that are valid to be assigned to Payload:
	//
	//	*ControlMessage_Register
	//	*ControlMessage_ClipPullRequest
	//	*ControlMessage_ClipProgress
	//	*ControlMessage_ClipDone
	//	*ControlMessage_Error
	//	*ControlMessage_Heartbeat
	//	*ControlMessage_DvrStartRequest
	//	*ControlMessage_DvrProgress
	//	*ControlMessage_DvrStopped
	//	*ControlMessage_DvrStopRequest
	//	*ControlMessage_DvrReadyRequest
	//	*ControlMessage_DvrReadyResponse
	//	*ControlMessage_MistTrigger
	//	*ControlMessage_MistTriggerResponse
	//	*ControlMessage_ConfigSeed
	Payload       isControlMessage_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControlMessage) Reset() {
	*x = ControlMessage{}
	mi := &file_ipc_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControlMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControlMessage) ProtoMessage() {}

func (x *ControlMessage) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControlMessage.ProtoReflect.Descriptor instead.
func (*ControlMessage) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{0}
}

func (x *ControlMessage) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ControlMessage) GetSentAt() *timestamppb.Timestamp {
	if x != nil {
		return x.SentAt
	}
	return nil
}

func (x *ControlMessage) GetPayload() isControlMessage_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ControlMessage) GetRegister() *Register {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_Register); ok {
			return x.Register
		}
	}
	return nil
}

func (x *ControlMessage) GetClipPullRequest() *ClipPullRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ClipPullRequest); ok {
			return x.ClipPullRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetClipProgress() *ClipProgress {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ClipProgress); ok {
			return x.ClipProgress
		}
	}
	return nil
}

func (x *ControlMessage) GetClipDone() *ClipDone {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ClipDone); ok {
			return x.ClipDone
		}
	}
	return nil
}

func (x *ControlMessage) GetError() *ControlError {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_Error); ok {
			return x.Error
		}
	}
	return nil
}

func (x *ControlMessage) GetHeartbeat() *Heartbeat {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_Heartbeat); ok {
			return x.Heartbeat
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrStartRequest() *DVRStartRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrStartRequest); ok {
			return x.DvrStartRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrProgress() *DVRProgress {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrProgress); ok {
			return x.DvrProgress
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrStopped() *DVRStopped {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrStopped); ok {
			return x.DvrStopped
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrStopRequest() *DVRStopRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrStopRequest); ok {
			return x.DvrStopRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrReadyRequest() *DVRReadyRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrReadyRequest); ok {
			return x.DvrReadyRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrReadyResponse() *DVRReadyResponse {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrReadyResponse); ok {
			return x.DvrReadyResponse
		}
	}
	return nil
}

func (x *ControlMessage) GetMistTrigger() *MistTrigger {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_MistTrigger); ok {
			return x.MistTrigger
		}
	}
	return nil
}

func (x *ControlMessage) GetMistTriggerResponse() *MistTriggerResponse {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_MistTriggerResponse); ok {
			return x.MistTriggerResponse
		}
	}
	return nil
}

func (x *ControlMessage) GetConfigSeed() *ConfigSeed {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ConfigSeed); ok {
			return x.ConfigSeed
		}
	}
	return nil
}

type isControlMessage_Payload interface {
	isControlMessage_Payload()
}

type ControlMessage_Register struct {
	Register *Register `protobuf:"bytes,10,opt,name=register,proto3,oneof"`
}

type ControlMessage_ClipPullRequest struct {
	ClipPullRequest *ClipPullRequest `protobuf:"bytes,12,opt,name=clip_pull_request,json=clipPullRequest,proto3,oneof"`
}

type ControlMessage_ClipProgress struct {
	ClipProgress *ClipProgress `protobuf:"bytes,13,opt,name=clip_progress,json=clipProgress,proto3,oneof"`
}

type ControlMessage_ClipDone struct {
	ClipDone *ClipDone `protobuf:"bytes,14,opt,name=clip_done,json=clipDone,proto3,oneof"`
}

type ControlMessage_Error struct {
	Error *ControlError `protobuf:"bytes,15,opt,name=error,proto3,oneof"`
}

type ControlMessage_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,16,opt,name=heartbeat,proto3,oneof"`
}

type ControlMessage_DvrStartRequest struct {
	DvrStartRequest *DVRStartRequest `protobuf:"bytes,18,opt,name=dvr_start_request,json=dvrStartRequest,proto3,oneof"`
}

type ControlMessage_DvrProgress struct {
	DvrProgress *DVRProgress `protobuf:"bytes,19,opt,name=dvr_progress,json=dvrProgress,proto3,oneof"`
}

type ControlMessage_DvrStopped struct {
	DvrStopped *DVRStopped `protobuf:"bytes,20,opt,name=dvr_stopped,json=dvrStopped,proto3,oneof"`
}

type ControlMessage_DvrStopRequest struct {
	DvrStopRequest *DVRStopRequest `protobuf:"bytes,21,opt,name=dvr_stop_request,json=dvrStopRequest,proto3,oneof"`
}

type ControlMessage_DvrReadyRequest struct {
	DvrReadyRequest *DVRReadyRequest `protobuf:"bytes,22,opt,name=dvr_ready_request,json=dvrReadyRequest,proto3,oneof"`
}

type ControlMessage_DvrReadyResponse struct {
	DvrReadyResponse *DVRReadyResponse `protobuf:"bytes,23,opt,name=dvr_ready_response,json=dvrReadyResponse,proto3,oneof"`
}

type ControlMessage_MistTrigger struct {
	MistTrigger *MistTrigger `protobuf:"bytes,24,opt,name=mist_trigger,json=mistTrigger,proto3,oneof"`
}

type ControlMessage_MistTriggerResponse struct {
	MistTriggerResponse *MistTriggerResponse `protobuf:"bytes,25,opt,name=mist_trigger_response,json=mistTriggerResponse,proto3,oneof"`
}

type ControlMessage_ConfigSeed struct {
	ConfigSeed *ConfigSeed `protobuf:"bytes,29,opt,name=config_seed,json=configSeed,proto3,oneof"`
}

func (*ControlMessage_Register) isControlMessage_Payload() {}

func (*ControlMessage_ClipPullRequest) isControlMessage_Payload() {}

func (*ControlMessage_ClipProgress) isControlMessage_Payload() {}

func (*ControlMessage_ClipDone) isControlMessage_Payload() {}

func (*ControlMessage_Error) isControlMessage_Payload() {}

func (*ControlMessage_Heartbeat) isControlMessage_Payload() {}

func (*ControlMessage_DvrStartRequest) isControlMessage_Payload() {}

func (*ControlMessage_DvrProgress) isControlMessage_Payload() {}

func (*ControlMessage_DvrStopped) isControlMessage_Payload() {}

func (*ControlMessage_DvrStopRequest) isControlMessage_Payload() {}

func (*ControlMessage_DvrReadyRequest) isControlMessage_Payload() {}

func (*ControlMessage_DvrReadyResponse) isControlMessage_Payload() {}

func (*ControlMessage_MistTrigger) isControlMessage_Payload() {}

func (*ControlMessage_MistTriggerResponse) isControlMessage_Payload() {}

func (*ControlMessage_ConfigSeed) isControlMessage_Payload() {}

type Register struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Roles         []string               `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"` // e.g., ingest, edge, storage, processing
	CapIngest     bool                   `protobuf:"varint,3,opt,name=cap_ingest,json=capIngest,proto3" json:"cap_ingest,omitempty"`
	CapEdge       bool                   `protobuf:"varint,4,opt,name=cap_edge,json=capEdge,proto3" json:"cap_edge,omitempty"`
	CapStorage    bool                   `protobuf:"varint,5,opt,name=cap_storage,json=capStorage,proto3" json:"cap_storage,omitempty"`
	CapProcessing bool                   `protobuf:"varint,6,opt,name=cap_processing,json=capProcessing,proto3" json:"cap_processing,omitempty"`
	// Storage hints
	StorageLocal  string `protobuf:"bytes,7,opt,name=storage_local,json=storageLocal,proto3" json:"storage_local,omitempty"`
	StorageBucket string `protobuf:"bytes,8,opt,name=storage_bucket,json=storageBucket,proto3" json:"storage_bucket,omitempty"`
	StoragePrefix string `protobuf:"bytes,9,opt,name=storage_prefix,json=storagePrefix,proto3" json:"storage_prefix,omitempty"`
	// Edge enrollment token (optional). Sent by Helmsman on first connect for Foghorn to enroll the node with Quartermaster.
	EnrollmentToken string `protobuf:"bytes,10,opt,name=enrollment_token,json=enrollmentToken,proto3" json:"enrollment_token,omitempty"`
	// Optional stable fingerprint signals to aid node identity resolution.
	// Do not include volatile/process-specific values. Client-provided; server will add peer_ip & Geo.
	Fingerprint   *NodeFingerprint `protobuf:"bytes,11,opt,name=fingerprint,proto3" json:"fingerprint,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Register) Reset() {
	*x = Register{}
	mi := &file_ipc_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Register) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Register) ProtoMessage() {}

func (x *Register) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Register.ProtoReflect.Descriptor instead.
func (*Register) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{1}
}

func (x *Register) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *Register) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

func (x *Register) GetCapIngest() bool {
	if x != nil {
		return x.CapIngest
	}
	return false
}

func (x *Register) GetCapEdge() bool {
	if x != nil {
		return x.CapEdge
	}
	return false
}

func (x *Register) GetCapStorage() bool {
	if x != nil {
		return x.CapStorage
	}
	return false
}

func (x *Register) GetCapProcessing() bool {
	if x != nil {
		return x.CapProcessing
	}
	return false
}

func (x *Register) GetStorageLocal() string {
	if x != nil {
		return x.StorageLocal
	}
	return ""
}

func (x *Register) GetStorageBucket() string {
	if x != nil {
		return x.StorageBucket
	}
	return ""
}

func (x *Register) GetStoragePrefix() string {
	if x != nil {
		return x.StoragePrefix
	}
	return ""
}

func (x *Register) GetEnrollmentToken() string {
	if x != nil {
		return x.EnrollmentToken
	}
	return ""
}

func (x *Register) GetFingerprint() *NodeFingerprint {
	if x != nil {
		return x.Fingerprint
	}
	return nil
}

// NodeFingerprint carries stable identity hints from Helmsman.
type NodeFingerprint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Local interface IPs (best-effort). Helps disambiguate nodes behind NAT.
	LocalIpv4 []string `protobuf:"bytes,1,rep,name=local_ipv4,json=localIpv4,proto3" json:"local_ipv4,omitempty"`
	LocalIpv6 []string `protobuf:"bytes,2,rep,name=local_ipv6,json=localIpv6,proto3" json:"local_ipv6,omitempty"`
	// Deterministic aggregate hash of MAC addresses (sorted, lowercase, SHA-256 hex).
	// Avoids exposing raw MACs while remaining stable.
	MacsSha256 *string `protobuf:"bytes,3,opt,name=macs_sha256,json=macsSha256,proto3,oneof" json:"macs_sha256,omitempty"`
	// Optional machine-id hash when available (e.g., /etc/machine-id), SHA-256 hex.
	MachineIdSha256 *string `protobuf:"bytes,4,opt,name=machine_id_sha256,json=machineIdSha256,proto3,oneof" json:"machine_id_sha256,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *NodeFingerprint) Reset() {
	*x = NodeFingerprint{}
	mi := &file_ipc_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeFingerprint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeFingerprint) ProtoMessage() {}

func (x *NodeFingerprint) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeFingerprint.ProtoReflect.Descriptor instead.
func (*NodeFingerprint) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{2}
}

func (x *NodeFingerprint) GetLocalIpv4() []string {
	if x != nil {
		return x.LocalIpv4
	}
	return nil
}

func (x *NodeFingerprint) GetLocalIpv6() []string {
	if x != nil {
		return x.LocalIpv6
	}
	return nil
}

func (x *NodeFingerprint) GetMacsSha256() string {
	if x != nil && x.MacsSha256 != nil {
		return *x.MacsSha256
	}
	return ""
}

func (x *NodeFingerprint) GetMachineIdSha256() string {
	if x != nil && x.MachineIdSha256 != nil {
		return *x.MachineIdSha256
	}
	return ""
}

type ClipPullRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Security: Use opaque identifiers, never expose tenant_id on edge nodes
	ClipHash   string `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`       // Opaque identifier for the clip
	StreamName string `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"` // Stream name for MistServer (no tenant info)
	// Timing (one of):
	StartUnix   *int64 `protobuf:"varint,3,opt,name=start_unix,json=startUnix,proto3,oneof" json:"start_unix,omitempty"`       // seconds
	StopUnix    *int64 `protobuf:"varint,4,opt,name=stop_unix,json=stopUnix,proto3,oneof" json:"stop_unix,omitempty"`          // seconds
	StartMs     *int64 `protobuf:"varint,5,opt,name=start_ms,json=startMs,proto3,oneof" json:"start_ms,omitempty"`             // since stream start
	StopMs      *int64 `protobuf:"varint,6,opt,name=stop_ms,json=stopMs,proto3,oneof" json:"stop_ms,omitempty"`                // since stream start
	DurationSec *int64 `protobuf:"varint,7,opt,name=duration_sec,json=durationSec,proto3,oneof" json:"duration_sec,omitempty"` // seconds
	// Output
	Format     string `protobuf:"bytes,8,opt,name=format,proto3" json:"format,omitempty"`                           // mp4 default
	OutputName string `protobuf:"bytes,9,opt,name=output_name,json=outputName,proto3" json:"output_name,omitempty"` // suggested basename
	// Optional explicit Mist HTTP base (e.g., http://node:8080) to pull from
	SourceBaseUrl string `protobuf:"bytes,10,opt,name=source_base_url,json=sourceBaseUrl,proto3" json:"source_base_url,omitempty"`
	// Request tracking
	RequestId     string `protobuf:"bytes,11,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"` // Unique request ID for tracking
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipPullRequest) Reset() {
	*x = ClipPullRequest{}
	mi := &file_ipc_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipPullRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipPullRequest) ProtoMessage() {}

func (x *ClipPullRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipPullRequest.ProtoReflect.Descriptor instead.
func (*ClipPullRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{3}
}

func (x *ClipPullRequest) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *ClipPullRequest) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *ClipPullRequest) GetStartUnix() int64 {
	if x != nil && x.StartUnix != nil {
		return *x.StartUnix
	}
	return 0
}

func (x *ClipPullRequest) GetStopUnix() int64 {
	if x != nil && x.StopUnix != nil {
		return *x.StopUnix
	}
	return 0
}

func (x *ClipPullRequest) GetStartMs() int64 {
	if x != nil && x.StartMs != nil {
		return *x.StartMs
	}
	return 0
}

func (x *ClipPullRequest) GetStopMs() int64 {
	if x != nil && x.StopMs != nil {
		return *x.StopMs
	}
	return 0
}

func (x *ClipPullRequest) GetDurationSec() int64 {
	if x != nil && x.DurationSec != nil {
		return *x.DurationSec
	}
	return 0
}

func (x *ClipPullRequest) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *ClipPullRequest) GetOutputName() string {
	if x != nil {
		return x.OutputName
	}
	return ""
}

func (x *ClipPullRequest) GetSourceBaseUrl() string {
	if x != nil {
		return x.SourceBaseUrl
	}
	return ""
}

func (x *ClipPullRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

type ClipProgress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Percent       uint32                 `protobuf:"varint,2,opt,name=percent,proto3" json:"percent,omitempty"` // 0..100
	Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipProgress) Reset() {
	*x = ClipProgress{}
	mi := &file_ipc_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipProgress) ProtoMessage() {}

func (x *ClipProgress) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipProgress.ProtoReflect.Descriptor instead.
func (*ClipProgress) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{4}
}

func (x *ClipProgress) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ClipProgress) GetPercent() uint32 {
	if x != nil {
		return x.Percent
	}
	return 0
}

func (x *ClipProgress) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type ClipDone struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"` // local path on storage node (if applicable)
	S3Url         string                 `protobuf:"bytes,3,opt,name=s3_url,json=s3Url,proto3" json:"s3_url,omitempty"`          // s3://bucket/key or https URL (if applicable)
	SizeBytes     uint64                 `protobuf:"varint,4,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Status        string                 `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"` // success|failed
	Error         string                 `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`   // filled when failed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipDone) Reset() {
	*x = ClipDone{}
	mi := &file_ipc_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipDone) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipDone) ProtoMessage() {}

func (x *ClipDone) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipDone.ProtoReflect.Descriptor instead.
func (*ClipDone) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{5}
}

func (x *ClipDone) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ClipDone) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *ClipDone) GetS3Url() string {
	if x != nil {
		return x.S3Url
	}
	return ""
}

func (x *ClipDone) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *ClipDone) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *ClipDone) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ControlError struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          string                 `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControlError) Reset() {
	*x = ControlError{}
	mi := &file_ipc_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControlError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControlError) ProtoMessage() {}

func (x *ControlError) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControlError.ProtoReflect.Descriptor instead.
func (*ControlError) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{6}
}

func (x *ControlError) GetCode() string {
	if x != nil {
		return x.Code
	}
	return ""
}

func (x *ControlError) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type Heartbeat struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Heartbeat) Reset() {
	*x = Heartbeat{}
	mi := &file_ipc_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Heartbeat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Heartbeat) ProtoMessage() {}

func (x *Heartbeat) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Heartbeat.ProtoReflect.Descriptor instead.
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{7}
}

func (x *Heartbeat) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

type MistTrigger struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	TriggerType string                 `protobuf:"bytes,1,opt,name=trigger_type,json=triggerType,proto3" json:"trigger_type,omitempty"` // e.g., PUSH_REWRITE, VIEWER_RESOLVE, VIEWER_CONNECT, STREAM_BUFFER
	NodeId      string                 `protobuf:"bytes,3,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`                // Node that received the trigger
	Timestamp   int64                  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                       // When trigger was received
	Blocking    bool                   `protobuf:"varint,5,opt,name=blocking,proto3" json:"blocking,omitempty"`                         // Does this trigger need a response from Foghorn?
	RequestId   string                 `protobuf:"bytes,6,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`       // For correlating responses
	// Typed trigger payloads (one of these will be set based on trigger_type)
	//
	// Types that are valid to be assigned to TriggerPayload:
	//
	//	*MistTrigger_PushRewrite
	//	*MistTrigger_ViewerResolve
	//	*MistTrigger_StreamSource
	//	*MistTrigger_PushOutStart
	//	*MistTrigger_PushEnd
	//	*MistTrigger_ViewerConnect
	//	*MistTrigger_ViewerDisconnect
	//	*MistTrigger_StreamBuffer
	//	*MistTrigger_StreamEnd
	//	*MistTrigger_TrackList
	//	*MistTrigger_StreamBandwidth
	//	*MistTrigger_RecordingComplete
	//	*MistTrigger_StreamLifecycleUpdate
	//	*MistTrigger_ClientLifecycleUpdate
	//	*MistTrigger_NodeLifecycleUpdate
	//	*MistTrigger_LoadBalancingData
	//	*MistTrigger_ClipLifecycleData
	//	*MistTrigger_DvrLifecycleData
	TriggerPayload isMistTrigger_TriggerPayload `protobuf_oneof:"trigger_payload"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *MistTrigger) Reset() {
	*x = MistTrigger{}
	mi := &file_ipc_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MistTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MistTrigger) ProtoMessage() {}

func (x *MistTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MistTrigger.ProtoReflect.Descriptor instead.
func (*MistTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{8}
}

func (x *MistTrigger) GetTriggerType() string {
	if x != nil {
		return x.TriggerType
	}
	return ""
}

func (x *MistTrigger) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *MistTrigger) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *MistTrigger) GetBlocking() bool {
	if x != nil {
		return x.Blocking
	}
	return false
}

func (x *MistTrigger) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *MistTrigger) GetTriggerPayload() isMistTrigger_TriggerPayload {
	if x != nil {
		return x.TriggerPayload
	}
	return nil
}

func (x *MistTrigger) GetPushRewrite() *PushRewriteTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_PushRewrite); ok {
			return x.PushRewrite
		}
	}
	return nil
}

func (x *MistTrigger) GetViewerResolve() *ViewerResolveTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_ViewerResolve); ok {
			return x.ViewerResolve
		}
	}
	return nil
}

func (x *MistTrigger) GetStreamSource() *StreamSourceTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_StreamSource); ok {
			return x.StreamSource
		}
	}
	return nil
}

func (x *MistTrigger) GetPushOutStart() *PushOutStartTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_PushOutStart); ok {
			return x.PushOutStart
		}
	}
	return nil
}

func (x *MistTrigger) GetPushEnd() *PushEndTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_PushEnd); ok {
			return x.PushEnd
		}
	}
	return nil
}

func (x *MistTrigger) GetViewerConnect() *ViewerConnectTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_ViewerConnect); ok {
			return x.ViewerConnect
		}
	}
	return nil
}

func (x *MistTrigger) GetViewerDisconnect() *ViewerDisconnectTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_ViewerDisconnect); ok {
			return x.ViewerDisconnect
		}
	}
	return nil
}

func (x *MistTrigger) GetStreamBuffer() *StreamBufferTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_StreamBuffer); ok {
			return x.StreamBuffer
		}
	}
	return nil
}

func (x *MistTrigger) GetStreamEnd() *StreamEndTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_StreamEnd); ok {
			return x.StreamEnd
		}
	}
	return nil
}

func (x *MistTrigger) GetTrackList() *StreamTrackListTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_TrackList); ok {
			return x.TrackList
		}
	}
	return nil
}

func (x *MistTrigger) GetStreamBandwidth() *StreamBandwidthTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_StreamBandwidth); ok {
			return x.StreamBandwidth
		}
	}
	return nil
}

func (x *MistTrigger) GetRecordingComplete() *RecordingCompleteTrigger {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_RecordingComplete); ok {
			return x.RecordingComplete
		}
	}
	return nil
}

func (x *MistTrigger) GetStreamLifecycleUpdate() *StreamLifecycleUpdate {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_StreamLifecycleUpdate); ok {
			return x.StreamLifecycleUpdate
		}
	}
	return nil
}

func (x *MistTrigger) GetClientLifecycleUpdate() *ClientLifecycleUpdate {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_ClientLifecycleUpdate); ok {
			return x.ClientLifecycleUpdate
		}
	}
	return nil
}

func (x *MistTrigger) GetNodeLifecycleUpdate() *NodeLifecycleUpdate {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_NodeLifecycleUpdate); ok {
			return x.NodeLifecycleUpdate
		}
	}
	return nil
}

func (x *MistTrigger) GetLoadBalancingData() *LoadBalancingData {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_LoadBalancingData); ok {
			return x.LoadBalancingData
		}
	}
	return nil
}

func (x *MistTrigger) GetClipLifecycleData() *ClipLifecycleData {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_ClipLifecycleData); ok {
			return x.ClipLifecycleData
		}
	}
	return nil
}

func (x *MistTrigger) GetDvrLifecycleData() *DVRLifecycleData {
	if x != nil {
		if x, ok := x.TriggerPayload.(*MistTrigger_DvrLifecycleData); ok {
			return x.DvrLifecycleData
		}
	}
	return nil
}

type isMistTrigger_TriggerPayload interface {
	isMistTrigger_TriggerPayload()
}

type MistTrigger_PushRewrite struct {
	PushRewrite *PushRewriteTrigger `protobuf:"bytes,10,opt,name=push_rewrite,json=pushRewrite,proto3,oneof"`
}

type MistTrigger_ViewerResolve struct {
	ViewerResolve *ViewerResolveTrigger `protobuf:"bytes,11,opt,name=viewer_resolve,json=viewerResolve,proto3,oneof"` // formerly DefaultStreamTrigger
}

type MistTrigger_StreamSource struct {
	StreamSource *StreamSourceTrigger `protobuf:"bytes,12,opt,name=stream_source,json=streamSource,proto3,oneof"` // VOD source resolution
}

type MistTrigger_PushOutStart struct {
	PushOutStart *PushOutStartTrigger `protobuf:"bytes,13,opt,name=push_out_start,json=pushOutStart,proto3,oneof"`
}

type MistTrigger_PushEnd struct {
	PushEnd *PushEndTrigger `protobuf:"bytes,14,opt,name=push_end,json=pushEnd,proto3,oneof"`
}

type MistTrigger_ViewerConnect struct {
	ViewerConnect *ViewerConnectTrigger `protobuf:"bytes,15,opt,name=viewer_connect,json=viewerConnect,proto3,oneof"` // formerly UserNewTrigger
}

type MistTrigger_ViewerDisconnect struct {
	ViewerDisconnect *ViewerDisconnectTrigger `protobuf:"bytes,16,opt,name=viewer_disconnect,json=viewerDisconnect,proto3,oneof"` // formerly UserEndTrigger
}

type MistTrigger_StreamBuffer struct {
	StreamBuffer *StreamBufferTrigger `protobuf:"bytes,17,opt,name=stream_buffer,json=streamBuffer,proto3,oneof"`
}

type MistTrigger_StreamEnd struct {
	StreamEnd *StreamEndTrigger `protobuf:"bytes,18,opt,name=stream_end,json=streamEnd,proto3,oneof"`
}

type MistTrigger_TrackList struct {
	TrackList *StreamTrackListTrigger `protobuf:"bytes,19,opt,name=track_list,json=trackList,proto3,oneof"` // formerly LiveTrackListTrigger
}

type MistTrigger_StreamBandwidth struct {
	StreamBandwidth *StreamBandwidthTrigger `protobuf:"bytes,20,opt,name=stream_bandwidth,json=streamBandwidth,proto3,oneof"` // formerly LiveBandwidthTrigger
}

type MistTrigger_RecordingComplete struct {
	RecordingComplete *RecordingCompleteTrigger `protobuf:"bytes,21,opt,name=recording_complete,json=recordingComplete,proto3,oneof"` // formerly RecordingEndTrigger
}

type MistTrigger_StreamLifecycleUpdate struct {
	StreamLifecycleUpdate *StreamLifecycleUpdate `protobuf:"bytes,22,opt,name=stream_lifecycle_update,json=streamLifecycleUpdate,proto3,oneof"`
}

type MistTrigger_ClientLifecycleUpdate struct {
	ClientLifecycleUpdate *ClientLifecycleUpdate `protobuf:"bytes,23,opt,name=client_lifecycle_update,json=clientLifecycleUpdate,proto3,oneof"`
}

type MistTrigger_NodeLifecycleUpdate struct {
	NodeLifecycleUpdate *NodeLifecycleUpdate `protobuf:"bytes,24,opt,name=node_lifecycle_update,json=nodeLifecycleUpdate,proto3,oneof"`
}

type MistTrigger_LoadBalancingData struct {
	LoadBalancingData *LoadBalancingData `protobuf:"bytes,25,opt,name=load_balancing_data,json=loadBalancingData,proto3,oneof"`
}

type MistTrigger_ClipLifecycleData struct {
	ClipLifecycleData *ClipLifecycleData `protobuf:"bytes,26,opt,name=clip_lifecycle_data,json=clipLifecycleData,proto3,oneof"`
}

type MistTrigger_DvrLifecycleData struct {
	DvrLifecycleData *DVRLifecycleData `protobuf:"bytes,27,opt,name=dvr_lifecycle_data,json=dvrLifecycleData,proto3,oneof"`
}

func (*MistTrigger_PushRewrite) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_ViewerResolve) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_StreamSource) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_PushOutStart) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_PushEnd) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_ViewerConnect) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_ViewerDisconnect) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_StreamBuffer) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_StreamEnd) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_TrackList) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_StreamBandwidth) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_RecordingComplete) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_StreamLifecycleUpdate) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_ClientLifecycleUpdate) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_NodeLifecycleUpdate) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_LoadBalancingData) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_ClipLifecycleData) isMistTrigger_TriggerPayload() {}

func (*MistTrigger_DvrLifecycleData) isMistTrigger_TriggerPayload() {}

type MistTriggerResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"` // Correlates to MistTrigger.request_id
	Response      string                 `protobuf:"bytes,2,opt,name=response,proto3" json:"response,omitempty"`                    // What to return to MistServer (empty string aborts for blocking triggers)
	Abort         bool                   `protobuf:"varint,3,opt,name=abort,proto3" json:"abort,omitempty"`                         // Explicit abort flag
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MistTriggerResponse) Reset() {
	*x = MistTriggerResponse{}
	mi := &file_ipc_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MistTriggerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MistTriggerResponse) ProtoMessage() {}

func (x *MistTriggerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MistTriggerResponse.ProtoReflect.Descriptor instead.
func (*MistTriggerResponse) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{9}
}

func (x *MistTriggerResponse) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *MistTriggerResponse) GetResponse() string {
	if x != nil {
		return x.Response
	}
	return ""
}

func (x *MistTriggerResponse) GetAbort() bool {
	if x != nil {
		return x.Abort
	}
	return false
}

type ClipHashRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClipHash      string                 `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipHashRequest) Reset() {
	*x = ClipHashRequest{}
	mi := &file_ipc_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipHashRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipHashRequest) ProtoMessage() {}

func (x *ClipHashRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipHashRequest.ProtoReflect.Descriptor instead.
func (*ClipHashRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{10}
}

func (x *ClipHashRequest) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

type ClipHashResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClipHash      string                 `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`
	TenantId      string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	StreamName    string                 `protobuf:"bytes,3,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipHashResponse) Reset() {
	*x = ClipHashResponse{}
	mi := &file_ipc_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipHashResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipHashResponse) ProtoMessage() {}

func (x *ClipHashResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipHashResponse.ProtoReflect.Descriptor instead.
func (*ClipHashResponse) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{11}
}

func (x *ClipHashResponse) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *ClipHashResponse) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *ClipHashResponse) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

// DVR (Digital Video Recording) messages
type DVRStartRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`                     // Unique DVR identifier (32-char hex) - generated by Foghorn
	InternalName  string                 `protobuf:"bytes,2,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`      // Stream internal name (same as stream name)
	SourceBaseUrl string                 `protobuf:"bytes,3,opt,name=source_base_url,json=sourceBaseUrl,proto3" json:"source_base_url,omitempty"` // DTSC source URL to pull from - filled by Foghorn
	RequestId     string                 `protobuf:"bytes,4,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`               // Unique request ID for tracking
	Config        *DVRConfig             `protobuf:"bytes,5,opt,name=config,proto3" json:"config,omitempty"`                                      // Recording configuration
	TenantId      string                 `protobuf:"bytes,6,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`                  // Tenant ID for the stream
	UserId        string                 `protobuf:"bytes,7,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`                        // User ID for the stream
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRStartRequest) Reset() {
	*x = DVRStartRequest{}
	mi := &file_ipc_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRStartRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRStartRequest) ProtoMessage() {}

func (x *DVRStartRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRStartRequest.ProtoReflect.Descriptor instead.
func (*DVRStartRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{12}
}

func (x *DVRStartRequest) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRStartRequest) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *DVRStartRequest) GetSourceBaseUrl() string {
	if x != nil {
		return x.SourceBaseUrl
	}
	return ""
}

func (x *DVRStartRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DVRStartRequest) GetConfig() *DVRConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *DVRStartRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *DVRStartRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

type DVRConfig struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Enabled         bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`                                        // Whether DVR is enabled
	RetentionDays   int32                  `protobuf:"varint,2,opt,name=retention_days,json=retentionDays,proto3" json:"retention_days,omitempty"`       // How long to keep the recording
	Format          string                 `protobuf:"bytes,3,opt,name=format,proto3" json:"format,omitempty"`                                           // ts, mp4, etc.
	SegmentDuration int32                  `protobuf:"varint,4,opt,name=segment_duration,json=segmentDuration,proto3" json:"segment_duration,omitempty"` // Segment duration in seconds
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DVRConfig) Reset() {
	*x = DVRConfig{}
	mi := &file_ipc_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRConfig) ProtoMessage() {}

func (x *DVRConfig) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRConfig.ProtoReflect.Descriptor instead.
func (*DVRConfig) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{13}
}

func (x *DVRConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *DVRConfig) GetRetentionDays() int32 {
	if x != nil {
		return x.RetentionDays
	}
	return 0
}

func (x *DVRConfig) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *DVRConfig) GetSegmentDuration() int32 {
	if x != nil {
		return x.SegmentDuration
	}
	return 0
}

type DVRProgress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	DvrHash       string                 `protobuf:"bytes,2,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`                 // DVR identifier
	Status        string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`                                  // recording, segments_available, etc.
	StartedAt     int64                  `protobuf:"varint,4,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`          // Unix timestamp when recording started
	SegmentCount  int32                  `protobuf:"varint,5,opt,name=segment_count,json=segmentCount,proto3" json:"segment_count,omitempty"` // Number of segments recorded so far
	SizeBytes     uint64                 `protobuf:"varint,6,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`          // Total size of recording so far
	Message       string                 `protobuf:"bytes,7,opt,name=message,proto3" json:"message,omitempty"`                                // Optional progress message
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRProgress) Reset() {
	*x = DVRProgress{}
	mi := &file_ipc_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRProgress) ProtoMessage() {}

func (x *DVRProgress) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRProgress.ProtoReflect.Descriptor instead.
func (*DVRProgress) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{14}
}

func (x *DVRProgress) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DVRProgress) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRProgress) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *DVRProgress) GetStartedAt() int64 {
	if x != nil {
		return x.StartedAt
	}
	return 0
}

func (x *DVRProgress) GetSegmentCount() int32 {
	if x != nil {
		return x.SegmentCount
	}
	return 0
}

func (x *DVRProgress) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *DVRProgress) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type DVRStopped struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	RequestId       string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	DvrHash         string                 `protobuf:"bytes,2,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`                          // DVR identifier
	Status          string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`                                           // completed, failed, terminated
	Error           string                 `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`                                             // Error message if failed
	StartedAt       int64                  `protobuf:"varint,5,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`                   // Unix timestamp when recording started
	EndedAt         int64                  `protobuf:"varint,6,opt,name=ended_at,json=endedAt,proto3" json:"ended_at,omitempty"`                         // Unix timestamp when recording ended
	DurationSeconds int32                  `protobuf:"varint,7,opt,name=duration_seconds,json=durationSeconds,proto3" json:"duration_seconds,omitempty"` // Total duration of the recording
	SizeBytes       uint64                 `protobuf:"varint,8,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`                   // Total size of the recording
	ManifestPath    string                 `protobuf:"bytes,9,opt,name=manifest_path,json=manifestPath,proto3" json:"manifest_path,omitempty"`           // Path to the m3u8 manifest for playback
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DVRStopped) Reset() {
	*x = DVRStopped{}
	mi := &file_ipc_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRStopped) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRStopped) ProtoMessage() {}

func (x *DVRStopped) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRStopped.ProtoReflect.Descriptor instead.
func (*DVRStopped) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{15}
}

func (x *DVRStopped) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DVRStopped) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRStopped) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *DVRStopped) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *DVRStopped) GetStartedAt() int64 {
	if x != nil {
		return x.StartedAt
	}
	return 0
}

func (x *DVRStopped) GetEndedAt() int64 {
	if x != nil {
		return x.EndedAt
	}
	return 0
}

func (x *DVRStopped) GetDurationSeconds() int32 {
	if x != nil {
		return x.DurationSeconds
	}
	return 0
}

func (x *DVRStopped) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *DVRStopped) GetManifestPath() string {
	if x != nil {
		return x.ManifestPath
	}
	return ""
}

type DVRStopRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`                      // Unique DVR identifier to stop (empty = stop all for internal_name)
	RequestId     string                 `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`                // Request ID for tracking
	InternalName  *string                `protobuf:"bytes,3,opt,name=internal_name,json=internalName,proto3,oneof" json:"internal_name,omitempty"` // Stream internal name (for stopping all DVR recordings for a stream)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRStopRequest) Reset() {
	*x = DVRStopRequest{}
	mi := &file_ipc_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRStopRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRStopRequest) ProtoMessage() {}

func (x *DVRStopRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRStopRequest.ProtoReflect.Descriptor instead.
func (*DVRStopRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{16}
}

func (x *DVRStopRequest) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRStopRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DVRStopRequest) GetInternalName() string {
	if x != nil && x.InternalName != nil {
		return *x.InternalName
	}
	return ""
}

type DVRReadyRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"` // Which DVR job we're asking about
	NodeId        string                 `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`    // Which storage node is asking
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRReadyRequest) Reset() {
	*x = DVRReadyRequest{}
	mi := &file_ipc_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRReadyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRReadyRequest) ProtoMessage() {}

func (x *DVRReadyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRReadyRequest.ProtoReflect.Descriptor instead.
func (*DVRReadyRequest) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{17}
}

func (x *DVRReadyRequest) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRReadyRequest) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

type DVRReadyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`       // DVR identifier
	Ready         bool                   `protobuf:"varint,2,opt,name=ready,proto3" json:"ready,omitempty"`                         // Is stream ready for pulling?
	SourceUri     string                 `protobuf:"bytes,3,opt,name=source_uri,json=sourceUri,proto3" json:"source_uri,omitempty"` // Full DTSC URI when ready (e.g., "http://ingest-node:8080/stream_name.dtsc")
	Config        *DVRConfig             `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`                        // Potentially updated config based on stream characteristics
	Reason        string                 `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`                        // If not ready, why? (e.g., "stream_booting", "stream_unhealthy", "stream_offline")
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRReadyResponse) Reset() {
	*x = DVRReadyResponse{}
	mi := &file_ipc_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRReadyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRReadyResponse) ProtoMessage() {}

func (x *DVRReadyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRReadyResponse.ProtoReflect.Descriptor instead.
func (*DVRReadyResponse) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{18}
}

func (x *DVRReadyResponse) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRReadyResponse) GetReady() bool {
	if x != nil {
		return x.Ready
	}
	return false
}

func (x *DVRReadyResponse) GetSourceUri() string {
	if x != nil {
		return x.SourceUri
	}
	return ""
}

func (x *DVRReadyResponse) GetConfig() *DVRConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *DVRReadyResponse) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type PushRewriteTrigger struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	PushUrl    string                 `protobuf:"bytes,1,opt,name=push_url,json=pushUrl,proto3" json:"push_url,omitempty"`
	Hostname   string                 `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	StreamName string                 `protobuf:"bytes,3,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	// Enrichment fields for analytics (populated by Foghorn)
	Protocol       *string  `protobuf:"bytes,4,opt,name=protocol,proto3,oneof" json:"protocol,omitempty"`
	Encoder        *string  `protobuf:"bytes,5,opt,name=encoder,proto3,oneof" json:"encoder,omitempty"`
	StreamSettings *string  `protobuf:"bytes,6,opt,name=stream_settings,json=streamSettings,proto3,oneof" json:"stream_settings,omitempty"`
	NodeId         *string  `protobuf:"bytes,7,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	Latitude       *float64 `protobuf:"fixed64,8,opt,name=latitude,proto3,oneof" json:"latitude,omitempty"`
	Longitude      *float64 `protobuf:"fixed64,9,opt,name=longitude,proto3,oneof" json:"longitude,omitempty"`
	Location       *string  `protobuf:"bytes,10,opt,name=location,proto3,oneof" json:"location,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PushRewriteTrigger) Reset() {
	*x = PushRewriteTrigger{}
	mi := &file_ipc_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PushRewriteTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PushRewriteTrigger) ProtoMessage() {}

func (x *PushRewriteTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PushRewriteTrigger.ProtoReflect.Descriptor instead.
func (*PushRewriteTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{19}
}

func (x *PushRewriteTrigger) GetPushUrl() string {
	if x != nil {
		return x.PushUrl
	}
	return ""
}

func (x *PushRewriteTrigger) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *PushRewriteTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *PushRewriteTrigger) GetProtocol() string {
	if x != nil && x.Protocol != nil {
		return *x.Protocol
	}
	return ""
}

func (x *PushRewriteTrigger) GetEncoder() string {
	if x != nil && x.Encoder != nil {
		return *x.Encoder
	}
	return ""
}

func (x *PushRewriteTrigger) GetStreamSettings() string {
	if x != nil && x.StreamSettings != nil {
		return *x.StreamSettings
	}
	return ""
}

func (x *PushRewriteTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *PushRewriteTrigger) GetLatitude() float64 {
	if x != nil && x.Latitude != nil {
		return *x.Latitude
	}
	return 0
}

func (x *PushRewriteTrigger) GetLongitude() float64 {
	if x != nil && x.Longitude != nil {
		return *x.Longitude
	}
	return 0
}

func (x *PushRewriteTrigger) GetLocation() string {
	if x != nil && x.Location != nil {
		return *x.Location
	}
	return ""
}

// ViewerResolveTrigger represents a viewer-side resolve of a playback request.
// This is NOT publisher ingest. It fires when a viewer requests a stream by
// playback ID or artifact hash; enrichment may include geo and node context.
type ViewerResolveTrigger struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	DefaultStream   string                 `protobuf:"bytes,1,opt,name=default_stream,json=defaultStream,proto3" json:"default_stream,omitempty"`       // the default route name
	RequestedStream string                 `protobuf:"bytes,2,opt,name=requested_stream,json=requestedStream,proto3" json:"requested_stream,omitempty"` // playback ID or artifact hash
	ViewerHost      string                 `protobuf:"bytes,3,opt,name=viewer_host,json=viewerHost,proto3" json:"viewer_host,omitempty"`                // viewer IP/host
	OutputType      string                 `protobuf:"bytes,4,opt,name=output_type,json=outputType,proto3" json:"output_type,omitempty"`                // HLS/DASH/WebRTC
	RequestUrl      string                 `protobuf:"bytes,5,opt,name=request_url,json=requestUrl,proto3" json:"request_url,omitempty"`
	// Enrichment (by Foghorn). Do not replace the payload type; enrich in-place.
	NodeId        *string  `protobuf:"bytes,6,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	CountryCode   *string  `protobuf:"bytes,7,opt,name=country_code,json=countryCode,proto3,oneof" json:"country_code,omitempty"`
	City          *string  `protobuf:"bytes,8,opt,name=city,proto3,oneof" json:"city,omitempty"`
	Latitude      *float64 `protobuf:"fixed64,9,opt,name=latitude,proto3,oneof" json:"latitude,omitempty"`
	Longitude     *float64 `protobuf:"fixed64,10,opt,name=longitude,proto3,oneof" json:"longitude,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ViewerResolveTrigger) Reset() {
	*x = ViewerResolveTrigger{}
	mi := &file_ipc_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ViewerResolveTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ViewerResolveTrigger) ProtoMessage() {}

func (x *ViewerResolveTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ViewerResolveTrigger.ProtoReflect.Descriptor instead.
func (*ViewerResolveTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{20}
}

func (x *ViewerResolveTrigger) GetDefaultStream() string {
	if x != nil {
		return x.DefaultStream
	}
	return ""
}

func (x *ViewerResolveTrigger) GetRequestedStream() string {
	if x != nil {
		return x.RequestedStream
	}
	return ""
}

func (x *ViewerResolveTrigger) GetViewerHost() string {
	if x != nil {
		return x.ViewerHost
	}
	return ""
}

func (x *ViewerResolveTrigger) GetOutputType() string {
	if x != nil {
		return x.OutputType
	}
	return ""
}

func (x *ViewerResolveTrigger) GetRequestUrl() string {
	if x != nil {
		return x.RequestUrl
	}
	return ""
}

func (x *ViewerResolveTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *ViewerResolveTrigger) GetCountryCode() string {
	if x != nil && x.CountryCode != nil {
		return *x.CountryCode
	}
	return ""
}

func (x *ViewerResolveTrigger) GetCity() string {
	if x != nil && x.City != nil {
		return *x.City
	}
	return ""
}

func (x *ViewerResolveTrigger) GetLatitude() float64 {
	if x != nil && x.Latitude != nil {
		return *x.Latitude
	}
	return 0
}

func (x *ViewerResolveTrigger) GetLongitude() float64 {
	if x != nil && x.Longitude != nil {
		return *x.Longitude
	}
	return 0
}

type StreamSourceTrigger struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StreamName    string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamSourceTrigger) Reset() {
	*x = StreamSourceTrigger{}
	mi := &file_ipc_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamSourceTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamSourceTrigger) ProtoMessage() {}

func (x *StreamSourceTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamSourceTrigger.ProtoReflect.Descriptor instead.
func (*StreamSourceTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{21}
}

func (x *StreamSourceTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

type PushOutStartTrigger struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StreamName    string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	PushTarget    string                 `protobuf:"bytes,2,opt,name=push_target,json=pushTarget,proto3" json:"push_target,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PushOutStartTrigger) Reset() {
	*x = PushOutStartTrigger{}
	mi := &file_ipc_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PushOutStartTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PushOutStartTrigger) ProtoMessage() {}

func (x *PushOutStartTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PushOutStartTrigger.ProtoReflect.Descriptor instead.
func (*PushOutStartTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{22}
}

func (x *PushOutStartTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *PushOutStartTrigger) GetPushTarget() string {
	if x != nil {
		return x.PushTarget
	}
	return ""
}

type PushEndTrigger struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	PushId          int64                  `protobuf:"varint,1,opt,name=push_id,json=pushId,proto3" json:"push_id,omitempty"`
	StreamName      string                 `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	TargetUriBefore string                 `protobuf:"bytes,3,opt,name=target_uri_before,json=targetUriBefore,proto3" json:"target_uri_before,omitempty"`
	TargetUriAfter  string                 `protobuf:"bytes,4,opt,name=target_uri_after,json=targetUriAfter,proto3" json:"target_uri_after,omitempty"`
	LogMessages     string                 `protobuf:"bytes,5,opt,name=log_messages,json=logMessages,proto3" json:"log_messages,omitempty"`
	PushStatus      string                 `protobuf:"bytes,6,opt,name=push_status,json=pushStatus,proto3" json:"push_status,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PushEndTrigger) Reset() {
	*x = PushEndTrigger{}
	mi := &file_ipc_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PushEndTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PushEndTrigger) ProtoMessage() {}

func (x *PushEndTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PushEndTrigger.ProtoReflect.Descriptor instead.
func (*PushEndTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{23}
}

func (x *PushEndTrigger) GetPushId() int64 {
	if x != nil {
		return x.PushId
	}
	return 0
}

func (x *PushEndTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *PushEndTrigger) GetTargetUriBefore() string {
	if x != nil {
		return x.TargetUriBefore
	}
	return ""
}

func (x *PushEndTrigger) GetTargetUriAfter() string {
	if x != nil {
		return x.TargetUriAfter
	}
	return ""
}

func (x *PushEndTrigger) GetLogMessages() string {
	if x != nil {
		return x.LogMessages
	}
	return ""
}

func (x *PushEndTrigger) GetPushStatus() string {
	if x != nil {
		return x.PushStatus
	}
	return ""
}

// ViewerConnectTrigger (formerly USER_NEW) indicates a viewer connection.
type ViewerConnectTrigger struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StreamName    string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	Host          string                 `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	ConnectionId  string                 `protobuf:"bytes,3,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	Connector     string                 `protobuf:"bytes,4,opt,name=connector,proto3" json:"connector,omitempty"`
	RequestUrl    string                 `protobuf:"bytes,5,opt,name=request_url,json=requestUrl,proto3" json:"request_url,omitempty"`
	SessionId     string                 `protobuf:"bytes,6,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ViewerConnectTrigger) Reset() {
	*x = ViewerConnectTrigger{}
	mi := &file_ipc_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ViewerConnectTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ViewerConnectTrigger) ProtoMessage() {}

func (x *ViewerConnectTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ViewerConnectTrigger.ProtoReflect.Descriptor instead.
func (*ViewerConnectTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{24}
}

func (x *ViewerConnectTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *ViewerConnectTrigger) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *ViewerConnectTrigger) GetConnectionId() string {
	if x != nil {
		return x.ConnectionId
	}
	return ""
}

func (x *ViewerConnectTrigger) GetConnector() string {
	if x != nil {
		return x.Connector
	}
	return ""
}

func (x *ViewerConnectTrigger) GetRequestUrl() string {
	if x != nil {
		return x.RequestUrl
	}
	return ""
}

func (x *ViewerConnectTrigger) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

// ViewerDisconnectTrigger (formerly USER_END) indicates a viewer disconnect.
type ViewerDisconnectTrigger struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	SessionId  string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	StreamName string                 `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	Connector  string                 `protobuf:"bytes,3,opt,name=connector,proto3" json:"connector,omitempty"`
	Host       string                 `protobuf:"bytes,4,opt,name=host,proto3" json:"host,omitempty"`
	Duration   int64                  `protobuf:"varint,5,opt,name=duration,proto3" json:"duration,omitempty"`
	UpBytes    int64                  `protobuf:"varint,6,opt,name=up_bytes,json=upBytes,proto3" json:"up_bytes,omitempty"`
	DownBytes  int64                  `protobuf:"varint,7,opt,name=down_bytes,json=downBytes,proto3" json:"down_bytes,omitempty"`
	Tags       string                 `protobuf:"bytes,8,opt,name=tags,proto3" json:"tags,omitempty"`
	// Enrichment fields for analytics (populated by Foghorn)
	NodeId            *string  `protobuf:"bytes,9,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	CountryCode       *string  `protobuf:"bytes,10,opt,name=country_code,json=countryCode,proto3,oneof" json:"country_code,omitempty"`
	City              *string  `protobuf:"bytes,11,opt,name=city,proto3,oneof" json:"city,omitempty"`
	Latitude          *float64 `protobuf:"fixed64,12,opt,name=latitude,proto3,oneof" json:"latitude,omitempty"`
	Longitude         *float64 `protobuf:"fixed64,13,opt,name=longitude,proto3,oneof" json:"longitude,omitempty"`
	SessionIdentifier *string  `protobuf:"bytes,14,opt,name=session_identifier,json=sessionIdentifier,proto3,oneof" json:"session_identifier,omitempty"`
	SecondsConnected  *uint64  `protobuf:"varint,15,opt,name=seconds_connected,json=secondsConnected,proto3,oneof" json:"seconds_connected,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ViewerDisconnectTrigger) Reset() {
	*x = ViewerDisconnectTrigger{}
	mi := &file_ipc_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ViewerDisconnectTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ViewerDisconnectTrigger) ProtoMessage() {}

func (x *ViewerDisconnectTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ViewerDisconnectTrigger.ProtoReflect.Descriptor instead.
func (*ViewerDisconnectTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{25}
}

func (x *ViewerDisconnectTrigger) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetConnector() string {
	if x != nil {
		return x.Connector
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetDuration() int64 {
	if x != nil {
		return x.Duration
	}
	return 0
}

func (x *ViewerDisconnectTrigger) GetUpBytes() int64 {
	if x != nil {
		return x.UpBytes
	}
	return 0
}

func (x *ViewerDisconnectTrigger) GetDownBytes() int64 {
	if x != nil {
		return x.DownBytes
	}
	return 0
}

func (x *ViewerDisconnectTrigger) GetTags() string {
	if x != nil {
		return x.Tags
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetCountryCode() string {
	if x != nil && x.CountryCode != nil {
		return *x.CountryCode
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetCity() string {
	if x != nil && x.City != nil {
		return *x.City
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetLatitude() float64 {
	if x != nil && x.Latitude != nil {
		return *x.Latitude
	}
	return 0
}

func (x *ViewerDisconnectTrigger) GetLongitude() float64 {
	if x != nil && x.Longitude != nil {
		return *x.Longitude
	}
	return 0
}

func (x *ViewerDisconnectTrigger) GetSessionIdentifier() string {
	if x != nil && x.SessionIdentifier != nil {
		return *x.SessionIdentifier
	}
	return ""
}

func (x *ViewerDisconnectTrigger) GetSecondsConnected() uint64 {
	if x != nil && x.SecondsConnected != nil {
		return *x.SecondsConnected
	}
	return 0
}

type StreamBufferTrigger struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	StreamName  string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	BufferState string                 `protobuf:"bytes,2,opt,name=buffer_state,json=bufferState,proto3" json:"buffer_state,omitempty"`
	// Fully typed stream details (no more JSON strings)
	Tracks            []*StreamTrack `protobuf:"bytes,3,rep,name=tracks,proto3" json:"tracks,omitempty"`
	HealthScore       *float32       `protobuf:"fixed32,4,opt,name=health_score,json=healthScore,proto3,oneof" json:"health_score,omitempty"`
	HasIssues         *bool          `protobuf:"varint,5,opt,name=has_issues,json=hasIssues,proto3,oneof" json:"has_issues,omitempty"`
	IssuesDescription *string        `protobuf:"bytes,6,opt,name=issues_description,json=issuesDescription,proto3,oneof" json:"issues_description,omitempty"`
	TrackCount        *int32         `protobuf:"varint,7,opt,name=track_count,json=trackCount,proto3,oneof" json:"track_count,omitempty"`
	QualityTier       *string        `protobuf:"bytes,8,opt,name=quality_tier,json=qualityTier,proto3,oneof" json:"quality_tier,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StreamBufferTrigger) Reset() {
	*x = StreamBufferTrigger{}
	mi := &file_ipc_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamBufferTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamBufferTrigger) ProtoMessage() {}

func (x *StreamBufferTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamBufferTrigger.ProtoReflect.Descriptor instead.
func (*StreamBufferTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{26}
}

func (x *StreamBufferTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *StreamBufferTrigger) GetBufferState() string {
	if x != nil {
		return x.BufferState
	}
	return ""
}

func (x *StreamBufferTrigger) GetTracks() []*StreamTrack {
	if x != nil {
		return x.Tracks
	}
	return nil
}

func (x *StreamBufferTrigger) GetHealthScore() float32 {
	if x != nil && x.HealthScore != nil {
		return *x.HealthScore
	}
	return 0
}

func (x *StreamBufferTrigger) GetHasIssues() bool {
	if x != nil && x.HasIssues != nil {
		return *x.HasIssues
	}
	return false
}

func (x *StreamBufferTrigger) GetIssuesDescription() string {
	if x != nil && x.IssuesDescription != nil {
		return *x.IssuesDescription
	}
	return ""
}

func (x *StreamBufferTrigger) GetTrackCount() int32 {
	if x != nil && x.TrackCount != nil {
		return *x.TrackCount
	}
	return 0
}

func (x *StreamBufferTrigger) GetQualityTier() string {
	if x != nil && x.QualityTier != nil {
		return *x.QualityTier
	}
	return ""
}

type StreamEndTrigger struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	StreamName      string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	DownloadedBytes *int64                 `protobuf:"varint,2,opt,name=downloaded_bytes,json=downloadedBytes,proto3,oneof" json:"downloaded_bytes,omitempty"`
	UploadedBytes   *int64                 `protobuf:"varint,3,opt,name=uploaded_bytes,json=uploadedBytes,proto3,oneof" json:"uploaded_bytes,omitempty"`
	TotalViewers    *int64                 `protobuf:"varint,4,opt,name=total_viewers,json=totalViewers,proto3,oneof" json:"total_viewers,omitempty"`
	TotalInputs     *int64                 `protobuf:"varint,5,opt,name=total_inputs,json=totalInputs,proto3,oneof" json:"total_inputs,omitempty"`
	TotalOutputs    *int64                 `protobuf:"varint,6,opt,name=total_outputs,json=totalOutputs,proto3,oneof" json:"total_outputs,omitempty"`
	ViewerSeconds   *int64                 `protobuf:"varint,7,opt,name=viewer_seconds,json=viewerSeconds,proto3,oneof" json:"viewer_seconds,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StreamEndTrigger) Reset() {
	*x = StreamEndTrigger{}
	mi := &file_ipc_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamEndTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamEndTrigger) ProtoMessage() {}

func (x *StreamEndTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamEndTrigger.ProtoReflect.Descriptor instead.
func (*StreamEndTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{27}
}

func (x *StreamEndTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *StreamEndTrigger) GetDownloadedBytes() int64 {
	if x != nil && x.DownloadedBytes != nil {
		return *x.DownloadedBytes
	}
	return 0
}

func (x *StreamEndTrigger) GetUploadedBytes() int64 {
	if x != nil && x.UploadedBytes != nil {
		return *x.UploadedBytes
	}
	return 0
}

func (x *StreamEndTrigger) GetTotalViewers() int64 {
	if x != nil && x.TotalViewers != nil {
		return *x.TotalViewers
	}
	return 0
}

func (x *StreamEndTrigger) GetTotalInputs() int64 {
	if x != nil && x.TotalInputs != nil {
		return *x.TotalInputs
	}
	return 0
}

func (x *StreamEndTrigger) GetTotalOutputs() int64 {
	if x != nil && x.TotalOutputs != nil {
		return *x.TotalOutputs
	}
	return 0
}

func (x *StreamEndTrigger) GetViewerSeconds() int64 {
	if x != nil && x.ViewerSeconds != nil {
		return *x.ViewerSeconds
	}
	return 0
}

// StreamTrackListTrigger (formerly LIVE_TRACK_LIST) provides track inventory.
type StreamTrackListTrigger struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	StreamName string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	// Fully typed track list (no more JSON strings)
	Tracks          []*StreamTrack `protobuf:"bytes,2,rep,name=tracks,proto3" json:"tracks,omitempty"`
	TotalTracks     *int32         `protobuf:"varint,3,opt,name=total_tracks,json=totalTracks,proto3,oneof" json:"total_tracks,omitempty"`
	VideoTrackCount *int32         `protobuf:"varint,4,opt,name=video_track_count,json=videoTrackCount,proto3,oneof" json:"video_track_count,omitempty"`
	AudioTrackCount *int32         `protobuf:"varint,5,opt,name=audio_track_count,json=audioTrackCount,proto3,oneof" json:"audio_track_count,omitempty"`
	QualityTier     *string        `protobuf:"bytes,6,opt,name=quality_tier,json=qualityTier,proto3,oneof" json:"quality_tier,omitempty"`
	// Primary video track info
	PrimaryWidth        *int32   `protobuf:"varint,7,opt,name=primary_width,json=primaryWidth,proto3,oneof" json:"primary_width,omitempty"`
	PrimaryHeight       *int32   `protobuf:"varint,8,opt,name=primary_height,json=primaryHeight,proto3,oneof" json:"primary_height,omitempty"`
	PrimaryFps          *float64 `protobuf:"fixed64,9,opt,name=primary_fps,json=primaryFps,proto3,oneof" json:"primary_fps,omitempty"`
	PrimaryVideoBitrate *int32   `protobuf:"varint,10,opt,name=primary_video_bitrate,json=primaryVideoBitrate,proto3,oneof" json:"primary_video_bitrate,omitempty"`
	PrimaryVideoCodec   *string  `protobuf:"bytes,11,opt,name=primary_video_codec,json=primaryVideoCodec,proto3,oneof" json:"primary_video_codec,omitempty"`
	// Primary audio track info
	PrimaryAudioBitrate    *int32  `protobuf:"varint,12,opt,name=primary_audio_bitrate,json=primaryAudioBitrate,proto3,oneof" json:"primary_audio_bitrate,omitempty"`
	PrimaryAudioCodec      *string `protobuf:"bytes,13,opt,name=primary_audio_codec,json=primaryAudioCodec,proto3,oneof" json:"primary_audio_codec,omitempty"`
	PrimaryAudioChannels   *int32  `protobuf:"varint,14,opt,name=primary_audio_channels,json=primaryAudioChannels,proto3,oneof" json:"primary_audio_channels,omitempty"`
	PrimaryAudioSampleRate *int32  `protobuf:"varint,15,opt,name=primary_audio_sample_rate,json=primaryAudioSampleRate,proto3,oneof" json:"primary_audio_sample_rate,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *StreamTrackListTrigger) Reset() {
	*x = StreamTrackListTrigger{}
	mi := &file_ipc_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamTrackListTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamTrackListTrigger) ProtoMessage() {}

func (x *StreamTrackListTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamTrackListTrigger.ProtoReflect.Descriptor instead.
func (*StreamTrackListTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{28}
}

func (x *StreamTrackListTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *StreamTrackListTrigger) GetTracks() []*StreamTrack {
	if x != nil {
		return x.Tracks
	}
	return nil
}

func (x *StreamTrackListTrigger) GetTotalTracks() int32 {
	if x != nil && x.TotalTracks != nil {
		return *x.TotalTracks
	}
	return 0
}

func (x *StreamTrackListTrigger) GetVideoTrackCount() int32 {
	if x != nil && x.VideoTrackCount != nil {
		return *x.VideoTrackCount
	}
	return 0
}

func (x *StreamTrackListTrigger) GetAudioTrackCount() int32 {
	if x != nil && x.AudioTrackCount != nil {
		return *x.AudioTrackCount
	}
	return 0
}

func (x *StreamTrackListTrigger) GetQualityTier() string {
	if x != nil && x.QualityTier != nil {
		return *x.QualityTier
	}
	return ""
}

func (x *StreamTrackListTrigger) GetPrimaryWidth() int32 {
	if x != nil && x.PrimaryWidth != nil {
		return *x.PrimaryWidth
	}
	return 0
}

func (x *StreamTrackListTrigger) GetPrimaryHeight() int32 {
	if x != nil && x.PrimaryHeight != nil {
		return *x.PrimaryHeight
	}
	return 0
}

func (x *StreamTrackListTrigger) GetPrimaryFps() float64 {
	if x != nil && x.PrimaryFps != nil {
		return *x.PrimaryFps
	}
	return 0
}

func (x *StreamTrackListTrigger) GetPrimaryVideoBitrate() int32 {
	if x != nil && x.PrimaryVideoBitrate != nil {
		return *x.PrimaryVideoBitrate
	}
	return 0
}

func (x *StreamTrackListTrigger) GetPrimaryVideoCodec() string {
	if x != nil && x.PrimaryVideoCodec != nil {
		return *x.PrimaryVideoCodec
	}
	return ""
}

func (x *StreamTrackListTrigger) GetPrimaryAudioBitrate() int32 {
	if x != nil && x.PrimaryAudioBitrate != nil {
		return *x.PrimaryAudioBitrate
	}
	return 0
}

func (x *StreamTrackListTrigger) GetPrimaryAudioCodec() string {
	if x != nil && x.PrimaryAudioCodec != nil {
		return *x.PrimaryAudioCodec
	}
	return ""
}

func (x *StreamTrackListTrigger) GetPrimaryAudioChannels() int32 {
	if x != nil && x.PrimaryAudioChannels != nil {
		return *x.PrimaryAudioChannels
	}
	return 0
}

func (x *StreamTrackListTrigger) GetPrimaryAudioSampleRate() int32 {
	if x != nil && x.PrimaryAudioSampleRate != nil {
		return *x.PrimaryAudioSampleRate
	}
	return 0
}

// StreamBandwidthTrigger (formerly LIVE_BANDWIDTH) provides transport bandwidth.
type StreamBandwidthTrigger struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	StreamName            string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	CurrentBytesPerSecond int64                  `protobuf:"varint,2,opt,name=current_bytes_per_second,json=currentBytesPerSecond,proto3" json:"current_bytes_per_second,omitempty"`
	// Enrichment fields for analytics (populated by Foghorn)
	ThresholdExceeded *bool   `protobuf:"varint,3,opt,name=threshold_exceeded,json=thresholdExceeded,proto3,oneof" json:"threshold_exceeded,omitempty"`
	ThresholdValue    *uint64 `protobuf:"varint,4,opt,name=threshold_value,json=thresholdValue,proto3,oneof" json:"threshold_value,omitempty"`
	NodeId            *string `protobuf:"bytes,5,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StreamBandwidthTrigger) Reset() {
	*x = StreamBandwidthTrigger{}
	mi := &file_ipc_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamBandwidthTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamBandwidthTrigger) ProtoMessage() {}

func (x *StreamBandwidthTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamBandwidthTrigger.ProtoReflect.Descriptor instead.
func (*StreamBandwidthTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{29}
}

func (x *StreamBandwidthTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *StreamBandwidthTrigger) GetCurrentBytesPerSecond() int64 {
	if x != nil {
		return x.CurrentBytesPerSecond
	}
	return 0
}

func (x *StreamBandwidthTrigger) GetThresholdExceeded() bool {
	if x != nil && x.ThresholdExceeded != nil {
		return *x.ThresholdExceeded
	}
	return false
}

func (x *StreamBandwidthTrigger) GetThresholdValue() uint64 {
	if x != nil && x.ThresholdValue != nil {
		return *x.ThresholdValue
	}
	return 0
}

func (x *StreamBandwidthTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

// RecordingCompleteTrigger (formerly RECORDING_END) indicates recorder completion.
type RecordingCompleteTrigger struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	StreamName      string                 `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	FilePath        string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	OutputProtocol  string                 `protobuf:"bytes,3,opt,name=output_protocol,json=outputProtocol,proto3" json:"output_protocol,omitempty"`
	BytesWritten    int64                  `protobuf:"varint,4,opt,name=bytes_written,json=bytesWritten,proto3" json:"bytes_written,omitempty"`
	SecondsWriting  int64                  `protobuf:"varint,5,opt,name=seconds_writing,json=secondsWriting,proto3" json:"seconds_writing,omitempty"`
	TimeStarted     int64                  `protobuf:"varint,6,opt,name=time_started,json=timeStarted,proto3" json:"time_started,omitempty"`
	TimeEnded       int64                  `protobuf:"varint,7,opt,name=time_ended,json=timeEnded,proto3" json:"time_ended,omitempty"`
	MediaDurationMs int64                  `protobuf:"varint,8,opt,name=media_duration_ms,json=mediaDurationMs,proto3" json:"media_duration_ms,omitempty"`
	// Enrichment fields for analytics (populated by Foghorn)
	NodeId        *string `protobuf:"bytes,9,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RecordingCompleteTrigger) Reset() {
	*x = RecordingCompleteTrigger{}
	mi := &file_ipc_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecordingCompleteTrigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecordingCompleteTrigger) ProtoMessage() {}

func (x *RecordingCompleteTrigger) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecordingCompleteTrigger.ProtoReflect.Descriptor instead.
func (*RecordingCompleteTrigger) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{30}
}

func (x *RecordingCompleteTrigger) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *RecordingCompleteTrigger) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *RecordingCompleteTrigger) GetOutputProtocol() string {
	if x != nil {
		return x.OutputProtocol
	}
	return ""
}

func (x *RecordingCompleteTrigger) GetBytesWritten() int64 {
	if x != nil {
		return x.BytesWritten
	}
	return 0
}

func (x *RecordingCompleteTrigger) GetSecondsWriting() int64 {
	if x != nil {
		return x.SecondsWriting
	}
	return 0
}

func (x *RecordingCompleteTrigger) GetTimeStarted() int64 {
	if x != nil {
		return x.TimeStarted
	}
	return 0
}

func (x *RecordingCompleteTrigger) GetTimeEnded() int64 {
	if x != nil {
		return x.TimeEnded
	}
	return 0
}

func (x *RecordingCompleteTrigger) GetMediaDurationMs() int64 {
	if x != nil {
		return x.MediaDurationMs
	}
	return 0
}

func (x *RecordingCompleteTrigger) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

// Analytics event messages for forwarding to Decklog
type StreamLifecycleUpdate struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	NodeId          string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	TenantId        *string                `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"` // Optional - enriched by Foghorn via Commodore lookup
	InternalName    string                 `protobuf:"bytes,3,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`
	Status          string                 `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`                                    // "live", "offline"
	BufferState     *string                `protobuf:"bytes,5,opt,name=buffer_state,json=bufferState,proto3,oneof" json:"buffer_state,omitempty"` // "FULL", "EMPTY", "DRY", "RECOVER"
	UploadedBytes   *uint64                `protobuf:"varint,6,opt,name=uploaded_bytes,json=uploadedBytes,proto3,oneof" json:"uploaded_bytes,omitempty"`
	DownloadedBytes *uint64                `protobuf:"varint,7,opt,name=downloaded_bytes,json=downloadedBytes,proto3,oneof" json:"downloaded_bytes,omitempty"`
	TotalViewers    *uint32                `protobuf:"varint,8,opt,name=total_viewers,json=totalViewers,proto3,oneof" json:"total_viewers,omitempty"`
	TotalInputs     *uint32                `protobuf:"varint,9,opt,name=total_inputs,json=totalInputs,proto3,oneof" json:"total_inputs,omitempty"`
	ViewerSeconds   *uint64                `protobuf:"varint,10,opt,name=viewer_seconds,json=viewerSeconds,proto3,oneof" json:"viewer_seconds,omitempty"`
	StreamDetails   *string                `protobuf:"bytes,11,opt,name=stream_details,json=streamDetails,proto3,oneof" json:"stream_details,omitempty"` // JSON health data
	Timestamp       int64                  `protobuf:"varint,12,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Quality and health metrics (calculated by Helmsman from MistServer data)
	HealthScore       *float32 `protobuf:"fixed32,13,opt,name=health_score,json=healthScore,proto3,oneof" json:"health_score,omitempty"`
	HasIssues         *bool    `protobuf:"varint,14,opt,name=has_issues,json=hasIssues,proto3,oneof" json:"has_issues,omitempty"`
	IssuesDescription *string  `protobuf:"bytes,15,opt,name=issues_description,json=issuesDescription,proto3,oneof" json:"issues_description,omitempty"`
	TrackCount        *int32   `protobuf:"varint,16,opt,name=track_count,json=trackCount,proto3,oneof" json:"track_count,omitempty"`
	QualityTier       *string  `protobuf:"bytes,17,opt,name=quality_tier,json=qualityTier,proto3,oneof" json:"quality_tier,omitempty"` // "4K", "1080p", "720p", "480p", "SD"
	PrimaryWidth      *int32   `protobuf:"varint,18,opt,name=primary_width,json=primaryWidth,proto3,oneof" json:"primary_width,omitempty"`
	PrimaryHeight     *int32   `protobuf:"varint,19,opt,name=primary_height,json=primaryHeight,proto3,oneof" json:"primary_height,omitempty"`
	PrimaryFps        *float32 `protobuf:"fixed32,20,opt,name=primary_fps,json=primaryFps,proto3,oneof" json:"primary_fps,omitempty"`
	PrimaryCodec      *string  `protobuf:"bytes,21,opt,name=primary_codec,json=primaryCodec,proto3,oneof" json:"primary_codec,omitempty"`
	PrimaryBitrate    *int32   `protobuf:"varint,22,opt,name=primary_bitrate,json=primaryBitrate,proto3,oneof" json:"primary_bitrate,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StreamLifecycleUpdate) Reset() {
	*x = StreamLifecycleUpdate{}
	mi := &file_ipc_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamLifecycleUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamLifecycleUpdate) ProtoMessage() {}

func (x *StreamLifecycleUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamLifecycleUpdate.ProtoReflect.Descriptor instead.
func (*StreamLifecycleUpdate) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{31}
}

func (x *StreamLifecycleUpdate) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetBufferState() string {
	if x != nil && x.BufferState != nil {
		return *x.BufferState
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetUploadedBytes() uint64 {
	if x != nil && x.UploadedBytes != nil {
		return *x.UploadedBytes
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetDownloadedBytes() uint64 {
	if x != nil && x.DownloadedBytes != nil {
		return *x.DownloadedBytes
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetTotalViewers() uint32 {
	if x != nil && x.TotalViewers != nil {
		return *x.TotalViewers
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetTotalInputs() uint32 {
	if x != nil && x.TotalInputs != nil {
		return *x.TotalInputs
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetViewerSeconds() uint64 {
	if x != nil && x.ViewerSeconds != nil {
		return *x.ViewerSeconds
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetStreamDetails() string {
	if x != nil && x.StreamDetails != nil {
		return *x.StreamDetails
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetHealthScore() float32 {
	if x != nil && x.HealthScore != nil {
		return *x.HealthScore
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetHasIssues() bool {
	if x != nil && x.HasIssues != nil {
		return *x.HasIssues
	}
	return false
}

func (x *StreamLifecycleUpdate) GetIssuesDescription() string {
	if x != nil && x.IssuesDescription != nil {
		return *x.IssuesDescription
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetTrackCount() int32 {
	if x != nil && x.TrackCount != nil {
		return *x.TrackCount
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetQualityTier() string {
	if x != nil && x.QualityTier != nil {
		return *x.QualityTier
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetPrimaryWidth() int32 {
	if x != nil && x.PrimaryWidth != nil {
		return *x.PrimaryWidth
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetPrimaryHeight() int32 {
	if x != nil && x.PrimaryHeight != nil {
		return *x.PrimaryHeight
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetPrimaryFps() float32 {
	if x != nil && x.PrimaryFps != nil {
		return *x.PrimaryFps
	}
	return 0
}

func (x *StreamLifecycleUpdate) GetPrimaryCodec() string {
	if x != nil && x.PrimaryCodec != nil {
		return *x.PrimaryCodec
	}
	return ""
}

func (x *StreamLifecycleUpdate) GetPrimaryBitrate() int32 {
	if x != nil && x.PrimaryBitrate != nil {
		return *x.PrimaryBitrate
	}
	return 0
}

type ClientLifecycleUpdate struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	NodeId               string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	TenantId             *string                `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"` // Optional - enriched by Foghorn via Commodore lookup
	InternalName         string                 `protobuf:"bytes,3,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`
	Action               string                 `protobuf:"bytes,4,opt,name=action,proto3" json:"action,omitempty"` // "connect", "disconnect"
	Protocol             string                 `protobuf:"bytes,5,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Host                 string                 `protobuf:"bytes,6,opt,name=host,proto3" json:"host,omitempty"`
	SessionId            *string                `protobuf:"bytes,7,opt,name=session_id,json=sessionId,proto3,oneof" json:"session_id,omitempty"`
	ConnectionTime       *float32               `protobuf:"fixed32,8,opt,name=connection_time,json=connectionTime,proto3,oneof" json:"connection_time,omitempty"`
	Position             *float32               `protobuf:"fixed32,9,opt,name=position,proto3,oneof" json:"position,omitempty"`
	BandwidthInBps       *uint64                `protobuf:"varint,10,opt,name=bandwidth_in_bps,json=bandwidthInBps,proto3,oneof" json:"bandwidth_in_bps,omitempty"`
	BandwidthOutBps      *uint64                `protobuf:"varint,11,opt,name=bandwidth_out_bps,json=bandwidthOutBps,proto3,oneof" json:"bandwidth_out_bps,omitempty"`
	BytesDownloaded      *uint64                `protobuf:"varint,12,opt,name=bytes_downloaded,json=bytesDownloaded,proto3,oneof" json:"bytes_downloaded,omitempty"`
	BytesUploaded        *uint64                `protobuf:"varint,13,opt,name=bytes_uploaded,json=bytesUploaded,proto3,oneof" json:"bytes_uploaded,omitempty"`
	PacketsSent          *uint64                `protobuf:"varint,14,opt,name=packets_sent,json=packetsSent,proto3,oneof" json:"packets_sent,omitempty"`
	PacketsLost          *uint64                `protobuf:"varint,15,opt,name=packets_lost,json=packetsLost,proto3,oneof" json:"packets_lost,omitempty"`
	PacketsRetransmitted *uint64                `protobuf:"varint,16,opt,name=packets_retransmitted,json=packetsRetransmitted,proto3,oneof" json:"packets_retransmitted,omitempty"`
	Timestamp            int64                  `protobuf:"varint,17,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Client identification and geo fields (client_ip from Helmsman, geo enriched by Foghorn)
	ClientIp        *string  `protobuf:"bytes,18,opt,name=client_ip,json=clientIp,proto3,oneof" json:"client_ip,omitempty"`                        // Client IP address
	ClientCountry   *string  `protobuf:"bytes,19,opt,name=client_country,json=clientCountry,proto3,oneof" json:"client_country,omitempty"`         // GeoIP enriched country
	ClientCity      *string  `protobuf:"bytes,20,opt,name=client_city,json=clientCity,proto3,oneof" json:"client_city,omitempty"`                  // GeoIP enriched city
	ClientLatitude  *float64 `protobuf:"fixed64,21,opt,name=client_latitude,json=clientLatitude,proto3,oneof" json:"client_latitude,omitempty"`    // GeoIP enriched latitude
	ClientLongitude *float64 `protobuf:"fixed64,22,opt,name=client_longitude,json=clientLongitude,proto3,oneof" json:"client_longitude,omitempty"` // GeoIP enriched longitude
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ClientLifecycleUpdate) Reset() {
	*x = ClientLifecycleUpdate{}
	mi := &file_ipc_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientLifecycleUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientLifecycleUpdate) ProtoMessage() {}

func (x *ClientLifecycleUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientLifecycleUpdate.ProtoReflect.Descriptor instead.
func (*ClientLifecycleUpdate) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{32}
}

func (x *ClientLifecycleUpdate) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetSessionId() string {
	if x != nil && x.SessionId != nil {
		return *x.SessionId
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetConnectionTime() float32 {
	if x != nil && x.ConnectionTime != nil {
		return *x.ConnectionTime
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetPosition() float32 {
	if x != nil && x.Position != nil {
		return *x.Position
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetBandwidthInBps() uint64 {
	if x != nil && x.BandwidthInBps != nil {
		return *x.BandwidthInBps
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetBandwidthOutBps() uint64 {
	if x != nil && x.BandwidthOutBps != nil {
		return *x.BandwidthOutBps
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetBytesDownloaded() uint64 {
	if x != nil && x.BytesDownloaded != nil {
		return *x.BytesDownloaded
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetBytesUploaded() uint64 {
	if x != nil && x.BytesUploaded != nil {
		return *x.BytesUploaded
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetPacketsSent() uint64 {
	if x != nil && x.PacketsSent != nil {
		return *x.PacketsSent
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetPacketsLost() uint64 {
	if x != nil && x.PacketsLost != nil {
		return *x.PacketsLost
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetPacketsRetransmitted() uint64 {
	if x != nil && x.PacketsRetransmitted != nil {
		return *x.PacketsRetransmitted
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetClientIp() string {
	if x != nil && x.ClientIp != nil {
		return *x.ClientIp
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetClientCountry() string {
	if x != nil && x.ClientCountry != nil {
		return *x.ClientCountry
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetClientCity() string {
	if x != nil && x.ClientCity != nil {
		return *x.ClientCity
	}
	return ""
}

func (x *ClientLifecycleUpdate) GetClientLatitude() float64 {
	if x != nil && x.ClientLatitude != nil {
		return *x.ClientLatitude
	}
	return 0
}

func (x *ClientLifecycleUpdate) GetClientLongitude() float64 {
	if x != nil && x.ClientLongitude != nil {
		return *x.ClientLongitude
	}
	return 0
}

type NodeLifecycleUpdate struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	NodeId string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Resource metrics
	CpuTenths  uint32 `protobuf:"varint,2,opt,name=cpu_tenths,json=cpuTenths,proto3" json:"cpu_tenths,omitempty"`    // 0-1000
	RamMax     uint64 `protobuf:"varint,3,opt,name=ram_max,json=ramMax,proto3" json:"ram_max,omitempty"`             // MiB
	RamCurrent uint64 `protobuf:"varint,4,opt,name=ram_current,json=ramCurrent,proto3" json:"ram_current,omitempty"` // MiB
	UpSpeed    uint64 `protobuf:"varint,5,opt,name=up_speed,json=upSpeed,proto3" json:"up_speed,omitempty"`          // bytes/sec
	DownSpeed  uint64 `protobuf:"varint,6,opt,name=down_speed,json=downSpeed,proto3" json:"down_speed,omitempty"`    // bytes/sec
	BwLimit    uint64 `protobuf:"varint,7,opt,name=bw_limit,json=bwLimit,proto3" json:"bw_limit,omitempty"`          // bytes/sec
	// Geo/location
	Latitude      float64 `protobuf:"fixed64,8,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude     float64 `protobuf:"fixed64,9,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Location      string  `protobuf:"bytes,10,opt,name=location,proto3" json:"location,omitempty"`
	ActiveStreams uint32  `protobuf:"varint,11,opt,name=active_streams,json=activeStreams,proto3" json:"active_streams,omitempty"`
	// Extended metrics (matching HTTP payload)
	BaseUrl   string `protobuf:"bytes,12,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`
	IsHealthy bool   `protobuf:"varint,13,opt,name=is_healthy,json=isHealthy,proto3" json:"is_healthy,omitempty"`
	EventType string `protobuf:"bytes,14,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	Timestamp int64  `protobuf:"varint,15,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Node capabilities
	Capabilities *NodeCapabilities `protobuf:"bytes,16,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	// Storage information
	Storage *StorageInfo `protobuf:"bytes,17,opt,name=storage,proto3" json:"storage,omitempty"`
	// Node limits and usage
	Limits *NodeLimits `protobuf:"bytes,18,opt,name=limits,proto3" json:"limits,omitempty"`
	// Stream metrics
	Streams map[string]*StreamData `protobuf:"bytes,19,rep,name=streams,proto3" json:"streams,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Stored artifacts
	Artifacts []*StoredArtifact `protobuf:"bytes,20,rep,name=artifacts,proto3" json:"artifacts,omitempty"`
	// MistServer outputs configuration (parsed from koekjes endpoint)
	OutputsJson string `protobuf:"bytes,21,opt,name=outputs_json,json=outputsJson,proto3" json:"outputs_json,omitempty"`
	// Enrichment fields added by Foghorn
	TenantId      *string `protobuf:"bytes,22,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeLifecycleUpdate) Reset() {
	*x = NodeLifecycleUpdate{}
	mi := &file_ipc_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeLifecycleUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeLifecycleUpdate) ProtoMessage() {}

func (x *NodeLifecycleUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeLifecycleUpdate.ProtoReflect.Descriptor instead.
func (*NodeLifecycleUpdate) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{33}
}

func (x *NodeLifecycleUpdate) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetCpuTenths() uint32 {
	if x != nil {
		return x.CpuTenths
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetRamMax() uint64 {
	if x != nil {
		return x.RamMax
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetRamCurrent() uint64 {
	if x != nil {
		return x.RamCurrent
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetUpSpeed() uint64 {
	if x != nil {
		return x.UpSpeed
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetDownSpeed() uint64 {
	if x != nil {
		return x.DownSpeed
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetBwLimit() uint64 {
	if x != nil {
		return x.BwLimit
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetLatitude() float64 {
	if x != nil {
		return x.Latitude
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetLongitude() float64 {
	if x != nil {
		return x.Longitude
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetLocation() string {
	if x != nil {
		return x.Location
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetActiveStreams() uint32 {
	if x != nil {
		return x.ActiveStreams
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetBaseUrl() string {
	if x != nil {
		return x.BaseUrl
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetIsHealthy() bool {
	if x != nil {
		return x.IsHealthy
	}
	return false
}

func (x *NodeLifecycleUpdate) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *NodeLifecycleUpdate) GetCapabilities() *NodeCapabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *NodeLifecycleUpdate) GetStorage() *StorageInfo {
	if x != nil {
		return x.Storage
	}
	return nil
}

func (x *NodeLifecycleUpdate) GetLimits() *NodeLimits {
	if x != nil {
		return x.Limits
	}
	return nil
}

func (x *NodeLifecycleUpdate) GetStreams() map[string]*StreamData {
	if x != nil {
		return x.Streams
	}
	return nil
}

func (x *NodeLifecycleUpdate) GetArtifacts() []*StoredArtifact {
	if x != nil {
		return x.Artifacts
	}
	return nil
}

func (x *NodeLifecycleUpdate) GetOutputsJson() string {
	if x != nil {
		return x.OutputsJson
	}
	return ""
}

func (x *NodeLifecycleUpdate) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

// Load balancing specific data (no trigger equivalent - generated by Foghorn routing)
type LoadBalancingData struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	SelectedNode      string                 `protobuf:"bytes,1,opt,name=selected_node,json=selectedNode,proto3" json:"selected_node,omitempty"`
	Latitude          float64                `protobuf:"fixed64,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude         float64                `protobuf:"fixed64,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Status            string                 `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	Details           string                 `protobuf:"bytes,5,opt,name=details,proto3" json:"details,omitempty"`
	Score             uint64                 `protobuf:"varint,6,opt,name=score,proto3" json:"score,omitempty"`
	ClientIp          string                 `protobuf:"bytes,7,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
	ClientCountry     string                 `protobuf:"bytes,8,opt,name=client_country,json=clientCountry,proto3" json:"client_country,omitempty"`
	NodeLatitude      float64                `protobuf:"fixed64,9,opt,name=node_latitude,json=nodeLatitude,proto3" json:"node_latitude,omitempty"`
	NodeLongitude     float64                `protobuf:"fixed64,10,opt,name=node_longitude,json=nodeLongitude,proto3" json:"node_longitude,omitempty"`
	NodeName          string                 `protobuf:"bytes,11,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	SelectedNodeId    *string                `protobuf:"bytes,12,opt,name=selected_node_id,json=selectedNodeId,proto3,oneof" json:"selected_node_id,omitempty"`
	RoutingDistanceKm *float64               `protobuf:"fixed64,13,opt,name=routing_distance_km,json=routingDistanceKm,proto3,oneof" json:"routing_distance_km,omitempty"`
	// Enrichment fields added by Foghorn
	TenantId      *string `protobuf:"bytes,14,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"`
	InternalName  *string `protobuf:"bytes,15,opt,name=internal_name,json=internalName,proto3,oneof" json:"internal_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LoadBalancingData) Reset() {
	*x = LoadBalancingData{}
	mi := &file_ipc_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LoadBalancingData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadBalancingData) ProtoMessage() {}

func (x *LoadBalancingData) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadBalancingData.ProtoReflect.Descriptor instead.
func (*LoadBalancingData) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{34}
}

func (x *LoadBalancingData) GetSelectedNode() string {
	if x != nil {
		return x.SelectedNode
	}
	return ""
}

func (x *LoadBalancingData) GetLatitude() float64 {
	if x != nil {
		return x.Latitude
	}
	return 0
}

func (x *LoadBalancingData) GetLongitude() float64 {
	if x != nil {
		return x.Longitude
	}
	return 0
}

func (x *LoadBalancingData) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *LoadBalancingData) GetDetails() string {
	if x != nil {
		return x.Details
	}
	return ""
}

func (x *LoadBalancingData) GetScore() uint64 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *LoadBalancingData) GetClientIp() string {
	if x != nil {
		return x.ClientIp
	}
	return ""
}

func (x *LoadBalancingData) GetClientCountry() string {
	if x != nil {
		return x.ClientCountry
	}
	return ""
}

func (x *LoadBalancingData) GetNodeLatitude() float64 {
	if x != nil {
		return x.NodeLatitude
	}
	return 0
}

func (x *LoadBalancingData) GetNodeLongitude() float64 {
	if x != nil {
		return x.NodeLongitude
	}
	return 0
}

func (x *LoadBalancingData) GetNodeName() string {
	if x != nil {
		return x.NodeName
	}
	return ""
}

func (x *LoadBalancingData) GetSelectedNodeId() string {
	if x != nil && x.SelectedNodeId != nil {
		return *x.SelectedNodeId
	}
	return ""
}

func (x *LoadBalancingData) GetRoutingDistanceKm() float64 {
	if x != nil && x.RoutingDistanceKm != nil {
		return *x.RoutingDistanceKm
	}
	return 0
}

func (x *LoadBalancingData) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *LoadBalancingData) GetInternalName() string {
	if x != nil && x.InternalName != nil {
		return *x.InternalName
	}
	return ""
}

// Clip lifecycle specific data (separate from ClipProgress/ClipDone control messages)
type ClipLifecycleData struct {
	state           protoimpl.MessageState  `protogen:"open.v1"`
	Stage           ClipLifecycleData_Stage `protobuf:"varint,1,opt,name=stage,proto3,enum=helmsmancontrol.ClipLifecycleData_Stage" json:"stage,omitempty"`
	ClipHash        string                  `protobuf:"bytes,2,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`
	RequestId       *string                 `protobuf:"bytes,3,opt,name=request_id,json=requestId,proto3,oneof" json:"request_id,omitempty"`
	ProgressPercent *uint32                 `protobuf:"varint,4,opt,name=progress_percent,json=progressPercent,proto3,oneof" json:"progress_percent,omitempty"`
	FilePath        *string                 `protobuf:"bytes,5,opt,name=file_path,json=filePath,proto3,oneof" json:"file_path,omitempty"`
	S3Url           *string                 `protobuf:"bytes,6,opt,name=s3_url,json=s3Url,proto3,oneof" json:"s3_url,omitempty"`
	SizeBytes       *uint64                 `protobuf:"varint,7,opt,name=size_bytes,json=sizeBytes,proto3,oneof" json:"size_bytes,omitempty"`
	Error           *string                 `protobuf:"bytes,8,opt,name=error,proto3,oneof" json:"error,omitempty"`
	StartedAt       *int64                  `protobuf:"varint,9,opt,name=started_at,json=startedAt,proto3,oneof" json:"started_at,omitempty"`
	CompletedAt     *int64                  `protobuf:"varint,10,opt,name=completed_at,json=completedAt,proto3,oneof" json:"completed_at,omitempty"`
	NodeId          *string                 `protobuf:"bytes,11,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	// Enrichment fields added by Foghorn
	TenantId      *string `protobuf:"bytes,12,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"`
	InternalName  *string `protobuf:"bytes,13,opt,name=internal_name,json=internalName,proto3,oneof" json:"internal_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipLifecycleData) Reset() {
	*x = ClipLifecycleData{}
	mi := &file_ipc_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipLifecycleData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipLifecycleData) ProtoMessage() {}

func (x *ClipLifecycleData) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipLifecycleData.ProtoReflect.Descriptor instead.
func (*ClipLifecycleData) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{35}
}

func (x *ClipLifecycleData) GetStage() ClipLifecycleData_Stage {
	if x != nil {
		return x.Stage
	}
	return ClipLifecycleData_STAGE_UNSPECIFIED
}

func (x *ClipLifecycleData) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *ClipLifecycleData) GetRequestId() string {
	if x != nil && x.RequestId != nil {
		return *x.RequestId
	}
	return ""
}

func (x *ClipLifecycleData) GetProgressPercent() uint32 {
	if x != nil && x.ProgressPercent != nil {
		return *x.ProgressPercent
	}
	return 0
}

func (x *ClipLifecycleData) GetFilePath() string {
	if x != nil && x.FilePath != nil {
		return *x.FilePath
	}
	return ""
}

func (x *ClipLifecycleData) GetS3Url() string {
	if x != nil && x.S3Url != nil {
		return *x.S3Url
	}
	return ""
}

func (x *ClipLifecycleData) GetSizeBytes() uint64 {
	if x != nil && x.SizeBytes != nil {
		return *x.SizeBytes
	}
	return 0
}

func (x *ClipLifecycleData) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

func (x *ClipLifecycleData) GetStartedAt() int64 {
	if x != nil && x.StartedAt != nil {
		return *x.StartedAt
	}
	return 0
}

func (x *ClipLifecycleData) GetCompletedAt() int64 {
	if x != nil && x.CompletedAt != nil {
		return *x.CompletedAt
	}
	return 0
}

func (x *ClipLifecycleData) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *ClipLifecycleData) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *ClipLifecycleData) GetInternalName() string {
	if x != nil && x.InternalName != nil {
		return *x.InternalName
	}
	return ""
}

// DVR lifecycle specific data (separate from DVR control messages)
type DVRLifecycleData struct {
	state        protoimpl.MessageState  `protogen:"open.v1"`
	Status       DVRLifecycleData_Status `protobuf:"varint,1,opt,name=status,proto3,enum=helmsmancontrol.DVRLifecycleData_Status" json:"status,omitempty"`
	DvrHash      string                  `protobuf:"bytes,2,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`
	ManifestPath *string                 `protobuf:"bytes,3,opt,name=manifest_path,json=manifestPath,proto3,oneof" json:"manifest_path,omitempty"`
	StartedAt    *int64                  `protobuf:"varint,4,opt,name=started_at,json=startedAt,proto3,oneof" json:"started_at,omitempty"`
	EndedAt      *int64                  `protobuf:"varint,5,opt,name=ended_at,json=endedAt,proto3,oneof" json:"ended_at,omitempty"`
	SizeBytes    *uint64                 `protobuf:"varint,6,opt,name=size_bytes,json=sizeBytes,proto3,oneof" json:"size_bytes,omitempty"`
	SegmentCount *int32                  `protobuf:"varint,7,opt,name=segment_count,json=segmentCount,proto3,oneof" json:"segment_count,omitempty"`
	Error        *string                 `protobuf:"bytes,8,opt,name=error,proto3,oneof" json:"error,omitempty"`
	NodeId       *string                 `protobuf:"bytes,9,opt,name=node_id,json=nodeId,proto3,oneof" json:"node_id,omitempty"`
	// Enrichment fields added by Foghorn
	TenantId      *string `protobuf:"bytes,10,opt,name=tenant_id,json=tenantId,proto3,oneof" json:"tenant_id,omitempty"`
	InternalName  *string `protobuf:"bytes,11,opt,name=internal_name,json=internalName,proto3,oneof" json:"internal_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRLifecycleData) Reset() {
	*x = DVRLifecycleData{}
	mi := &file_ipc_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRLifecycleData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRLifecycleData) ProtoMessage() {}

func (x *DVRLifecycleData) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRLifecycleData.ProtoReflect.Descriptor instead.
func (*DVRLifecycleData) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{36}
}

func (x *DVRLifecycleData) GetStatus() DVRLifecycleData_Status {
	if x != nil {
		return x.Status
	}
	return DVRLifecycleData_STATUS_UNSPECIFIED
}

func (x *DVRLifecycleData) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRLifecycleData) GetManifestPath() string {
	if x != nil && x.ManifestPath != nil {
		return *x.ManifestPath
	}
	return ""
}

func (x *DVRLifecycleData) GetStartedAt() int64 {
	if x != nil && x.StartedAt != nil {
		return *x.StartedAt
	}
	return 0
}

func (x *DVRLifecycleData) GetEndedAt() int64 {
	if x != nil && x.EndedAt != nil {
		return *x.EndedAt
	}
	return 0
}

func (x *DVRLifecycleData) GetSizeBytes() uint64 {
	if x != nil && x.SizeBytes != nil {
		return *x.SizeBytes
	}
	return 0
}

func (x *DVRLifecycleData) GetSegmentCount() int32 {
	if x != nil && x.SegmentCount != nil {
		return *x.SegmentCount
	}
	return 0
}

func (x *DVRLifecycleData) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

func (x *DVRLifecycleData) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *DVRLifecycleData) GetTenantId() string {
	if x != nil && x.TenantId != nil {
		return *x.TenantId
	}
	return ""
}

func (x *DVRLifecycleData) GetInternalName() string {
	if x != nil && x.InternalName != nil {
		return *x.InternalName
	}
	return ""
}

type NodeCapabilities struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ingest        bool                   `protobuf:"varint,1,opt,name=ingest,proto3" json:"ingest,omitempty"`
	Edge          bool                   `protobuf:"varint,2,opt,name=edge,proto3" json:"edge,omitempty"`
	Storage       bool                   `protobuf:"varint,3,opt,name=storage,proto3" json:"storage,omitempty"`
	Processing    bool                   `protobuf:"varint,4,opt,name=processing,proto3" json:"processing,omitempty"`
	Roles         []string               `protobuf:"bytes,5,rep,name=roles,proto3" json:"roles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeCapabilities) Reset() {
	*x = NodeCapabilities{}
	mi := &file_ipc_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeCapabilities) ProtoMessage() {}

func (x *NodeCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeCapabilities.ProtoReflect.Descriptor instead.
func (*NodeCapabilities) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{37}
}

func (x *NodeCapabilities) GetIngest() bool {
	if x != nil {
		return x.Ingest
	}
	return false
}

func (x *NodeCapabilities) GetEdge() bool {
	if x != nil {
		return x.Edge
	}
	return false
}

func (x *NodeCapabilities) GetStorage() bool {
	if x != nil {
		return x.Storage
	}
	return false
}

func (x *NodeCapabilities) GetProcessing() bool {
	if x != nil {
		return x.Processing
	}
	return false
}

func (x *NodeCapabilities) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

type StorageInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	LocalPath     string                 `protobuf:"bytes,1,opt,name=local_path,json=localPath,proto3" json:"local_path,omitempty"`
	S3Bucket      string                 `protobuf:"bytes,2,opt,name=s3_bucket,json=s3Bucket,proto3" json:"s3_bucket,omitempty"`
	S3Prefix      string                 `protobuf:"bytes,3,opt,name=s3_prefix,json=s3Prefix,proto3" json:"s3_prefix,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StorageInfo) Reset() {
	*x = StorageInfo{}
	mi := &file_ipc_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageInfo) ProtoMessage() {}

func (x *StorageInfo) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageInfo.ProtoReflect.Descriptor instead.
func (*StorageInfo) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{38}
}

func (x *StorageInfo) GetLocalPath() string {
	if x != nil {
		return x.LocalPath
	}
	return ""
}

func (x *StorageInfo) GetS3Bucket() string {
	if x != nil {
		return x.S3Bucket
	}
	return ""
}

func (x *StorageInfo) GetS3Prefix() string {
	if x != nil {
		return x.S3Prefix
	}
	return ""
}

type NodeLimits struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	MaxTranscodes        int32                  `protobuf:"varint,1,opt,name=max_transcodes,json=maxTranscodes,proto3" json:"max_transcodes,omitempty"`
	StorageCapacityBytes uint64                 `protobuf:"varint,2,opt,name=storage_capacity_bytes,json=storageCapacityBytes,proto3" json:"storage_capacity_bytes,omitempty"`
	StorageUsedBytes     uint64                 `protobuf:"varint,3,opt,name=storage_used_bytes,json=storageUsedBytes,proto3" json:"storage_used_bytes,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *NodeLimits) Reset() {
	*x = NodeLimits{}
	mi := &file_ipc_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeLimits) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeLimits) ProtoMessage() {}

func (x *NodeLimits) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeLimits.ProtoReflect.Descriptor instead.
func (*NodeLimits) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{39}
}

func (x *NodeLimits) GetMaxTranscodes() int32 {
	if x != nil {
		return x.MaxTranscodes
	}
	return 0
}

func (x *NodeLimits) GetStorageCapacityBytes() uint64 {
	if x != nil {
		return x.StorageCapacityBytes
	}
	return 0
}

func (x *NodeLimits) GetStorageUsedBytes() uint64 {
	if x != nil {
		return x.StorageUsedBytes
	}
	return 0
}

type StreamData struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Total         uint64                 `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`                          // Total viewers
	Inputs        uint32                 `protobuf:"varint,2,opt,name=inputs,proto3" json:"inputs,omitempty"`                        // Input count
	BytesUp       uint64                 `protobuf:"varint,3,opt,name=bytes_up,json=bytesUp,proto3" json:"bytes_up,omitempty"`       // Upload bytes
	BytesDown     uint64                 `protobuf:"varint,4,opt,name=bytes_down,json=bytesDown,proto3" json:"bytes_down,omitempty"` // Download bytes
	Bandwidth     uint32                 `protobuf:"varint,5,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`                  // Bandwidth per viewer
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamData) Reset() {
	*x = StreamData{}
	mi := &file_ipc_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamData) ProtoMessage() {}

func (x *StreamData) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamData.ProtoReflect.Descriptor instead.
func (*StreamData) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{40}
}

func (x *StreamData) GetTotal() uint64 {
	if x != nil {
		return x.Total
	}
	return 0
}

func (x *StreamData) GetInputs() uint32 {
	if x != nil {
		return x.Inputs
	}
	return 0
}

func (x *StreamData) GetBytesUp() uint64 {
	if x != nil {
		return x.BytesUp
	}
	return 0
}

func (x *StreamData) GetBytesDown() uint64 {
	if x != nil {
		return x.BytesDown
	}
	return 0
}

func (x *StreamData) GetBandwidth() uint32 {
	if x != nil {
		return x.Bandwidth
	}
	return 0
}

// Stream track information (replaces JSON parsing)
type StreamTrack struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	TrackName   string                 `protobuf:"bytes,1,opt,name=track_name,json=trackName,proto3" json:"track_name,omitempty"` // e.g., "video_1", "audio_1", "meta_1"
	TrackType   string                 `protobuf:"bytes,2,opt,name=track_type,json=trackType,proto3" json:"track_type,omitempty"` // "video", "audio", "meta", "unknown"
	Codec       string                 `protobuf:"bytes,3,opt,name=codec,proto3" json:"codec,omitempty"`                          // H264, AAC, JSON, etc.
	BitrateKbps *int32                 `protobuf:"varint,4,opt,name=bitrate_kbps,json=bitrateKbps,proto3,oneof" json:"bitrate_kbps,omitempty"`
	BitrateBps  *int64                 `protobuf:"varint,5,opt,name=bitrate_bps,json=bitrateBps,proto3,oneof" json:"bitrate_bps,omitempty"`
	Buffer      *int32                 `protobuf:"varint,6,opt,name=buffer,proto3,oneof" json:"buffer,omitempty"`
	Jitter      *int32                 `protobuf:"varint,7,opt,name=jitter,proto3,oneof" json:"jitter,omitempty"`
	// Video-specific fields
	Width      *int32   `protobuf:"varint,8,opt,name=width,proto3,oneof" json:"width,omitempty"`
	Height     *int32   `protobuf:"varint,9,opt,name=height,proto3,oneof" json:"height,omitempty"`
	Fps        *float64 `protobuf:"fixed64,10,opt,name=fps,proto3,oneof" json:"fps,omitempty"`
	Resolution *string  `protobuf:"bytes,11,opt,name=resolution,proto3,oneof" json:"resolution,omitempty"` // e.g., "1920x1080"
	HasBframes *bool    `protobuf:"varint,12,opt,name=has_bframes,json=hasBframes,proto3,oneof" json:"has_bframes,omitempty"`
	// Audio-specific fields
	Channels   *int32 `protobuf:"varint,13,opt,name=channels,proto3,oneof" json:"channels,omitempty"`
	SampleRate *int32 `protobuf:"varint,14,opt,name=sample_rate,json=sampleRate,proto3,oneof" json:"sample_rate,omitempty"`
	// Frame timing and quality metrics
	FramesMax           *int32   `protobuf:"varint,15,opt,name=frames_max,json=framesMax,proto3,oneof" json:"frames_max,omitempty"`
	FramesMin           *int32   `protobuf:"varint,16,opt,name=frames_min,json=framesMin,proto3,oneof" json:"frames_min,omitempty"`
	FrameMsMax          *float64 `protobuf:"fixed64,17,opt,name=frame_ms_max,json=frameMsMax,proto3,oneof" json:"frame_ms_max,omitempty"`
	FrameMsMin          *float64 `protobuf:"fixed64,18,opt,name=frame_ms_min,json=frameMsMin,proto3,oneof" json:"frame_ms_min,omitempty"`
	FrameJitterMs       *float64 `protobuf:"fixed64,19,opt,name=frame_jitter_ms,json=frameJitterMs,proto3,oneof" json:"frame_jitter_ms,omitempty"`
	KeyframeStabilityMs *float64 `protobuf:"fixed64,20,opt,name=keyframe_stability_ms,json=keyframeStabilityMs,proto3,oneof" json:"keyframe_stability_ms,omitempty"`
	KeyframeIntervalMs  *float64 `protobuf:"fixed64,21,opt,name=keyframe_interval_ms,json=keyframeIntervalMs,proto3,oneof" json:"keyframe_interval_ms,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *StreamTrack) Reset() {
	*x = StreamTrack{}
	mi := &file_ipc_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamTrack) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamTrack) ProtoMessage() {}

func (x *StreamTrack) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamTrack.ProtoReflect.Descriptor instead.
func (*StreamTrack) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{41}
}

func (x *StreamTrack) GetTrackName() string {
	if x != nil {
		return x.TrackName
	}
	return ""
}

func (x *StreamTrack) GetTrackType() string {
	if x != nil {
		return x.TrackType
	}
	return ""
}

func (x *StreamTrack) GetCodec() string {
	if x != nil {
		return x.Codec
	}
	return ""
}

func (x *StreamTrack) GetBitrateKbps() int32 {
	if x != nil && x.BitrateKbps != nil {
		return *x.BitrateKbps
	}
	return 0
}

func (x *StreamTrack) GetBitrateBps() int64 {
	if x != nil && x.BitrateBps != nil {
		return *x.BitrateBps
	}
	return 0
}

func (x *StreamTrack) GetBuffer() int32 {
	if x != nil && x.Buffer != nil {
		return *x.Buffer
	}
	return 0
}

func (x *StreamTrack) GetJitter() int32 {
	if x != nil && x.Jitter != nil {
		return *x.Jitter
	}
	return 0
}

func (x *StreamTrack) GetWidth() int32 {
	if x != nil && x.Width != nil {
		return *x.Width
	}
	return 0
}

func (x *StreamTrack) GetHeight() int32 {
	if x != nil && x.Height != nil {
		return *x.Height
	}
	return 0
}

func (x *StreamTrack) GetFps() float64 {
	if x != nil && x.Fps != nil {
		return *x.Fps
	}
	return 0
}

func (x *StreamTrack) GetResolution() string {
	if x != nil && x.Resolution != nil {
		return *x.Resolution
	}
	return ""
}

func (x *StreamTrack) GetHasBframes() bool {
	if x != nil && x.HasBframes != nil {
		return *x.HasBframes
	}
	return false
}

func (x *StreamTrack) GetChannels() int32 {
	if x != nil && x.Channels != nil {
		return *x.Channels
	}
	return 0
}

func (x *StreamTrack) GetSampleRate() int32 {
	if x != nil && x.SampleRate != nil {
		return *x.SampleRate
	}
	return 0
}

func (x *StreamTrack) GetFramesMax() int32 {
	if x != nil && x.FramesMax != nil {
		return *x.FramesMax
	}
	return 0
}

func (x *StreamTrack) GetFramesMin() int32 {
	if x != nil && x.FramesMin != nil {
		return *x.FramesMin
	}
	return 0
}

func (x *StreamTrack) GetFrameMsMax() float64 {
	if x != nil && x.FrameMsMax != nil {
		return *x.FrameMsMax
	}
	return 0
}

func (x *StreamTrack) GetFrameMsMin() float64 {
	if x != nil && x.FrameMsMin != nil {
		return *x.FrameMsMin
	}
	return 0
}

func (x *StreamTrack) GetFrameJitterMs() float64 {
	if x != nil && x.FrameJitterMs != nil {
		return *x.FrameJitterMs
	}
	return 0
}

func (x *StreamTrack) GetKeyframeStabilityMs() float64 {
	if x != nil && x.KeyframeStabilityMs != nil {
		return *x.KeyframeStabilityMs
	}
	return 0
}

func (x *StreamTrack) GetKeyframeIntervalMs() float64 {
	if x != nil && x.KeyframeIntervalMs != nil {
		return *x.KeyframeIntervalMs
	}
	return 0
}

type StoredArtifact struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Security: Use opaque identifiers, never expose tenant_id on edge nodes
	ClipHash      string `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`       // Opaque identifier for the clip
	StreamName    string `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"` // Stream name (safe to expose)
	FilePath      string `protobuf:"bytes,3,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`       // Local file path on storage node
	S3Url         string `protobuf:"bytes,4,opt,name=s3_url,json=s3Url,proto3" json:"s3_url,omitempty"`                // S3 URL if uploaded to cloud storage
	SizeBytes     uint64 `protobuf:"varint,5,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`   // File size in bytes
	CreatedAt     int64  `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`   // Creation timestamp (Unix seconds)
	Format        string `protobuf:"bytes,7,opt,name=format,proto3" json:"format,omitempty"`                           // File format (mp4, webm, etc.)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StoredArtifact) Reset() {
	*x = StoredArtifact{}
	mi := &file_ipc_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StoredArtifact) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoredArtifact) ProtoMessage() {}

func (x *StoredArtifact) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StoredArtifact.ProtoReflect.Descriptor instead.
func (*StoredArtifact) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{42}
}

func (x *StoredArtifact) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *StoredArtifact) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *StoredArtifact) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *StoredArtifact) GetS3Url() string {
	if x != nil {
		return x.S3Url
	}
	return ""
}

func (x *StoredArtifact) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *StoredArtifact) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *StoredArtifact) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

type StreamProcess struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Process         string                 `protobuf:"bytes,1,opt,name=process,proto3" json:"process,omitempty"`
	Codec           string                 `protobuf:"bytes,2,opt,name=codec,proto3" json:"codec,omitempty"`
	Bitrate         int64                  `protobuf:"varint,3,opt,name=bitrate,proto3" json:"bitrate,omitempty"`
	TrackSelect     string                 `protobuf:"bytes,4,opt,name=track_select,json=trackSelect,proto3" json:"track_select,omitempty"`
	TrackInhibit    string                 `protobuf:"bytes,5,opt,name=track_inhibit,json=trackInhibit,proto3" json:"track_inhibit,omitempty"`
	RestartType     string                 `protobuf:"bytes,6,opt,name=restart_type,json=restartType,proto3" json:"restart_type,omitempty"`
	Inconsequential bool                   `protobuf:"varint,7,opt,name=inconsequential,proto3" json:"inconsequential,omitempty"`
	ExitUnmask      bool                   `protobuf:"varint,8,opt,name=exit_unmask,json=exitUnmask,proto3" json:"exit_unmask,omitempty"`
	Extra           map[string]string      `protobuf:"bytes,100,rep,name=extra,proto3" json:"extra,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StreamProcess) Reset() {
	*x = StreamProcess{}
	mi := &file_ipc_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamProcess) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamProcess) ProtoMessage() {}

func (x *StreamProcess) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamProcess.ProtoReflect.Descriptor instead.
func (*StreamProcess) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{43}
}

func (x *StreamProcess) GetProcess() string {
	if x != nil {
		return x.Process
	}
	return ""
}

func (x *StreamProcess) GetCodec() string {
	if x != nil {
		return x.Codec
	}
	return ""
}

func (x *StreamProcess) GetBitrate() int64 {
	if x != nil {
		return x.Bitrate
	}
	return 0
}

func (x *StreamProcess) GetTrackSelect() string {
	if x != nil {
		return x.TrackSelect
	}
	return ""
}

func (x *StreamProcess) GetTrackInhibit() string {
	if x != nil {
		return x.TrackInhibit
	}
	return ""
}

func (x *StreamProcess) GetRestartType() string {
	if x != nil {
		return x.RestartType
	}
	return ""
}

func (x *StreamProcess) GetInconsequential() bool {
	if x != nil {
		return x.Inconsequential
	}
	return false
}

func (x *StreamProcess) GetExitUnmask() bool {
	if x != nil {
		return x.ExitUnmask
	}
	return false
}

func (x *StreamProcess) GetExtra() map[string]string {
	if x != nil {
		return x.Extra
	}
	return nil
}

type StreamDef struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Realtime      bool                   `protobuf:"varint,2,opt,name=realtime,proto3" json:"realtime,omitempty"`
	StopSessions  bool                   `protobuf:"varint,3,opt,name=stop_sessions,json=stopSessions,proto3" json:"stop_sessions,omitempty"`
	Tags          []string               `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty"`
	Processes     []*StreamProcess       `protobuf:"bytes,5,rep,name=processes,proto3" json:"processes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDef) Reset() {
	*x = StreamDef{}
	mi := &file_ipc_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDef) ProtoMessage() {}

func (x *StreamDef) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDef.ProtoReflect.Descriptor instead.
func (*StreamDef) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{44}
}

func (x *StreamDef) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *StreamDef) GetRealtime() bool {
	if x != nil {
		return x.Realtime
	}
	return false
}

func (x *StreamDef) GetStopSessions() bool {
	if x != nil {
		return x.StopSessions
	}
	return false
}

func (x *StreamDef) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *StreamDef) GetProcesses() []*StreamProcess {
	if x != nil {
		return x.Processes
	}
	return nil
}

type StreamTemplate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Def           *StreamDef             `protobuf:"bytes,2,opt,name=def,proto3" json:"def,omitempty"`
	Roles         []string               `protobuf:"bytes,3,rep,name=roles,proto3" json:"roles,omitempty"`
	Caps          []string               `protobuf:"bytes,4,rep,name=caps,proto3" json:"caps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamTemplate) Reset() {
	*x = StreamTemplate{}
	mi := &file_ipc_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamTemplate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamTemplate) ProtoMessage() {}

func (x *StreamTemplate) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamTemplate.ProtoReflect.Descriptor instead.
func (*StreamTemplate) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{45}
}

func (x *StreamTemplate) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *StreamTemplate) GetDef() *StreamDef {
	if x != nil {
		return x.Def
	}
	return nil
}

func (x *StreamTemplate) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

func (x *StreamTemplate) GetCaps() []string {
	if x != nil {
		return x.Caps
	}
	return nil
}

type ConfigSeed struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	NodeId       string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Latitude     float64                `protobuf:"fixed64,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude    float64                `protobuf:"fixed64,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	LocationName string                 `protobuf:"bytes,4,opt,name=location_name,json=locationName,proto3" json:"location_name,omitempty"`
	// Tenant owning this node (resolved by Foghorn via Quartermaster)
	TenantId      string            `protobuf:"bytes,5,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	Templates     []*StreamTemplate `protobuf:"bytes,10,rep,name=templates,proto3" json:"templates,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigSeed) Reset() {
	*x = ConfigSeed{}
	mi := &file_ipc_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigSeed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigSeed) ProtoMessage() {}

func (x *ConfigSeed) ProtoReflect() protoreflect.Message {
	mi := &file_ipc_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigSeed.ProtoReflect.Descriptor instead.
func (*ConfigSeed) Descriptor() ([]byte, []int) {
	return file_ipc_proto_rawDescGZIP(), []int{46}
}

func (x *ConfigSeed) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *ConfigSeed) GetLatitude() float64 {
	if x != nil {
		return x.Latitude
	}
	return 0
}

func (x *ConfigSeed) GetLongitude() float64 {
	if x != nil {
		return x.Longitude
	}
	return 0
}

func (x *ConfigSeed) GetLocationName() string {
	if x != nil {
		return x.LocationName
	}
	return ""
}

func (x *ConfigSeed) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *ConfigSeed) GetTemplates() []*StreamTemplate {
	if x != nil {
		return x.Templates
	}
	return nil
}

var File_ipc_proto protoreflect.FileDescriptor

const file_ipc_proto_rawDesc = "" +
	"\n" +
	"\tipc.proto\x12\x0fhelmsmancontrol\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.proto\"\x8d\t\n" +
	"\x0eControlMessage\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x123\n" +
	"\asent_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x06sentAt\x127\n" +
	"\bregister\x18\n" +
	" \x01(\v2\x19.helmsmancontrol.RegisterH\x00R\bregister\x12N\n" +
	"\x11clip_pull_request\x18\f \x01(\v2 .helmsmancontrol.ClipPullRequestH\x00R\x0fclipPullRequest\x12D\n" +
	"\rclip_progress\x18\r \x01(\v2\x1d.helmsmancontrol.ClipProgressH\x00R\fclipProgress\x128\n" +
	"\tclip_done\x18\x0e \x01(\v2\x19.helmsmancontrol.ClipDoneH\x00R\bclipDone\x125\n" +
	"\x05error\x18\x0f \x01(\v2\x1d.helmsmancontrol.ControlErrorH\x00R\x05error\x12:\n" +
	"\theartbeat\x18\x10 \x01(\v2\x1a.helmsmancontrol.HeartbeatH\x00R\theartbeat\x12N\n" +
	"\x11dvr_start_request\x18\x12 \x01(\v2 .helmsmancontrol.DVRStartRequestH\x00R\x0fdvrStartRequest\x12A\n" +
	"\fdvr_progress\x18\x13 \x01(\v2\x1c.helmsmancontrol.DVRProgressH\x00R\vdvrProgress\x12>\n" +
	"\vdvr_stopped\x18\x14 \x01(\v2\x1b.helmsmancontrol.DVRStoppedH\x00R\n" +
	"dvrStopped\x12K\n" +
	"\x10dvr_stop_request\x18\x15 \x01(\v2\x1f.helmsmancontrol.DVRStopRequestH\x00R\x0edvrStopRequest\x12N\n" +
	"\x11dvr_ready_request\x18\x16 \x01(\v2 .helmsmancontrol.DVRReadyRequestH\x00R\x0fdvrReadyRequest\x12Q\n" +
	"\x12dvr_ready_response\x18\x17 \x01(\v2!.helmsmancontrol.DVRReadyResponseH\x00R\x10dvrReadyResponse\x12A\n" +
	"\fmist_trigger\x18\x18 \x01(\v2\x1c.helmsmancontrol.MistTriggerH\x00R\vmistTrigger\x12Z\n" +
	"\x15mist_trigger_response\x18\x19 \x01(\v2$.helmsmancontrol.MistTriggerResponseH\x00R\x13mistTriggerResponse\x12>\n" +
	"\vconfig_seed\x18\x1d \x01(\v2\x1b.helmsmancontrol.ConfigSeedH\x00R\n" +
	"configSeedB\t\n" +
	"\apayload\"\x9d\x03\n" +
	"\bRegister\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x14\n" +
	"\x05roles\x18\x02 \x03(\tR\x05roles\x12\x1d\n" +
	"\n" +
	"cap_ingest\x18\x03 \x01(\bR\tcapIngest\x12\x19\n" +
	"\bcap_edge\x18\x04 \x01(\bR\acapEdge\x12\x1f\n" +
	"\vcap_storage\x18\x05 \x01(\bR\n" +
	"capStorage\x12%\n" +
	"\x0ecap_processing\x18\x06 \x01(\bR\rcapProcessing\x12#\n" +
	"\rstorage_local\x18\a \x01(\tR\fstorageLocal\x12%\n" +
	"\x0estorage_bucket\x18\b \x01(\tR\rstorageBucket\x12%\n" +
	"\x0estorage_prefix\x18\t \x01(\tR\rstoragePrefix\x12)\n" +
	"\x10enrollment_token\x18\n" +
	" \x01(\tR\x0fenrollmentToken\x12B\n" +
	"\vfingerprint\x18\v \x01(\v2 .helmsmancontrol.NodeFingerprintR\vfingerprint\"\xcc\x01\n" +
	"\x0fNodeFingerprint\x12\x1d\n" +
	"\n" +
	"local_ipv4\x18\x01 \x03(\tR\tlocalIpv4\x12\x1d\n" +
	"\n" +
	"local_ipv6\x18\x02 \x03(\tR\tlocalIpv6\x12$\n" +
	"\vmacs_sha256\x18\x03 \x01(\tH\x00R\n" +
	"macsSha256\x88\x01\x01\x12/\n" +
	"\x11machine_id_sha256\x18\x04 \x01(\tH\x01R\x0fmachineIdSha256\x88\x01\x01B\x0e\n" +
	"\f_macs_sha256B\x14\n" +
	"\x12_machine_id_sha256\"\xc2\x03\n" +
	"\x0fClipPullRequest\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\x12\x1f\n" +
	"\vstream_name\x18\x02 \x01(\tR\n" +
	"streamName\x12\"\n" +
	"\n" +
	"start_unix\x18\x03 \x01(\x03H\x00R\tstartUnix\x88\x01\x01\x12 \n" +
	"\tstop_unix\x18\x04 \x01(\x03H\x01R\bstopUnix\x88\x01\x01\x12\x1e\n" +
	"\bstart_ms\x18\x05 \x01(\x03H\x02R\astartMs\x88\x01\x01\x12\x1c\n" +
	"\astop_ms\x18\x06 \x01(\x03H\x03R\x06stopMs\x88\x01\x01\x12&\n" +
	"\fduration_sec\x18\a \x01(\x03H\x04R\vdurationSec\x88\x01\x01\x12\x16\n" +
	"\x06format\x18\b \x01(\tR\x06format\x12\x1f\n" +
	"\voutput_name\x18\t \x01(\tR\n" +
	"outputName\x12&\n" +
	"\x0fsource_base_url\x18\n" +
	" \x01(\tR\rsourceBaseUrl\x12\x1d\n" +
	"\n" +
	"request_id\x18\v \x01(\tR\trequestIdB\r\n" +
	"\v_start_unixB\f\n" +
	"\n" +
	"_stop_unixB\v\n" +
	"\t_start_msB\n" +
	"\n" +
	"\b_stop_msB\x0f\n" +
	"\r_duration_sec\"a\n" +
	"\fClipProgress\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x18\n" +
	"\apercent\x18\x02 \x01(\rR\apercent\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"\xaa\x01\n" +
	"\bClipDone\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\x12\x15\n" +
	"\x06s3_url\x18\x03 \x01(\tR\x05s3Url\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x04 \x01(\x04R\tsizeBytes\x12\x16\n" +
	"\x06status\x18\x05 \x01(\tR\x06status\x12\x14\n" +
	"\x05error\x18\x06 \x01(\tR\x05error\"<\n" +
	"\fControlError\x12\x12\n" +
	"\x04code\x18\x01 \x01(\tR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"$\n" +
	"\tHeartbeat\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\"\xfd\f\n" +
	"\vMistTrigger\x12!\n" +
	"\ftrigger_type\x18\x01 \x01(\tR\vtriggerType\x12\x17\n" +
	"\anode_id\x18\x03 \x01(\tR\x06nodeId\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\x03R\ttimestamp\x12\x1a\n" +
	"\bblocking\x18\x05 \x01(\bR\bblocking\x12\x1d\n" +
	"\n" +
	"request_id\x18\x06 \x01(\tR\trequestId\x12H\n" +
	"\fpush_rewrite\x18\n" +
	" \x01(\v2#.helmsmancontrol.PushRewriteTriggerH\x00R\vpushRewrite\x12N\n" +
	"\x0eviewer_resolve\x18\v \x01(\v2%.helmsmancontrol.ViewerResolveTriggerH\x00R\rviewerResolve\x12K\n" +
	"\rstream_source\x18\f \x01(\v2$.helmsmancontrol.StreamSourceTriggerH\x00R\fstreamSource\x12L\n" +
	"\x0epush_out_start\x18\r \x01(\v2$.helmsmancontrol.PushOutStartTriggerH\x00R\fpushOutStart\x12<\n" +
	"\bpush_end\x18\x0e \x01(\v2\x1f.helmsmancontrol.PushEndTriggerH\x00R\apushEnd\x12N\n" +
	"\x0eviewer_connect\x18\x0f \x01(\v2%.helmsmancontrol.ViewerConnectTriggerH\x00R\rviewerConnect\x12W\n" +
	"\x11viewer_disconnect\x18\x10 \x01(\v2(.helmsmancontrol.ViewerDisconnectTriggerH\x00R\x10viewerDisconnect\x12K\n" +
	"\rstream_buffer\x18\x11 \x01(\v2$.helmsmancontrol.StreamBufferTriggerH\x00R\fstreamBuffer\x12B\n" +
	"\n" +
	"stream_end\x18\x12 \x01(\v2!.helmsmancontrol.StreamEndTriggerH\x00R\tstreamEnd\x12H\n" +
	"\n" +
	"track_list\x18\x13 \x01(\v2'.helmsmancontrol.StreamTrackListTriggerH\x00R\ttrackList\x12T\n" +
	"\x10stream_bandwidth\x18\x14 \x01(\v2'.helmsmancontrol.StreamBandwidthTriggerH\x00R\x0fstreamBandwidth\x12Z\n" +
	"\x12recording_complete\x18\x15 \x01(\v2).helmsmancontrol.RecordingCompleteTriggerH\x00R\x11recordingComplete\x12`\n" +
	"\x17stream_lifecycle_update\x18\x16 \x01(\v2&.helmsmancontrol.StreamLifecycleUpdateH\x00R\x15streamLifecycleUpdate\x12`\n" +
	"\x17client_lifecycle_update\x18\x17 \x01(\v2&.helmsmancontrol.ClientLifecycleUpdateH\x00R\x15clientLifecycleUpdate\x12Z\n" +
	"\x15node_lifecycle_update\x18\x18 \x01(\v2$.helmsmancontrol.NodeLifecycleUpdateH\x00R\x13nodeLifecycleUpdate\x12T\n" +
	"\x13load_balancing_data\x18\x19 \x01(\v2\".helmsmancontrol.LoadBalancingDataH\x00R\x11loadBalancingData\x12T\n" +
	"\x13clip_lifecycle_data\x18\x1a \x01(\v2\".helmsmancontrol.ClipLifecycleDataH\x00R\x11clipLifecycleData\x12Q\n" +
	"\x12dvr_lifecycle_data\x18\x1b \x01(\v2!.helmsmancontrol.DVRLifecycleDataH\x00R\x10dvrLifecycleDataB\x11\n" +
	"\x0ftrigger_payload\"f\n" +
	"\x13MistTriggerResponse\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1a\n" +
	"\bresponse\x18\x02 \x01(\tR\bresponse\x12\x14\n" +
	"\x05abort\x18\x03 \x01(\bR\x05abort\".\n" +
	"\x0fClipHashRequest\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\"m\n" +
	"\x10ClipHashResponse\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\x12\x1b\n" +
	"\ttenant_id\x18\x02 \x01(\tR\btenantId\x12\x1f\n" +
	"\vstream_name\x18\x03 \x01(\tR\n" +
	"streamName\"\x82\x02\n" +
	"\x0fDVRStartRequest\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12#\n" +
	"\rinternal_name\x18\x02 \x01(\tR\finternalName\x12&\n" +
	"\x0fsource_base_url\x18\x03 \x01(\tR\rsourceBaseUrl\x12\x1d\n" +
	"\n" +
	"request_id\x18\x04 \x01(\tR\trequestId\x122\n" +
	"\x06config\x18\x05 \x01(\v2\x1a.helmsmancontrol.DVRConfigR\x06config\x12\x1b\n" +
	"\ttenant_id\x18\x06 \x01(\tR\btenantId\x12\x17\n" +
	"\auser_id\x18\a \x01(\tR\x06userId\"\x8f\x01\n" +
	"\tDVRConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12%\n" +
	"\x0eretention_days\x18\x02 \x01(\x05R\rretentionDays\x12\x16\n" +
	"\x06format\x18\x03 \x01(\tR\x06format\x12)\n" +
	"\x10segment_duration\x18\x04 \x01(\x05R\x0fsegmentDuration\"\xdc\x01\n" +
	"\vDVRProgress\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x19\n" +
	"\bdvr_hash\x18\x02 \x01(\tR\advrHash\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x1d\n" +
	"\n" +
	"started_at\x18\x04 \x01(\x03R\tstartedAt\x12#\n" +
	"\rsegment_count\x18\x05 \x01(\x05R\fsegmentCount\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x06 \x01(\x04R\tsizeBytes\x12\x18\n" +
	"\amessage\x18\a \x01(\tR\amessage\"\x9d\x02\n" +
	"\n" +
	"DVRStopped\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x19\n" +
	"\bdvr_hash\x18\x02 \x01(\tR\advrHash\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x14\n" +
	"\x05error\x18\x04 \x01(\tR\x05error\x12\x1d\n" +
	"\n" +
	"started_at\x18\x05 \x01(\x03R\tstartedAt\x12\x19\n" +
	"\bended_at\x18\x06 \x01(\x03R\aendedAt\x12)\n" +
	"\x10duration_seconds\x18\a \x01(\x05R\x0fdurationSeconds\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\b \x01(\x04R\tsizeBytes\x12#\n" +
	"\rmanifest_path\x18\t \x01(\tR\fmanifestPath\"\x86\x01\n" +
	"\x0eDVRStopRequest\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\tR\trequestId\x12(\n" +
	"\rinternal_name\x18\x03 \x01(\tH\x00R\finternalName\x88\x01\x01B\x10\n" +
	"\x0e_internal_name\"E\n" +
	"\x0fDVRReadyRequest\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12\x17\n" +
	"\anode_id\x18\x02 \x01(\tR\x06nodeId\"\xae\x01\n" +
	"\x10DVRReadyResponse\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12\x14\n" +
	"\x05ready\x18\x02 \x01(\bR\x05ready\x12\x1d\n" +
	"\n" +
	"source_uri\x18\x03 \x01(\tR\tsourceUri\x122\n" +
	"\x06config\x18\x04 \x01(\v2\x1a.helmsmancontrol.DVRConfigR\x06config\x12\x16\n" +
	"\x06reason\x18\x05 \x01(\tR\x06reason\"\xbe\x03\n" +
	"\x12PushRewriteTrigger\x12\x19\n" +
	"\bpush_url\x18\x01 \x01(\tR\apushUrl\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname\x12\x1f\n" +
	"\vstream_name\x18\x03 \x01(\tR\n" +
	"streamName\x12\x1f\n" +
	"\bprotocol\x18\x04 \x01(\tH\x00R\bprotocol\x88\x01\x01\x12\x1d\n" +
	"\aencoder\x18\x05 \x01(\tH\x01R\aencoder\x88\x01\x01\x12,\n" +
	"\x0fstream_settings\x18\x06 \x01(\tH\x02R\x0estreamSettings\x88\x01\x01\x12\x1c\n" +
	"\anode_id\x18\a \x01(\tH\x03R\x06nodeId\x88\x01\x01\x12\x1f\n" +
	"\blatitude\x18\b \x01(\x01H\x04R\blatitude\x88\x01\x01\x12!\n" +
	"\tlongitude\x18\t \x01(\x01H\x05R\tlongitude\x88\x01\x01\x12\x1f\n" +
	"\blocation\x18\n" +
	" \x01(\tH\x06R\blocation\x88\x01\x01B\v\n" +
	"\t_protocolB\n" +
	"\n" +
	"\b_encoderB\x12\n" +
	"\x10_stream_settingsB\n" +
	"\n" +
	"\b_node_idB\v\n" +
	"\t_latitudeB\f\n" +
	"\n" +
	"_longitudeB\v\n" +
	"\t_location\"\xaf\x03\n" +
	"\x14ViewerResolveTrigger\x12%\n" +
	"\x0edefault_stream\x18\x01 \x01(\tR\rdefaultStream\x12)\n" +
	"\x10requested_stream\x18\x02 \x01(\tR\x0frequestedStream\x12\x1f\n" +
	"\vviewer_host\x18\x03 \x01(\tR\n" +
	"viewerHost\x12\x1f\n" +
	"\voutput_type\x18\x04 \x01(\tR\n" +
	"outputType\x12\x1f\n" +
	"\vrequest_url\x18\x05 \x01(\tR\n" +
	"requestUrl\x12\x1c\n" +
	"\anode_id\x18\x06 \x01(\tH\x00R\x06nodeId\x88\x01\x01\x12&\n" +
	"\fcountry_code\x18\a \x01(\tH\x01R\vcountryCode\x88\x01\x01\x12\x17\n" +
	"\x04city\x18\b \x01(\tH\x02R\x04city\x88\x01\x01\x12\x1f\n" +
	"\blatitude\x18\t \x01(\x01H\x03R\blatitude\x88\x01\x01\x12!\n" +
	"\tlongitude\x18\n" +
	" \x01(\x01H\x04R\tlongitude\x88\x01\x01B\n" +
	"\n" +
	"\b_node_idB\x0f\n" +
	"\r_country_codeB\a\n" +
	"\x05_cityB\v\n" +
	"\t_latitudeB\f\n" +
	"\n" +
	"_longitude\"6\n" +
	"\x13StreamSourceTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\"W\n" +
	"\x13PushOutStartTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12\x1f\n" +
	"\vpush_target\x18\x02 \x01(\tR\n" +
	"pushTarget\"\xe4\x01\n" +
	"\x0ePushEndTrigger\x12\x17\n" +
	"\apush_id\x18\x01 \x01(\x03R\x06pushId\x12\x1f\n" +
	"\vstream_name\x18\x02 \x01(\tR\n" +
	"streamName\x12*\n" +
	"\x11target_uri_before\x18\x03 \x01(\tR\x0ftargetUriBefore\x12(\n" +
	"\x10target_uri_after\x18\x04 \x01(\tR\x0etargetUriAfter\x12!\n" +
	"\flog_messages\x18\x05 \x01(\tR\vlogMessages\x12\x1f\n" +
	"\vpush_status\x18\x06 \x01(\tR\n" +
	"pushStatus\"\xce\x01\n" +
	"\x14ViewerConnectTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12\x12\n" +
	"\x04host\x18\x02 \x01(\tR\x04host\x12#\n" +
	"\rconnection_id\x18\x03 \x01(\tR\fconnectionId\x12\x1c\n" +
	"\tconnector\x18\x04 \x01(\tR\tconnector\x12\x1f\n" +
	"\vrequest_url\x18\x05 \x01(\tR\n" +
	"requestUrl\x12\x1d\n" +
	"\n" +
	"session_id\x18\x06 \x01(\tR\tsessionId\"\xec\x04\n" +
	"\x17ViewerDisconnectTrigger\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x1f\n" +
	"\vstream_name\x18\x02 \x01(\tR\n" +
	"streamName\x12\x1c\n" +
	"\tconnector\x18\x03 \x01(\tR\tconnector\x12\x12\n" +
	"\x04host\x18\x04 \x01(\tR\x04host\x12\x1a\n" +
	"\bduration\x18\x05 \x01(\x03R\bduration\x12\x19\n" +
	"\bup_bytes\x18\x06 \x01(\x03R\aupBytes\x12\x1d\n" +
	"\n" +
	"down_bytes\x18\a \x01(\x03R\tdownBytes\x12\x12\n" +
	"\x04tags\x18\b \x01(\tR\x04tags\x12\x1c\n" +
	"\anode_id\x18\t \x01(\tH\x00R\x06nodeId\x88\x01\x01\x12&\n" +
	"\fcountry_code\x18\n" +
	" \x01(\tH\x01R\vcountryCode\x88\x01\x01\x12\x17\n" +
	"\x04city\x18\v \x01(\tH\x02R\x04city\x88\x01\x01\x12\x1f\n" +
	"\blatitude\x18\f \x01(\x01H\x03R\blatitude\x88\x01\x01\x12!\n" +
	"\tlongitude\x18\r \x01(\x01H\x04R\tlongitude\x88\x01\x01\x122\n" +
	"\x12session_identifier\x18\x0e \x01(\tH\x05R\x11sessionIdentifier\x88\x01\x01\x120\n" +
	"\x11seconds_connected\x18\x0f \x01(\x04H\x06R\x10secondsConnected\x88\x01\x01B\n" +
	"\n" +
	"\b_node_idB\x0f\n" +
	"\r_country_codeB\a\n" +
	"\x05_cityB\v\n" +
	"\t_latitudeB\f\n" +
	"\n" +
	"_longitudeB\x15\n" +
	"\x13_session_identifierB\x14\n" +
	"\x12_seconds_connected\"\xb5\x03\n" +
	"\x13StreamBufferTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12!\n" +
	"\fbuffer_state\x18\x02 \x01(\tR\vbufferState\x124\n" +
	"\x06tracks\x18\x03 \x03(\v2\x1c.helmsmancontrol.StreamTrackR\x06tracks\x12&\n" +
	"\fhealth_score\x18\x04 \x01(\x02H\x00R\vhealthScore\x88\x01\x01\x12\"\n" +
	"\n" +
	"has_issues\x18\x05 \x01(\bH\x01R\thasIssues\x88\x01\x01\x122\n" +
	"\x12issues_description\x18\x06 \x01(\tH\x02R\x11issuesDescription\x88\x01\x01\x12$\n" +
	"\vtrack_count\x18\a \x01(\x05H\x03R\n" +
	"trackCount\x88\x01\x01\x12&\n" +
	"\fquality_tier\x18\b \x01(\tH\x04R\vqualityTier\x88\x01\x01B\x0f\n" +
	"\r_health_scoreB\r\n" +
	"\v_has_issuesB\x15\n" +
	"\x13_issues_descriptionB\x0e\n" +
	"\f_track_countB\x0f\n" +
	"\r_quality_tier\"\xa7\x03\n" +
	"\x10StreamEndTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12.\n" +
	"\x10downloaded_bytes\x18\x02 \x01(\x03H\x00R\x0fdownloadedBytes\x88\x01\x01\x12*\n" +
	"\x0euploaded_bytes\x18\x03 \x01(\x03H\x01R\ruploadedBytes\x88\x01\x01\x12(\n" +
	"\rtotal_viewers\x18\x04 \x01(\x03H\x02R\ftotalViewers\x88\x01\x01\x12&\n" +
	"\ftotal_inputs\x18\x05 \x01(\x03H\x03R\vtotalInputs\x88\x01\x01\x12(\n" +
	"\rtotal_outputs\x18\x06 \x01(\x03H\x04R\ftotalOutputs\x88\x01\x01\x12*\n" +
	"\x0eviewer_seconds\x18\a \x01(\x03H\x05R\rviewerSeconds\x88\x01\x01B\x13\n" +
	"\x11_downloaded_bytesB\x11\n" +
	"\x0f_uploaded_bytesB\x10\n" +
	"\x0e_total_viewersB\x0f\n" +
	"\r_total_inputsB\x10\n" +
	"\x0e_total_outputsB\x11\n" +
	"\x0f_viewer_seconds\"\x94\b\n" +
	"\x16StreamTrackListTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x124\n" +
	"\x06tracks\x18\x02 \x03(\v2\x1c.helmsmancontrol.StreamTrackR\x06tracks\x12&\n" +
	"\ftotal_tracks\x18\x03 \x01(\x05H\x00R\vtotalTracks\x88\x01\x01\x12/\n" +
	"\x11video_track_count\x18\x04 \x01(\x05H\x01R\x0fvideoTrackCount\x88\x01\x01\x12/\n" +
	"\x11audio_track_count\x18\x05 \x01(\x05H\x02R\x0faudioTrackCount\x88\x01\x01\x12&\n" +
	"\fquality_tier\x18\x06 \x01(\tH\x03R\vqualityTier\x88\x01\x01\x12(\n" +
	"\rprimary_width\x18\a \x01(\x05H\x04R\fprimaryWidth\x88\x01\x01\x12*\n" +
	"\x0eprimary_height\x18\b \x01(\x05H\x05R\rprimaryHeight\x88\x01\x01\x12$\n" +
	"\vprimary_fps\x18\t \x01(\x01H\x06R\n" +
	"primaryFps\x88\x01\x01\x127\n" +
	"\x15primary_video_bitrate\x18\n" +
	" \x01(\x05H\aR\x13primaryVideoBitrate\x88\x01\x01\x123\n" +
	"\x13primary_video_codec\x18\v \x01(\tH\bR\x11primaryVideoCodec\x88\x01\x01\x127\n" +
	"\x15primary_audio_bitrate\x18\f \x01(\x05H\tR\x13primaryAudioBitrate\x88\x01\x01\x123\n" +
	"\x13primary_audio_codec\x18\r \x01(\tH\n" +
	"R\x11primaryAudioCodec\x88\x01\x01\x129\n" +
	"\x16primary_audio_channels\x18\x0e \x01(\x05H\vR\x14primaryAudioChannels\x88\x01\x01\x12>\n" +
	"\x19primary_audio_sample_rate\x18\x0f \x01(\x05H\fR\x16primaryAudioSampleRate\x88\x01\x01B\x0f\n" +
	"\r_total_tracksB\x14\n" +
	"\x12_video_track_countB\x14\n" +
	"\x12_audio_track_countB\x0f\n" +
	"\r_quality_tierB\x10\n" +
	"\x0e_primary_widthB\x11\n" +
	"\x0f_primary_heightB\x0e\n" +
	"\f_primary_fpsB\x18\n" +
	"\x16_primary_video_bitrateB\x16\n" +
	"\x14_primary_video_codecB\x18\n" +
	"\x16_primary_audio_bitrateB\x16\n" +
	"\x14_primary_audio_codecB\x19\n" +
	"\x17_primary_audio_channelsB\x1c\n" +
	"\x1a_primary_audio_sample_rate\"\xa9\x02\n" +
	"\x16StreamBandwidthTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x127\n" +
	"\x18current_bytes_per_second\x18\x02 \x01(\x03R\x15currentBytesPerSecond\x122\n" +
	"\x12threshold_exceeded\x18\x03 \x01(\bH\x00R\x11thresholdExceeded\x88\x01\x01\x12,\n" +
	"\x0fthreshold_value\x18\x04 \x01(\x04H\x01R\x0ethresholdValue\x88\x01\x01\x12\x1c\n" +
	"\anode_id\x18\x05 \x01(\tH\x02R\x06nodeId\x88\x01\x01B\x15\n" +
	"\x13_threshold_exceededB\x12\n" +
	"\x10_threshold_valueB\n" +
	"\n" +
	"\b_node_id\"\xe7\x02\n" +
	"\x18RecordingCompleteTrigger\x12\x1f\n" +
	"\vstream_name\x18\x01 \x01(\tR\n" +
	"streamName\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\x12'\n" +
	"\x0foutput_protocol\x18\x03 \x01(\tR\x0eoutputProtocol\x12#\n" +
	"\rbytes_written\x18\x04 \x01(\x03R\fbytesWritten\x12'\n" +
	"\x0fseconds_writing\x18\x05 \x01(\x03R\x0esecondsWriting\x12!\n" +
	"\ftime_started\x18\x06 \x01(\x03R\vtimeStarted\x12\x1d\n" +
	"\n" +
	"time_ended\x18\a \x01(\x03R\ttimeEnded\x12*\n" +
	"\x11media_duration_ms\x18\b \x01(\x03R\x0fmediaDurationMs\x12\x1c\n" +
	"\anode_id\x18\t \x01(\tH\x00R\x06nodeId\x88\x01\x01B\n" +
	"\n" +
	"\b_node_id\"\xc0\t\n" +
	"\x15StreamLifecycleUpdate\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12 \n" +
	"\ttenant_id\x18\x02 \x01(\tH\x00R\btenantId\x88\x01\x01\x12#\n" +
	"\rinternal_name\x18\x03 \x01(\tR\finternalName\x12\x16\n" +
	"\x06status\x18\x04 \x01(\tR\x06status\x12&\n" +
	"\fbuffer_state\x18\x05 \x01(\tH\x01R\vbufferState\x88\x01\x01\x12*\n" +
	"\x0euploaded_bytes\x18\x06 \x01(\x04H\x02R\ruploadedBytes\x88\x01\x01\x12.\n" +
	"\x10downloaded_bytes\x18\a \x01(\x04H\x03R\x0fdownloadedBytes\x88\x01\x01\x12(\n" +
	"\rtotal_viewers\x18\b \x01(\rH\x04R\ftotalViewers\x88\x01\x01\x12&\n" +
	"\ftotal_inputs\x18\t \x01(\rH\x05R\vtotalInputs\x88\x01\x01\x12*\n" +
	"\x0eviewer_seconds\x18\n" +
	" \x01(\x04H\x06R\rviewerSeconds\x88\x01\x01\x12*\n" +
	"\x0estream_details\x18\v \x01(\tH\aR\rstreamDetails\x88\x01\x01\x12\x1c\n" +
	"\ttimestamp\x18\f \x01(\x03R\ttimestamp\x12&\n" +
	"\fhealth_score\x18\r \x01(\x02H\bR\vhealthScore\x88\x01\x01\x12\"\n" +
	"\n" +
	"has_issues\x18\x0e \x01(\bH\tR\thasIssues\x88\x01\x01\x122\n" +
	"\x12issues_description\x18\x0f \x01(\tH\n" +
	"R\x11issuesDescription\x88\x01\x01\x12$\n" +
	"\vtrack_count\x18\x10 \x01(\x05H\vR\n" +
	"trackCount\x88\x01\x01\x12&\n" +
	"\fquality_tier\x18\x11 \x01(\tH\fR\vqualityTier\x88\x01\x01\x12(\n" +
	"\rprimary_width\x18\x12 \x01(\x05H\rR\fprimaryWidth\x88\x01\x01\x12*\n" +
	"\x0eprimary_height\x18\x13 \x01(\x05H\x0eR\rprimaryHeight\x88\x01\x01\x12$\n" +
	"\vprimary_fps\x18\x14 \x01(\x02H\x0fR\n" +
	"primaryFps\x88\x01\x01\x12(\n" +
	"\rprimary_codec\x18\x15 \x01(\tH\x10R\fprimaryCodec\x88\x01\x01\x12,\n" +
	"\x0fprimary_bitrate\x18\x16 \x01(\x05H\x11R\x0eprimaryBitrate\x88\x01\x01B\f\n" +
	"\n" +
	"_tenant_idB\x0f\n" +
	"\r_buffer_stateB\x11\n" +
	"\x0f_uploaded_bytesB\x13\n" +
	"\x11_downloaded_bytesB\x10\n" +
	"\x0e_total_viewersB\x0f\n" +
	"\r_total_inputsB\x11\n" +
	"\x0f_viewer_secondsB\x11\n" +
	"\x0f_stream_detailsB\x0f\n" +
	"\r_health_scoreB\r\n" +
	"\v_has_issuesB\x15\n" +
	"\x13_issues_descriptionB\x0e\n" +
	"\f_track_countB\x0f\n" +
	"\r_quality_tierB\x10\n" +
	"\x0e_primary_widthB\x11\n" +
	"\x0f_primary_heightB\x0e\n" +
	"\f_primary_fpsB\x10\n" +
	"\x0e_primary_codecB\x12\n" +
	"\x10_primary_bitrate\"\x8f\t\n" +
	"\x15ClientLifecycleUpdate\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12 \n" +
	"\ttenant_id\x18\x02 \x01(\tH\x00R\btenantId\x88\x01\x01\x12#\n" +
	"\rinternal_name\x18\x03 \x01(\tR\finternalName\x12\x16\n" +
	"\x06action\x18\x04 \x01(\tR\x06action\x12\x1a\n" +
	"\bprotocol\x18\x05 \x01(\tR\bprotocol\x12\x12\n" +
	"\x04host\x18\x06 \x01(\tR\x04host\x12\"\n" +
	"\n" +
	"session_id\x18\a \x01(\tH\x01R\tsessionId\x88\x01\x01\x12,\n" +
	"\x0fconnection_time\x18\b \x01(\x02H\x02R\x0econnectionTime\x88\x01\x01\x12\x1f\n" +
	"\bposition\x18\t \x01(\x02H\x03R\bposition\x88\x01\x01\x12-\n" +
	"\x10bandwidth_in_bps\x18\n" +
	" \x01(\x04H\x04R\x0ebandwidthInBps\x88\x01\x01\x12/\n" +
	"\x11bandwidth_out_bps\x18\v \x01(\x04H\x05R\x0fbandwidthOutBps\x88\x01\x01\x12.\n" +
	"\x10bytes_downloaded\x18\f \x01(\x04H\x06R\x0fbytesDownloaded\x88\x01\x01\x12*\n" +
	"\x0ebytes_uploaded\x18\r \x01(\x04H\aR\rbytesUploaded\x88\x01\x01\x12&\n" +
	"\fpackets_sent\x18\x0e \x01(\x04H\bR\vpacketsSent\x88\x01\x01\x12&\n" +
	"\fpackets_lost\x18\x0f \x01(\x04H\tR\vpacketsLost\x88\x01\x01\x128\n" +
	"\x15packets_retransmitted\x18\x10 \x01(\x04H\n" +
	"R\x14packetsRetransmitted\x88\x01\x01\x12\x1c\n" +
	"\ttimestamp\x18\x11 \x01(\x03R\ttimestamp\x12 \n" +
	"\tclient_ip\x18\x12 \x01(\tH\vR\bclientIp\x88\x01\x01\x12*\n" +
	"\x0eclient_country\x18\x13 \x01(\tH\fR\rclientCountry\x88\x01\x01\x12$\n" +
	"\vclient_city\x18\x14 \x01(\tH\rR\n" +
	"clientCity\x88\x01\x01\x12,\n" +
	"\x0fclient_latitude\x18\x15 \x01(\x01H\x0eR\x0eclientLatitude\x88\x01\x01\x12.\n" +
	"\x10client_longitude\x18\x16 \x01(\x01H\x0fR\x0fclientLongitude\x88\x01\x01B\f\n" +
	"\n" +
	"_tenant_idB\r\n" +
	"\v_session_idB\x12\n" +
	"\x10_connection_timeB\v\n" +
	"\t_positionB\x13\n" +
	"\x11_bandwidth_in_bpsB\x14\n" +
	"\x12_bandwidth_out_bpsB\x13\n" +
	"\x11_bytes_downloadedB\x11\n" +
	"\x0f_bytes_uploadedB\x0f\n" +
	"\r_packets_sentB\x0f\n" +
	"\r_packets_lostB\x18\n" +
	"\x16_packets_retransmittedB\f\n" +
	"\n" +
	"_client_ipB\x11\n" +
	"\x0f_client_countryB\x0e\n" +
	"\f_client_cityB\x12\n" +
	"\x10_client_latitudeB\x13\n" +
	"\x11_client_longitude\"\xbc\a\n" +
	"\x13NodeLifecycleUpdate\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1d\n" +
	"\n" +
	"cpu_tenths\x18\x02 \x01(\rR\tcpuTenths\x12\x17\n" +
	"\aram_max\x18\x03 \x01(\x04R\x06ramMax\x12\x1f\n" +
	"\vram_current\x18\x04 \x01(\x04R\n" +
	"ramCurrent\x12\x19\n" +
	"\bup_speed\x18\x05 \x01(\x04R\aupSpeed\x12\x1d\n" +
	"\n" +
	"down_speed\x18\x06 \x01(\x04R\tdownSpeed\x12\x19\n" +
	"\bbw_limit\x18\a \x01(\x04R\abwLimit\x12\x1a\n" +
	"\blatitude\x18\b \x01(\x01R\blatitude\x12\x1c\n" +
	"\tlongitude\x18\t \x01(\x01R\tlongitude\x12\x1a\n" +
	"\blocation\x18\n" +
	" \x01(\tR\blocation\x12%\n" +
	"\x0eactive_streams\x18\v \x01(\rR\ractiveStreams\x12\x19\n" +
	"\bbase_url\x18\f \x01(\tR\abaseUrl\x12\x1d\n" +
	"\n" +
	"is_healthy\x18\r \x01(\bR\tisHealthy\x12\x1d\n" +
	"\n" +
	"event_type\x18\x0e \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x0f \x01(\x03R\ttimestamp\x12E\n" +
	"\fcapabilities\x18\x10 \x01(\v2!.helmsmancontrol.NodeCapabilitiesR\fcapabilities\x126\n" +
	"\astorage\x18\x11 \x01(\v2\x1c.helmsmancontrol.StorageInfoR\astorage\x123\n" +
	"\x06limits\x18\x12 \x01(\v2\x1b.helmsmancontrol.NodeLimitsR\x06limits\x12K\n" +
	"\astreams\x18\x13 \x03(\v21.helmsmancontrol.NodeLifecycleUpdate.StreamsEntryR\astreams\x12=\n" +
	"\tartifacts\x18\x14 \x03(\v2\x1f.helmsmancontrol.StoredArtifactR\tartifacts\x12!\n" +
	"\foutputs_json\x18\x15 \x01(\tR\voutputsJson\x12 \n" +
	"\ttenant_id\x18\x16 \x01(\tH\x00R\btenantId\x88\x01\x01\x1aW\n" +
	"\fStreamsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x121\n" +
	"\x05value\x18\x02 \x01(\v2\x1b.helmsmancontrol.StreamDataR\x05value:\x028\x01B\f\n" +
	"\n" +
	"_tenant_id\"\xe4\x04\n" +
	"\x11LoadBalancingData\x12#\n" +
	"\rselected_node\x18\x01 \x01(\tR\fselectedNode\x12\x1a\n" +
	"\blatitude\x18\x02 \x01(\x01R\blatitude\x12\x1c\n" +
	"\tlongitude\x18\x03 \x01(\x01R\tlongitude\x12\x16\n" +
	"\x06status\x18\x04 \x01(\tR\x06status\x12\x18\n" +
	"\adetails\x18\x05 \x01(\tR\adetails\x12\x14\n" +
	"\x05score\x18\x06 \x01(\x04R\x05score\x12\x1b\n" +
	"\tclient_ip\x18\a \x01(\tR\bclientIp\x12%\n" +
	"\x0eclient_country\x18\b \x01(\tR\rclientCountry\x12#\n" +
	"\rnode_latitude\x18\t \x01(\x01R\fnodeLatitude\x12%\n" +
	"\x0enode_longitude\x18\n" +
	" \x01(\x01R\rnodeLongitude\x12\x1b\n" +
	"\tnode_name\x18\v \x01(\tR\bnodeName\x12-\n" +
	"\x10selected_node_id\x18\f \x01(\tH\x00R\x0eselectedNodeId\x88\x01\x01\x123\n" +
	"\x13routing_distance_km\x18\r \x01(\x01H\x01R\x11routingDistanceKm\x88\x01\x01\x12 \n" +
	"\ttenant_id\x18\x0e \x01(\tH\x02R\btenantId\x88\x01\x01\x12(\n" +
	"\rinternal_name\x18\x0f \x01(\tH\x03R\finternalName\x88\x01\x01B\x13\n" +
	"\x11_selected_node_idB\x16\n" +
	"\x14_routing_distance_kmB\f\n" +
	"\n" +
	"_tenant_idB\x10\n" +
	"\x0e_internal_name\"\x96\x06\n" +
	"\x11ClipLifecycleData\x12>\n" +
	"\x05stage\x18\x01 \x01(\x0e2(.helmsmancontrol.ClipLifecycleData.StageR\x05stage\x12\x1b\n" +
	"\tclip_hash\x18\x02 \x01(\tR\bclipHash\x12\"\n" +
	"\n" +
	"request_id\x18\x03 \x01(\tH\x00R\trequestId\x88\x01\x01\x12.\n" +
	"\x10progress_percent\x18\x04 \x01(\rH\x01R\x0fprogressPercent\x88\x01\x01\x12 \n" +
	"\tfile_path\x18\x05 \x01(\tH\x02R\bfilePath\x88\x01\x01\x12\x1a\n" +
	"\x06s3_url\x18\x06 \x01(\tH\x03R\x05s3Url\x88\x01\x01\x12\"\n" +
	"\n" +
	"size_bytes\x18\a \x01(\x04H\x04R\tsizeBytes\x88\x01\x01\x12\x19\n" +
	"\x05error\x18\b \x01(\tH\x05R\x05error\x88\x01\x01\x12\"\n" +
	"\n" +
	"started_at\x18\t \x01(\x03H\x06R\tstartedAt\x88\x01\x01\x12&\n" +
	"\fcompleted_at\x18\n" +
	" \x01(\x03H\aR\vcompletedAt\x88\x01\x01\x12\x1c\n" +
	"\anode_id\x18\v \x01(\tH\bR\x06nodeId\x88\x01\x01\x12 \n" +
	"\ttenant_id\x18\f \x01(\tH\tR\btenantId\x88\x01\x01\x12(\n" +
	"\rinternal_name\x18\r \x01(\tH\n" +
	"R\finternalName\x88\x01\x01\"{\n" +
	"\x05Stage\x12\x15\n" +
	"\x11STAGE_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fSTAGE_REQUESTED\x10\x01\x12\x10\n" +
	"\fSTAGE_QUEUED\x10\x02\x12\x12\n" +
	"\x0eSTAGE_PROGRESS\x10\x03\x12\x0e\n" +
	"\n" +
	"STAGE_DONE\x10\x04\x12\x10\n" +
	"\fSTAGE_FAILED\x10\x05B\r\n" +
	"\v_request_idB\x13\n" +
	"\x11_progress_percentB\f\n" +
	"\n" +
	"_file_pathB\t\n" +
	"\a_s3_urlB\r\n" +
	"\v_size_bytesB\b\n" +
	"\x06_errorB\r\n" +
	"\v_started_atB\x0f\n" +
	"\r_completed_atB\n" +
	"\n" +
	"\b_node_idB\f\n" +
	"\n" +
	"_tenant_idB\x10\n" +
	"\x0e_internal_name\"\xa8\x05\n" +
	"\x10DVRLifecycleData\x12@\n" +
	"\x06status\x18\x01 \x01(\x0e2(.helmsmancontrol.DVRLifecycleData.StatusR\x06status\x12\x19\n" +
	"\bdvr_hash\x18\x02 \x01(\tR\advrHash\x12(\n" +
	"\rmanifest_path\x18\x03 \x01(\tH\x00R\fmanifestPath\x88\x01\x01\x12\"\n" +
	"\n" +
	"started_at\x18\x04 \x01(\x03H\x01R\tstartedAt\x88\x01\x01\x12\x1e\n" +
	"\bended_at\x18\x05 \x01(\x03H\x02R\aendedAt\x88\x01\x01\x12\"\n" +
	"\n" +
	"size_bytes\x18\x06 \x01(\x04H\x03R\tsizeBytes\x88\x01\x01\x12(\n" +
	"\rsegment_count\x18\a \x01(\x05H\x04R\fsegmentCount\x88\x01\x01\x12\x19\n" +
	"\x05error\x18\b \x01(\tH\x05R\x05error\x88\x01\x01\x12\x1c\n" +
	"\anode_id\x18\t \x01(\tH\x06R\x06nodeId\x88\x01\x01\x12 \n" +
	"\ttenant_id\x18\n" +
	" \x01(\tH\aR\btenantId\x88\x01\x01\x12(\n" +
	"\rinternal_name\x18\v \x01(\tH\bR\finternalName\x88\x01\x01\"q\n" +
	"\x06Status\x12\x16\n" +
	"\x12STATUS_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eSTATUS_STARTED\x10\x01\x12\x14\n" +
	"\x10STATUS_RECORDING\x10\x02\x12\x12\n" +
	"\x0eSTATUS_STOPPED\x10\x03\x12\x11\n" +
	"\rSTATUS_FAILED\x10\x04B\x10\n" +
	"\x0e_manifest_pathB\r\n" +
	"\v_started_atB\v\n" +
	"\t_ended_atB\r\n" +
	"\v_size_bytesB\x10\n" +
	"\x0e_segment_countB\b\n" +
	"\x06_errorB\n" +
	"\n" +
	"\b_node_idB\f\n" +
	"\n" +
	"_tenant_idB\x10\n" +
	"\x0e_internal_name\"\x8e\x01\n" +
	"\x10NodeCapabilities\x12\x16\n" +
	"\x06ingest\x18\x01 \x01(\bR\x06ingest\x12\x12\n" +
	"\x04edge\x18\x02 \x01(\bR\x04edge\x12\x18\n" +
	"\astorage\x18\x03 \x01(\bR\astorage\x12\x1e\n" +
	"\n" +
	"processing\x18\x04 \x01(\bR\n" +
	"processing\x12\x14\n" +
	"\x05roles\x18\x05 \x03(\tR\x05roles\"f\n" +
	"\vStorageInfo\x12\x1d\n" +
	"\n" +
	"local_path\x18\x01 \x01(\tR\tlocalPath\x12\x1b\n" +
	"\ts3_bucket\x18\x02 \x01(\tR\bs3Bucket\x12\x1b\n" +
	"\ts3_prefix\x18\x03 \x01(\tR\bs3Prefix\"\x97\x01\n" +
	"\n" +
	"NodeLimits\x12%\n" +
	"\x0emax_transcodes\x18\x01 \x01(\x05R\rmaxTranscodes\x124\n" +
	"\x16storage_capacity_bytes\x18\x02 \x01(\x04R\x14storageCapacityBytes\x12,\n" +
	"\x12storage_used_bytes\x18\x03 \x01(\x04R\x10storageUsedBytes\"\x92\x01\n" +
	"\n" +
	"StreamData\x12\x14\n" +
	"\x05total\x18\x01 \x01(\x04R\x05total\x12\x16\n" +
	"\x06inputs\x18\x02 \x01(\rR\x06inputs\x12\x19\n" +
	"\bbytes_up\x18\x03 \x01(\x04R\abytesUp\x12\x1d\n" +
	"\n" +
	"bytes_down\x18\x04 \x01(\x04R\tbytesDown\x12\x1c\n" +
	"\tbandwidth\x18\x05 \x01(\rR\tbandwidth\"\x94\b\n" +
	"\vStreamTrack\x12\x1d\n" +
	"\n" +
	"track_name\x18\x01 \x01(\tR\ttrackName\x12\x1d\n" +
	"\n" +
	"track_type\x18\x02 \x01(\tR\ttrackType\x12\x14\n" +
	"\x05codec\x18\x03 \x01(\tR\x05codec\x12&\n" +
	"\fbitrate_kbps\x18\x04 \x01(\x05H\x00R\vbitrateKbps\x88\x01\x01\x12$\n" +
	"\vbitrate_bps\x18\x05 \x01(\x03H\x01R\n" +
	"bitrateBps\x88\x01\x01\x12\x1b\n" +
	"\x06buffer\x18\x06 \x01(\x05H\x02R\x06buffer\x88\x01\x01\x12\x1b\n" +
	"\x06jitter\x18\a \x01(\x05H\x03R\x06jitter\x88\x01\x01\x12\x19\n" +
	"\x05width\x18\b \x01(\x05H\x04R\x05width\x88\x01\x01\x12\x1b\n" +
	"\x06height\x18\t \x01(\x05H\x05R\x06height\x88\x01\x01\x12\x15\n" +
	"\x03fps\x18\n" +
	" \x01(\x01H\x06R\x03fps\x88\x01\x01\x12#\n" +
	"\n" +
	"resolution\x18\v \x01(\tH\aR\n" +
	"resolution\x88\x01\x01\x12$\n" +
	"\vhas_bframes\x18\f \x01(\bH\bR\n" +
	"hasBframes\x88\x01\x01\x12\x1f\n" +
	"\bchannels\x18\r \x01(\x05H\tR\bchannels\x88\x01\x01\x12$\n" +
	"\vsample_rate\x18\x0e \x01(\x05H\n" +
	"R\n" +
	"sampleRate\x88\x01\x01\x12\"\n" +
	"\n" +
	"frames_max\x18\x0f \x01(\x05H\vR\tframesMax\x88\x01\x01\x12\"\n" +
	"\n" +
	"frames_min\x18\x10 \x01(\x05H\fR\tframesMin\x88\x01\x01\x12%\n" +
	"\fframe_ms_max\x18\x11 \x01(\x01H\rR\n" +
	"frameMsMax\x88\x01\x01\x12%\n" +
	"\fframe_ms_min\x18\x12 \x01(\x01H\x0eR\n" +
	"frameMsMin\x88\x01\x01\x12+\n" +
	"\x0fframe_jitter_ms\x18\x13 \x01(\x01H\x0fR\rframeJitterMs\x88\x01\x01\x127\n" +
	"\x15keyframe_stability_ms\x18\x14 \x01(\x01H\x10R\x13keyframeStabilityMs\x88\x01\x01\x125\n" +
	"\x14keyframe_interval_ms\x18\x15 \x01(\x01H\x11R\x12keyframeIntervalMs\x88\x01\x01B\x0f\n" +
	"\r_bitrate_kbpsB\x0e\n" +
	"\f_bitrate_bpsB\t\n" +
	"\a_bufferB\t\n" +
	"\a_jitterB\b\n" +
	"\x06_widthB\t\n" +
	"\a_heightB\x06\n" +
	"\x04_fpsB\r\n" +
	"\v_resolutionB\x0e\n" +
	"\f_has_bframesB\v\n" +
	"\t_channelsB\x0e\n" +
	"\f_sample_rateB\r\n" +
	"\v_frames_maxB\r\n" +
	"\v_frames_minB\x0f\n" +
	"\r_frame_ms_maxB\x0f\n" +
	"\r_frame_ms_minB\x12\n" +
	"\x10_frame_jitter_msB\x18\n" +
	"\x16_keyframe_stability_msB\x17\n" +
	"\x15_keyframe_interval_ms\"\xd8\x01\n" +
	"\x0eStoredArtifact\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\x12\x1f\n" +
	"\vstream_name\x18\x02 \x01(\tR\n" +
	"streamName\x12\x1b\n" +
	"\tfile_path\x18\x03 \x01(\tR\bfilePath\x12\x15\n" +
	"\x06s3_url\x18\x04 \x01(\tR\x05s3Url\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x05 \x01(\x04R\tsizeBytes\x12\x1d\n" +
	"\n" +
	"created_at\x18\x06 \x01(\x03R\tcreatedAt\x12\x16\n" +
	"\x06format\x18\a \x01(\tR\x06format\"\x8a\x03\n" +
	"\rStreamProcess\x12\x18\n" +
	"\aprocess\x18\x01 \x01(\tR\aprocess\x12\x14\n" +
	"\x05codec\x18\x02 \x01(\tR\x05codec\x12\x18\n" +
	"\abitrate\x18\x03 \x01(\x03R\abitrate\x12!\n" +
	"\ftrack_select\x18\x04 \x01(\tR\vtrackSelect\x12#\n" +
	"\rtrack_inhibit\x18\x05 \x01(\tR\ftrackInhibit\x12!\n" +
	"\frestart_type\x18\x06 \x01(\tR\vrestartType\x12(\n" +
	"\x0finconsequential\x18\a \x01(\bR\x0finconsequential\x12\x1f\n" +
	"\vexit_unmask\x18\b \x01(\bR\n" +
	"exitUnmask\x12?\n" +
	"\x05extra\x18d \x03(\v2).helmsmancontrol.StreamProcess.ExtraEntryR\x05extra\x1a8\n" +
	"\n" +
	"ExtraEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb2\x01\n" +
	"\tStreamDef\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1a\n" +
	"\brealtime\x18\x02 \x01(\bR\brealtime\x12#\n" +
	"\rstop_sessions\x18\x03 \x01(\bR\fstopSessions\x12\x12\n" +
	"\x04tags\x18\x04 \x03(\tR\x04tags\x12<\n" +
	"\tprocesses\x18\x05 \x03(\v2\x1e.helmsmancontrol.StreamProcessR\tprocesses\"x\n" +
	"\x0eStreamTemplate\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12,\n" +
	"\x03def\x18\x02 \x01(\v2\x1a.helmsmancontrol.StreamDefR\x03def\x12\x14\n" +
	"\x05roles\x18\x03 \x03(\tR\x05roles\x12\x12\n" +
	"\x04caps\x18\x04 \x03(\tR\x04caps\"\xe0\x01\n" +
	"\n" +
	"ConfigSeed\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1a\n" +
	"\blatitude\x18\x02 \x01(\x01R\blatitude\x12\x1c\n" +
	"\tlongitude\x18\x03 \x01(\x01R\tlongitude\x12#\n" +
	"\rlocation_name\x18\x04 \x01(\tR\flocationName\x12\x1b\n" +
	"\ttenant_id\x18\x05 \x01(\tR\btenantId\x12=\n" +
	"\ttemplates\x18\n" +
	" \x03(\v2\x1f.helmsmancontrol.StreamTemplateR\ttemplates2\xba\x01\n" +
	"\x0fHelmsmanControl\x12O\n" +
	"\aConnect\x12\x1f.helmsmancontrol.ControlMessage\x1a\x1f.helmsmancontrol.ControlMessage(\x010\x01\x12V\n" +
	"\x0fResolveClipHash\x12 .helmsmancontrol.ClipHashRequest\x1a!.helmsmancontrol.ClipHashResponse2S\n" +
	"\x0eDecklogService\x12A\n" +
	"\tSendEvent\x12\x1c.helmsmancontrol.MistTrigger\x1a\x16.google.protobuf.EmptyB\x16Z\x14frameworks/pkg/protob\x06proto3"

var (
	file_ipc_proto_rawDescOnce sync.Once
	file_ipc_proto_rawDescData []byte
)

func file_ipc_proto_rawDescGZIP() []byte {
	file_ipc_proto_rawDescOnce.Do(func() {
		file_ipc_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ipc_proto_rawDesc), len(file_ipc_proto_rawDesc)))
	})
	return file_ipc_proto_rawDescData
}

var file_ipc_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_ipc_proto_msgTypes = make([]protoimpl.MessageInfo, 49)
var file_ipc_proto_goTypes = []any{
	(ClipLifecycleData_Stage)(0),     // 0: helmsmancontrol.ClipLifecycleData.Stage
	(DVRLifecycleData_Status)(0),     // 1: helmsmancontrol.DVRLifecycleData.Status
	(*ControlMessage)(nil),           // 2: helmsmancontrol.ControlMessage
	(*Register)(nil),                 // 3: helmsmancontrol.Register
	(*NodeFingerprint)(nil),          // 4: helmsmancontrol.NodeFingerprint
	(*ClipPullRequest)(nil),          // 5: helmsmancontrol.ClipPullRequest
	(*ClipProgress)(nil),             // 6: helmsmancontrol.ClipProgress
	(*ClipDone)(nil),                 // 7: helmsmancontrol.ClipDone
	(*ControlError)(nil),             // 8: helmsmancontrol.ControlError
	(*Heartbeat)(nil),                // 9: helmsmancontrol.Heartbeat
	(*MistTrigger)(nil),              // 10: helmsmancontrol.MistTrigger
	(*MistTriggerResponse)(nil),      // 11: helmsmancontrol.MistTriggerResponse
	(*ClipHashRequest)(nil),          // 12: helmsmancontrol.ClipHashRequest
	(*ClipHashResponse)(nil),         // 13: helmsmancontrol.ClipHashResponse
	(*DVRStartRequest)(nil),          // 14: helmsmancontrol.DVRStartRequest
	(*DVRConfig)(nil),                // 15: helmsmancontrol.DVRConfig
	(*DVRProgress)(nil),              // 16: helmsmancontrol.DVRProgress
	(*DVRStopped)(nil),               // 17: helmsmancontrol.DVRStopped
	(*DVRStopRequest)(nil),           // 18: helmsmancontrol.DVRStopRequest
	(*DVRReadyRequest)(nil),          // 19: helmsmancontrol.DVRReadyRequest
	(*DVRReadyResponse)(nil),         // 20: helmsmancontrol.DVRReadyResponse
	(*PushRewriteTrigger)(nil),       // 21: helmsmancontrol.PushRewriteTrigger
	(*ViewerResolveTrigger)(nil),     // 22: helmsmancontrol.ViewerResolveTrigger
	(*StreamSourceTrigger)(nil),      // 23: helmsmancontrol.StreamSourceTrigger
	(*PushOutStartTrigger)(nil),      // 24: helmsmancontrol.PushOutStartTrigger
	(*PushEndTrigger)(nil),           // 25: helmsmancontrol.PushEndTrigger
	(*ViewerConnectTrigger)(nil),     // 26: helmsmancontrol.ViewerConnectTrigger
	(*ViewerDisconnectTrigger)(nil),  // 27: helmsmancontrol.ViewerDisconnectTrigger
	(*StreamBufferTrigger)(nil),      // 28: helmsmancontrol.StreamBufferTrigger
	(*StreamEndTrigger)(nil),         // 29: helmsmancontrol.StreamEndTrigger
	(*StreamTrackListTrigger)(nil),   // 30: helmsmancontrol.StreamTrackListTrigger
	(*StreamBandwidthTrigger)(nil),   // 31: helmsmancontrol.StreamBandwidthTrigger
	(*RecordingCompleteTrigger)(nil), // 32: helmsmancontrol.RecordingCompleteTrigger
	(*StreamLifecycleUpdate)(nil),    // 33: helmsmancontrol.StreamLifecycleUpdate
	(*ClientLifecycleUpdate)(nil),    // 34: helmsmancontrol.ClientLifecycleUpdate
	(*NodeLifecycleUpdate)(nil),      // 35: helmsmancontrol.NodeLifecycleUpdate
	(*LoadBalancingData)(nil),        // 36: helmsmancontrol.LoadBalancingData
	(*ClipLifecycleData)(nil),        // 37: helmsmancontrol.ClipLifecycleData
	(*DVRLifecycleData)(nil),         // 38: helmsmancontrol.DVRLifecycleData
	(*NodeCapabilities)(nil),         // 39: helmsmancontrol.NodeCapabilities
	(*StorageInfo)(nil),              // 40: helmsmancontrol.StorageInfo
	(*NodeLimits)(nil),               // 41: helmsmancontrol.NodeLimits
	(*StreamData)(nil),               // 42: helmsmancontrol.StreamData
	(*StreamTrack)(nil),              // 43: helmsmancontrol.StreamTrack
	(*StoredArtifact)(nil),           // 44: helmsmancontrol.StoredArtifact
	(*StreamProcess)(nil),            // 45: helmsmancontrol.StreamProcess
	(*StreamDef)(nil),                // 46: helmsmancontrol.StreamDef
	(*StreamTemplate)(nil),           // 47: helmsmancontrol.StreamTemplate
	(*ConfigSeed)(nil),               // 48: helmsmancontrol.ConfigSeed
	nil,                              // 49: helmsmancontrol.NodeLifecycleUpdate.StreamsEntry
	nil,                              // 50: helmsmancontrol.StreamProcess.ExtraEntry
	(*timestamppb.Timestamp)(nil),    // 51: google.protobuf.Timestamp
	(*emptypb.Empty)(nil),            // 52: google.protobuf.Empty
}
var file_ipc_proto_depIdxs = []int32{
	51, // 0: helmsmancontrol.ControlMessage.sent_at:type_name -> google.protobuf.Timestamp
	3,  // 1: helmsmancontrol.ControlMessage.register:type_name -> helmsmancontrol.Register
	5,  // 2: helmsmancontrol.ControlMessage.clip_pull_request:type_name -> helmsmancontrol.ClipPullRequest
	6,  // 3: helmsmancontrol.ControlMessage.clip_progress:type_name -> helmsmancontrol.ClipProgress
	7,  // 4: helmsmancontrol.ControlMessage.clip_done:type_name -> helmsmancontrol.ClipDone
	8,  // 5: helmsmancontrol.ControlMessage.error:type_name -> helmsmancontrol.ControlError
	9,  // 6: helmsmancontrol.ControlMessage.heartbeat:type_name -> helmsmancontrol.Heartbeat
	14, // 7: helmsmancontrol.ControlMessage.dvr_start_request:type_name -> helmsmancontrol.DVRStartRequest
	16, // 8: helmsmancontrol.ControlMessage.dvr_progress:type_name -> helmsmancontrol.DVRProgress
	17, // 9: helmsmancontrol.ControlMessage.dvr_stopped:type_name -> helmsmancontrol.DVRStopped
	18, // 10: helmsmancontrol.ControlMessage.dvr_stop_request:type_name -> helmsmancontrol.DVRStopRequest
	19, // 11: helmsmancontrol.ControlMessage.dvr_ready_request:type_name -> helmsmancontrol.DVRReadyRequest
	20, // 12: helmsmancontrol.ControlMessage.dvr_ready_response:type_name -> helmsmancontrol.DVRReadyResponse
	10, // 13: helmsmancontrol.ControlMessage.mist_trigger:type_name -> helmsmancontrol.MistTrigger
	11, // 14: helmsmancontrol.ControlMessage.mist_trigger_response:type_name -> helmsmancontrol.MistTriggerResponse
	48, // 15: helmsmancontrol.ControlMessage.config_seed:type_name -> helmsmancontrol.ConfigSeed
	4,  // 16: helmsmancontrol.Register.fingerprint:type_name -> helmsmancontrol.NodeFingerprint
	21, // 17: helmsmancontrol.MistTrigger.push_rewrite:type_name -> helmsmancontrol.PushRewriteTrigger
	22, // 18: helmsmancontrol.MistTrigger.viewer_resolve:type_name -> helmsmancontrol.ViewerResolveTrigger
	23, // 19: helmsmancontrol.MistTrigger.stream_source:type_name -> helmsmancontrol.StreamSourceTrigger
	24, // 20: helmsmancontrol.MistTrigger.push_out_start:type_name -> helmsmancontrol.PushOutStartTrigger
	25, // 21: helmsmancontrol.MistTrigger.push_end:type_name -> helmsmancontrol.PushEndTrigger
	26, // 22: helmsmancontrol.MistTrigger.viewer_connect:type_name -> helmsmancontrol.ViewerConnectTrigger
	27, // 23: helmsmancontrol.MistTrigger.viewer_disconnect:type_name -> helmsmancontrol.ViewerDisconnectTrigger
	28, // 24: helmsmancontrol.MistTrigger.stream_buffer:type_name -> helmsmancontrol.StreamBufferTrigger
	29, // 25: helmsmancontrol.MistTrigger.stream_end:type_name -> helmsmancontrol.StreamEndTrigger
	30, // 26: helmsmancontrol.MistTrigger.track_list:type_name -> helmsmancontrol.StreamTrackListTrigger
	31, // 27: helmsmancontrol.MistTrigger.stream_bandwidth:type_name -> helmsmancontrol.StreamBandwidthTrigger
	32, // 28: helmsmancontrol.MistTrigger.recording_complete:type_name -> helmsmancontrol.RecordingCompleteTrigger
	33, // 29: helmsmancontrol.MistTrigger.stream_lifecycle_update:type_name -> helmsmancontrol.StreamLifecycleUpdate
	34, // 30: helmsmancontrol.MistTrigger.client_lifecycle_update:type_name -> helmsmancontrol.ClientLifecycleUpdate
	35, // 31: helmsmancontrol.MistTrigger.node_lifecycle_update:type_name -> helmsmancontrol.NodeLifecycleUpdate
	36, // 32: helmsmancontrol.MistTrigger.load_balancing_data:type_name -> helmsmancontrol.LoadBalancingData
	37, // 33: helmsmancontrol.MistTrigger.clip_lifecycle_data:type_name -> helmsmancontrol.ClipLifecycleData
	38, // 34: helmsmancontrol.MistTrigger.dvr_lifecycle_data:type_name -> helmsmancontrol.DVRLifecycleData
	15, // 35: helmsmancontrol.DVRStartRequest.config:type_name -> helmsmancontrol.DVRConfig
	15, // 36: helmsmancontrol.DVRReadyResponse.config:type_name -> helmsmancontrol.DVRConfig
	43, // 37: helmsmancontrol.StreamBufferTrigger.tracks:type_name -> helmsmancontrol.StreamTrack
	43, // 38: helmsmancontrol.StreamTrackListTrigger.tracks:type_name -> helmsmancontrol.StreamTrack
	39, // 39: helmsmancontrol.NodeLifecycleUpdate.capabilities:type_name -> helmsmancontrol.NodeCapabilities
	40, // 40: helmsmancontrol.NodeLifecycleUpdate.storage:type_name -> helmsmancontrol.StorageInfo
	41, // 41: helmsmancontrol.NodeLifecycleUpdate.limits:type_name -> helmsmancontrol.NodeLimits
	49, // 42: helmsmancontrol.NodeLifecycleUpdate.streams:type_name -> helmsmancontrol.NodeLifecycleUpdate.StreamsEntry
	44, // 43: helmsmancontrol.NodeLifecycleUpdate.artifacts:type_name -> helmsmancontrol.StoredArtifact
	0,  // 44: helmsmancontrol.ClipLifecycleData.stage:type_name -> helmsmancontrol.ClipLifecycleData.Stage
	1,  // 45: helmsmancontrol.DVRLifecycleData.status:type_name -> helmsmancontrol.DVRLifecycleData.Status
	50, // 46: helmsmancontrol.StreamProcess.extra:type_name -> helmsmancontrol.StreamProcess.ExtraEntry
	45, // 47: helmsmancontrol.StreamDef.processes:type_name -> helmsmancontrol.StreamProcess
	46, // 48: helmsmancontrol.StreamTemplate.def:type_name -> helmsmancontrol.StreamDef
	47, // 49: helmsmancontrol.ConfigSeed.templates:type_name -> helmsmancontrol.StreamTemplate
	42, // 50: helmsmancontrol.NodeLifecycleUpdate.StreamsEntry.value:type_name -> helmsmancontrol.StreamData
	2,  // 51: helmsmancontrol.HelmsmanControl.Connect:input_type -> helmsmancontrol.ControlMessage
	12, // 52: helmsmancontrol.HelmsmanControl.ResolveClipHash:input_type -> helmsmancontrol.ClipHashRequest
	10, // 53: helmsmancontrol.DecklogService.SendEvent:input_type -> helmsmancontrol.MistTrigger
	2,  // 54: helmsmancontrol.HelmsmanControl.Connect:output_type -> helmsmancontrol.ControlMessage
	13, // 55: helmsmancontrol.HelmsmanControl.ResolveClipHash:output_type -> helmsmancontrol.ClipHashResponse
	52, // 56: helmsmancontrol.DecklogService.SendEvent:output_type -> google.protobuf.Empty
	54, // [54:57] is the sub-list for method output_type
	51, // [51:54] is the sub-list for method input_type
	51, // [51:51] is the sub-list for extension type_name
	51, // [51:51] is the sub-list for extension extendee
	0,  // [0:51] is the sub-list for field type_name
}

func init() { file_ipc_proto_init() }
func file_ipc_proto_init() {
	if File_ipc_proto != nil {
		return
	}
	file_ipc_proto_msgTypes[0].OneofWrappers = []any{
		(*ControlMessage_Register)(nil),
		(*ControlMessage_ClipPullRequest)(nil),
		(*ControlMessage_ClipProgress)(nil),
		(*ControlMessage_ClipDone)(nil),
		(*ControlMessage_Error)(nil),
		(*ControlMessage_Heartbeat)(nil),
		(*ControlMessage_DvrStartRequest)(nil),
		(*ControlMessage_DvrProgress)(nil),
		(*ControlMessage_DvrStopped)(nil),
		(*ControlMessage_DvrStopRequest)(nil),
		(*ControlMessage_DvrReadyRequest)(nil),
		(*ControlMessage_DvrReadyResponse)(nil),
		(*ControlMessage_MistTrigger)(nil),
		(*ControlMessage_MistTriggerResponse)(nil),
		(*ControlMessage_ConfigSeed)(nil),
	}
	file_ipc_proto_msgTypes[2].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[3].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[8].OneofWrappers = []any{
		(*MistTrigger_PushRewrite)(nil),
		(*MistTrigger_ViewerResolve)(nil),
		(*MistTrigger_StreamSource)(nil),
		(*MistTrigger_PushOutStart)(nil),
		(*MistTrigger_PushEnd)(nil),
		(*MistTrigger_ViewerConnect)(nil),
		(*MistTrigger_ViewerDisconnect)(nil),
		(*MistTrigger_StreamBuffer)(nil),
		(*MistTrigger_StreamEnd)(nil),
		(*MistTrigger_TrackList)(nil),
		(*MistTrigger_StreamBandwidth)(nil),
		(*MistTrigger_RecordingComplete)(nil),
		(*MistTrigger_StreamLifecycleUpdate)(nil),
		(*MistTrigger_ClientLifecycleUpdate)(nil),
		(*MistTrigger_NodeLifecycleUpdate)(nil),
		(*MistTrigger_LoadBalancingData)(nil),
		(*MistTrigger_ClipLifecycleData)(nil),
		(*MistTrigger_DvrLifecycleData)(nil),
	}
	file_ipc_proto_msgTypes[16].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[19].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[20].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[25].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[26].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[27].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[28].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[29].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[30].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[31].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[32].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[33].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[34].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[35].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[36].OneofWrappers = []any{}
	file_ipc_proto_msgTypes[41].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_ipc_proto_rawDesc), len(file_ipc_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   49,
			NumExtensions: 0,
			NumServices:   2,
		},
		GoTypes:           file_ipc_proto_goTypes,
		DependencyIndexes: file_ipc_proto_depIdxs,
		EnumInfos:         file_ipc_proto_enumTypes,
		MessageInfos:      file_ipc_proto_msgTypes,
	}.Build()
	File_ipc_proto = out.File
	file_ipc_proto_goTypes = nil
	file_ipc_proto_depIdxs = nil
}
