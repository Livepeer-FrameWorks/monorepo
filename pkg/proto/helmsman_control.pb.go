// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: helmsman_control.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ControlMessage struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	RequestId string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"` // Correlates requests/responses
	SentAt    *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=sent_at,json=sentAt,proto3" json:"sent_at,omitempty"`
	// Types that are valid to be assigned to Payload:
	//
	//	*ControlMessage_Register
	//	*ControlMessage_NodeUpdate
	//	*ControlMessage_ClipPullRequest
	//	*ControlMessage_ClipProgress
	//	*ControlMessage_ClipDone
	//	*ControlMessage_Error
	//	*ControlMessage_Heartbeat
	//	*ControlMessage_StreamHealthUpdate
	//	*ControlMessage_DvrStartRequest
	//	*ControlMessage_DvrProgress
	//	*ControlMessage_DvrStopped
	//	*ControlMessage_DvrStopRequest
	//	*ControlMessage_DvrReadyRequest
	//	*ControlMessage_DvrReadyResponse
	Payload       isControlMessage_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControlMessage) Reset() {
	*x = ControlMessage{}
	mi := &file_helmsman_control_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControlMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControlMessage) ProtoMessage() {}

func (x *ControlMessage) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControlMessage.ProtoReflect.Descriptor instead.
func (*ControlMessage) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{0}
}

func (x *ControlMessage) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ControlMessage) GetSentAt() *timestamppb.Timestamp {
	if x != nil {
		return x.SentAt
	}
	return nil
}

func (x *ControlMessage) GetPayload() isControlMessage_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ControlMessage) GetRegister() *Register {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_Register); ok {
			return x.Register
		}
	}
	return nil
}

func (x *ControlMessage) GetNodeUpdate() *NodeUpdate {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_NodeUpdate); ok {
			return x.NodeUpdate
		}
	}
	return nil
}

func (x *ControlMessage) GetClipPullRequest() *ClipPullRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ClipPullRequest); ok {
			return x.ClipPullRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetClipProgress() *ClipProgress {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ClipProgress); ok {
			return x.ClipProgress
		}
	}
	return nil
}

func (x *ControlMessage) GetClipDone() *ClipDone {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_ClipDone); ok {
			return x.ClipDone
		}
	}
	return nil
}

func (x *ControlMessage) GetError() *ControlError {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_Error); ok {
			return x.Error
		}
	}
	return nil
}

func (x *ControlMessage) GetHeartbeat() *Heartbeat {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_Heartbeat); ok {
			return x.Heartbeat
		}
	}
	return nil
}

func (x *ControlMessage) GetStreamHealthUpdate() *StreamHealthUpdate {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_StreamHealthUpdate); ok {
			return x.StreamHealthUpdate
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrStartRequest() *DVRStartRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrStartRequest); ok {
			return x.DvrStartRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrProgress() *DVRProgress {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrProgress); ok {
			return x.DvrProgress
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrStopped() *DVRStopped {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrStopped); ok {
			return x.DvrStopped
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrStopRequest() *DVRStopRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrStopRequest); ok {
			return x.DvrStopRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrReadyRequest() *DVRReadyRequest {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrReadyRequest); ok {
			return x.DvrReadyRequest
		}
	}
	return nil
}

func (x *ControlMessage) GetDvrReadyResponse() *DVRReadyResponse {
	if x != nil {
		if x, ok := x.Payload.(*ControlMessage_DvrReadyResponse); ok {
			return x.DvrReadyResponse
		}
	}
	return nil
}

type isControlMessage_Payload interface {
	isControlMessage_Payload()
}

type ControlMessage_Register struct {
	Register *Register `protobuf:"bytes,10,opt,name=register,proto3,oneof"`
}

type ControlMessage_NodeUpdate struct {
	NodeUpdate *NodeUpdate `protobuf:"bytes,11,opt,name=node_update,json=nodeUpdate,proto3,oneof"`
}

type ControlMessage_ClipPullRequest struct {
	ClipPullRequest *ClipPullRequest `protobuf:"bytes,12,opt,name=clip_pull_request,json=clipPullRequest,proto3,oneof"`
}

type ControlMessage_ClipProgress struct {
	ClipProgress *ClipProgress `protobuf:"bytes,13,opt,name=clip_progress,json=clipProgress,proto3,oneof"`
}

type ControlMessage_ClipDone struct {
	ClipDone *ClipDone `protobuf:"bytes,14,opt,name=clip_done,json=clipDone,proto3,oneof"`
}

type ControlMessage_Error struct {
	Error *ControlError `protobuf:"bytes,15,opt,name=error,proto3,oneof"`
}

type ControlMessage_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,16,opt,name=heartbeat,proto3,oneof"`
}

type ControlMessage_StreamHealthUpdate struct {
	StreamHealthUpdate *StreamHealthUpdate `protobuf:"bytes,17,opt,name=stream_health_update,json=streamHealthUpdate,proto3,oneof"`
}

type ControlMessage_DvrStartRequest struct {
	DvrStartRequest *DVRStartRequest `protobuf:"bytes,18,opt,name=dvr_start_request,json=dvrStartRequest,proto3,oneof"`
}

type ControlMessage_DvrProgress struct {
	DvrProgress *DVRProgress `protobuf:"bytes,19,opt,name=dvr_progress,json=dvrProgress,proto3,oneof"`
}

type ControlMessage_DvrStopped struct {
	DvrStopped *DVRStopped `protobuf:"bytes,20,opt,name=dvr_stopped,json=dvrStopped,proto3,oneof"`
}

type ControlMessage_DvrStopRequest struct {
	DvrStopRequest *DVRStopRequest `protobuf:"bytes,21,opt,name=dvr_stop_request,json=dvrStopRequest,proto3,oneof"`
}

type ControlMessage_DvrReadyRequest struct {
	DvrReadyRequest *DVRReadyRequest `protobuf:"bytes,22,opt,name=dvr_ready_request,json=dvrReadyRequest,proto3,oneof"`
}

type ControlMessage_DvrReadyResponse struct {
	DvrReadyResponse *DVRReadyResponse `protobuf:"bytes,23,opt,name=dvr_ready_response,json=dvrReadyResponse,proto3,oneof"`
}

func (*ControlMessage_Register) isControlMessage_Payload() {}

func (*ControlMessage_NodeUpdate) isControlMessage_Payload() {}

func (*ControlMessage_ClipPullRequest) isControlMessage_Payload() {}

func (*ControlMessage_ClipProgress) isControlMessage_Payload() {}

func (*ControlMessage_ClipDone) isControlMessage_Payload() {}

func (*ControlMessage_Error) isControlMessage_Payload() {}

func (*ControlMessage_Heartbeat) isControlMessage_Payload() {}

func (*ControlMessage_StreamHealthUpdate) isControlMessage_Payload() {}

func (*ControlMessage_DvrStartRequest) isControlMessage_Payload() {}

func (*ControlMessage_DvrProgress) isControlMessage_Payload() {}

func (*ControlMessage_DvrStopped) isControlMessage_Payload() {}

func (*ControlMessage_DvrStopRequest) isControlMessage_Payload() {}

func (*ControlMessage_DvrReadyRequest) isControlMessage_Payload() {}

func (*ControlMessage_DvrReadyResponse) isControlMessage_Payload() {}

type Register struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Roles         []string               `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"` // e.g., ingest, edge, storage, processing
	CapIngest     bool                   `protobuf:"varint,3,opt,name=cap_ingest,json=capIngest,proto3" json:"cap_ingest,omitempty"`
	CapEdge       bool                   `protobuf:"varint,4,opt,name=cap_edge,json=capEdge,proto3" json:"cap_edge,omitempty"`
	CapStorage    bool                   `protobuf:"varint,5,opt,name=cap_storage,json=capStorage,proto3" json:"cap_storage,omitempty"`
	CapProcessing bool                   `protobuf:"varint,6,opt,name=cap_processing,json=capProcessing,proto3" json:"cap_processing,omitempty"`
	// Storage hints
	StorageLocal  string `protobuf:"bytes,7,opt,name=storage_local,json=storageLocal,proto3" json:"storage_local,omitempty"`
	StorageBucket string `protobuf:"bytes,8,opt,name=storage_bucket,json=storageBucket,proto3" json:"storage_bucket,omitempty"`
	StoragePrefix string `protobuf:"bytes,9,opt,name=storage_prefix,json=storagePrefix,proto3" json:"storage_prefix,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Register) Reset() {
	*x = Register{}
	mi := &file_helmsman_control_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Register) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Register) ProtoMessage() {}

func (x *Register) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Register.ProtoReflect.Descriptor instead.
func (*Register) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{1}
}

func (x *Register) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *Register) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

func (x *Register) GetCapIngest() bool {
	if x != nil {
		return x.CapIngest
	}
	return false
}

func (x *Register) GetCapEdge() bool {
	if x != nil {
		return x.CapEdge
	}
	return false
}

func (x *Register) GetCapStorage() bool {
	if x != nil {
		return x.CapStorage
	}
	return false
}

func (x *Register) GetCapProcessing() bool {
	if x != nil {
		return x.CapProcessing
	}
	return false
}

func (x *Register) GetStorageLocal() string {
	if x != nil {
		return x.StorageLocal
	}
	return ""
}

func (x *Register) GetStorageBucket() string {
	if x != nil {
		return x.StorageBucket
	}
	return ""
}

func (x *Register) GetStoragePrefix() string {
	if x != nil {
		return x.StoragePrefix
	}
	return ""
}

type NodeUpdate struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	NodeId string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Resource metrics
	CpuTenths  uint32 `protobuf:"varint,2,opt,name=cpu_tenths,json=cpuTenths,proto3" json:"cpu_tenths,omitempty"`    // 0-1000
	RamMax     uint64 `protobuf:"varint,3,opt,name=ram_max,json=ramMax,proto3" json:"ram_max,omitempty"`             // MiB
	RamCurrent uint64 `protobuf:"varint,4,opt,name=ram_current,json=ramCurrent,proto3" json:"ram_current,omitempty"` // MiB
	UpSpeed    uint64 `protobuf:"varint,5,opt,name=up_speed,json=upSpeed,proto3" json:"up_speed,omitempty"`          // bytes/sec
	DownSpeed  uint64 `protobuf:"varint,6,opt,name=down_speed,json=downSpeed,proto3" json:"down_speed,omitempty"`    // bytes/sec
	BwLimit    uint64 `protobuf:"varint,7,opt,name=bw_limit,json=bwLimit,proto3" json:"bw_limit,omitempty"`          // bytes/sec
	// Geo/location
	Latitude      float64 `protobuf:"fixed64,8,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude     float64 `protobuf:"fixed64,9,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Location      string  `protobuf:"bytes,10,opt,name=location,proto3" json:"location,omitempty"`
	ActiveStreams uint32  `protobuf:"varint,11,opt,name=active_streams,json=activeStreams,proto3" json:"active_streams,omitempty"`
	// Extended metrics (matching HTTP payload)
	BaseUrl   string `protobuf:"bytes,12,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`
	IsHealthy bool   `protobuf:"varint,13,opt,name=is_healthy,json=isHealthy,proto3" json:"is_healthy,omitempty"`
	EventType string `protobuf:"bytes,14,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	Timestamp int64  `protobuf:"varint,15,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Node capabilities
	Capabilities *NodeCapabilities `protobuf:"bytes,16,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	// Storage information
	Storage *StorageInfo `protobuf:"bytes,17,opt,name=storage,proto3" json:"storage,omitempty"`
	// Node limits and usage
	Limits *NodeLimits `protobuf:"bytes,18,opt,name=limits,proto3" json:"limits,omitempty"`
	// Stream metrics
	Streams map[string]*StreamData `protobuf:"bytes,19,rep,name=streams,proto3" json:"streams,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Stored artifacts
	Artifacts []*StoredArtifact `protobuf:"bytes,20,rep,name=artifacts,proto3" json:"artifacts,omitempty"`
	// MistServer outputs configuration (parsed from koekjes endpoint)
	OutputsJson   string `protobuf:"bytes,21,opt,name=outputs_json,json=outputsJson,proto3" json:"outputs_json,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeUpdate) Reset() {
	*x = NodeUpdate{}
	mi := &file_helmsman_control_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeUpdate) ProtoMessage() {}

func (x *NodeUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeUpdate.ProtoReflect.Descriptor instead.
func (*NodeUpdate) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{2}
}

func (x *NodeUpdate) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *NodeUpdate) GetCpuTenths() uint32 {
	if x != nil {
		return x.CpuTenths
	}
	return 0
}

func (x *NodeUpdate) GetRamMax() uint64 {
	if x != nil {
		return x.RamMax
	}
	return 0
}

func (x *NodeUpdate) GetRamCurrent() uint64 {
	if x != nil {
		return x.RamCurrent
	}
	return 0
}

func (x *NodeUpdate) GetUpSpeed() uint64 {
	if x != nil {
		return x.UpSpeed
	}
	return 0
}

func (x *NodeUpdate) GetDownSpeed() uint64 {
	if x != nil {
		return x.DownSpeed
	}
	return 0
}

func (x *NodeUpdate) GetBwLimit() uint64 {
	if x != nil {
		return x.BwLimit
	}
	return 0
}

func (x *NodeUpdate) GetLatitude() float64 {
	if x != nil {
		return x.Latitude
	}
	return 0
}

func (x *NodeUpdate) GetLongitude() float64 {
	if x != nil {
		return x.Longitude
	}
	return 0
}

func (x *NodeUpdate) GetLocation() string {
	if x != nil {
		return x.Location
	}
	return ""
}

func (x *NodeUpdate) GetActiveStreams() uint32 {
	if x != nil {
		return x.ActiveStreams
	}
	return 0
}

func (x *NodeUpdate) GetBaseUrl() string {
	if x != nil {
		return x.BaseUrl
	}
	return ""
}

func (x *NodeUpdate) GetIsHealthy() bool {
	if x != nil {
		return x.IsHealthy
	}
	return false
}

func (x *NodeUpdate) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *NodeUpdate) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *NodeUpdate) GetCapabilities() *NodeCapabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *NodeUpdate) GetStorage() *StorageInfo {
	if x != nil {
		return x.Storage
	}
	return nil
}

func (x *NodeUpdate) GetLimits() *NodeLimits {
	if x != nil {
		return x.Limits
	}
	return nil
}

func (x *NodeUpdate) GetStreams() map[string]*StreamData {
	if x != nil {
		return x.Streams
	}
	return nil
}

func (x *NodeUpdate) GetArtifacts() []*StoredArtifact {
	if x != nil {
		return x.Artifacts
	}
	return nil
}

func (x *NodeUpdate) GetOutputsJson() string {
	if x != nil {
		return x.OutputsJson
	}
	return ""
}

type NodeCapabilities struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ingest        bool                   `protobuf:"varint,1,opt,name=ingest,proto3" json:"ingest,omitempty"`
	Edge          bool                   `protobuf:"varint,2,opt,name=edge,proto3" json:"edge,omitempty"`
	Storage       bool                   `protobuf:"varint,3,opt,name=storage,proto3" json:"storage,omitempty"`
	Processing    bool                   `protobuf:"varint,4,opt,name=processing,proto3" json:"processing,omitempty"`
	Roles         []string               `protobuf:"bytes,5,rep,name=roles,proto3" json:"roles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeCapabilities) Reset() {
	*x = NodeCapabilities{}
	mi := &file_helmsman_control_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeCapabilities) ProtoMessage() {}

func (x *NodeCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeCapabilities.ProtoReflect.Descriptor instead.
func (*NodeCapabilities) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{3}
}

func (x *NodeCapabilities) GetIngest() bool {
	if x != nil {
		return x.Ingest
	}
	return false
}

func (x *NodeCapabilities) GetEdge() bool {
	if x != nil {
		return x.Edge
	}
	return false
}

func (x *NodeCapabilities) GetStorage() bool {
	if x != nil {
		return x.Storage
	}
	return false
}

func (x *NodeCapabilities) GetProcessing() bool {
	if x != nil {
		return x.Processing
	}
	return false
}

func (x *NodeCapabilities) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

type StorageInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	LocalPath     string                 `protobuf:"bytes,1,opt,name=local_path,json=localPath,proto3" json:"local_path,omitempty"`
	S3Bucket      string                 `protobuf:"bytes,2,opt,name=s3_bucket,json=s3Bucket,proto3" json:"s3_bucket,omitempty"`
	S3Prefix      string                 `protobuf:"bytes,3,opt,name=s3_prefix,json=s3Prefix,proto3" json:"s3_prefix,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StorageInfo) Reset() {
	*x = StorageInfo{}
	mi := &file_helmsman_control_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageInfo) ProtoMessage() {}

func (x *StorageInfo) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageInfo.ProtoReflect.Descriptor instead.
func (*StorageInfo) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{4}
}

func (x *StorageInfo) GetLocalPath() string {
	if x != nil {
		return x.LocalPath
	}
	return ""
}

func (x *StorageInfo) GetS3Bucket() string {
	if x != nil {
		return x.S3Bucket
	}
	return ""
}

func (x *StorageInfo) GetS3Prefix() string {
	if x != nil {
		return x.S3Prefix
	}
	return ""
}

type NodeLimits struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	MaxTranscodes        int32                  `protobuf:"varint,1,opt,name=max_transcodes,json=maxTranscodes,proto3" json:"max_transcodes,omitempty"`
	StorageCapacityBytes uint64                 `protobuf:"varint,2,opt,name=storage_capacity_bytes,json=storageCapacityBytes,proto3" json:"storage_capacity_bytes,omitempty"`
	StorageUsedBytes     uint64                 `protobuf:"varint,3,opt,name=storage_used_bytes,json=storageUsedBytes,proto3" json:"storage_used_bytes,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *NodeLimits) Reset() {
	*x = NodeLimits{}
	mi := &file_helmsman_control_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeLimits) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeLimits) ProtoMessage() {}

func (x *NodeLimits) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeLimits.ProtoReflect.Descriptor instead.
func (*NodeLimits) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{5}
}

func (x *NodeLimits) GetMaxTranscodes() int32 {
	if x != nil {
		return x.MaxTranscodes
	}
	return 0
}

func (x *NodeLimits) GetStorageCapacityBytes() uint64 {
	if x != nil {
		return x.StorageCapacityBytes
	}
	return 0
}

func (x *NodeLimits) GetStorageUsedBytes() uint64 {
	if x != nil {
		return x.StorageUsedBytes
	}
	return 0
}

type StreamData struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Total         uint64                 `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`                          // Total viewers
	Inputs        uint32                 `protobuf:"varint,2,opt,name=inputs,proto3" json:"inputs,omitempty"`                        // Input count
	BytesUp       uint64                 `protobuf:"varint,3,opt,name=bytes_up,json=bytesUp,proto3" json:"bytes_up,omitempty"`       // Upload bytes
	BytesDown     uint64                 `protobuf:"varint,4,opt,name=bytes_down,json=bytesDown,proto3" json:"bytes_down,omitempty"` // Download bytes
	Bandwidth     uint32                 `protobuf:"varint,5,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`                  // Bandwidth per viewer
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamData) Reset() {
	*x = StreamData{}
	mi := &file_helmsman_control_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamData) ProtoMessage() {}

func (x *StreamData) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamData.ProtoReflect.Descriptor instead.
func (*StreamData) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{6}
}

func (x *StreamData) GetTotal() uint64 {
	if x != nil {
		return x.Total
	}
	return 0
}

func (x *StreamData) GetInputs() uint32 {
	if x != nil {
		return x.Inputs
	}
	return 0
}

func (x *StreamData) GetBytesUp() uint64 {
	if x != nil {
		return x.BytesUp
	}
	return 0
}

func (x *StreamData) GetBytesDown() uint64 {
	if x != nil {
		return x.BytesDown
	}
	return 0
}

func (x *StreamData) GetBandwidth() uint32 {
	if x != nil {
		return x.Bandwidth
	}
	return 0
}

type StoredArtifact struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Security: Use opaque identifiers, never expose tenant_id on edge nodes
	ClipHash      string `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`       // Opaque identifier for the clip
	StreamName    string `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"` // Stream name (safe to expose)
	FilePath      string `protobuf:"bytes,3,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`       // Local file path on storage node
	S3Url         string `protobuf:"bytes,4,opt,name=s3_url,json=s3Url,proto3" json:"s3_url,omitempty"`                // S3 URL if uploaded to cloud storage
	SizeBytes     uint64 `protobuf:"varint,5,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`   // File size in bytes
	CreatedAt     int64  `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`   // Creation timestamp (Unix seconds)
	Format        string `protobuf:"bytes,7,opt,name=format,proto3" json:"format,omitempty"`                           // File format (mp4, webm, etc.)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StoredArtifact) Reset() {
	*x = StoredArtifact{}
	mi := &file_helmsman_control_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StoredArtifact) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoredArtifact) ProtoMessage() {}

func (x *StoredArtifact) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StoredArtifact.ProtoReflect.Descriptor instead.
func (*StoredArtifact) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{7}
}

func (x *StoredArtifact) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *StoredArtifact) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *StoredArtifact) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *StoredArtifact) GetS3Url() string {
	if x != nil {
		return x.S3Url
	}
	return ""
}

func (x *StoredArtifact) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *StoredArtifact) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *StoredArtifact) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

type ClipPullRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Security: Use opaque identifiers, never expose tenant_id on edge nodes
	ClipHash   string `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`       // Opaque identifier for the clip
	StreamName string `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"` // Stream name for MistServer (no tenant info)
	// Timing (one of):
	StartUnix   *int64 `protobuf:"varint,3,opt,name=start_unix,json=startUnix,proto3,oneof" json:"start_unix,omitempty"`       // seconds
	StopUnix    *int64 `protobuf:"varint,4,opt,name=stop_unix,json=stopUnix,proto3,oneof" json:"stop_unix,omitempty"`          // seconds
	StartMs     *int64 `protobuf:"varint,5,opt,name=start_ms,json=startMs,proto3,oneof" json:"start_ms,omitempty"`             // since stream start
	StopMs      *int64 `protobuf:"varint,6,opt,name=stop_ms,json=stopMs,proto3,oneof" json:"stop_ms,omitempty"`                // since stream start
	DurationSec *int64 `protobuf:"varint,7,opt,name=duration_sec,json=durationSec,proto3,oneof" json:"duration_sec,omitempty"` // seconds
	// Output
	Format     string `protobuf:"bytes,8,opt,name=format,proto3" json:"format,omitempty"`                           // mp4 default
	OutputName string `protobuf:"bytes,9,opt,name=output_name,json=outputName,proto3" json:"output_name,omitempty"` // suggested basename
	// Optional explicit Mist HTTP base (e.g., http://node:8080) to pull from
	SourceBaseUrl string `protobuf:"bytes,10,opt,name=source_base_url,json=sourceBaseUrl,proto3" json:"source_base_url,omitempty"`
	// Request tracking
	RequestId     string `protobuf:"bytes,11,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"` // Unique request ID for tracking
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipPullRequest) Reset() {
	*x = ClipPullRequest{}
	mi := &file_helmsman_control_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipPullRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipPullRequest) ProtoMessage() {}

func (x *ClipPullRequest) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipPullRequest.ProtoReflect.Descriptor instead.
func (*ClipPullRequest) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{8}
}

func (x *ClipPullRequest) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *ClipPullRequest) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *ClipPullRequest) GetStartUnix() int64 {
	if x != nil && x.StartUnix != nil {
		return *x.StartUnix
	}
	return 0
}

func (x *ClipPullRequest) GetStopUnix() int64 {
	if x != nil && x.StopUnix != nil {
		return *x.StopUnix
	}
	return 0
}

func (x *ClipPullRequest) GetStartMs() int64 {
	if x != nil && x.StartMs != nil {
		return *x.StartMs
	}
	return 0
}

func (x *ClipPullRequest) GetStopMs() int64 {
	if x != nil && x.StopMs != nil {
		return *x.StopMs
	}
	return 0
}

func (x *ClipPullRequest) GetDurationSec() int64 {
	if x != nil && x.DurationSec != nil {
		return *x.DurationSec
	}
	return 0
}

func (x *ClipPullRequest) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *ClipPullRequest) GetOutputName() string {
	if x != nil {
		return x.OutputName
	}
	return ""
}

func (x *ClipPullRequest) GetSourceBaseUrl() string {
	if x != nil {
		return x.SourceBaseUrl
	}
	return ""
}

func (x *ClipPullRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

type ClipProgress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Percent       uint32                 `protobuf:"varint,2,opt,name=percent,proto3" json:"percent,omitempty"` // 0..100
	Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipProgress) Reset() {
	*x = ClipProgress{}
	mi := &file_helmsman_control_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipProgress) ProtoMessage() {}

func (x *ClipProgress) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipProgress.ProtoReflect.Descriptor instead.
func (*ClipProgress) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{9}
}

func (x *ClipProgress) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ClipProgress) GetPercent() uint32 {
	if x != nil {
		return x.Percent
	}
	return 0
}

func (x *ClipProgress) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type ClipDone struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"` // local path on storage node (if applicable)
	S3Url         string                 `protobuf:"bytes,3,opt,name=s3_url,json=s3Url,proto3" json:"s3_url,omitempty"`          // s3://bucket/key or https URL (if applicable)
	SizeBytes     uint64                 `protobuf:"varint,4,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Status        string                 `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"` // success|failed
	Error         string                 `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`   // filled when failed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipDone) Reset() {
	*x = ClipDone{}
	mi := &file_helmsman_control_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipDone) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipDone) ProtoMessage() {}

func (x *ClipDone) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipDone.ProtoReflect.Descriptor instead.
func (*ClipDone) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{10}
}

func (x *ClipDone) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ClipDone) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *ClipDone) GetS3Url() string {
	if x != nil {
		return x.S3Url
	}
	return ""
}

func (x *ClipDone) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *ClipDone) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *ClipDone) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type ControlError struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          string                 `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControlError) Reset() {
	*x = ControlError{}
	mi := &file_helmsman_control_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControlError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControlError) ProtoMessage() {}

func (x *ControlError) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControlError.ProtoReflect.Descriptor instead.
func (*ControlError) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{11}
}

func (x *ControlError) GetCode() string {
	if x != nil {
		return x.Code
	}
	return ""
}

func (x *ControlError) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type Heartbeat struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Heartbeat) Reset() {
	*x = Heartbeat{}
	mi := &file_helmsman_control_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Heartbeat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Heartbeat) ProtoMessage() {}

func (x *Heartbeat) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Heartbeat.ProtoReflect.Descriptor instead.
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{12}
}

func (x *Heartbeat) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

type StreamHealthUpdate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	StreamName    string                 `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	InternalName  string                 `protobuf:"bytes,3,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`
	IsHealthy     bool                   `protobuf:"varint,4,opt,name=is_healthy,json=isHealthy,proto3" json:"is_healthy,omitempty"`
	Timestamp     int64                  `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Details       *StreamHealthDetails   `protobuf:"bytes,6,opt,name=details,proto3" json:"details,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamHealthUpdate) Reset() {
	*x = StreamHealthUpdate{}
	mi := &file_helmsman_control_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamHealthUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamHealthUpdate) ProtoMessage() {}

func (x *StreamHealthUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamHealthUpdate.ProtoReflect.Descriptor instead.
func (*StreamHealthUpdate) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{13}
}

func (x *StreamHealthUpdate) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *StreamHealthUpdate) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

func (x *StreamHealthUpdate) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *StreamHealthUpdate) GetIsHealthy() bool {
	if x != nil {
		return x.IsHealthy
	}
	return false
}

func (x *StreamHealthUpdate) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *StreamHealthUpdate) GetDetails() *StreamHealthDetails {
	if x != nil {
		return x.Details
	}
	return nil
}

type StreamHealthDetails struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	BufferState   string                 `protobuf:"bytes,1,opt,name=buffer_state,json=bufferState,proto3" json:"buffer_state,omitempty"`       // FULL, EMPTY, DRY, RECOVER
	Status        string                 `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`                                    // live, offline
	StreamDetails string                 `protobuf:"bytes,3,opt,name=stream_details,json=streamDetails,proto3" json:"stream_details,omitempty"` // JSON string from MistServer
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamHealthDetails) Reset() {
	*x = StreamHealthDetails{}
	mi := &file_helmsman_control_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamHealthDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamHealthDetails) ProtoMessage() {}

func (x *StreamHealthDetails) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamHealthDetails.ProtoReflect.Descriptor instead.
func (*StreamHealthDetails) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{14}
}

func (x *StreamHealthDetails) GetBufferState() string {
	if x != nil {
		return x.BufferState
	}
	return ""
}

func (x *StreamHealthDetails) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *StreamHealthDetails) GetStreamDetails() string {
	if x != nil {
		return x.StreamDetails
	}
	return ""
}

type ClipHashRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClipHash      string                 `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipHashRequest) Reset() {
	*x = ClipHashRequest{}
	mi := &file_helmsman_control_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipHashRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipHashRequest) ProtoMessage() {}

func (x *ClipHashRequest) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipHashRequest.ProtoReflect.Descriptor instead.
func (*ClipHashRequest) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{15}
}

func (x *ClipHashRequest) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

type ClipHashResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClipHash      string                 `protobuf:"bytes,1,opt,name=clip_hash,json=clipHash,proto3" json:"clip_hash,omitempty"`
	TenantId      string                 `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	StreamName    string                 `protobuf:"bytes,3,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipHashResponse) Reset() {
	*x = ClipHashResponse{}
	mi := &file_helmsman_control_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipHashResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipHashResponse) ProtoMessage() {}

func (x *ClipHashResponse) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipHashResponse.ProtoReflect.Descriptor instead.
func (*ClipHashResponse) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{16}
}

func (x *ClipHashResponse) GetClipHash() string {
	if x != nil {
		return x.ClipHash
	}
	return ""
}

func (x *ClipHashResponse) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *ClipHashResponse) GetStreamName() string {
	if x != nil {
		return x.StreamName
	}
	return ""
}

// DVR (Digital Video Recording) messages
type DVRStartRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`                     // Unique DVR identifier (32-char hex) - generated by Foghorn
	InternalName  string                 `protobuf:"bytes,2,opt,name=internal_name,json=internalName,proto3" json:"internal_name,omitempty"`      // Stream internal name (same as stream name)
	SourceBaseUrl string                 `protobuf:"bytes,3,opt,name=source_base_url,json=sourceBaseUrl,proto3" json:"source_base_url,omitempty"` // DTSC source URL to pull from - filled by Foghorn
	RequestId     string                 `protobuf:"bytes,4,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`               // Unique request ID for tracking
	Config        *DVRConfig             `protobuf:"bytes,5,opt,name=config,proto3" json:"config,omitempty"`                                      // Recording configuration
	TenantId      string                 `protobuf:"bytes,6,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`                  // Tenant ID for the stream
	UserId        string                 `protobuf:"bytes,7,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`                        // User ID for the stream
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRStartRequest) Reset() {
	*x = DVRStartRequest{}
	mi := &file_helmsman_control_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRStartRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRStartRequest) ProtoMessage() {}

func (x *DVRStartRequest) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRStartRequest.ProtoReflect.Descriptor instead.
func (*DVRStartRequest) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{17}
}

func (x *DVRStartRequest) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRStartRequest) GetInternalName() string {
	if x != nil {
		return x.InternalName
	}
	return ""
}

func (x *DVRStartRequest) GetSourceBaseUrl() string {
	if x != nil {
		return x.SourceBaseUrl
	}
	return ""
}

func (x *DVRStartRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DVRStartRequest) GetConfig() *DVRConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *DVRStartRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *DVRStartRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

type DVRConfig struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Enabled         bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`                                        // Whether DVR is enabled
	RetentionDays   int32                  `protobuf:"varint,2,opt,name=retention_days,json=retentionDays,proto3" json:"retention_days,omitempty"`       // How long to keep the recording
	Format          string                 `protobuf:"bytes,3,opt,name=format,proto3" json:"format,omitempty"`                                           // ts, mp4, etc.
	SegmentDuration int32                  `protobuf:"varint,4,opt,name=segment_duration,json=segmentDuration,proto3" json:"segment_duration,omitempty"` // Segment duration in seconds
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DVRConfig) Reset() {
	*x = DVRConfig{}
	mi := &file_helmsman_control_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRConfig) ProtoMessage() {}

func (x *DVRConfig) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRConfig.ProtoReflect.Descriptor instead.
func (*DVRConfig) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{18}
}

func (x *DVRConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *DVRConfig) GetRetentionDays() int32 {
	if x != nil {
		return x.RetentionDays
	}
	return 0
}

func (x *DVRConfig) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *DVRConfig) GetSegmentDuration() int32 {
	if x != nil {
		return x.SegmentDuration
	}
	return 0
}

type DVRProgress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	DvrHash       string                 `protobuf:"bytes,2,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`                 // DVR identifier
	Status        string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`                                  // recording, segments_available, etc.
	StartedAt     int64                  `protobuf:"varint,4,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`          // Unix timestamp when recording started
	SegmentCount  int32                  `protobuf:"varint,5,opt,name=segment_count,json=segmentCount,proto3" json:"segment_count,omitempty"` // Number of segments recorded so far
	SizeBytes     uint64                 `protobuf:"varint,6,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`          // Total size of recording so far
	Message       string                 `protobuf:"bytes,7,opt,name=message,proto3" json:"message,omitempty"`                                // Optional progress message
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRProgress) Reset() {
	*x = DVRProgress{}
	mi := &file_helmsman_control_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRProgress) ProtoMessage() {}

func (x *DVRProgress) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRProgress.ProtoReflect.Descriptor instead.
func (*DVRProgress) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{19}
}

func (x *DVRProgress) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DVRProgress) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRProgress) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *DVRProgress) GetStartedAt() int64 {
	if x != nil {
		return x.StartedAt
	}
	return 0
}

func (x *DVRProgress) GetSegmentCount() int32 {
	if x != nil {
		return x.SegmentCount
	}
	return 0
}

func (x *DVRProgress) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *DVRProgress) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type DVRStopped struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	RequestId       string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	DvrHash         string                 `protobuf:"bytes,2,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`                          // DVR identifier
	Status          string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`                                           // completed, failed, terminated
	Error           string                 `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`                                             // Error message if failed
	StartedAt       int64                  `protobuf:"varint,5,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`                   // Unix timestamp when recording started
	EndedAt         int64                  `protobuf:"varint,6,opt,name=ended_at,json=endedAt,proto3" json:"ended_at,omitempty"`                         // Unix timestamp when recording ended
	DurationSeconds int32                  `protobuf:"varint,7,opt,name=duration_seconds,json=durationSeconds,proto3" json:"duration_seconds,omitempty"` // Total duration of the recording
	SizeBytes       uint64                 `protobuf:"varint,8,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`                   // Total size of the recording
	ManifestPath    string                 `protobuf:"bytes,9,opt,name=manifest_path,json=manifestPath,proto3" json:"manifest_path,omitempty"`           // Path to the m3u8 manifest for playback
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DVRStopped) Reset() {
	*x = DVRStopped{}
	mi := &file_helmsman_control_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRStopped) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRStopped) ProtoMessage() {}

func (x *DVRStopped) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRStopped.ProtoReflect.Descriptor instead.
func (*DVRStopped) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{20}
}

func (x *DVRStopped) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DVRStopped) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRStopped) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *DVRStopped) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *DVRStopped) GetStartedAt() int64 {
	if x != nil {
		return x.StartedAt
	}
	return 0
}

func (x *DVRStopped) GetEndedAt() int64 {
	if x != nil {
		return x.EndedAt
	}
	return 0
}

func (x *DVRStopped) GetDurationSeconds() int32 {
	if x != nil {
		return x.DurationSeconds
	}
	return 0
}

func (x *DVRStopped) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *DVRStopped) GetManifestPath() string {
	if x != nil {
		return x.ManifestPath
	}
	return ""
}

type DVRStopRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`                      // Unique DVR identifier to stop (empty = stop all for internal_name)
	RequestId     string                 `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`                // Request ID for tracking
	InternalName  *string                `protobuf:"bytes,3,opt,name=internal_name,json=internalName,proto3,oneof" json:"internal_name,omitempty"` // Stream internal name (for stopping all DVR recordings for a stream)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRStopRequest) Reset() {
	*x = DVRStopRequest{}
	mi := &file_helmsman_control_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRStopRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRStopRequest) ProtoMessage() {}

func (x *DVRStopRequest) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRStopRequest.ProtoReflect.Descriptor instead.
func (*DVRStopRequest) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{21}
}

func (x *DVRStopRequest) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRStopRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *DVRStopRequest) GetInternalName() string {
	if x != nil && x.InternalName != nil {
		return *x.InternalName
	}
	return ""
}

type DVRReadyRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"` // Which DVR job we're asking about
	NodeId        string                 `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`    // Which storage node is asking
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRReadyRequest) Reset() {
	*x = DVRReadyRequest{}
	mi := &file_helmsman_control_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRReadyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRReadyRequest) ProtoMessage() {}

func (x *DVRReadyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRReadyRequest.ProtoReflect.Descriptor instead.
func (*DVRReadyRequest) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{22}
}

func (x *DVRReadyRequest) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRReadyRequest) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

type DVRReadyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DvrHash       string                 `protobuf:"bytes,1,opt,name=dvr_hash,json=dvrHash,proto3" json:"dvr_hash,omitempty"`       // DVR identifier
	Ready         bool                   `protobuf:"varint,2,opt,name=ready,proto3" json:"ready,omitempty"`                         // Is stream ready for pulling?
	SourceUri     string                 `protobuf:"bytes,3,opt,name=source_uri,json=sourceUri,proto3" json:"source_uri,omitempty"` // Full DTSC URI when ready (e.g., "http://ingest-node:8080/stream_name.dtsc")
	Config        *DVRConfig             `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`                        // Potentially updated config based on stream characteristics
	Reason        string                 `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`                        // If not ready, why? (e.g., "stream_booting", "stream_unhealthy", "stream_offline")
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DVRReadyResponse) Reset() {
	*x = DVRReadyResponse{}
	mi := &file_helmsman_control_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DVRReadyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DVRReadyResponse) ProtoMessage() {}

func (x *DVRReadyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_helmsman_control_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DVRReadyResponse.ProtoReflect.Descriptor instead.
func (*DVRReadyResponse) Descriptor() ([]byte, []int) {
	return file_helmsman_control_proto_rawDescGZIP(), []int{23}
}

func (x *DVRReadyResponse) GetDvrHash() string {
	if x != nil {
		return x.DvrHash
	}
	return ""
}

func (x *DVRReadyResponse) GetReady() bool {
	if x != nil {
		return x.Ready
	}
	return false
}

func (x *DVRReadyResponse) GetSourceUri() string {
	if x != nil {
		return x.SourceUri
	}
	return ""
}

func (x *DVRReadyResponse) GetConfig() *DVRConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *DVRReadyResponse) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

var File_helmsman_control_proto protoreflect.FileDescriptor

const file_helmsman_control_proto_rawDesc = "" +
	"\n" +
	"\x16helmsman_control.proto\x12\x0fhelmsmancontrol\x1a\x1fgoogle/protobuf/timestamp.proto\"\xc7\b\n" +
	"\x0eControlMessage\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x123\n" +
	"\asent_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x06sentAt\x127\n" +
	"\bregister\x18\n" +
	" \x01(\v2\x19.helmsmancontrol.RegisterH\x00R\bregister\x12>\n" +
	"\vnode_update\x18\v \x01(\v2\x1b.helmsmancontrol.NodeUpdateH\x00R\n" +
	"nodeUpdate\x12N\n" +
	"\x11clip_pull_request\x18\f \x01(\v2 .helmsmancontrol.ClipPullRequestH\x00R\x0fclipPullRequest\x12D\n" +
	"\rclip_progress\x18\r \x01(\v2\x1d.helmsmancontrol.ClipProgressH\x00R\fclipProgress\x128\n" +
	"\tclip_done\x18\x0e \x01(\v2\x19.helmsmancontrol.ClipDoneH\x00R\bclipDone\x125\n" +
	"\x05error\x18\x0f \x01(\v2\x1d.helmsmancontrol.ControlErrorH\x00R\x05error\x12:\n" +
	"\theartbeat\x18\x10 \x01(\v2\x1a.helmsmancontrol.HeartbeatH\x00R\theartbeat\x12W\n" +
	"\x14stream_health_update\x18\x11 \x01(\v2#.helmsmancontrol.StreamHealthUpdateH\x00R\x12streamHealthUpdate\x12N\n" +
	"\x11dvr_start_request\x18\x12 \x01(\v2 .helmsmancontrol.DVRStartRequestH\x00R\x0fdvrStartRequest\x12A\n" +
	"\fdvr_progress\x18\x13 \x01(\v2\x1c.helmsmancontrol.DVRProgressH\x00R\vdvrProgress\x12>\n" +
	"\vdvr_stopped\x18\x14 \x01(\v2\x1b.helmsmancontrol.DVRStoppedH\x00R\n" +
	"dvrStopped\x12K\n" +
	"\x10dvr_stop_request\x18\x15 \x01(\v2\x1f.helmsmancontrol.DVRStopRequestH\x00R\x0edvrStopRequest\x12N\n" +
	"\x11dvr_ready_request\x18\x16 \x01(\v2 .helmsmancontrol.DVRReadyRequestH\x00R\x0fdvrReadyRequest\x12Q\n" +
	"\x12dvr_ready_response\x18\x17 \x01(\v2!.helmsmancontrol.DVRReadyResponseH\x00R\x10dvrReadyResponseB\t\n" +
	"\apayload\"\xae\x02\n" +
	"\bRegister\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x14\n" +
	"\x05roles\x18\x02 \x03(\tR\x05roles\x12\x1d\n" +
	"\n" +
	"cap_ingest\x18\x03 \x01(\bR\tcapIngest\x12\x19\n" +
	"\bcap_edge\x18\x04 \x01(\bR\acapEdge\x12\x1f\n" +
	"\vcap_storage\x18\x05 \x01(\bR\n" +
	"capStorage\x12%\n" +
	"\x0ecap_processing\x18\x06 \x01(\bR\rcapProcessing\x12#\n" +
	"\rstorage_local\x18\a \x01(\tR\fstorageLocal\x12%\n" +
	"\x0estorage_bucket\x18\b \x01(\tR\rstorageBucket\x12%\n" +
	"\x0estorage_prefix\x18\t \x01(\tR\rstoragePrefix\"\xfa\x06\n" +
	"\n" +
	"NodeUpdate\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1d\n" +
	"\n" +
	"cpu_tenths\x18\x02 \x01(\rR\tcpuTenths\x12\x17\n" +
	"\aram_max\x18\x03 \x01(\x04R\x06ramMax\x12\x1f\n" +
	"\vram_current\x18\x04 \x01(\x04R\n" +
	"ramCurrent\x12\x19\n" +
	"\bup_speed\x18\x05 \x01(\x04R\aupSpeed\x12\x1d\n" +
	"\n" +
	"down_speed\x18\x06 \x01(\x04R\tdownSpeed\x12\x19\n" +
	"\bbw_limit\x18\a \x01(\x04R\abwLimit\x12\x1a\n" +
	"\blatitude\x18\b \x01(\x01R\blatitude\x12\x1c\n" +
	"\tlongitude\x18\t \x01(\x01R\tlongitude\x12\x1a\n" +
	"\blocation\x18\n" +
	" \x01(\tR\blocation\x12%\n" +
	"\x0eactive_streams\x18\v \x01(\rR\ractiveStreams\x12\x19\n" +
	"\bbase_url\x18\f \x01(\tR\abaseUrl\x12\x1d\n" +
	"\n" +
	"is_healthy\x18\r \x01(\bR\tisHealthy\x12\x1d\n" +
	"\n" +
	"event_type\x18\x0e \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x0f \x01(\x03R\ttimestamp\x12E\n" +
	"\fcapabilities\x18\x10 \x01(\v2!.helmsmancontrol.NodeCapabilitiesR\fcapabilities\x126\n" +
	"\astorage\x18\x11 \x01(\v2\x1c.helmsmancontrol.StorageInfoR\astorage\x123\n" +
	"\x06limits\x18\x12 \x01(\v2\x1b.helmsmancontrol.NodeLimitsR\x06limits\x12B\n" +
	"\astreams\x18\x13 \x03(\v2(.helmsmancontrol.NodeUpdate.StreamsEntryR\astreams\x12=\n" +
	"\tartifacts\x18\x14 \x03(\v2\x1f.helmsmancontrol.StoredArtifactR\tartifacts\x12!\n" +
	"\foutputs_json\x18\x15 \x01(\tR\voutputsJson\x1aW\n" +
	"\fStreamsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x121\n" +
	"\x05value\x18\x02 \x01(\v2\x1b.helmsmancontrol.StreamDataR\x05value:\x028\x01\"\x8e\x01\n" +
	"\x10NodeCapabilities\x12\x16\n" +
	"\x06ingest\x18\x01 \x01(\bR\x06ingest\x12\x12\n" +
	"\x04edge\x18\x02 \x01(\bR\x04edge\x12\x18\n" +
	"\astorage\x18\x03 \x01(\bR\astorage\x12\x1e\n" +
	"\n" +
	"processing\x18\x04 \x01(\bR\n" +
	"processing\x12\x14\n" +
	"\x05roles\x18\x05 \x03(\tR\x05roles\"f\n" +
	"\vStorageInfo\x12\x1d\n" +
	"\n" +
	"local_path\x18\x01 \x01(\tR\tlocalPath\x12\x1b\n" +
	"\ts3_bucket\x18\x02 \x01(\tR\bs3Bucket\x12\x1b\n" +
	"\ts3_prefix\x18\x03 \x01(\tR\bs3Prefix\"\x97\x01\n" +
	"\n" +
	"NodeLimits\x12%\n" +
	"\x0emax_transcodes\x18\x01 \x01(\x05R\rmaxTranscodes\x124\n" +
	"\x16storage_capacity_bytes\x18\x02 \x01(\x04R\x14storageCapacityBytes\x12,\n" +
	"\x12storage_used_bytes\x18\x03 \x01(\x04R\x10storageUsedBytes\"\x92\x01\n" +
	"\n" +
	"StreamData\x12\x14\n" +
	"\x05total\x18\x01 \x01(\x04R\x05total\x12\x16\n" +
	"\x06inputs\x18\x02 \x01(\rR\x06inputs\x12\x19\n" +
	"\bbytes_up\x18\x03 \x01(\x04R\abytesUp\x12\x1d\n" +
	"\n" +
	"bytes_down\x18\x04 \x01(\x04R\tbytesDown\x12\x1c\n" +
	"\tbandwidth\x18\x05 \x01(\rR\tbandwidth\"\xd8\x01\n" +
	"\x0eStoredArtifact\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\x12\x1f\n" +
	"\vstream_name\x18\x02 \x01(\tR\n" +
	"streamName\x12\x1b\n" +
	"\tfile_path\x18\x03 \x01(\tR\bfilePath\x12\x15\n" +
	"\x06s3_url\x18\x04 \x01(\tR\x05s3Url\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x05 \x01(\x04R\tsizeBytes\x12\x1d\n" +
	"\n" +
	"created_at\x18\x06 \x01(\x03R\tcreatedAt\x12\x16\n" +
	"\x06format\x18\a \x01(\tR\x06format\"\xc2\x03\n" +
	"\x0fClipPullRequest\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\x12\x1f\n" +
	"\vstream_name\x18\x02 \x01(\tR\n" +
	"streamName\x12\"\n" +
	"\n" +
	"start_unix\x18\x03 \x01(\x03H\x00R\tstartUnix\x88\x01\x01\x12 \n" +
	"\tstop_unix\x18\x04 \x01(\x03H\x01R\bstopUnix\x88\x01\x01\x12\x1e\n" +
	"\bstart_ms\x18\x05 \x01(\x03H\x02R\astartMs\x88\x01\x01\x12\x1c\n" +
	"\astop_ms\x18\x06 \x01(\x03H\x03R\x06stopMs\x88\x01\x01\x12&\n" +
	"\fduration_sec\x18\a \x01(\x03H\x04R\vdurationSec\x88\x01\x01\x12\x16\n" +
	"\x06format\x18\b \x01(\tR\x06format\x12\x1f\n" +
	"\voutput_name\x18\t \x01(\tR\n" +
	"outputName\x12&\n" +
	"\x0fsource_base_url\x18\n" +
	" \x01(\tR\rsourceBaseUrl\x12\x1d\n" +
	"\n" +
	"request_id\x18\v \x01(\tR\trequestIdB\r\n" +
	"\v_start_unixB\f\n" +
	"\n" +
	"_stop_unixB\v\n" +
	"\t_start_msB\n" +
	"\n" +
	"\b_stop_msB\x0f\n" +
	"\r_duration_sec\"a\n" +
	"\fClipProgress\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x18\n" +
	"\apercent\x18\x02 \x01(\rR\apercent\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"\xaa\x01\n" +
	"\bClipDone\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\x12\x15\n" +
	"\x06s3_url\x18\x03 \x01(\tR\x05s3Url\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x04 \x01(\x04R\tsizeBytes\x12\x16\n" +
	"\x06status\x18\x05 \x01(\tR\x06status\x12\x14\n" +
	"\x05error\x18\x06 \x01(\tR\x05error\"<\n" +
	"\fControlError\x12\x12\n" +
	"\x04code\x18\x01 \x01(\tR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"$\n" +
	"\tHeartbeat\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\"\xf0\x01\n" +
	"\x12StreamHealthUpdate\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1f\n" +
	"\vstream_name\x18\x02 \x01(\tR\n" +
	"streamName\x12#\n" +
	"\rinternal_name\x18\x03 \x01(\tR\finternalName\x12\x1d\n" +
	"\n" +
	"is_healthy\x18\x04 \x01(\bR\tisHealthy\x12\x1c\n" +
	"\ttimestamp\x18\x05 \x01(\x03R\ttimestamp\x12>\n" +
	"\adetails\x18\x06 \x01(\v2$.helmsmancontrol.StreamHealthDetailsR\adetails\"w\n" +
	"\x13StreamHealthDetails\x12!\n" +
	"\fbuffer_state\x18\x01 \x01(\tR\vbufferState\x12\x16\n" +
	"\x06status\x18\x02 \x01(\tR\x06status\x12%\n" +
	"\x0estream_details\x18\x03 \x01(\tR\rstreamDetails\".\n" +
	"\x0fClipHashRequest\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\"m\n" +
	"\x10ClipHashResponse\x12\x1b\n" +
	"\tclip_hash\x18\x01 \x01(\tR\bclipHash\x12\x1b\n" +
	"\ttenant_id\x18\x02 \x01(\tR\btenantId\x12\x1f\n" +
	"\vstream_name\x18\x03 \x01(\tR\n" +
	"streamName\"\x82\x02\n" +
	"\x0fDVRStartRequest\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12#\n" +
	"\rinternal_name\x18\x02 \x01(\tR\finternalName\x12&\n" +
	"\x0fsource_base_url\x18\x03 \x01(\tR\rsourceBaseUrl\x12\x1d\n" +
	"\n" +
	"request_id\x18\x04 \x01(\tR\trequestId\x122\n" +
	"\x06config\x18\x05 \x01(\v2\x1a.helmsmancontrol.DVRConfigR\x06config\x12\x1b\n" +
	"\ttenant_id\x18\x06 \x01(\tR\btenantId\x12\x17\n" +
	"\auser_id\x18\a \x01(\tR\x06userId\"\x8f\x01\n" +
	"\tDVRConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12%\n" +
	"\x0eretention_days\x18\x02 \x01(\x05R\rretentionDays\x12\x16\n" +
	"\x06format\x18\x03 \x01(\tR\x06format\x12)\n" +
	"\x10segment_duration\x18\x04 \x01(\x05R\x0fsegmentDuration\"\xdc\x01\n" +
	"\vDVRProgress\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x19\n" +
	"\bdvr_hash\x18\x02 \x01(\tR\advrHash\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x1d\n" +
	"\n" +
	"started_at\x18\x04 \x01(\x03R\tstartedAt\x12#\n" +
	"\rsegment_count\x18\x05 \x01(\x05R\fsegmentCount\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x06 \x01(\x04R\tsizeBytes\x12\x18\n" +
	"\amessage\x18\a \x01(\tR\amessage\"\x9d\x02\n" +
	"\n" +
	"DVRStopped\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x19\n" +
	"\bdvr_hash\x18\x02 \x01(\tR\advrHash\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x14\n" +
	"\x05error\x18\x04 \x01(\tR\x05error\x12\x1d\n" +
	"\n" +
	"started_at\x18\x05 \x01(\x03R\tstartedAt\x12\x19\n" +
	"\bended_at\x18\x06 \x01(\x03R\aendedAt\x12)\n" +
	"\x10duration_seconds\x18\a \x01(\x05R\x0fdurationSeconds\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\b \x01(\x04R\tsizeBytes\x12#\n" +
	"\rmanifest_path\x18\t \x01(\tR\fmanifestPath\"\x86\x01\n" +
	"\x0eDVRStopRequest\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\tR\trequestId\x12(\n" +
	"\rinternal_name\x18\x03 \x01(\tH\x00R\finternalName\x88\x01\x01B\x10\n" +
	"\x0e_internal_name\"E\n" +
	"\x0fDVRReadyRequest\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12\x17\n" +
	"\anode_id\x18\x02 \x01(\tR\x06nodeId\"\xae\x01\n" +
	"\x10DVRReadyResponse\x12\x19\n" +
	"\bdvr_hash\x18\x01 \x01(\tR\advrHash\x12\x14\n" +
	"\x05ready\x18\x02 \x01(\bR\x05ready\x12\x1d\n" +
	"\n" +
	"source_uri\x18\x03 \x01(\tR\tsourceUri\x122\n" +
	"\x06config\x18\x04 \x01(\v2\x1a.helmsmancontrol.DVRConfigR\x06config\x12\x16\n" +
	"\x06reason\x18\x05 \x01(\tR\x06reason2\xba\x01\n" +
	"\x0fHelmsmanControl\x12O\n" +
	"\aConnect\x12\x1f.helmsmancontrol.ControlMessage\x1a\x1f.helmsmancontrol.ControlMessage(\x010\x01\x12V\n" +
	"\x0fResolveClipHash\x12 .helmsmancontrol.ClipHashRequest\x1a!.helmsmancontrol.ClipHashResponseB\x16Z\x14frameworks/pkg/protob\x06proto3"

var (
	file_helmsman_control_proto_rawDescOnce sync.Once
	file_helmsman_control_proto_rawDescData []byte
)

func file_helmsman_control_proto_rawDescGZIP() []byte {
	file_helmsman_control_proto_rawDescOnce.Do(func() {
		file_helmsman_control_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_helmsman_control_proto_rawDesc), len(file_helmsman_control_proto_rawDesc)))
	})
	return file_helmsman_control_proto_rawDescData
}

var file_helmsman_control_proto_msgTypes = make([]protoimpl.MessageInfo, 25)
var file_helmsman_control_proto_goTypes = []any{
	(*ControlMessage)(nil),        // 0: helmsmancontrol.ControlMessage
	(*Register)(nil),              // 1: helmsmancontrol.Register
	(*NodeUpdate)(nil),            // 2: helmsmancontrol.NodeUpdate
	(*NodeCapabilities)(nil),      // 3: helmsmancontrol.NodeCapabilities
	(*StorageInfo)(nil),           // 4: helmsmancontrol.StorageInfo
	(*NodeLimits)(nil),            // 5: helmsmancontrol.NodeLimits
	(*StreamData)(nil),            // 6: helmsmancontrol.StreamData
	(*StoredArtifact)(nil),        // 7: helmsmancontrol.StoredArtifact
	(*ClipPullRequest)(nil),       // 8: helmsmancontrol.ClipPullRequest
	(*ClipProgress)(nil),          // 9: helmsmancontrol.ClipProgress
	(*ClipDone)(nil),              // 10: helmsmancontrol.ClipDone
	(*ControlError)(nil),          // 11: helmsmancontrol.ControlError
	(*Heartbeat)(nil),             // 12: helmsmancontrol.Heartbeat
	(*StreamHealthUpdate)(nil),    // 13: helmsmancontrol.StreamHealthUpdate
	(*StreamHealthDetails)(nil),   // 14: helmsmancontrol.StreamHealthDetails
	(*ClipHashRequest)(nil),       // 15: helmsmancontrol.ClipHashRequest
	(*ClipHashResponse)(nil),      // 16: helmsmancontrol.ClipHashResponse
	(*DVRStartRequest)(nil),       // 17: helmsmancontrol.DVRStartRequest
	(*DVRConfig)(nil),             // 18: helmsmancontrol.DVRConfig
	(*DVRProgress)(nil),           // 19: helmsmancontrol.DVRProgress
	(*DVRStopped)(nil),            // 20: helmsmancontrol.DVRStopped
	(*DVRStopRequest)(nil),        // 21: helmsmancontrol.DVRStopRequest
	(*DVRReadyRequest)(nil),       // 22: helmsmancontrol.DVRReadyRequest
	(*DVRReadyResponse)(nil),      // 23: helmsmancontrol.DVRReadyResponse
	nil,                           // 24: helmsmancontrol.NodeUpdate.StreamsEntry
	(*timestamppb.Timestamp)(nil), // 25: google.protobuf.Timestamp
}
var file_helmsman_control_proto_depIdxs = []int32{
	25, // 0: helmsmancontrol.ControlMessage.sent_at:type_name -> google.protobuf.Timestamp
	1,  // 1: helmsmancontrol.ControlMessage.register:type_name -> helmsmancontrol.Register
	2,  // 2: helmsmancontrol.ControlMessage.node_update:type_name -> helmsmancontrol.NodeUpdate
	8,  // 3: helmsmancontrol.ControlMessage.clip_pull_request:type_name -> helmsmancontrol.ClipPullRequest
	9,  // 4: helmsmancontrol.ControlMessage.clip_progress:type_name -> helmsmancontrol.ClipProgress
	10, // 5: helmsmancontrol.ControlMessage.clip_done:type_name -> helmsmancontrol.ClipDone
	11, // 6: helmsmancontrol.ControlMessage.error:type_name -> helmsmancontrol.ControlError
	12, // 7: helmsmancontrol.ControlMessage.heartbeat:type_name -> helmsmancontrol.Heartbeat
	13, // 8: helmsmancontrol.ControlMessage.stream_health_update:type_name -> helmsmancontrol.StreamHealthUpdate
	17, // 9: helmsmancontrol.ControlMessage.dvr_start_request:type_name -> helmsmancontrol.DVRStartRequest
	19, // 10: helmsmancontrol.ControlMessage.dvr_progress:type_name -> helmsmancontrol.DVRProgress
	20, // 11: helmsmancontrol.ControlMessage.dvr_stopped:type_name -> helmsmancontrol.DVRStopped
	21, // 12: helmsmancontrol.ControlMessage.dvr_stop_request:type_name -> helmsmancontrol.DVRStopRequest
	22, // 13: helmsmancontrol.ControlMessage.dvr_ready_request:type_name -> helmsmancontrol.DVRReadyRequest
	23, // 14: helmsmancontrol.ControlMessage.dvr_ready_response:type_name -> helmsmancontrol.DVRReadyResponse
	3,  // 15: helmsmancontrol.NodeUpdate.capabilities:type_name -> helmsmancontrol.NodeCapabilities
	4,  // 16: helmsmancontrol.NodeUpdate.storage:type_name -> helmsmancontrol.StorageInfo
	5,  // 17: helmsmancontrol.NodeUpdate.limits:type_name -> helmsmancontrol.NodeLimits
	24, // 18: helmsmancontrol.NodeUpdate.streams:type_name -> helmsmancontrol.NodeUpdate.StreamsEntry
	7,  // 19: helmsmancontrol.NodeUpdate.artifacts:type_name -> helmsmancontrol.StoredArtifact
	14, // 20: helmsmancontrol.StreamHealthUpdate.details:type_name -> helmsmancontrol.StreamHealthDetails
	18, // 21: helmsmancontrol.DVRStartRequest.config:type_name -> helmsmancontrol.DVRConfig
	18, // 22: helmsmancontrol.DVRReadyResponse.config:type_name -> helmsmancontrol.DVRConfig
	6,  // 23: helmsmancontrol.NodeUpdate.StreamsEntry.value:type_name -> helmsmancontrol.StreamData
	0,  // 24: helmsmancontrol.HelmsmanControl.Connect:input_type -> helmsmancontrol.ControlMessage
	15, // 25: helmsmancontrol.HelmsmanControl.ResolveClipHash:input_type -> helmsmancontrol.ClipHashRequest
	0,  // 26: helmsmancontrol.HelmsmanControl.Connect:output_type -> helmsmancontrol.ControlMessage
	16, // 27: helmsmancontrol.HelmsmanControl.ResolveClipHash:output_type -> helmsmancontrol.ClipHashResponse
	26, // [26:28] is the sub-list for method output_type
	24, // [24:26] is the sub-list for method input_type
	24, // [24:24] is the sub-list for extension type_name
	24, // [24:24] is the sub-list for extension extendee
	0,  // [0:24] is the sub-list for field type_name
}

func init() { file_helmsman_control_proto_init() }
func file_helmsman_control_proto_init() {
	if File_helmsman_control_proto != nil {
		return
	}
	file_helmsman_control_proto_msgTypes[0].OneofWrappers = []any{
		(*ControlMessage_Register)(nil),
		(*ControlMessage_NodeUpdate)(nil),
		(*ControlMessage_ClipPullRequest)(nil),
		(*ControlMessage_ClipProgress)(nil),
		(*ControlMessage_ClipDone)(nil),
		(*ControlMessage_Error)(nil),
		(*ControlMessage_Heartbeat)(nil),
		(*ControlMessage_StreamHealthUpdate)(nil),
		(*ControlMessage_DvrStartRequest)(nil),
		(*ControlMessage_DvrProgress)(nil),
		(*ControlMessage_DvrStopped)(nil),
		(*ControlMessage_DvrStopRequest)(nil),
		(*ControlMessage_DvrReadyRequest)(nil),
		(*ControlMessage_DvrReadyResponse)(nil),
	}
	file_helmsman_control_proto_msgTypes[8].OneofWrappers = []any{}
	file_helmsman_control_proto_msgTypes[21].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_helmsman_control_proto_rawDesc), len(file_helmsman_control_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   25,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_helmsman_control_proto_goTypes,
		DependencyIndexes: file_helmsman_control_proto_depIdxs,
		MessageInfos:      file_helmsman_control_proto_msgTypes,
	}.Build()
	File_helmsman_control_proto = out.File
	file_helmsman_control_proto_goTypes = nil
	file_helmsman_control_proto_depIdxs = nil
}
