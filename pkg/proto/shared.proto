syntax = "proto3";

package shared;

option go_package = "frameworks/pkg/proto";

import "google/protobuf/timestamp.proto";
import "common.proto";

// ============================================================================
// SHARED MESSAGES FOR CLIPS AND DVR
// Used by both Foghorn and Commodore services
// ============================================================================

// ClipMode - specifies how clip time boundaries are interpreted
enum ClipMode {
  CLIP_MODE_UNSPECIFIED = 0;
  CLIP_MODE_ABSOLUTE = 1;   // start_unix + stop_unix (Unix timestamps in seconds)
  CLIP_MODE_RELATIVE = 2;   // start_ms + stop_ms (media time in seconds from stream start)
  CLIP_MODE_DURATION = 3;   // start_unix or start_ms + duration_sec
  CLIP_MODE_CLIP_NOW = 4;   // negative start_unix + duration_sec (relative to live)
}

// CreateClipRequest - request to create a clip from a stream
// Source: pkg/api/foghorn/types.go:CreateClipRequest
message CreateClipRequest {
  string tenant_id = 1;
  string internal_name = 2;
  string format = 3;
  string title = 4;
  string description = 5;
  optional int64 start_unix = 6;    // Unix timestamp (seconds), negative for relative-to-now
  optional int64 stop_unix = 7;     // Unix timestamp (seconds)
  optional int64 start_ms = 8;      // Media time (seconds from stream start) - legacy name, actually seconds
  optional int64 stop_ms = 9;       // Media time (seconds from stream start) - legacy name, actually seconds
  optional int64 duration_sec = 10; // Duration (seconds)
  ClipMode mode = 11;               // How to interpret the time fields
  optional int64 expires_at = 12;   // Unix timestamp (seconds) for auto-deletion
  optional string clip_hash = 13;   // Pre-generated hash from Commodore (if provided, Foghorn uses it)
  optional string user_id = 14;     // User who created the clip (for Decklog events)
  optional string stream_id = 15;  // Public stream ID (UUID)
  optional string playback_id = 16; // Pre-generated playback ID (Commodore)
  optional string artifact_internal_name = 17; // Pre-generated artifact routing name (Commodore)
  string cluster_id = 18;                      // Cluster this stream belongs to (set by caller)
}

// CreateClipResponse - response from clip creation
// Source: pkg/api/foghorn/types.go:CreateClipResponse
message CreateClipResponse {
  string status = 1;
  string ingest_host = 2;
  string storage_host = 3;
  string node_id = 4;
  string request_id = 5;
  string clip_hash = 6;
  string playback_id = 7;      // Public playback key (artifact playback ID)
}

// ClipInfo - full clip details
// Source: pkg/api/commodore/types.go:ClipFullResponse
message ClipInfo {
  string id = 1;
  string clip_hash = 2;
  string stream_id = 3;       // Public stream ID (UUID)
  string title = 4;
  string description = 5;
  int64 start_time = 6;       // Resolved start time (seconds)
  int64 duration = 7;         // Resolved duration (seconds)
  string node_id = 8;
  string storage_path = 9;
  optional int64 size_bytes = 10;
  string status = 11;
  google.protobuf.Timestamp created_at = 13;
  google.protobuf.Timestamp updated_at = 14;
  // NEW: Original request parameters for audit/display
  optional string clip_mode = 15;         // Mode used: absolute, relative, duration, clip_now
  optional string requested_params = 16;  // JSON blob of original request params
  optional string storage_location = 17;  // "local" or "s3"
  optional google.protobuf.Timestamp expires_at = 18;
  string playback_id = 20;                // Public playback key (artifact playback ID)
  reserved 12, 19;
  reserved "access_count", "last_accessed";
}

// GetClipsRequest - request to list clips
message GetClipsRequest {
  string tenant_id = 1;
  optional string stream_id = 2;      // filter by stream (UUID)
  common.CursorPaginationRequest pagination = 3;
}

// GetClipsResponse - paginated list of clips
message GetClipsResponse {
  repeated ClipInfo clips = 1;
  common.CursorPaginationResponse pagination = 2;
}

// GetClipRequest - request to get a single clip
message GetClipRequest {
  string clip_hash = 1;
  string tenant_id = 2;  // Required for tenant isolation
}

// DeleteClipRequest - request to delete a clip
message DeleteClipRequest {
  string clip_hash = 1;
  string tenant_id = 2;  // Required for tenant isolation
}

// DeleteClipResponse - response from clip deletion
message DeleteClipResponse {
  bool success = 1;
  string message = 2;
}

// ============================================================================
// DVR MESSAGES
// ============================================================================

// StartDVRRequest - request to start DVR recording
// Source: pkg/api/foghorn/types.go:StartDVRRequest
message StartDVRRequest {
  string tenant_id = 1;
  string internal_name = 2;
  optional string stream_id = 3;
  optional string user_id = 4;
  optional int64 expires_at = 5;   // Unix timestamp (seconds) for auto-deletion
  string cluster_id = 6;           // Cluster this stream belongs to (set by caller)
}

// StartDVRResponse - response from starting DVR
// Source: pkg/api/foghorn/types.go:StartDVRResponse
message StartDVRResponse {
  string status = 1;
  string dvr_hash = 2;
  string ingest_host = 3;
  string storage_host = 4;
  string storage_node_id = 5;
  string playback_id = 6;      // Public playback key (artifact playback ID)
}

// StopDVRRequest - request to stop DVR recording
message StopDVRRequest {
  string dvr_hash = 1;
  string tenant_id = 2;  // Required for tenant isolation
  optional string stream_id = 3; // Public stream ID (UUID)
}

// StopDVRResponse - response from stopping DVR
message StopDVRResponse {
  bool success = 1;
  string message = 2;
}

// DeleteDVRRequest - request to delete a DVR recording
message DeleteDVRRequest {
  string dvr_hash = 1;
  string tenant_id = 2;  // Required for tenant isolation
}

// DeleteDVRResponse - response from DVR deletion
message DeleteDVRResponse {
  bool success = 1;
  string message = 2;
}

// DVRInfo - full DVR recording details
// Source: pkg/api/foghorn/types.go:DVRInfo
message DVRInfo {
  string dvr_hash = 1;
  string internal_name = 2;
  string storage_node_id = 3;
  string status = 4;
  optional google.protobuf.Timestamp started_at = 5;
  optional google.protobuf.Timestamp ended_at = 6;
  optional int32 duration_seconds = 7;
  optional int64 size_bytes = 8;
  string manifest_path = 9;
  string error_message = 10;
  google.protobuf.Timestamp created_at = 11;
  google.protobuf.Timestamp updated_at = 12;
  // Cold storage fields
  optional string storage_location = 13;  // "local", "s3", "freezing", "defrosting"
  optional string s3_url = 14;
  optional google.protobuf.Timestamp frozen_at = 15;
  optional google.protobuf.Timestamp expires_at = 16;
  // Business metadata (from Commodore registry)
  optional string id = 17;     // UUID from commodore.dvr_recordings
  optional string title = 18;  // Stream title or custom title
  optional string stream_id = 19; // Public stream ID (UUID)
  optional string playback_id = 20; // Public playback key (artifact playback ID)
}

// ListDVRRecordingsRequest - request to list DVR recordings
message ListDVRRecordingsRequest {
  string tenant_id = 1;
  optional string stream_id = 2;  // filter by stream (UUID)
  common.CursorPaginationRequest pagination = 3;
}

// ListDVRRecordingsResponse - paginated list of DVR recordings
message ListDVRRecordingsResponse {
  repeated DVRInfo dvr_recordings = 1;
  common.CursorPaginationResponse pagination = 2;
}

// ============================================================================
// VIEWER ENDPOINT MESSAGES
// Used by both Foghorn and Commodore services
// ============================================================================

// ViewerEndpointRequest - request to resolve viewer endpoint
message ViewerEndpointRequest {
  reserved 1;
  reserved "content_type";
  string content_id = 2;
  optional string viewer_ip = 3;
}

// OutputCapability - capabilities of an output protocol
message OutputCapability {
  bool supports_seek = 1;
  bool supports_quality_switch = 2;
  int32 max_bitrate = 3;
  bool has_audio = 4;
  bool has_video = 5;
  repeated string codecs = 6;
}

// OutputEndpoint - a single output endpoint with protocol info
message OutputEndpoint {
  string protocol = 1;
  string url = 2;
  OutputCapability capabilities = 3;
}

// ViewerEndpoint - resolved endpoint for a viewer
message ViewerEndpoint {
  string node_id = 1;
  string base_url = 2;
  string protocol = 3;
  string url = 4;
  double geo_distance = 5;
  double load_score = 6;
  // REMOVED: health_score = 7 (derived metric)
  map<string, OutputEndpoint> outputs = 8;
  string cluster_id = 9; // non-empty for remote edges from peer clusters
}

// PlaybackTrack - track information for playback
message PlaybackTrack {
  string type = 1;
  string codec = 2;
  int32 bitrate_kbps = 3;
  int32 width = 4;
  int32 height = 5;
  int32 channels = 6;
  int32 sample_rate = 7;
}

// PlaybackInstance - per-node stats for a stream instance
message PlaybackInstance {
  string node_id = 1;
  int32 viewers = 2;
  string buffer_state = 3;
  int64 bytes_up = 4;
  int64 bytes_down = 5;
  int32 total_connections = 6;
  int32 inputs = 7;
  google.protobuf.Timestamp last_update = 8;
}

// PlaybackMetadata - metadata for playback content
message PlaybackMetadata {
  string status = 1;
  bool is_live = 2;
  int32 viewers = 3;
  string buffer_state = 4;
  // REMOVED: health_score = 5 (derived metric)
  repeated PlaybackTrack tracks = 6;
  repeated string protocol_hints = 7;
  repeated PlaybackInstance instances = 8;
  string dvr_status = 9;
  string dvr_source_uri = 10;
  string tenant_id = 11;
  optional string stream_id = 21;  // Public stream ID (UUID)
  string content_id = 12;
  string content_type = 13;
  optional string title = 14;
  optional string description = 15;
  optional int32 duration_seconds = 16;
  optional int64 recording_size_bytes = 17;
  optional string clip_source = 18;
  optional google.protobuf.Timestamp created_at = 19;
  optional string format = 20;  // Native container format: mp4, m3u8, webm, etc.
}

// ViewerEndpointResponse - response with resolved endpoints
message ViewerEndpointResponse {
  ViewerEndpoint primary = 1;
  repeated ViewerEndpoint fallbacks = 2;
  optional PlaybackMetadata metadata = 3;
}

// ============================================================================
// INGEST ENDPOINT MESSAGES
// Used by Foghorn for StreamCrafter ingest endpoint resolution
// ============================================================================

// IngestEndpointRequest - request to resolve ingest endpoint for streaming
message IngestEndpointRequest {
  string stream_key = 1;
  optional string viewer_ip = 2;  // For geo-routing (client IP)
}

// IngestEndpoint - resolved ingest endpoint for a stream
message IngestEndpoint {
  string node_id = 1;
  string base_url = 2;
  optional string whip_url = 3;   // WHIP ingest URL
  optional string rtmp_url = 4;   // RTMP ingest URL
  optional string srt_url = 5;    // SRT ingest URL
  optional string region = 6;
  optional double load_score = 7;
}

// IngestMetadata - metadata about the stream for ingest
message IngestMetadata {
  string stream_id = 1;        // Public stream ID (UUID)
  string stream_key = 2;       // Original stream key (ingest key)
  string tenant_id = 3;
  bool recording_enabled = 4;
  optional string title = 5;
  optional string description = 6;
}

// IngestEndpointResponse - response with resolved ingest endpoints
message IngestEndpointResponse {
  IngestEndpoint primary = 1;
  repeated IngestEndpoint fallbacks = 2;
  optional IngestMetadata metadata = 3;
}

// ============================================================================
// VOD UPLOAD MESSAGES
// User-initiated video file uploads (distinct from clips/DVR which are derived)
// ============================================================================

// VodStatus - status of a VOD upload (named differently from GraphQL VodAssetStatus to avoid autobind)
enum VodStatus {
  VOD_STATUS_UNSPECIFIED = 0;
  VOD_STATUS_UPLOADING = 1;    // S3 multipart upload in progress
  VOD_STATUS_PROCESSING = 2;   // Validating and extracting metadata
  VOD_STATUS_READY = 3;        // Ready for playback
  VOD_STATUS_FAILED = 4;       // Validation or upload failed
  VOD_STATUS_DELETED = 5;      // Marked for deletion
}

// CreateVodUploadRequest - initiate a multipart upload
message CreateVodUploadRequest {
  string tenant_id = 1;
  string user_id = 2;
  string filename = 3;           // Original filename
  int64 size_bytes = 4;          // Total file size (for part calculation)
  optional string content_type = 5;  // MIME type (video/mp4, etc.)
  optional string title = 6;
  optional string description = 7;
  optional string vod_hash = 8;  // Pre-generated by Commodore (if provided, Foghorn uses it)
  optional string playback_id = 9;          // Pre-generated playback ID (Commodore)
  optional string artifact_internal_name = 10; // Pre-generated artifact routing name (Commodore)
  string cluster_id = 11;                      // Cluster for this tenant's context (set by caller)
}

// CreateVodUploadResponse - multipart upload instructions
message CreateVodUploadResponse {
  string upload_id = 1;          // S3 multipart upload ID
  string artifact_id = 2;        // ID in live_artifacts table
  string artifact_hash = 3;      // Hash for playback URL resolution
  int64 part_size = 4;           // Recommended part size (bytes)
  repeated VodUploadPart parts = 5;  // Presigned URLs for each part
  google.protobuf.Timestamp expires_at = 6;  // When URLs expire
  string playback_id = 7;        // Public playback key (artifact playback ID)
}

// VodUploadPart - presigned URL for a single part
message VodUploadPart {
  int32 part_number = 1;         // 1-indexed part number
  string presigned_url = 2;      // PUT URL for this part
}

// CompleteVodUploadRequest - finalize multipart upload
message CompleteVodUploadRequest {
  string tenant_id = 1;
  string upload_id = 2;          // S3 multipart upload ID
  repeated VodCompletedPart parts = 3;  // ETags from uploaded parts
}

// VodCompletedPart - ETag from uploaded part
message VodCompletedPart {
  int32 part_number = 1;
  string etag = 2;               // ETag returned by S3
}

// CompleteVodUploadResponse - completed upload info
message CompleteVodUploadResponse {
  VodAssetInfo asset = 1;
}

// AbortVodUploadRequest - cancel multipart upload
message AbortVodUploadRequest {
  string tenant_id = 1;
  string upload_id = 2;
}

// AbortVodUploadResponse - abort confirmation
message AbortVodUploadResponse {
  bool success = 1;
  string message = 2;
}

// DeleteVodAssetRequest - delete a VOD asset
message DeleteVodAssetRequest {
  string tenant_id = 1;
  string artifact_hash = 2;
}

// DeleteVodAssetResponse - delete confirmation
message DeleteVodAssetResponse {
  bool success = 1;
  string message = 2;
}

// GetVodAssetRequest - get a single VOD asset
message GetVodAssetRequest {
  string tenant_id = 1;
  string artifact_hash = 2;
}

// ListVodAssetsRequest - list VOD assets
message ListVodAssetsRequest {
  string tenant_id = 1;
  common.CursorPaginationRequest pagination = 2;
}

// ListVodAssetsResponse - paginated list of VOD assets
message ListVodAssetsResponse {
  repeated VodAssetInfo assets = 1;
  common.CursorPaginationResponse pagination = 2;
}

// VodAssetInfo - full VOD asset details (named differently from GraphQL VodAsset to avoid autobind collision)
message VodAssetInfo {
  string id = 1;                 // UUID from live_artifacts
  string artifact_hash = 2;      // Hash for playback URL resolution
  string title = 3;
  string description = 4;
  string filename = 5;           // Original uploaded filename
  VodStatus status = 6;
  string storage_location = 7;   // "s3", "local", "freezing", "defrosting"

  // File metadata (populated after validation)
  optional int64 size_bytes = 8;
  optional int32 duration_ms = 9;    // Video duration in milliseconds
  optional string resolution = 10;   // e.g., "1920x1080"
  optional string video_codec = 11;  // e.g., "h264", "h265", "vp9"
  optional string audio_codec = 12;  // e.g., "aac", "opus"
  optional int32 bitrate_kbps = 13;  // Average bitrate

  // S3 multipart tracking (internal)
  optional string s3_upload_id = 14;
  optional string s3_key = 15;

  // Timestamps
  google.protobuf.Timestamp created_at = 16;
  google.protobuf.Timestamp updated_at = 17;
  optional google.protobuf.Timestamp expires_at = 18;

  // Error info
  optional string error_message = 19;
  optional string playback_id = 20; // Public playback key (artifact playback ID)
}

// VodMetadata - metadata extracted from video file (returned by validation)
message VodMetadata {
  int32 duration_ms = 1;
  string resolution = 2;         // "1920x1080"
  string video_codec = 3;        // "h264"
  string audio_codec = 4;        // "aac"
  int32 bitrate_kbps = 5;
  optional int32 width = 6;
  optional int32 height = 7;
  optional float fps = 8;
  optional int32 audio_channels = 9;
  optional int32 audio_sample_rate = 10;
}

// ============================================================================
// WEBHOOK MESSAGES
// Generic webhook envelope for routing external webhooks through the gateway
// to internal services. Signature verification happens in the receiving service.
// ============================================================================

// WebhookRequest - envelope for routing webhooks from Gateway to internal services
// The Gateway packages raw HTTP into this message and routes via gRPC.
// Signature verification is the responsibility of the receiving service.
message WebhookRequest {
  string provider = 1;              // Provider identifier: "stripe", "mollie", "github", etc.
  bytes body = 2;                   // Raw HTTP request body
  map<string, string> headers = 3;  // HTTP headers (includes signature headers like Stripe-Signature)
  string source_ip = 4;             // Client IP address for logging/rate limiting
  int64 received_at = 5;            // Unix timestamp when Gateway received the request
}

// WebhookResponse - response from internal service back to Gateway
message WebhookResponse {
  bool success = 1;                 // Whether the webhook was processed successfully
  string error = 2;                 // Error message if processing failed
  int32 status_code = 3;            // HTTP status code to return to the provider (200, 400, 401, 500)
}
