// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: commodore.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	InternalService_ValidateStreamKey_FullMethodName           = "/commodore.InternalService/ValidateStreamKey"
	InternalService_ResolvePlaybackID_FullMethodName           = "/commodore.InternalService/ResolvePlaybackID"
	InternalService_ResolveInternalName_FullMethodName         = "/commodore.InternalService/ResolveInternalName"
	InternalService_ValidateAPIToken_FullMethodName            = "/commodore.InternalService/ValidateAPIToken"
	InternalService_StartDVR_FullMethodName                    = "/commodore.InternalService/StartDVR"
	InternalService_RegisterClip_FullMethodName                = "/commodore.InternalService/RegisterClip"
	InternalService_RegisterDVR_FullMethodName                 = "/commodore.InternalService/RegisterDVR"
	InternalService_ResolveClipHash_FullMethodName             = "/commodore.InternalService/ResolveClipHash"
	InternalService_ResolveDVRHash_FullMethodName              = "/commodore.InternalService/ResolveDVRHash"
	InternalService_ResolveArtifactPlaybackID_FullMethodName   = "/commodore.InternalService/ResolveArtifactPlaybackID"
	InternalService_ResolveArtifactInternalName_FullMethodName = "/commodore.InternalService/ResolveArtifactInternalName"
	InternalService_ResolveIdentifier_FullMethodName           = "/commodore.InternalService/ResolveIdentifier"
	InternalService_RegisterVod_FullMethodName                 = "/commodore.InternalService/RegisterVod"
	InternalService_ResolveVodHash_FullMethodName              = "/commodore.InternalService/ResolveVodHash"
	InternalService_ResolveVodID_FullMethodName                = "/commodore.InternalService/ResolveVodID"
	InternalService_GetOrCreateWalletUser_FullMethodName       = "/commodore.InternalService/GetOrCreateWalletUser"
	InternalService_TerminateTenantStreams_FullMethodName      = "/commodore.InternalService/TerminateTenantStreams"
	InternalService_InvalidateTenantCache_FullMethodName       = "/commodore.InternalService/InvalidateTenantCache"
	InternalService_GetTenantUserCount_FullMethodName          = "/commodore.InternalService/GetTenantUserCount"
	InternalService_GetTenantPrimaryUser_FullMethodName        = "/commodore.InternalService/GetTenantPrimaryUser"
)

// InternalServiceClient is the client API for InternalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InternalServiceClient interface {
	// Called by Foghorn on PUSH_REWRITE to validate stream key
	// Source: pkg/api/commodore/types.go:ValidateStreamKeyResponse
	ValidateStreamKey(ctx context.Context, in *ValidateStreamKeyRequest, opts ...grpc.CallOption) (*ValidateStreamKeyResponse, error)
	// Called by edge nodes to resolve playback ID to internal name
	// Source: pkg/api/commodore/types.go:ResolvePlaybackIDResponse
	ResolvePlaybackID(ctx context.Context, in *ResolvePlaybackIDRequest, opts ...grpc.CallOption) (*ResolvePlaybackIDResponse, error)
	// Called by Decklog/Foghorn to enrich events with tenant context
	// Source: pkg/api/commodore/types.go:InternalNameResponse
	ResolveInternalName(ctx context.Context, in *ResolveInternalNameRequest, opts ...grpc.CallOption) (*ResolveInternalNameResponse, error)
	// Called by Gateway to validate developer API tokens
	// Source: pkg/api/commodore/types.go:ValidateAPITokenResponse
	ValidateAPIToken(ctx context.Context, in *ValidateAPITokenRequest, opts ...grpc.CallOption) (*ValidateAPITokenResponse, error)
	// Called by Foghorn to initiate DVR recording for a stream
	StartDVR(ctx context.Context, in *StartDVRRequest, opts ...grpc.CallOption) (*StartDVRResponse, error)
	// Register a new clip in the business registry (called by Foghorn during CreateClip)
	RegisterClip(ctx context.Context, in *RegisterClipRequest, opts ...grpc.CallOption) (*RegisterClipResponse, error)
	// Register a new DVR recording in the business registry (called by Foghorn during StartDVR)
	RegisterDVR(ctx context.Context, in *RegisterDVRRequest, opts ...grpc.CallOption) (*RegisterDVRResponse, error)
	// Resolve clip hash to tenant context (for analytics enrichment and playback)
	ResolveClipHash(ctx context.Context, in *ResolveClipHashRequest, opts ...grpc.CallOption) (*ResolveClipHashResponse, error)
	// Resolve DVR hash to tenant context (for analytics enrichment and playback)
	ResolveDVRHash(ctx context.Context, in *ResolveDVRHashRequest, opts ...grpc.CallOption) (*ResolveDVRHashResponse, error)
	// Resolve artifact playback ID to artifact identity (clip/dvr/vod)
	ResolveArtifactPlaybackID(ctx context.Context, in *ResolveArtifactPlaybackIDRequest, opts ...grpc.CallOption) (*ResolveArtifactPlaybackIDResponse, error)
	// Resolve artifact internal routing name to artifact identity (clip/dvr/vod)
	ResolveArtifactInternalName(ctx context.Context, in *ResolveArtifactInternalNameRequest, opts ...grpc.CallOption) (*ResolveArtifactInternalNameResponse, error)
	// Unified identifier resolution - checks streams, clips, and DVR in one call
	// Used by Foghorn for analytics enrichment when local state cache misses
	ResolveIdentifier(ctx context.Context, in *ResolveIdentifierRequest, opts ...grpc.CallOption) (*ResolveIdentifierResponse, error)
	// Register a new VOD asset in the business registry (called by Foghorn during CreateVodUpload)
	RegisterVod(ctx context.Context, in *RegisterVodRequest, opts ...grpc.CallOption) (*RegisterVodResponse, error)
	// Resolve VOD hash to tenant context (for analytics enrichment and playback)
	ResolveVodHash(ctx context.Context, in *ResolveVodHashRequest, opts ...grpc.CallOption) (*ResolveVodHashResponse, error)
	// Resolve VOD relay ID (vod_assets.id) to VOD hash + tenant context
	ResolveVodID(ctx context.Context, in *ResolveVodIDRequest, opts ...grpc.CallOption) (*ResolveVodIDResponse, error)
	// Lookup or create a tenant/user for a verified wallet address.
	// Called by x402 middleware after verifying ERC-3009 payment signature.
	// If wallet is unknown, creates: tenant (prepaid) + user (email=NULL) + wallet_identity
	GetOrCreateWalletUser(ctx context.Context, in *GetOrCreateWalletUserRequest, opts ...grpc.CallOption) (*GetOrCreateWalletUserResponse, error)
	// ============================================================================
	// TENANT STREAM TERMINATION (Purser → Commodore → Foghorn)
	// Called when a tenant is suspended due to insufficient prepaid balance.
	// Commodore forwards to Foghorn which stops all sessions on affected nodes.
	// ============================================================================
	TerminateTenantStreams(ctx context.Context, in *TerminateTenantStreamsRequest, opts ...grpc.CallOption) (*TerminateTenantStreamsResponse, error)
	// ============================================================================
	// TENANT CACHE INVALIDATION (Purser → Commodore → Foghorn)
	// Called when a tenant is reactivated after payment.
	// Commodore forwards to Foghorn which clears cached suspension status.
	// ============================================================================
	InvalidateTenantCache(ctx context.Context, in *InvalidateTenantCacheRequest, opts ...grpc.CallOption) (*InvalidateTenantCacheResponse, error)
	// Get active user count for a tenant (for billing calculation)
	GetTenantUserCount(ctx context.Context, in *GetTenantUserCountRequest, opts ...grpc.CallOption) (*GetTenantUserCountResponse, error)
	// Get primary user info for a tenant (for billing notifications/invoices)
	GetTenantPrimaryUser(ctx context.Context, in *GetTenantPrimaryUserRequest, opts ...grpc.CallOption) (*GetTenantPrimaryUserResponse, error)
}

type internalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInternalServiceClient(cc grpc.ClientConnInterface) InternalServiceClient {
	return &internalServiceClient{cc}
}

func (c *internalServiceClient) ValidateStreamKey(ctx context.Context, in *ValidateStreamKeyRequest, opts ...grpc.CallOption) (*ValidateStreamKeyResponse, error) {
	out := new(ValidateStreamKeyResponse)
	err := c.cc.Invoke(ctx, InternalService_ValidateStreamKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ResolvePlaybackID(ctx context.Context, in *ResolvePlaybackIDRequest, opts ...grpc.CallOption) (*ResolvePlaybackIDResponse, error) {
	out := new(ResolvePlaybackIDResponse)
	err := c.cc.Invoke(ctx, InternalService_ResolvePlaybackID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ResolveInternalName(ctx context.Context, in *ResolveInternalNameRequest, opts ...grpc.CallOption) (*ResolveInternalNameResponse, error) {
	out := new(ResolveInternalNameResponse)
	err := c.cc.Invoke(ctx, InternalService_ResolveInternalName_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ValidateAPIToken(ctx context.Context, in *ValidateAPITokenRequest, opts ...grpc.CallOption) (*ValidateAPITokenResponse, error) {
	out := new(ValidateAPITokenResponse)
	err := c.cc.Invoke(ctx, InternalService_ValidateAPIToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) StartDVR(ctx context.Context, in *StartDVRRequest, opts ...grpc.CallOption) (*StartDVRResponse, error) {
	out := new(StartDVRResponse)
	err := c.cc.Invoke(ctx, InternalService_StartDVR_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) RegisterClip(ctx context.Context, in *RegisterClipRequest, opts ...grpc.CallOption) (*RegisterClipResponse, error) {
	out := new(RegisterClipResponse)
	err := c.cc.Invoke(ctx, InternalService_RegisterClip_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) RegisterDVR(ctx context.Context, in *RegisterDVRRequest, opts ...grpc.CallOption) (*RegisterDVRResponse, error) {
	out := new(RegisterDVRResponse)
	err := c.cc.Invoke(ctx, InternalService_RegisterDVR_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ResolveClipHash(ctx context.Context, in *ResolveClipHashRequest, opts ...grpc.CallOption) (*ResolveClipHashResponse, error) {
	out := new(ResolveClipHashResponse)
	err := c.cc.Invoke(ctx, InternalService_ResolveClipHash_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ResolveDVRHash(ctx context.Context, in *ResolveDVRHashRequest, opts ...grpc.CallOption) (*ResolveDVRHashResponse, error) {
	out := new(ResolveDVRHashResponse)
	err := c.cc.Invoke(ctx, InternalService_ResolveDVRHash_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ResolveArtifactPlaybackID(ctx context.Context, in *ResolveArtifactPlaybackIDRequest, opts ...grpc.CallOption) (*ResolveArtifactPlaybackIDResponse, error) {
	out := new(ResolveArtifactPlaybackIDResponse)
	err := c.cc.Invoke(ctx, InternalService_ResolveArtifactPlaybackID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ResolveArtifactInternalName(ctx context.Context, in *ResolveArtifactInternalNameRequest, opts ...grpc.CallOption) (*ResolveArtifactInternalNameResponse, error) {
	out := new(ResolveArtifactInternalNameResponse)
	err := c.cc.Invoke(ctx, InternalService_ResolveArtifactInternalName_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ResolveIdentifier(ctx context.Context, in *ResolveIdentifierRequest, opts ...grpc.CallOption) (*ResolveIdentifierResponse, error) {
	out := new(ResolveIdentifierResponse)
	err := c.cc.Invoke(ctx, InternalService_ResolveIdentifier_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) RegisterVod(ctx context.Context, in *RegisterVodRequest, opts ...grpc.CallOption) (*RegisterVodResponse, error) {
	out := new(RegisterVodResponse)
	err := c.cc.Invoke(ctx, InternalService_RegisterVod_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ResolveVodHash(ctx context.Context, in *ResolveVodHashRequest, opts ...grpc.CallOption) (*ResolveVodHashResponse, error) {
	out := new(ResolveVodHashResponse)
	err := c.cc.Invoke(ctx, InternalService_ResolveVodHash_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ResolveVodID(ctx context.Context, in *ResolveVodIDRequest, opts ...grpc.CallOption) (*ResolveVodIDResponse, error) {
	out := new(ResolveVodIDResponse)
	err := c.cc.Invoke(ctx, InternalService_ResolveVodID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) GetOrCreateWalletUser(ctx context.Context, in *GetOrCreateWalletUserRequest, opts ...grpc.CallOption) (*GetOrCreateWalletUserResponse, error) {
	out := new(GetOrCreateWalletUserResponse)
	err := c.cc.Invoke(ctx, InternalService_GetOrCreateWalletUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) TerminateTenantStreams(ctx context.Context, in *TerminateTenantStreamsRequest, opts ...grpc.CallOption) (*TerminateTenantStreamsResponse, error) {
	out := new(TerminateTenantStreamsResponse)
	err := c.cc.Invoke(ctx, InternalService_TerminateTenantStreams_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) InvalidateTenantCache(ctx context.Context, in *InvalidateTenantCacheRequest, opts ...grpc.CallOption) (*InvalidateTenantCacheResponse, error) {
	out := new(InvalidateTenantCacheResponse)
	err := c.cc.Invoke(ctx, InternalService_InvalidateTenantCache_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) GetTenantUserCount(ctx context.Context, in *GetTenantUserCountRequest, opts ...grpc.CallOption) (*GetTenantUserCountResponse, error) {
	out := new(GetTenantUserCountResponse)
	err := c.cc.Invoke(ctx, InternalService_GetTenantUserCount_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) GetTenantPrimaryUser(ctx context.Context, in *GetTenantPrimaryUserRequest, opts ...grpc.CallOption) (*GetTenantPrimaryUserResponse, error) {
	out := new(GetTenantPrimaryUserResponse)
	err := c.cc.Invoke(ctx, InternalService_GetTenantPrimaryUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InternalServiceServer is the server API for InternalService service.
// All implementations must embed UnimplementedInternalServiceServer
// for forward compatibility
type InternalServiceServer interface {
	// Called by Foghorn on PUSH_REWRITE to validate stream key
	// Source: pkg/api/commodore/types.go:ValidateStreamKeyResponse
	ValidateStreamKey(context.Context, *ValidateStreamKeyRequest) (*ValidateStreamKeyResponse, error)
	// Called by edge nodes to resolve playback ID to internal name
	// Source: pkg/api/commodore/types.go:ResolvePlaybackIDResponse
	ResolvePlaybackID(context.Context, *ResolvePlaybackIDRequest) (*ResolvePlaybackIDResponse, error)
	// Called by Decklog/Foghorn to enrich events with tenant context
	// Source: pkg/api/commodore/types.go:InternalNameResponse
	ResolveInternalName(context.Context, *ResolveInternalNameRequest) (*ResolveInternalNameResponse, error)
	// Called by Gateway to validate developer API tokens
	// Source: pkg/api/commodore/types.go:ValidateAPITokenResponse
	ValidateAPIToken(context.Context, *ValidateAPITokenRequest) (*ValidateAPITokenResponse, error)
	// Called by Foghorn to initiate DVR recording for a stream
	StartDVR(context.Context, *StartDVRRequest) (*StartDVRResponse, error)
	// Register a new clip in the business registry (called by Foghorn during CreateClip)
	RegisterClip(context.Context, *RegisterClipRequest) (*RegisterClipResponse, error)
	// Register a new DVR recording in the business registry (called by Foghorn during StartDVR)
	RegisterDVR(context.Context, *RegisterDVRRequest) (*RegisterDVRResponse, error)
	// Resolve clip hash to tenant context (for analytics enrichment and playback)
	ResolveClipHash(context.Context, *ResolveClipHashRequest) (*ResolveClipHashResponse, error)
	// Resolve DVR hash to tenant context (for analytics enrichment and playback)
	ResolveDVRHash(context.Context, *ResolveDVRHashRequest) (*ResolveDVRHashResponse, error)
	// Resolve artifact playback ID to artifact identity (clip/dvr/vod)
	ResolveArtifactPlaybackID(context.Context, *ResolveArtifactPlaybackIDRequest) (*ResolveArtifactPlaybackIDResponse, error)
	// Resolve artifact internal routing name to artifact identity (clip/dvr/vod)
	ResolveArtifactInternalName(context.Context, *ResolveArtifactInternalNameRequest) (*ResolveArtifactInternalNameResponse, error)
	// Unified identifier resolution - checks streams, clips, and DVR in one call
	// Used by Foghorn for analytics enrichment when local state cache misses
	ResolveIdentifier(context.Context, *ResolveIdentifierRequest) (*ResolveIdentifierResponse, error)
	// Register a new VOD asset in the business registry (called by Foghorn during CreateVodUpload)
	RegisterVod(context.Context, *RegisterVodRequest) (*RegisterVodResponse, error)
	// Resolve VOD hash to tenant context (for analytics enrichment and playback)
	ResolveVodHash(context.Context, *ResolveVodHashRequest) (*ResolveVodHashResponse, error)
	// Resolve VOD relay ID (vod_assets.id) to VOD hash + tenant context
	ResolveVodID(context.Context, *ResolveVodIDRequest) (*ResolveVodIDResponse, error)
	// Lookup or create a tenant/user for a verified wallet address.
	// Called by x402 middleware after verifying ERC-3009 payment signature.
	// If wallet is unknown, creates: tenant (prepaid) + user (email=NULL) + wallet_identity
	GetOrCreateWalletUser(context.Context, *GetOrCreateWalletUserRequest) (*GetOrCreateWalletUserResponse, error)
	// ============================================================================
	// TENANT STREAM TERMINATION (Purser → Commodore → Foghorn)
	// Called when a tenant is suspended due to insufficient prepaid balance.
	// Commodore forwards to Foghorn which stops all sessions on affected nodes.
	// ============================================================================
	TerminateTenantStreams(context.Context, *TerminateTenantStreamsRequest) (*TerminateTenantStreamsResponse, error)
	// ============================================================================
	// TENANT CACHE INVALIDATION (Purser → Commodore → Foghorn)
	// Called when a tenant is reactivated after payment.
	// Commodore forwards to Foghorn which clears cached suspension status.
	// ============================================================================
	InvalidateTenantCache(context.Context, *InvalidateTenantCacheRequest) (*InvalidateTenantCacheResponse, error)
	// Get active user count for a tenant (for billing calculation)
	GetTenantUserCount(context.Context, *GetTenantUserCountRequest) (*GetTenantUserCountResponse, error)
	// Get primary user info for a tenant (for billing notifications/invoices)
	GetTenantPrimaryUser(context.Context, *GetTenantPrimaryUserRequest) (*GetTenantPrimaryUserResponse, error)
	mustEmbedUnimplementedInternalServiceServer()
}

// UnimplementedInternalServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInternalServiceServer struct {
}

func (UnimplementedInternalServiceServer) ValidateStreamKey(context.Context, *ValidateStreamKeyRequest) (*ValidateStreamKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateStreamKey not implemented")
}
func (UnimplementedInternalServiceServer) ResolvePlaybackID(context.Context, *ResolvePlaybackIDRequest) (*ResolvePlaybackIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolvePlaybackID not implemented")
}
func (UnimplementedInternalServiceServer) ResolveInternalName(context.Context, *ResolveInternalNameRequest) (*ResolveInternalNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveInternalName not implemented")
}
func (UnimplementedInternalServiceServer) ValidateAPIToken(context.Context, *ValidateAPITokenRequest) (*ValidateAPITokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAPIToken not implemented")
}
func (UnimplementedInternalServiceServer) StartDVR(context.Context, *StartDVRRequest) (*StartDVRResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartDVR not implemented")
}
func (UnimplementedInternalServiceServer) RegisterClip(context.Context, *RegisterClipRequest) (*RegisterClipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterClip not implemented")
}
func (UnimplementedInternalServiceServer) RegisterDVR(context.Context, *RegisterDVRRequest) (*RegisterDVRResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterDVR not implemented")
}
func (UnimplementedInternalServiceServer) ResolveClipHash(context.Context, *ResolveClipHashRequest) (*ResolveClipHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveClipHash not implemented")
}
func (UnimplementedInternalServiceServer) ResolveDVRHash(context.Context, *ResolveDVRHashRequest) (*ResolveDVRHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveDVRHash not implemented")
}
func (UnimplementedInternalServiceServer) ResolveArtifactPlaybackID(context.Context, *ResolveArtifactPlaybackIDRequest) (*ResolveArtifactPlaybackIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveArtifactPlaybackID not implemented")
}
func (UnimplementedInternalServiceServer) ResolveArtifactInternalName(context.Context, *ResolveArtifactInternalNameRequest) (*ResolveArtifactInternalNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveArtifactInternalName not implemented")
}
func (UnimplementedInternalServiceServer) ResolveIdentifier(context.Context, *ResolveIdentifierRequest) (*ResolveIdentifierResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveIdentifier not implemented")
}
func (UnimplementedInternalServiceServer) RegisterVod(context.Context, *RegisterVodRequest) (*RegisterVodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterVod not implemented")
}
func (UnimplementedInternalServiceServer) ResolveVodHash(context.Context, *ResolveVodHashRequest) (*ResolveVodHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveVodHash not implemented")
}
func (UnimplementedInternalServiceServer) ResolveVodID(context.Context, *ResolveVodIDRequest) (*ResolveVodIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveVodID not implemented")
}
func (UnimplementedInternalServiceServer) GetOrCreateWalletUser(context.Context, *GetOrCreateWalletUserRequest) (*GetOrCreateWalletUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrCreateWalletUser not implemented")
}
func (UnimplementedInternalServiceServer) TerminateTenantStreams(context.Context, *TerminateTenantStreamsRequest) (*TerminateTenantStreamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateTenantStreams not implemented")
}
func (UnimplementedInternalServiceServer) InvalidateTenantCache(context.Context, *InvalidateTenantCacheRequest) (*InvalidateTenantCacheResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InvalidateTenantCache not implemented")
}
func (UnimplementedInternalServiceServer) GetTenantUserCount(context.Context, *GetTenantUserCountRequest) (*GetTenantUserCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTenantUserCount not implemented")
}
func (UnimplementedInternalServiceServer) GetTenantPrimaryUser(context.Context, *GetTenantPrimaryUserRequest) (*GetTenantPrimaryUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTenantPrimaryUser not implemented")
}
func (UnimplementedInternalServiceServer) mustEmbedUnimplementedInternalServiceServer() {}

// UnsafeInternalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InternalServiceServer will
// result in compilation errors.
type UnsafeInternalServiceServer interface {
	mustEmbedUnimplementedInternalServiceServer()
}

func RegisterInternalServiceServer(s grpc.ServiceRegistrar, srv InternalServiceServer) {
	s.RegisterService(&InternalService_ServiceDesc, srv)
}

func _InternalService_ValidateStreamKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateStreamKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ValidateStreamKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ValidateStreamKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ValidateStreamKey(ctx, req.(*ValidateStreamKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ResolvePlaybackID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolvePlaybackIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ResolvePlaybackID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ResolvePlaybackID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ResolvePlaybackID(ctx, req.(*ResolvePlaybackIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ResolveInternalName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveInternalNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ResolveInternalName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ResolveInternalName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ResolveInternalName(ctx, req.(*ResolveInternalNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ValidateAPIToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateAPITokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ValidateAPIToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ValidateAPIToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ValidateAPIToken(ctx, req.(*ValidateAPITokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_StartDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).StartDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_StartDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).StartDVR(ctx, req.(*StartDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_RegisterClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).RegisterClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_RegisterClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).RegisterClip(ctx, req.(*RegisterClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_RegisterDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).RegisterDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_RegisterDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).RegisterDVR(ctx, req.(*RegisterDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ResolveClipHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveClipHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ResolveClipHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ResolveClipHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ResolveClipHash(ctx, req.(*ResolveClipHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ResolveDVRHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveDVRHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ResolveDVRHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ResolveDVRHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ResolveDVRHash(ctx, req.(*ResolveDVRHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ResolveArtifactPlaybackID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveArtifactPlaybackIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ResolveArtifactPlaybackID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ResolveArtifactPlaybackID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ResolveArtifactPlaybackID(ctx, req.(*ResolveArtifactPlaybackIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ResolveArtifactInternalName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveArtifactInternalNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ResolveArtifactInternalName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ResolveArtifactInternalName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ResolveArtifactInternalName(ctx, req.(*ResolveArtifactInternalNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ResolveIdentifier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveIdentifierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ResolveIdentifier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ResolveIdentifier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ResolveIdentifier(ctx, req.(*ResolveIdentifierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_RegisterVod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterVodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).RegisterVod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_RegisterVod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).RegisterVod(ctx, req.(*RegisterVodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ResolveVodHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveVodHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ResolveVodHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ResolveVodHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ResolveVodHash(ctx, req.(*ResolveVodHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ResolveVodID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveVodIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ResolveVodID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ResolveVodID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ResolveVodID(ctx, req.(*ResolveVodIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_GetOrCreateWalletUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrCreateWalletUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).GetOrCreateWalletUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_GetOrCreateWalletUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).GetOrCreateWalletUser(ctx, req.(*GetOrCreateWalletUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_TerminateTenantStreams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateTenantStreamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).TerminateTenantStreams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_TerminateTenantStreams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).TerminateTenantStreams(ctx, req.(*TerminateTenantStreamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_InvalidateTenantCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvalidateTenantCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).InvalidateTenantCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_InvalidateTenantCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).InvalidateTenantCache(ctx, req.(*InvalidateTenantCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_GetTenantUserCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTenantUserCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).GetTenantUserCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_GetTenantUserCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).GetTenantUserCount(ctx, req.(*GetTenantUserCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_GetTenantPrimaryUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTenantPrimaryUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).GetTenantPrimaryUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_GetTenantPrimaryUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).GetTenantPrimaryUser(ctx, req.(*GetTenantPrimaryUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InternalService_ServiceDesc is the grpc.ServiceDesc for InternalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InternalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.InternalService",
	HandlerType: (*InternalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateStreamKey",
			Handler:    _InternalService_ValidateStreamKey_Handler,
		},
		{
			MethodName: "ResolvePlaybackID",
			Handler:    _InternalService_ResolvePlaybackID_Handler,
		},
		{
			MethodName: "ResolveInternalName",
			Handler:    _InternalService_ResolveInternalName_Handler,
		},
		{
			MethodName: "ValidateAPIToken",
			Handler:    _InternalService_ValidateAPIToken_Handler,
		},
		{
			MethodName: "StartDVR",
			Handler:    _InternalService_StartDVR_Handler,
		},
		{
			MethodName: "RegisterClip",
			Handler:    _InternalService_RegisterClip_Handler,
		},
		{
			MethodName: "RegisterDVR",
			Handler:    _InternalService_RegisterDVR_Handler,
		},
		{
			MethodName: "ResolveClipHash",
			Handler:    _InternalService_ResolveClipHash_Handler,
		},
		{
			MethodName: "ResolveDVRHash",
			Handler:    _InternalService_ResolveDVRHash_Handler,
		},
		{
			MethodName: "ResolveArtifactPlaybackID",
			Handler:    _InternalService_ResolveArtifactPlaybackID_Handler,
		},
		{
			MethodName: "ResolveArtifactInternalName",
			Handler:    _InternalService_ResolveArtifactInternalName_Handler,
		},
		{
			MethodName: "ResolveIdentifier",
			Handler:    _InternalService_ResolveIdentifier_Handler,
		},
		{
			MethodName: "RegisterVod",
			Handler:    _InternalService_RegisterVod_Handler,
		},
		{
			MethodName: "ResolveVodHash",
			Handler:    _InternalService_ResolveVodHash_Handler,
		},
		{
			MethodName: "ResolveVodID",
			Handler:    _InternalService_ResolveVodID_Handler,
		},
		{
			MethodName: "GetOrCreateWalletUser",
			Handler:    _InternalService_GetOrCreateWalletUser_Handler,
		},
		{
			MethodName: "TerminateTenantStreams",
			Handler:    _InternalService_TerminateTenantStreams_Handler,
		},
		{
			MethodName: "InvalidateTenantCache",
			Handler:    _InternalService_InvalidateTenantCache_Handler,
		},
		{
			MethodName: "GetTenantUserCount",
			Handler:    _InternalService_GetTenantUserCount_Handler,
		},
		{
			MethodName: "GetTenantPrimaryUser",
			Handler:    _InternalService_GetTenantPrimaryUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	UserService_Login_FullMethodName               = "/commodore.UserService/Login"
	UserService_Register_FullMethodName            = "/commodore.UserService/Register"
	UserService_Logout_FullMethodName              = "/commodore.UserService/Logout"
	UserService_RefreshToken_FullMethodName        = "/commodore.UserService/RefreshToken"
	UserService_VerifyEmail_FullMethodName         = "/commodore.UserService/VerifyEmail"
	UserService_ResendVerification_FullMethodName  = "/commodore.UserService/ResendVerification"
	UserService_ForgotPassword_FullMethodName      = "/commodore.UserService/ForgotPassword"
	UserService_ResetPassword_FullMethodName       = "/commodore.UserService/ResetPassword"
	UserService_GetMe_FullMethodName               = "/commodore.UserService/GetMe"
	UserService_UpdateMe_FullMethodName            = "/commodore.UserService/UpdateMe"
	UserService_UpdateNewsletter_FullMethodName    = "/commodore.UserService/UpdateNewsletter"
	UserService_GetNewsletterStatus_FullMethodName = "/commodore.UserService/GetNewsletterStatus"
	UserService_WalletLogin_FullMethodName         = "/commodore.UserService/WalletLogin"
	UserService_WalletLoginWithX402_FullMethodName = "/commodore.UserService/WalletLoginWithX402"
	UserService_LinkWallet_FullMethodName          = "/commodore.UserService/LinkWallet"
	UserService_UnlinkWallet_FullMethodName        = "/commodore.UserService/UnlinkWallet"
	UserService_ListWallets_FullMethodName         = "/commodore.UserService/ListWallets"
	UserService_LinkEmail_FullMethodName           = "/commodore.UserService/LinkEmail"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	// Authentication
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
	RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	// Email verification
	VerifyEmail(ctx context.Context, in *VerifyEmailRequest, opts ...grpc.CallOption) (*VerifyEmailResponse, error)
	ResendVerification(ctx context.Context, in *ResendVerificationRequest, opts ...grpc.CallOption) (*ResendVerificationResponse, error)
	// Password reset
	ForgotPassword(ctx context.Context, in *ForgotPasswordRequest, opts ...grpc.CallOption) (*ForgotPasswordResponse, error)
	ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error)
	// Profile
	GetMe(ctx context.Context, in *GetMeRequest, opts ...grpc.CallOption) (*User, error)
	UpdateMe(ctx context.Context, in *UpdateMeRequest, opts ...grpc.CallOption) (*User, error)
	UpdateNewsletter(ctx context.Context, in *UpdateNewsletterRequest, opts ...grpc.CallOption) (*UpdateNewsletterResponse, error)
	GetNewsletterStatus(ctx context.Context, in *GetNewsletterStatusRequest, opts ...grpc.CallOption) (*GetNewsletterStatusResponse, error)
	// Wallet authentication (x402 / agent access)
	WalletLogin(ctx context.Context, in *WalletLoginRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	WalletLoginWithX402(ctx context.Context, in *WalletLoginWithX402Request, opts ...grpc.CallOption) (*WalletLoginWithX402Response, error)
	LinkWallet(ctx context.Context, in *LinkWalletRequest, opts ...grpc.CallOption) (*WalletIdentity, error)
	UnlinkWallet(ctx context.Context, in *UnlinkWalletRequest, opts ...grpc.CallOption) (*UnlinkWalletResponse, error)
	ListWallets(ctx context.Context, in *ListWalletsRequest, opts ...grpc.CallOption) (*ListWalletsResponse, error)
	// Email linking (for wallet-only users to add email for postpaid upgrade)
	LinkEmail(ctx context.Context, in *LinkEmailRequest, opts ...grpc.CallOption) (*LinkEmailResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, UserService_Login_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, UserService_Register_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) {
	out := new(LogoutResponse)
	err := c.cc.Invoke(ctx, UserService_Logout_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, UserService_RefreshToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) VerifyEmail(ctx context.Context, in *VerifyEmailRequest, opts ...grpc.CallOption) (*VerifyEmailResponse, error) {
	out := new(VerifyEmailResponse)
	err := c.cc.Invoke(ctx, UserService_VerifyEmail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ResendVerification(ctx context.Context, in *ResendVerificationRequest, opts ...grpc.CallOption) (*ResendVerificationResponse, error) {
	out := new(ResendVerificationResponse)
	err := c.cc.Invoke(ctx, UserService_ResendVerification_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ForgotPassword(ctx context.Context, in *ForgotPasswordRequest, opts ...grpc.CallOption) (*ForgotPasswordResponse, error) {
	out := new(ForgotPasswordResponse)
	err := c.cc.Invoke(ctx, UserService_ForgotPassword_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error) {
	out := new(ResetPasswordResponse)
	err := c.cc.Invoke(ctx, UserService_ResetPassword_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetMe(ctx context.Context, in *GetMeRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_GetMe_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateMe(ctx context.Context, in *UpdateMeRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_UpdateMe_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateNewsletter(ctx context.Context, in *UpdateNewsletterRequest, opts ...grpc.CallOption) (*UpdateNewsletterResponse, error) {
	out := new(UpdateNewsletterResponse)
	err := c.cc.Invoke(ctx, UserService_UpdateNewsletter_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetNewsletterStatus(ctx context.Context, in *GetNewsletterStatusRequest, opts ...grpc.CallOption) (*GetNewsletterStatusResponse, error) {
	out := new(GetNewsletterStatusResponse)
	err := c.cc.Invoke(ctx, UserService_GetNewsletterStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) WalletLogin(ctx context.Context, in *WalletLoginRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, UserService_WalletLogin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) WalletLoginWithX402(ctx context.Context, in *WalletLoginWithX402Request, opts ...grpc.CallOption) (*WalletLoginWithX402Response, error) {
	out := new(WalletLoginWithX402Response)
	err := c.cc.Invoke(ctx, UserService_WalletLoginWithX402_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) LinkWallet(ctx context.Context, in *LinkWalletRequest, opts ...grpc.CallOption) (*WalletIdentity, error) {
	out := new(WalletIdentity)
	err := c.cc.Invoke(ctx, UserService_LinkWallet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UnlinkWallet(ctx context.Context, in *UnlinkWalletRequest, opts ...grpc.CallOption) (*UnlinkWalletResponse, error) {
	out := new(UnlinkWalletResponse)
	err := c.cc.Invoke(ctx, UserService_UnlinkWallet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ListWallets(ctx context.Context, in *ListWalletsRequest, opts ...grpc.CallOption) (*ListWalletsResponse, error) {
	out := new(ListWalletsResponse)
	err := c.cc.Invoke(ctx, UserService_ListWallets_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) LinkEmail(ctx context.Context, in *LinkEmailRequest, opts ...grpc.CallOption) (*LinkEmailResponse, error) {
	out := new(LinkEmailResponse)
	err := c.cc.Invoke(ctx, UserService_LinkEmail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	// Authentication
	Login(context.Context, *LoginRequest) (*AuthResponse, error)
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
	RefreshToken(context.Context, *RefreshTokenRequest) (*AuthResponse, error)
	// Email verification
	VerifyEmail(context.Context, *VerifyEmailRequest) (*VerifyEmailResponse, error)
	ResendVerification(context.Context, *ResendVerificationRequest) (*ResendVerificationResponse, error)
	// Password reset
	ForgotPassword(context.Context, *ForgotPasswordRequest) (*ForgotPasswordResponse, error)
	ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error)
	// Profile
	GetMe(context.Context, *GetMeRequest) (*User, error)
	UpdateMe(context.Context, *UpdateMeRequest) (*User, error)
	UpdateNewsletter(context.Context, *UpdateNewsletterRequest) (*UpdateNewsletterResponse, error)
	GetNewsletterStatus(context.Context, *GetNewsletterStatusRequest) (*GetNewsletterStatusResponse, error)
	// Wallet authentication (x402 / agent access)
	WalletLogin(context.Context, *WalletLoginRequest) (*AuthResponse, error)
	WalletLoginWithX402(context.Context, *WalletLoginWithX402Request) (*WalletLoginWithX402Response, error)
	LinkWallet(context.Context, *LinkWalletRequest) (*WalletIdentity, error)
	UnlinkWallet(context.Context, *UnlinkWalletRequest) (*UnlinkWalletResponse, error)
	ListWallets(context.Context, *ListWalletsRequest) (*ListWalletsResponse, error)
	// Email linking (for wallet-only users to add email for postpaid upgrade)
	LinkEmail(context.Context, *LinkEmailRequest) (*LinkEmailResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) Login(context.Context, *LoginRequest) (*AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedUserServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedUserServiceServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedUserServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedUserServiceServer) VerifyEmail(context.Context, *VerifyEmailRequest) (*VerifyEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyEmail not implemented")
}
func (UnimplementedUserServiceServer) ResendVerification(context.Context, *ResendVerificationRequest) (*ResendVerificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResendVerification not implemented")
}
func (UnimplementedUserServiceServer) ForgotPassword(context.Context, *ForgotPasswordRequest) (*ForgotPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForgotPassword not implemented")
}
func (UnimplementedUserServiceServer) ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedUserServiceServer) GetMe(context.Context, *GetMeRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMe not implemented")
}
func (UnimplementedUserServiceServer) UpdateMe(context.Context, *UpdateMeRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMe not implemented")
}
func (UnimplementedUserServiceServer) UpdateNewsletter(context.Context, *UpdateNewsletterRequest) (*UpdateNewsletterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNewsletter not implemented")
}
func (UnimplementedUserServiceServer) GetNewsletterStatus(context.Context, *GetNewsletterStatusRequest) (*GetNewsletterStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNewsletterStatus not implemented")
}
func (UnimplementedUserServiceServer) WalletLogin(context.Context, *WalletLoginRequest) (*AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WalletLogin not implemented")
}
func (UnimplementedUserServiceServer) WalletLoginWithX402(context.Context, *WalletLoginWithX402Request) (*WalletLoginWithX402Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WalletLoginWithX402 not implemented")
}
func (UnimplementedUserServiceServer) LinkWallet(context.Context, *LinkWalletRequest) (*WalletIdentity, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkWallet not implemented")
}
func (UnimplementedUserServiceServer) UnlinkWallet(context.Context, *UnlinkWalletRequest) (*UnlinkWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlinkWallet not implemented")
}
func (UnimplementedUserServiceServer) ListWallets(context.Context, *ListWalletsRequest) (*ListWalletsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWallets not implemented")
}
func (UnimplementedUserServiceServer) LinkEmail(context.Context, *LinkEmailRequest) (*LinkEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkEmail not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_VerifyEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).VerifyEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_VerifyEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).VerifyEmail(ctx, req.(*VerifyEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ResendVerification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResendVerificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ResendVerification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ResendVerification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ResendVerification(ctx, req.(*ResendVerificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ForgotPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForgotPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ForgotPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ForgotPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ForgotPassword(ctx, req.(*ForgotPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ResetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ResetPassword(ctx, req.(*ResetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetMe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetMe(ctx, req.(*GetMeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateMe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateMe(ctx, req.(*UpdateMeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateNewsletter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNewsletterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateNewsletter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateNewsletter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateNewsletter(ctx, req.(*UpdateNewsletterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetNewsletterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNewsletterStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetNewsletterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetNewsletterStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetNewsletterStatus(ctx, req.(*GetNewsletterStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_WalletLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WalletLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).WalletLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_WalletLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).WalletLogin(ctx, req.(*WalletLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_WalletLoginWithX402_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WalletLoginWithX402Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).WalletLoginWithX402(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_WalletLoginWithX402_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).WalletLoginWithX402(ctx, req.(*WalletLoginWithX402Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_LinkWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).LinkWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_LinkWallet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).LinkWallet(ctx, req.(*LinkWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UnlinkWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlinkWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UnlinkWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UnlinkWallet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UnlinkWallet(ctx, req.(*UnlinkWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ListWallets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWalletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ListWallets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ListWallets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ListWallets(ctx, req.(*ListWalletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_LinkEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).LinkEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_LinkEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).LinkEmail(ctx, req.(*LinkEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _UserService_Login_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _UserService_Register_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _UserService_Logout_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _UserService_RefreshToken_Handler,
		},
		{
			MethodName: "VerifyEmail",
			Handler:    _UserService_VerifyEmail_Handler,
		},
		{
			MethodName: "ResendVerification",
			Handler:    _UserService_ResendVerification_Handler,
		},
		{
			MethodName: "ForgotPassword",
			Handler:    _UserService_ForgotPassword_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _UserService_ResetPassword_Handler,
		},
		{
			MethodName: "GetMe",
			Handler:    _UserService_GetMe_Handler,
		},
		{
			MethodName: "UpdateMe",
			Handler:    _UserService_UpdateMe_Handler,
		},
		{
			MethodName: "UpdateNewsletter",
			Handler:    _UserService_UpdateNewsletter_Handler,
		},
		{
			MethodName: "GetNewsletterStatus",
			Handler:    _UserService_GetNewsletterStatus_Handler,
		},
		{
			MethodName: "WalletLogin",
			Handler:    _UserService_WalletLogin_Handler,
		},
		{
			MethodName: "WalletLoginWithX402",
			Handler:    _UserService_WalletLoginWithX402_Handler,
		},
		{
			MethodName: "LinkWallet",
			Handler:    _UserService_LinkWallet_Handler,
		},
		{
			MethodName: "UnlinkWallet",
			Handler:    _UserService_UnlinkWallet_Handler,
		},
		{
			MethodName: "ListWallets",
			Handler:    _UserService_ListWallets_Handler,
		},
		{
			MethodName: "LinkEmail",
			Handler:    _UserService_LinkEmail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	StreamService_CreateStream_FullMethodName     = "/commodore.StreamService/CreateStream"
	StreamService_GetStream_FullMethodName        = "/commodore.StreamService/GetStream"
	StreamService_ListStreams_FullMethodName      = "/commodore.StreamService/ListStreams"
	StreamService_UpdateStream_FullMethodName     = "/commodore.StreamService/UpdateStream"
	StreamService_DeleteStream_FullMethodName     = "/commodore.StreamService/DeleteStream"
	StreamService_RefreshStreamKey_FullMethodName = "/commodore.StreamService/RefreshStreamKey"
)

// StreamServiceClient is the client API for StreamService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StreamServiceClient interface {
	CreateStream(ctx context.Context, in *CreateStreamRequest, opts ...grpc.CallOption) (*CreateStreamResponse, error)
	GetStream(ctx context.Context, in *GetStreamRequest, opts ...grpc.CallOption) (*Stream, error)
	ListStreams(ctx context.Context, in *ListStreamsRequest, opts ...grpc.CallOption) (*ListStreamsResponse, error)
	UpdateStream(ctx context.Context, in *UpdateStreamRequest, opts ...grpc.CallOption) (*Stream, error)
	DeleteStream(ctx context.Context, in *DeleteStreamRequest, opts ...grpc.CallOption) (*DeleteStreamResponse, error)
	RefreshStreamKey(ctx context.Context, in *RefreshStreamKeyRequest, opts ...grpc.CallOption) (*RefreshStreamKeyResponse, error)
}

type streamServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamServiceClient(cc grpc.ClientConnInterface) StreamServiceClient {
	return &streamServiceClient{cc}
}

func (c *streamServiceClient) CreateStream(ctx context.Context, in *CreateStreamRequest, opts ...grpc.CallOption) (*CreateStreamResponse, error) {
	out := new(CreateStreamResponse)
	err := c.cc.Invoke(ctx, StreamService_CreateStream_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) GetStream(ctx context.Context, in *GetStreamRequest, opts ...grpc.CallOption) (*Stream, error) {
	out := new(Stream)
	err := c.cc.Invoke(ctx, StreamService_GetStream_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) ListStreams(ctx context.Context, in *ListStreamsRequest, opts ...grpc.CallOption) (*ListStreamsResponse, error) {
	out := new(ListStreamsResponse)
	err := c.cc.Invoke(ctx, StreamService_ListStreams_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) UpdateStream(ctx context.Context, in *UpdateStreamRequest, opts ...grpc.CallOption) (*Stream, error) {
	out := new(Stream)
	err := c.cc.Invoke(ctx, StreamService_UpdateStream_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) DeleteStream(ctx context.Context, in *DeleteStreamRequest, opts ...grpc.CallOption) (*DeleteStreamResponse, error) {
	out := new(DeleteStreamResponse)
	err := c.cc.Invoke(ctx, StreamService_DeleteStream_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) RefreshStreamKey(ctx context.Context, in *RefreshStreamKeyRequest, opts ...grpc.CallOption) (*RefreshStreamKeyResponse, error) {
	out := new(RefreshStreamKeyResponse)
	err := c.cc.Invoke(ctx, StreamService_RefreshStreamKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StreamServiceServer is the server API for StreamService service.
// All implementations must embed UnimplementedStreamServiceServer
// for forward compatibility
type StreamServiceServer interface {
	CreateStream(context.Context, *CreateStreamRequest) (*CreateStreamResponse, error)
	GetStream(context.Context, *GetStreamRequest) (*Stream, error)
	ListStreams(context.Context, *ListStreamsRequest) (*ListStreamsResponse, error)
	UpdateStream(context.Context, *UpdateStreamRequest) (*Stream, error)
	DeleteStream(context.Context, *DeleteStreamRequest) (*DeleteStreamResponse, error)
	RefreshStreamKey(context.Context, *RefreshStreamKeyRequest) (*RefreshStreamKeyResponse, error)
	mustEmbedUnimplementedStreamServiceServer()
}

// UnimplementedStreamServiceServer must be embedded to have forward compatible implementations.
type UnimplementedStreamServiceServer struct {
}

func (UnimplementedStreamServiceServer) CreateStream(context.Context, *CreateStreamRequest) (*CreateStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStream not implemented")
}
func (UnimplementedStreamServiceServer) GetStream(context.Context, *GetStreamRequest) (*Stream, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStream not implemented")
}
func (UnimplementedStreamServiceServer) ListStreams(context.Context, *ListStreamsRequest) (*ListStreamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStreams not implemented")
}
func (UnimplementedStreamServiceServer) UpdateStream(context.Context, *UpdateStreamRequest) (*Stream, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStream not implemented")
}
func (UnimplementedStreamServiceServer) DeleteStream(context.Context, *DeleteStreamRequest) (*DeleteStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStream not implemented")
}
func (UnimplementedStreamServiceServer) RefreshStreamKey(context.Context, *RefreshStreamKeyRequest) (*RefreshStreamKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshStreamKey not implemented")
}
func (UnimplementedStreamServiceServer) mustEmbedUnimplementedStreamServiceServer() {}

// UnsafeStreamServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StreamServiceServer will
// result in compilation errors.
type UnsafeStreamServiceServer interface {
	mustEmbedUnimplementedStreamServiceServer()
}

func RegisterStreamServiceServer(s grpc.ServiceRegistrar, srv StreamServiceServer) {
	s.RegisterService(&StreamService_ServiceDesc, srv)
}

func _StreamService_CreateStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).CreateStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_CreateStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).CreateStream(ctx, req.(*CreateStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_GetStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).GetStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_GetStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).GetStream(ctx, req.(*GetStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_ListStreams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStreamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).ListStreams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_ListStreams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).ListStreams(ctx, req.(*ListStreamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_UpdateStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).UpdateStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_UpdateStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).UpdateStream(ctx, req.(*UpdateStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_DeleteStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).DeleteStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_DeleteStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).DeleteStream(ctx, req.(*DeleteStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_RefreshStreamKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshStreamKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).RefreshStreamKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_RefreshStreamKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).RefreshStreamKey(ctx, req.(*RefreshStreamKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StreamService_ServiceDesc is the grpc.ServiceDesc for StreamService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StreamService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.StreamService",
	HandlerType: (*StreamServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateStream",
			Handler:    _StreamService_CreateStream_Handler,
		},
		{
			MethodName: "GetStream",
			Handler:    _StreamService_GetStream_Handler,
		},
		{
			MethodName: "ListStreams",
			Handler:    _StreamService_ListStreams_Handler,
		},
		{
			MethodName: "UpdateStream",
			Handler:    _StreamService_UpdateStream_Handler,
		},
		{
			MethodName: "DeleteStream",
			Handler:    _StreamService_DeleteStream_Handler,
		},
		{
			MethodName: "RefreshStreamKey",
			Handler:    _StreamService_RefreshStreamKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	StreamKeyService_CreateStreamKey_FullMethodName     = "/commodore.StreamKeyService/CreateStreamKey"
	StreamKeyService_ListStreamKeys_FullMethodName      = "/commodore.StreamKeyService/ListStreamKeys"
	StreamKeyService_DeactivateStreamKey_FullMethodName = "/commodore.StreamKeyService/DeactivateStreamKey"
)

// StreamKeyServiceClient is the client API for StreamKeyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StreamKeyServiceClient interface {
	CreateStreamKey(ctx context.Context, in *CreateStreamKeyRequest, opts ...grpc.CallOption) (*StreamKeyResponse, error)
	ListStreamKeys(ctx context.Context, in *ListStreamKeysRequest, opts ...grpc.CallOption) (*ListStreamKeysResponse, error)
	DeactivateStreamKey(ctx context.Context, in *DeactivateStreamKeyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type streamKeyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamKeyServiceClient(cc grpc.ClientConnInterface) StreamKeyServiceClient {
	return &streamKeyServiceClient{cc}
}

func (c *streamKeyServiceClient) CreateStreamKey(ctx context.Context, in *CreateStreamKeyRequest, opts ...grpc.CallOption) (*StreamKeyResponse, error) {
	out := new(StreamKeyResponse)
	err := c.cc.Invoke(ctx, StreamKeyService_CreateStreamKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamKeyServiceClient) ListStreamKeys(ctx context.Context, in *ListStreamKeysRequest, opts ...grpc.CallOption) (*ListStreamKeysResponse, error) {
	out := new(ListStreamKeysResponse)
	err := c.cc.Invoke(ctx, StreamKeyService_ListStreamKeys_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamKeyServiceClient) DeactivateStreamKey(ctx context.Context, in *DeactivateStreamKeyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, StreamKeyService_DeactivateStreamKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StreamKeyServiceServer is the server API for StreamKeyService service.
// All implementations must embed UnimplementedStreamKeyServiceServer
// for forward compatibility
type StreamKeyServiceServer interface {
	CreateStreamKey(context.Context, *CreateStreamKeyRequest) (*StreamKeyResponse, error)
	ListStreamKeys(context.Context, *ListStreamKeysRequest) (*ListStreamKeysResponse, error)
	DeactivateStreamKey(context.Context, *DeactivateStreamKeyRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedStreamKeyServiceServer()
}

// UnimplementedStreamKeyServiceServer must be embedded to have forward compatible implementations.
type UnimplementedStreamKeyServiceServer struct {
}

func (UnimplementedStreamKeyServiceServer) CreateStreamKey(context.Context, *CreateStreamKeyRequest) (*StreamKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStreamKey not implemented")
}
func (UnimplementedStreamKeyServiceServer) ListStreamKeys(context.Context, *ListStreamKeysRequest) (*ListStreamKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStreamKeys not implemented")
}
func (UnimplementedStreamKeyServiceServer) DeactivateStreamKey(context.Context, *DeactivateStreamKeyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeactivateStreamKey not implemented")
}
func (UnimplementedStreamKeyServiceServer) mustEmbedUnimplementedStreamKeyServiceServer() {}

// UnsafeStreamKeyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StreamKeyServiceServer will
// result in compilation errors.
type UnsafeStreamKeyServiceServer interface {
	mustEmbedUnimplementedStreamKeyServiceServer()
}

func RegisterStreamKeyServiceServer(s grpc.ServiceRegistrar, srv StreamKeyServiceServer) {
	s.RegisterService(&StreamKeyService_ServiceDesc, srv)
}

func _StreamKeyService_CreateStreamKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStreamKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamKeyServiceServer).CreateStreamKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamKeyService_CreateStreamKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamKeyServiceServer).CreateStreamKey(ctx, req.(*CreateStreamKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamKeyService_ListStreamKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStreamKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamKeyServiceServer).ListStreamKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamKeyService_ListStreamKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamKeyServiceServer).ListStreamKeys(ctx, req.(*ListStreamKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamKeyService_DeactivateStreamKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeactivateStreamKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamKeyServiceServer).DeactivateStreamKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamKeyService_DeactivateStreamKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamKeyServiceServer).DeactivateStreamKey(ctx, req.(*DeactivateStreamKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StreamKeyService_ServiceDesc is the grpc.ServiceDesc for StreamKeyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StreamKeyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.StreamKeyService",
	HandlerType: (*StreamKeyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateStreamKey",
			Handler:    _StreamKeyService_CreateStreamKey_Handler,
		},
		{
			MethodName: "ListStreamKeys",
			Handler:    _StreamKeyService_ListStreamKeys_Handler,
		},
		{
			MethodName: "DeactivateStreamKey",
			Handler:    _StreamKeyService_DeactivateStreamKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	DeveloperService_CreateAPIToken_FullMethodName = "/commodore.DeveloperService/CreateAPIToken"
	DeveloperService_ListAPITokens_FullMethodName  = "/commodore.DeveloperService/ListAPITokens"
	DeveloperService_RevokeAPIToken_FullMethodName = "/commodore.DeveloperService/RevokeAPIToken"
)

// DeveloperServiceClient is the client API for DeveloperService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeveloperServiceClient interface {
	CreateAPIToken(ctx context.Context, in *CreateAPITokenRequest, opts ...grpc.CallOption) (*CreateAPITokenResponse, error)
	ListAPITokens(ctx context.Context, in *ListAPITokensRequest, opts ...grpc.CallOption) (*ListAPITokensResponse, error)
	RevokeAPIToken(ctx context.Context, in *RevokeAPITokenRequest, opts ...grpc.CallOption) (*RevokeAPITokenResponse, error)
}

type developerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDeveloperServiceClient(cc grpc.ClientConnInterface) DeveloperServiceClient {
	return &developerServiceClient{cc}
}

func (c *developerServiceClient) CreateAPIToken(ctx context.Context, in *CreateAPITokenRequest, opts ...grpc.CallOption) (*CreateAPITokenResponse, error) {
	out := new(CreateAPITokenResponse)
	err := c.cc.Invoke(ctx, DeveloperService_CreateAPIToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *developerServiceClient) ListAPITokens(ctx context.Context, in *ListAPITokensRequest, opts ...grpc.CallOption) (*ListAPITokensResponse, error) {
	out := new(ListAPITokensResponse)
	err := c.cc.Invoke(ctx, DeveloperService_ListAPITokens_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *developerServiceClient) RevokeAPIToken(ctx context.Context, in *RevokeAPITokenRequest, opts ...grpc.CallOption) (*RevokeAPITokenResponse, error) {
	out := new(RevokeAPITokenResponse)
	err := c.cc.Invoke(ctx, DeveloperService_RevokeAPIToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeveloperServiceServer is the server API for DeveloperService service.
// All implementations must embed UnimplementedDeveloperServiceServer
// for forward compatibility
type DeveloperServiceServer interface {
	CreateAPIToken(context.Context, *CreateAPITokenRequest) (*CreateAPITokenResponse, error)
	ListAPITokens(context.Context, *ListAPITokensRequest) (*ListAPITokensResponse, error)
	RevokeAPIToken(context.Context, *RevokeAPITokenRequest) (*RevokeAPITokenResponse, error)
	mustEmbedUnimplementedDeveloperServiceServer()
}

// UnimplementedDeveloperServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDeveloperServiceServer struct {
}

func (UnimplementedDeveloperServiceServer) CreateAPIToken(context.Context, *CreateAPITokenRequest) (*CreateAPITokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAPIToken not implemented")
}
func (UnimplementedDeveloperServiceServer) ListAPITokens(context.Context, *ListAPITokensRequest) (*ListAPITokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAPITokens not implemented")
}
func (UnimplementedDeveloperServiceServer) RevokeAPIToken(context.Context, *RevokeAPITokenRequest) (*RevokeAPITokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeAPIToken not implemented")
}
func (UnimplementedDeveloperServiceServer) mustEmbedUnimplementedDeveloperServiceServer() {}

// UnsafeDeveloperServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeveloperServiceServer will
// result in compilation errors.
type UnsafeDeveloperServiceServer interface {
	mustEmbedUnimplementedDeveloperServiceServer()
}

func RegisterDeveloperServiceServer(s grpc.ServiceRegistrar, srv DeveloperServiceServer) {
	s.RegisterService(&DeveloperService_ServiceDesc, srv)
}

func _DeveloperService_CreateAPIToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAPITokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeveloperServiceServer).CreateAPIToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeveloperService_CreateAPIToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeveloperServiceServer).CreateAPIToken(ctx, req.(*CreateAPITokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeveloperService_ListAPITokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAPITokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeveloperServiceServer).ListAPITokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeveloperService_ListAPITokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeveloperServiceServer).ListAPITokens(ctx, req.(*ListAPITokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeveloperService_RevokeAPIToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeAPITokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeveloperServiceServer).RevokeAPIToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeveloperService_RevokeAPIToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeveloperServiceServer).RevokeAPIToken(ctx, req.(*RevokeAPITokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DeveloperService_ServiceDesc is the grpc.ServiceDesc for DeveloperService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeveloperService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.DeveloperService",
	HandlerType: (*DeveloperServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAPIToken",
			Handler:    _DeveloperService_CreateAPIToken_Handler,
		},
		{
			MethodName: "ListAPITokens",
			Handler:    _DeveloperService_ListAPITokens_Handler,
		},
		{
			MethodName: "RevokeAPIToken",
			Handler:    _DeveloperService_RevokeAPIToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	ClipService_CreateClip_FullMethodName = "/commodore.ClipService/CreateClip"
	ClipService_GetClips_FullMethodName   = "/commodore.ClipService/GetClips"
	ClipService_GetClip_FullMethodName    = "/commodore.ClipService/GetClip"
	ClipService_DeleteClip_FullMethodName = "/commodore.ClipService/DeleteClip"
)

// ClipServiceClient is the client API for ClipService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClipServiceClient interface {
	CreateClip(ctx context.Context, in *CreateClipRequest, opts ...grpc.CallOption) (*CreateClipResponse, error)
	GetClips(ctx context.Context, in *GetClipsRequest, opts ...grpc.CallOption) (*GetClipsResponse, error)
	GetClip(ctx context.Context, in *GetClipRequest, opts ...grpc.CallOption) (*ClipInfo, error)
	DeleteClip(ctx context.Context, in *DeleteClipRequest, opts ...grpc.CallOption) (*DeleteClipResponse, error)
}

type clipServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClipServiceClient(cc grpc.ClientConnInterface) ClipServiceClient {
	return &clipServiceClient{cc}
}

func (c *clipServiceClient) CreateClip(ctx context.Context, in *CreateClipRequest, opts ...grpc.CallOption) (*CreateClipResponse, error) {
	out := new(CreateClipResponse)
	err := c.cc.Invoke(ctx, ClipService_CreateClip_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipServiceClient) GetClips(ctx context.Context, in *GetClipsRequest, opts ...grpc.CallOption) (*GetClipsResponse, error) {
	out := new(GetClipsResponse)
	err := c.cc.Invoke(ctx, ClipService_GetClips_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipServiceClient) GetClip(ctx context.Context, in *GetClipRequest, opts ...grpc.CallOption) (*ClipInfo, error) {
	out := new(ClipInfo)
	err := c.cc.Invoke(ctx, ClipService_GetClip_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipServiceClient) DeleteClip(ctx context.Context, in *DeleteClipRequest, opts ...grpc.CallOption) (*DeleteClipResponse, error) {
	out := new(DeleteClipResponse)
	err := c.cc.Invoke(ctx, ClipService_DeleteClip_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClipServiceServer is the server API for ClipService service.
// All implementations must embed UnimplementedClipServiceServer
// for forward compatibility
type ClipServiceServer interface {
	CreateClip(context.Context, *CreateClipRequest) (*CreateClipResponse, error)
	GetClips(context.Context, *GetClipsRequest) (*GetClipsResponse, error)
	GetClip(context.Context, *GetClipRequest) (*ClipInfo, error)
	DeleteClip(context.Context, *DeleteClipRequest) (*DeleteClipResponse, error)
	mustEmbedUnimplementedClipServiceServer()
}

// UnimplementedClipServiceServer must be embedded to have forward compatible implementations.
type UnimplementedClipServiceServer struct {
}

func (UnimplementedClipServiceServer) CreateClip(context.Context, *CreateClipRequest) (*CreateClipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateClip not implemented")
}
func (UnimplementedClipServiceServer) GetClips(context.Context, *GetClipsRequest) (*GetClipsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClips not implemented")
}
func (UnimplementedClipServiceServer) GetClip(context.Context, *GetClipRequest) (*ClipInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClip not implemented")
}
func (UnimplementedClipServiceServer) DeleteClip(context.Context, *DeleteClipRequest) (*DeleteClipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteClip not implemented")
}
func (UnimplementedClipServiceServer) mustEmbedUnimplementedClipServiceServer() {}

// UnsafeClipServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClipServiceServer will
// result in compilation errors.
type UnsafeClipServiceServer interface {
	mustEmbedUnimplementedClipServiceServer()
}

func RegisterClipServiceServer(s grpc.ServiceRegistrar, srv ClipServiceServer) {
	s.RegisterService(&ClipService_ServiceDesc, srv)
}

func _ClipService_CreateClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).CreateClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_CreateClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).CreateClip(ctx, req.(*CreateClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipService_GetClips_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClipsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).GetClips(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_GetClips_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).GetClips(ctx, req.(*GetClipsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipService_GetClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).GetClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_GetClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).GetClip(ctx, req.(*GetClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipService_DeleteClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).DeleteClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_DeleteClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).DeleteClip(ctx, req.(*DeleteClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClipService_ServiceDesc is the grpc.ServiceDesc for ClipService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClipService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.ClipService",
	HandlerType: (*ClipServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateClip",
			Handler:    _ClipService_CreateClip_Handler,
		},
		{
			MethodName: "GetClips",
			Handler:    _ClipService_GetClips_Handler,
		},
		{
			MethodName: "GetClip",
			Handler:    _ClipService_GetClip_Handler,
		},
		{
			MethodName: "DeleteClip",
			Handler:    _ClipService_DeleteClip_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	DVRService_StopDVR_FullMethodName         = "/commodore.DVRService/StopDVR"
	DVRService_DeleteDVR_FullMethodName       = "/commodore.DVRService/DeleteDVR"
	DVRService_ListDVRRequests_FullMethodName = "/commodore.DVRService/ListDVRRequests"
)

// DVRServiceClient is the client API for DVRService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DVRServiceClient interface {
	StopDVR(ctx context.Context, in *StopDVRRequest, opts ...grpc.CallOption) (*StopDVRResponse, error)
	DeleteDVR(ctx context.Context, in *DeleteDVRRequest, opts ...grpc.CallOption) (*DeleteDVRResponse, error)
	ListDVRRequests(ctx context.Context, in *ListDVRRecordingsRequest, opts ...grpc.CallOption) (*ListDVRRecordingsResponse, error)
}

type dVRServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDVRServiceClient(cc grpc.ClientConnInterface) DVRServiceClient {
	return &dVRServiceClient{cc}
}

func (c *dVRServiceClient) StopDVR(ctx context.Context, in *StopDVRRequest, opts ...grpc.CallOption) (*StopDVRResponse, error) {
	out := new(StopDVRResponse)
	err := c.cc.Invoke(ctx, DVRService_StopDVR_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dVRServiceClient) DeleteDVR(ctx context.Context, in *DeleteDVRRequest, opts ...grpc.CallOption) (*DeleteDVRResponse, error) {
	out := new(DeleteDVRResponse)
	err := c.cc.Invoke(ctx, DVRService_DeleteDVR_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dVRServiceClient) ListDVRRequests(ctx context.Context, in *ListDVRRecordingsRequest, opts ...grpc.CallOption) (*ListDVRRecordingsResponse, error) {
	out := new(ListDVRRecordingsResponse)
	err := c.cc.Invoke(ctx, DVRService_ListDVRRequests_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DVRServiceServer is the server API for DVRService service.
// All implementations must embed UnimplementedDVRServiceServer
// for forward compatibility
type DVRServiceServer interface {
	StopDVR(context.Context, *StopDVRRequest) (*StopDVRResponse, error)
	DeleteDVR(context.Context, *DeleteDVRRequest) (*DeleteDVRResponse, error)
	ListDVRRequests(context.Context, *ListDVRRecordingsRequest) (*ListDVRRecordingsResponse, error)
	mustEmbedUnimplementedDVRServiceServer()
}

// UnimplementedDVRServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDVRServiceServer struct {
}

func (UnimplementedDVRServiceServer) StopDVR(context.Context, *StopDVRRequest) (*StopDVRResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopDVR not implemented")
}
func (UnimplementedDVRServiceServer) DeleteDVR(context.Context, *DeleteDVRRequest) (*DeleteDVRResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDVR not implemented")
}
func (UnimplementedDVRServiceServer) ListDVRRequests(context.Context, *ListDVRRecordingsRequest) (*ListDVRRecordingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDVRRequests not implemented")
}
func (UnimplementedDVRServiceServer) mustEmbedUnimplementedDVRServiceServer() {}

// UnsafeDVRServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DVRServiceServer will
// result in compilation errors.
type UnsafeDVRServiceServer interface {
	mustEmbedUnimplementedDVRServiceServer()
}

func RegisterDVRServiceServer(s grpc.ServiceRegistrar, srv DVRServiceServer) {
	s.RegisterService(&DVRService_ServiceDesc, srv)
}

func _DVRService_StopDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRServiceServer).StopDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRService_StopDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRServiceServer).StopDVR(ctx, req.(*StopDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DVRService_DeleteDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRServiceServer).DeleteDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRService_DeleteDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRServiceServer).DeleteDVR(ctx, req.(*DeleteDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DVRService_ListDVRRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDVRRecordingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRServiceServer).ListDVRRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRService_ListDVRRequests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRServiceServer).ListDVRRequests(ctx, req.(*ListDVRRecordingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DVRService_ServiceDesc is the grpc.ServiceDesc for DVRService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DVRService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.DVRService",
	HandlerType: (*DVRServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StopDVR",
			Handler:    _DVRService_StopDVR_Handler,
		},
		{
			MethodName: "DeleteDVR",
			Handler:    _DVRService_DeleteDVR_Handler,
		},
		{
			MethodName: "ListDVRRequests",
			Handler:    _DVRService_ListDVRRequests_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	ViewerService_ResolveViewerEndpoint_FullMethodName = "/commodore.ViewerService/ResolveViewerEndpoint"
	ViewerService_ResolveIngestEndpoint_FullMethodName = "/commodore.ViewerService/ResolveIngestEndpoint"
)

// ViewerServiceClient is the client API for ViewerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ViewerServiceClient interface {
	ResolveViewerEndpoint(ctx context.Context, in *ViewerEndpointRequest, opts ...grpc.CallOption) (*ViewerEndpointResponse, error)
	ResolveIngestEndpoint(ctx context.Context, in *IngestEndpointRequest, opts ...grpc.CallOption) (*IngestEndpointResponse, error)
}

type viewerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewViewerServiceClient(cc grpc.ClientConnInterface) ViewerServiceClient {
	return &viewerServiceClient{cc}
}

func (c *viewerServiceClient) ResolveViewerEndpoint(ctx context.Context, in *ViewerEndpointRequest, opts ...grpc.CallOption) (*ViewerEndpointResponse, error) {
	out := new(ViewerEndpointResponse)
	err := c.cc.Invoke(ctx, ViewerService_ResolveViewerEndpoint_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *viewerServiceClient) ResolveIngestEndpoint(ctx context.Context, in *IngestEndpointRequest, opts ...grpc.CallOption) (*IngestEndpointResponse, error) {
	out := new(IngestEndpointResponse)
	err := c.cc.Invoke(ctx, ViewerService_ResolveIngestEndpoint_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ViewerServiceServer is the server API for ViewerService service.
// All implementations must embed UnimplementedViewerServiceServer
// for forward compatibility
type ViewerServiceServer interface {
	ResolveViewerEndpoint(context.Context, *ViewerEndpointRequest) (*ViewerEndpointResponse, error)
	ResolveIngestEndpoint(context.Context, *IngestEndpointRequest) (*IngestEndpointResponse, error)
	mustEmbedUnimplementedViewerServiceServer()
}

// UnimplementedViewerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedViewerServiceServer struct {
}

func (UnimplementedViewerServiceServer) ResolveViewerEndpoint(context.Context, *ViewerEndpointRequest) (*ViewerEndpointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveViewerEndpoint not implemented")
}
func (UnimplementedViewerServiceServer) ResolveIngestEndpoint(context.Context, *IngestEndpointRequest) (*IngestEndpointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveIngestEndpoint not implemented")
}
func (UnimplementedViewerServiceServer) mustEmbedUnimplementedViewerServiceServer() {}

// UnsafeViewerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ViewerServiceServer will
// result in compilation errors.
type UnsafeViewerServiceServer interface {
	mustEmbedUnimplementedViewerServiceServer()
}

func RegisterViewerServiceServer(s grpc.ServiceRegistrar, srv ViewerServiceServer) {
	s.RegisterService(&ViewerService_ServiceDesc, srv)
}

func _ViewerService_ResolveViewerEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ViewerEndpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerServiceServer).ResolveViewerEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerService_ResolveViewerEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerServiceServer).ResolveViewerEndpoint(ctx, req.(*ViewerEndpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ViewerService_ResolveIngestEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestEndpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerServiceServer).ResolveIngestEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerService_ResolveIngestEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerServiceServer).ResolveIngestEndpoint(ctx, req.(*IngestEndpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ViewerService_ServiceDesc is the grpc.ServiceDesc for ViewerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ViewerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.ViewerService",
	HandlerType: (*ViewerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResolveViewerEndpoint",
			Handler:    _ViewerService_ResolveViewerEndpoint_Handler,
		},
		{
			MethodName: "ResolveIngestEndpoint",
			Handler:    _ViewerService_ResolveIngestEndpoint_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	VodService_CreateVodUpload_FullMethodName   = "/commodore.VodService/CreateVodUpload"
	VodService_CompleteVodUpload_FullMethodName = "/commodore.VodService/CompleteVodUpload"
	VodService_AbortVodUpload_FullMethodName    = "/commodore.VodService/AbortVodUpload"
	VodService_GetVodAsset_FullMethodName       = "/commodore.VodService/GetVodAsset"
	VodService_ListVodAssets_FullMethodName     = "/commodore.VodService/ListVodAssets"
	VodService_DeleteVodAsset_FullMethodName    = "/commodore.VodService/DeleteVodAsset"
)

// VodServiceClient is the client API for VodService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VodServiceClient interface {
	// Initiate multipart upload - returns presigned URLs for direct S3 upload
	CreateVodUpload(ctx context.Context, in *CreateVodUploadRequest, opts ...grpc.CallOption) (*CreateVodUploadResponse, error)
	// Finalize upload after all parts uploaded
	CompleteVodUpload(ctx context.Context, in *CompleteVodUploadRequest, opts ...grpc.CallOption) (*CompleteVodUploadResponse, error)
	// Cancel in-progress upload
	AbortVodUpload(ctx context.Context, in *AbortVodUploadRequest, opts ...grpc.CallOption) (*AbortVodUploadResponse, error)
	// Get single VOD asset
	GetVodAsset(ctx context.Context, in *GetVodAssetRequest, opts ...grpc.CallOption) (*VodAssetInfo, error)
	// List VOD assets with pagination
	ListVodAssets(ctx context.Context, in *ListVodAssetsRequest, opts ...grpc.CallOption) (*ListVodAssetsResponse, error)
	// Delete VOD asset
	DeleteVodAsset(ctx context.Context, in *DeleteVodAssetRequest, opts ...grpc.CallOption) (*DeleteVodAssetResponse, error)
}

type vodServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVodServiceClient(cc grpc.ClientConnInterface) VodServiceClient {
	return &vodServiceClient{cc}
}

func (c *vodServiceClient) CreateVodUpload(ctx context.Context, in *CreateVodUploadRequest, opts ...grpc.CallOption) (*CreateVodUploadResponse, error) {
	out := new(CreateVodUploadResponse)
	err := c.cc.Invoke(ctx, VodService_CreateVodUpload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vodServiceClient) CompleteVodUpload(ctx context.Context, in *CompleteVodUploadRequest, opts ...grpc.CallOption) (*CompleteVodUploadResponse, error) {
	out := new(CompleteVodUploadResponse)
	err := c.cc.Invoke(ctx, VodService_CompleteVodUpload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vodServiceClient) AbortVodUpload(ctx context.Context, in *AbortVodUploadRequest, opts ...grpc.CallOption) (*AbortVodUploadResponse, error) {
	out := new(AbortVodUploadResponse)
	err := c.cc.Invoke(ctx, VodService_AbortVodUpload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vodServiceClient) GetVodAsset(ctx context.Context, in *GetVodAssetRequest, opts ...grpc.CallOption) (*VodAssetInfo, error) {
	out := new(VodAssetInfo)
	err := c.cc.Invoke(ctx, VodService_GetVodAsset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vodServiceClient) ListVodAssets(ctx context.Context, in *ListVodAssetsRequest, opts ...grpc.CallOption) (*ListVodAssetsResponse, error) {
	out := new(ListVodAssetsResponse)
	err := c.cc.Invoke(ctx, VodService_ListVodAssets_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vodServiceClient) DeleteVodAsset(ctx context.Context, in *DeleteVodAssetRequest, opts ...grpc.CallOption) (*DeleteVodAssetResponse, error) {
	out := new(DeleteVodAssetResponse)
	err := c.cc.Invoke(ctx, VodService_DeleteVodAsset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VodServiceServer is the server API for VodService service.
// All implementations must embed UnimplementedVodServiceServer
// for forward compatibility
type VodServiceServer interface {
	// Initiate multipart upload - returns presigned URLs for direct S3 upload
	CreateVodUpload(context.Context, *CreateVodUploadRequest) (*CreateVodUploadResponse, error)
	// Finalize upload after all parts uploaded
	CompleteVodUpload(context.Context, *CompleteVodUploadRequest) (*CompleteVodUploadResponse, error)
	// Cancel in-progress upload
	AbortVodUpload(context.Context, *AbortVodUploadRequest) (*AbortVodUploadResponse, error)
	// Get single VOD asset
	GetVodAsset(context.Context, *GetVodAssetRequest) (*VodAssetInfo, error)
	// List VOD assets with pagination
	ListVodAssets(context.Context, *ListVodAssetsRequest) (*ListVodAssetsResponse, error)
	// Delete VOD asset
	DeleteVodAsset(context.Context, *DeleteVodAssetRequest) (*DeleteVodAssetResponse, error)
	mustEmbedUnimplementedVodServiceServer()
}

// UnimplementedVodServiceServer must be embedded to have forward compatible implementations.
type UnimplementedVodServiceServer struct {
}

func (UnimplementedVodServiceServer) CreateVodUpload(context.Context, *CreateVodUploadRequest) (*CreateVodUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVodUpload not implemented")
}
func (UnimplementedVodServiceServer) CompleteVodUpload(context.Context, *CompleteVodUploadRequest) (*CompleteVodUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompleteVodUpload not implemented")
}
func (UnimplementedVodServiceServer) AbortVodUpload(context.Context, *AbortVodUploadRequest) (*AbortVodUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbortVodUpload not implemented")
}
func (UnimplementedVodServiceServer) GetVodAsset(context.Context, *GetVodAssetRequest) (*VodAssetInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVodAsset not implemented")
}
func (UnimplementedVodServiceServer) ListVodAssets(context.Context, *ListVodAssetsRequest) (*ListVodAssetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVodAssets not implemented")
}
func (UnimplementedVodServiceServer) DeleteVodAsset(context.Context, *DeleteVodAssetRequest) (*DeleteVodAssetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVodAsset not implemented")
}
func (UnimplementedVodServiceServer) mustEmbedUnimplementedVodServiceServer() {}

// UnsafeVodServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VodServiceServer will
// result in compilation errors.
type UnsafeVodServiceServer interface {
	mustEmbedUnimplementedVodServiceServer()
}

func RegisterVodServiceServer(s grpc.ServiceRegistrar, srv VodServiceServer) {
	s.RegisterService(&VodService_ServiceDesc, srv)
}

func _VodService_CreateVodUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVodUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VodServiceServer).CreateVodUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VodService_CreateVodUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VodServiceServer).CreateVodUpload(ctx, req.(*CreateVodUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VodService_CompleteVodUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteVodUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VodServiceServer).CompleteVodUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VodService_CompleteVodUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VodServiceServer).CompleteVodUpload(ctx, req.(*CompleteVodUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VodService_AbortVodUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbortVodUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VodServiceServer).AbortVodUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VodService_AbortVodUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VodServiceServer).AbortVodUpload(ctx, req.(*AbortVodUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VodService_GetVodAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVodAssetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VodServiceServer).GetVodAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VodService_GetVodAsset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VodServiceServer).GetVodAsset(ctx, req.(*GetVodAssetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VodService_ListVodAssets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVodAssetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VodServiceServer).ListVodAssets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VodService_ListVodAssets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VodServiceServer).ListVodAssets(ctx, req.(*ListVodAssetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VodService_DeleteVodAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVodAssetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VodServiceServer).DeleteVodAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VodService_DeleteVodAsset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VodServiceServer).DeleteVodAsset(ctx, req.(*DeleteVodAssetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VodService_ServiceDesc is the grpc.ServiceDesc for VodService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VodService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.VodService",
	HandlerType: (*VodServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVodUpload",
			Handler:    _VodService_CreateVodUpload_Handler,
		},
		{
			MethodName: "CompleteVodUpload",
			Handler:    _VodService_CompleteVodUpload_Handler,
		},
		{
			MethodName: "AbortVodUpload",
			Handler:    _VodService_AbortVodUpload_Handler,
		},
		{
			MethodName: "GetVodAsset",
			Handler:    _VodService_GetVodAsset_Handler,
		},
		{
			MethodName: "ListVodAssets",
			Handler:    _VodService_ListVodAssets_Handler,
		},
		{
			MethodName: "DeleteVodAsset",
			Handler:    _VodService_DeleteVodAsset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}
