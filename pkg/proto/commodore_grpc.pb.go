// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.1
// source: commodore.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	InternalService_ValidateStreamKey_FullMethodName   = "/commodore.InternalService/ValidateStreamKey"
	InternalService_ResolvePlaybackID_FullMethodName   = "/commodore.InternalService/ResolvePlaybackID"
	InternalService_ResolveInternalName_FullMethodName = "/commodore.InternalService/ResolveInternalName"
	InternalService_ValidateAPIToken_FullMethodName    = "/commodore.InternalService/ValidateAPIToken"
	InternalService_StartDVR_FullMethodName            = "/commodore.InternalService/StartDVR"
)

// InternalServiceClient is the client API for InternalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// InternalService handles service-to-service lookups (Foghorn, Decklog, etc.)
type InternalServiceClient interface {
	// Called by Foghorn on PUSH_REWRITE to validate stream key
	// Source: pkg/api/commodore/types.go:ValidateStreamKeyResponse
	ValidateStreamKey(ctx context.Context, in *ValidateStreamKeyRequest, opts ...grpc.CallOption) (*ValidateStreamKeyResponse, error)
	// Called by edge nodes to resolve playback ID to internal name
	// Source: pkg/api/commodore/types.go:ResolvePlaybackIDResponse
	ResolvePlaybackID(ctx context.Context, in *ResolvePlaybackIDRequest, opts ...grpc.CallOption) (*ResolvePlaybackIDResponse, error)
	// Called by Decklog/Foghorn to enrich events with tenant context
	// Source: pkg/api/commodore/types.go:InternalNameResponse
	ResolveInternalName(ctx context.Context, in *ResolveInternalNameRequest, opts ...grpc.CallOption) (*ResolveInternalNameResponse, error)
	// Called by Gateway to validate developer API tokens
	// Source: pkg/api/commodore/types.go:ValidateAPITokenResponse
	ValidateAPIToken(ctx context.Context, in *ValidateAPITokenRequest, opts ...grpc.CallOption) (*ValidateAPITokenResponse, error)
	// Called by Foghorn to initiate DVR recording for a stream
	StartDVR(ctx context.Context, in *StartDVRRequest, opts ...grpc.CallOption) (*StartDVRResponse, error)
}

type internalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInternalServiceClient(cc grpc.ClientConnInterface) InternalServiceClient {
	return &internalServiceClient{cc}
}

func (c *internalServiceClient) ValidateStreamKey(ctx context.Context, in *ValidateStreamKeyRequest, opts ...grpc.CallOption) (*ValidateStreamKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateStreamKeyResponse)
	err := c.cc.Invoke(ctx, InternalService_ValidateStreamKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ResolvePlaybackID(ctx context.Context, in *ResolvePlaybackIDRequest, opts ...grpc.CallOption) (*ResolvePlaybackIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolvePlaybackIDResponse)
	err := c.cc.Invoke(ctx, InternalService_ResolvePlaybackID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ResolveInternalName(ctx context.Context, in *ResolveInternalNameRequest, opts ...grpc.CallOption) (*ResolveInternalNameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveInternalNameResponse)
	err := c.cc.Invoke(ctx, InternalService_ResolveInternalName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) ValidateAPIToken(ctx context.Context, in *ValidateAPITokenRequest, opts ...grpc.CallOption) (*ValidateAPITokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateAPITokenResponse)
	err := c.cc.Invoke(ctx, InternalService_ValidateAPIToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) StartDVR(ctx context.Context, in *StartDVRRequest, opts ...grpc.CallOption) (*StartDVRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartDVRResponse)
	err := c.cc.Invoke(ctx, InternalService_StartDVR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InternalServiceServer is the server API for InternalService service.
// All implementations must embed UnimplementedInternalServiceServer
// for forward compatibility.
//
// InternalService handles service-to-service lookups (Foghorn, Decklog, etc.)
type InternalServiceServer interface {
	// Called by Foghorn on PUSH_REWRITE to validate stream key
	// Source: pkg/api/commodore/types.go:ValidateStreamKeyResponse
	ValidateStreamKey(context.Context, *ValidateStreamKeyRequest) (*ValidateStreamKeyResponse, error)
	// Called by edge nodes to resolve playback ID to internal name
	// Source: pkg/api/commodore/types.go:ResolvePlaybackIDResponse
	ResolvePlaybackID(context.Context, *ResolvePlaybackIDRequest) (*ResolvePlaybackIDResponse, error)
	// Called by Decklog/Foghorn to enrich events with tenant context
	// Source: pkg/api/commodore/types.go:InternalNameResponse
	ResolveInternalName(context.Context, *ResolveInternalNameRequest) (*ResolveInternalNameResponse, error)
	// Called by Gateway to validate developer API tokens
	// Source: pkg/api/commodore/types.go:ValidateAPITokenResponse
	ValidateAPIToken(context.Context, *ValidateAPITokenRequest) (*ValidateAPITokenResponse, error)
	// Called by Foghorn to initiate DVR recording for a stream
	StartDVR(context.Context, *StartDVRRequest) (*StartDVRResponse, error)
	mustEmbedUnimplementedInternalServiceServer()
}

// UnimplementedInternalServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInternalServiceServer struct{}

func (UnimplementedInternalServiceServer) ValidateStreamKey(context.Context, *ValidateStreamKeyRequest) (*ValidateStreamKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateStreamKey not implemented")
}
func (UnimplementedInternalServiceServer) ResolvePlaybackID(context.Context, *ResolvePlaybackIDRequest) (*ResolvePlaybackIDResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolvePlaybackID not implemented")
}
func (UnimplementedInternalServiceServer) ResolveInternalName(context.Context, *ResolveInternalNameRequest) (*ResolveInternalNameResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveInternalName not implemented")
}
func (UnimplementedInternalServiceServer) ValidateAPIToken(context.Context, *ValidateAPITokenRequest) (*ValidateAPITokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateAPIToken not implemented")
}
func (UnimplementedInternalServiceServer) StartDVR(context.Context, *StartDVRRequest) (*StartDVRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartDVR not implemented")
}
func (UnimplementedInternalServiceServer) mustEmbedUnimplementedInternalServiceServer() {}
func (UnimplementedInternalServiceServer) testEmbeddedByValue()                         {}

// UnsafeInternalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InternalServiceServer will
// result in compilation errors.
type UnsafeInternalServiceServer interface {
	mustEmbedUnimplementedInternalServiceServer()
}

func RegisterInternalServiceServer(s grpc.ServiceRegistrar, srv InternalServiceServer) {
	// If the following call panics, it indicates UnimplementedInternalServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InternalService_ServiceDesc, srv)
}

func _InternalService_ValidateStreamKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateStreamKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ValidateStreamKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ValidateStreamKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ValidateStreamKey(ctx, req.(*ValidateStreamKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ResolvePlaybackID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolvePlaybackIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ResolvePlaybackID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ResolvePlaybackID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ResolvePlaybackID(ctx, req.(*ResolvePlaybackIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ResolveInternalName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveInternalNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ResolveInternalName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ResolveInternalName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ResolveInternalName(ctx, req.(*ResolveInternalNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_ValidateAPIToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateAPITokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).ValidateAPIToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_ValidateAPIToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).ValidateAPIToken(ctx, req.(*ValidateAPITokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_StartDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).StartDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalService_StartDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).StartDVR(ctx, req.(*StartDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InternalService_ServiceDesc is the grpc.ServiceDesc for InternalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InternalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.InternalService",
	HandlerType: (*InternalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateStreamKey",
			Handler:    _InternalService_ValidateStreamKey_Handler,
		},
		{
			MethodName: "ResolvePlaybackID",
			Handler:    _InternalService_ResolvePlaybackID_Handler,
		},
		{
			MethodName: "ResolveInternalName",
			Handler:    _InternalService_ResolveInternalName_Handler,
		},
		{
			MethodName: "ValidateAPIToken",
			Handler:    _InternalService_ValidateAPIToken_Handler,
		},
		{
			MethodName: "StartDVR",
			Handler:    _InternalService_StartDVR_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	UserService_Login_FullMethodName              = "/commodore.UserService/Login"
	UserService_Register_FullMethodName           = "/commodore.UserService/Register"
	UserService_Logout_FullMethodName             = "/commodore.UserService/Logout"
	UserService_RefreshToken_FullMethodName       = "/commodore.UserService/RefreshToken"
	UserService_VerifyEmail_FullMethodName        = "/commodore.UserService/VerifyEmail"
	UserService_ResendVerification_FullMethodName = "/commodore.UserService/ResendVerification"
	UserService_ForgotPassword_FullMethodName     = "/commodore.UserService/ForgotPassword"
	UserService_ResetPassword_FullMethodName      = "/commodore.UserService/ResetPassword"
	UserService_GetMe_FullMethodName              = "/commodore.UserService/GetMe"
	UserService_UpdateMe_FullMethodName           = "/commodore.UserService/UpdateMe"
	UserService_UpdateNewsletter_FullMethodName   = "/commodore.UserService/UpdateNewsletter"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	// Authentication
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
	RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	// Email verification
	VerifyEmail(ctx context.Context, in *VerifyEmailRequest, opts ...grpc.CallOption) (*VerifyEmailResponse, error)
	ResendVerification(ctx context.Context, in *ResendVerificationRequest, opts ...grpc.CallOption) (*ResendVerificationResponse, error)
	// Password reset
	ForgotPassword(ctx context.Context, in *ForgotPasswordRequest, opts ...grpc.CallOption) (*ForgotPasswordResponse, error)
	ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error)
	// Profile
	GetMe(ctx context.Context, in *GetMeRequest, opts ...grpc.CallOption) (*User, error)
	UpdateMe(ctx context.Context, in *UpdateMeRequest, opts ...grpc.CallOption) (*User, error)
	UpdateNewsletter(ctx context.Context, in *UpdateNewsletterRequest, opts ...grpc.CallOption) (*UpdateNewsletterResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, UserService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, UserService_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogoutResponse)
	err := c.cc.Invoke(ctx, UserService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, UserService_RefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) VerifyEmail(ctx context.Context, in *VerifyEmailRequest, opts ...grpc.CallOption) (*VerifyEmailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyEmailResponse)
	err := c.cc.Invoke(ctx, UserService_VerifyEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ResendVerification(ctx context.Context, in *ResendVerificationRequest, opts ...grpc.CallOption) (*ResendVerificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResendVerificationResponse)
	err := c.cc.Invoke(ctx, UserService_ResendVerification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ForgotPassword(ctx context.Context, in *ForgotPasswordRequest, opts ...grpc.CallOption) (*ForgotPasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ForgotPasswordResponse)
	err := c.cc.Invoke(ctx, UserService_ForgotPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetPasswordResponse)
	err := c.cc.Invoke(ctx, UserService_ResetPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetMe(ctx context.Context, in *GetMeRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_GetMe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateMe(ctx context.Context, in *UpdateMeRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_UpdateMe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateNewsletter(ctx context.Context, in *UpdateNewsletterRequest, opts ...grpc.CallOption) (*UpdateNewsletterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateNewsletterResponse)
	err := c.cc.Invoke(ctx, UserService_UpdateNewsletter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	// Authentication
	Login(context.Context, *LoginRequest) (*AuthResponse, error)
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
	RefreshToken(context.Context, *RefreshTokenRequest) (*AuthResponse, error)
	// Email verification
	VerifyEmail(context.Context, *VerifyEmailRequest) (*VerifyEmailResponse, error)
	ResendVerification(context.Context, *ResendVerificationRequest) (*ResendVerificationResponse, error)
	// Password reset
	ForgotPassword(context.Context, *ForgotPasswordRequest) (*ForgotPasswordResponse, error)
	ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error)
	// Profile
	GetMe(context.Context, *GetMeRequest) (*User, error)
	UpdateMe(context.Context, *UpdateMeRequest) (*User, error)
	UpdateNewsletter(context.Context, *UpdateNewsletterRequest) (*UpdateNewsletterResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) Login(context.Context, *LoginRequest) (*AuthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedUserServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedUserServiceServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedUserServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*AuthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedUserServiceServer) VerifyEmail(context.Context, *VerifyEmailRequest) (*VerifyEmailResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyEmail not implemented")
}
func (UnimplementedUserServiceServer) ResendVerification(context.Context, *ResendVerificationRequest) (*ResendVerificationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResendVerification not implemented")
}
func (UnimplementedUserServiceServer) ForgotPassword(context.Context, *ForgotPasswordRequest) (*ForgotPasswordResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ForgotPassword not implemented")
}
func (UnimplementedUserServiceServer) ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedUserServiceServer) GetMe(context.Context, *GetMeRequest) (*User, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMe not implemented")
}
func (UnimplementedUserServiceServer) UpdateMe(context.Context, *UpdateMeRequest) (*User, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateMe not implemented")
}
func (UnimplementedUserServiceServer) UpdateNewsletter(context.Context, *UpdateNewsletterRequest) (*UpdateNewsletterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateNewsletter not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call panics, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_VerifyEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).VerifyEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_VerifyEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).VerifyEmail(ctx, req.(*VerifyEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ResendVerification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResendVerificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ResendVerification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ResendVerification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ResendVerification(ctx, req.(*ResendVerificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ForgotPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForgotPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ForgotPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ForgotPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ForgotPassword(ctx, req.(*ForgotPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ResetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ResetPassword(ctx, req.(*ResetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetMe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetMe(ctx, req.(*GetMeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateMe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateMe(ctx, req.(*UpdateMeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateNewsletter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNewsletterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateNewsletter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateNewsletter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateNewsletter(ctx, req.(*UpdateNewsletterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _UserService_Login_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _UserService_Register_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _UserService_Logout_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _UserService_RefreshToken_Handler,
		},
		{
			MethodName: "VerifyEmail",
			Handler:    _UserService_VerifyEmail_Handler,
		},
		{
			MethodName: "ResendVerification",
			Handler:    _UserService_ResendVerification_Handler,
		},
		{
			MethodName: "ForgotPassword",
			Handler:    _UserService_ForgotPassword_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _UserService_ResetPassword_Handler,
		},
		{
			MethodName: "GetMe",
			Handler:    _UserService_GetMe_Handler,
		},
		{
			MethodName: "UpdateMe",
			Handler:    _UserService_UpdateMe_Handler,
		},
		{
			MethodName: "UpdateNewsletter",
			Handler:    _UserService_UpdateNewsletter_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	StreamService_CreateStream_FullMethodName     = "/commodore.StreamService/CreateStream"
	StreamService_GetStream_FullMethodName        = "/commodore.StreamService/GetStream"
	StreamService_ListStreams_FullMethodName      = "/commodore.StreamService/ListStreams"
	StreamService_UpdateStream_FullMethodName     = "/commodore.StreamService/UpdateStream"
	StreamService_DeleteStream_FullMethodName     = "/commodore.StreamService/DeleteStream"
	StreamService_RefreshStreamKey_FullMethodName = "/commodore.StreamService/RefreshStreamKey"
)

// StreamServiceClient is the client API for StreamService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StreamServiceClient interface {
	CreateStream(ctx context.Context, in *CreateStreamRequest, opts ...grpc.CallOption) (*CreateStreamResponse, error)
	GetStream(ctx context.Context, in *GetStreamRequest, opts ...grpc.CallOption) (*Stream, error)
	ListStreams(ctx context.Context, in *ListStreamsRequest, opts ...grpc.CallOption) (*ListStreamsResponse, error)
	UpdateStream(ctx context.Context, in *UpdateStreamRequest, opts ...grpc.CallOption) (*Stream, error)
	DeleteStream(ctx context.Context, in *DeleteStreamRequest, opts ...grpc.CallOption) (*DeleteStreamResponse, error)
	RefreshStreamKey(ctx context.Context, in *RefreshStreamKeyRequest, opts ...grpc.CallOption) (*RefreshStreamKeyResponse, error)
}

type streamServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamServiceClient(cc grpc.ClientConnInterface) StreamServiceClient {
	return &streamServiceClient{cc}
}

func (c *streamServiceClient) CreateStream(ctx context.Context, in *CreateStreamRequest, opts ...grpc.CallOption) (*CreateStreamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateStreamResponse)
	err := c.cc.Invoke(ctx, StreamService_CreateStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) GetStream(ctx context.Context, in *GetStreamRequest, opts ...grpc.CallOption) (*Stream, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Stream)
	err := c.cc.Invoke(ctx, StreamService_GetStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) ListStreams(ctx context.Context, in *ListStreamsRequest, opts ...grpc.CallOption) (*ListStreamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListStreamsResponse)
	err := c.cc.Invoke(ctx, StreamService_ListStreams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) UpdateStream(ctx context.Context, in *UpdateStreamRequest, opts ...grpc.CallOption) (*Stream, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Stream)
	err := c.cc.Invoke(ctx, StreamService_UpdateStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) DeleteStream(ctx context.Context, in *DeleteStreamRequest, opts ...grpc.CallOption) (*DeleteStreamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteStreamResponse)
	err := c.cc.Invoke(ctx, StreamService_DeleteStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) RefreshStreamKey(ctx context.Context, in *RefreshStreamKeyRequest, opts ...grpc.CallOption) (*RefreshStreamKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshStreamKeyResponse)
	err := c.cc.Invoke(ctx, StreamService_RefreshStreamKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StreamServiceServer is the server API for StreamService service.
// All implementations must embed UnimplementedStreamServiceServer
// for forward compatibility.
type StreamServiceServer interface {
	CreateStream(context.Context, *CreateStreamRequest) (*CreateStreamResponse, error)
	GetStream(context.Context, *GetStreamRequest) (*Stream, error)
	ListStreams(context.Context, *ListStreamsRequest) (*ListStreamsResponse, error)
	UpdateStream(context.Context, *UpdateStreamRequest) (*Stream, error)
	DeleteStream(context.Context, *DeleteStreamRequest) (*DeleteStreamResponse, error)
	RefreshStreamKey(context.Context, *RefreshStreamKeyRequest) (*RefreshStreamKeyResponse, error)
	mustEmbedUnimplementedStreamServiceServer()
}

// UnimplementedStreamServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStreamServiceServer struct{}

func (UnimplementedStreamServiceServer) CreateStream(context.Context, *CreateStreamRequest) (*CreateStreamResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateStream not implemented")
}
func (UnimplementedStreamServiceServer) GetStream(context.Context, *GetStreamRequest) (*Stream, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStream not implemented")
}
func (UnimplementedStreamServiceServer) ListStreams(context.Context, *ListStreamsRequest) (*ListStreamsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListStreams not implemented")
}
func (UnimplementedStreamServiceServer) UpdateStream(context.Context, *UpdateStreamRequest) (*Stream, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateStream not implemented")
}
func (UnimplementedStreamServiceServer) DeleteStream(context.Context, *DeleteStreamRequest) (*DeleteStreamResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteStream not implemented")
}
func (UnimplementedStreamServiceServer) RefreshStreamKey(context.Context, *RefreshStreamKeyRequest) (*RefreshStreamKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RefreshStreamKey not implemented")
}
func (UnimplementedStreamServiceServer) mustEmbedUnimplementedStreamServiceServer() {}
func (UnimplementedStreamServiceServer) testEmbeddedByValue()                       {}

// UnsafeStreamServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StreamServiceServer will
// result in compilation errors.
type UnsafeStreamServiceServer interface {
	mustEmbedUnimplementedStreamServiceServer()
}

func RegisterStreamServiceServer(s grpc.ServiceRegistrar, srv StreamServiceServer) {
	// If the following call panics, it indicates UnimplementedStreamServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StreamService_ServiceDesc, srv)
}

func _StreamService_CreateStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).CreateStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_CreateStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).CreateStream(ctx, req.(*CreateStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_GetStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).GetStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_GetStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).GetStream(ctx, req.(*GetStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_ListStreams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStreamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).ListStreams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_ListStreams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).ListStreams(ctx, req.(*ListStreamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_UpdateStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).UpdateStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_UpdateStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).UpdateStream(ctx, req.(*UpdateStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_DeleteStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).DeleteStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_DeleteStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).DeleteStream(ctx, req.(*DeleteStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_RefreshStreamKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshStreamKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).RefreshStreamKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_RefreshStreamKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).RefreshStreamKey(ctx, req.(*RefreshStreamKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StreamService_ServiceDesc is the grpc.ServiceDesc for StreamService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StreamService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.StreamService",
	HandlerType: (*StreamServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateStream",
			Handler:    _StreamService_CreateStream_Handler,
		},
		{
			MethodName: "GetStream",
			Handler:    _StreamService_GetStream_Handler,
		},
		{
			MethodName: "ListStreams",
			Handler:    _StreamService_ListStreams_Handler,
		},
		{
			MethodName: "UpdateStream",
			Handler:    _StreamService_UpdateStream_Handler,
		},
		{
			MethodName: "DeleteStream",
			Handler:    _StreamService_DeleteStream_Handler,
		},
		{
			MethodName: "RefreshStreamKey",
			Handler:    _StreamService_RefreshStreamKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	StreamKeyService_CreateStreamKey_FullMethodName     = "/commodore.StreamKeyService/CreateStreamKey"
	StreamKeyService_ListStreamKeys_FullMethodName      = "/commodore.StreamKeyService/ListStreamKeys"
	StreamKeyService_DeactivateStreamKey_FullMethodName = "/commodore.StreamKeyService/DeactivateStreamKey"
)

// StreamKeyServiceClient is the client API for StreamKeyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StreamKeyServiceClient interface {
	CreateStreamKey(ctx context.Context, in *CreateStreamKeyRequest, opts ...grpc.CallOption) (*StreamKeyResponse, error)
	ListStreamKeys(ctx context.Context, in *ListStreamKeysRequest, opts ...grpc.CallOption) (*ListStreamKeysResponse, error)
	DeactivateStreamKey(ctx context.Context, in *DeactivateStreamKeyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type streamKeyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamKeyServiceClient(cc grpc.ClientConnInterface) StreamKeyServiceClient {
	return &streamKeyServiceClient{cc}
}

func (c *streamKeyServiceClient) CreateStreamKey(ctx context.Context, in *CreateStreamKeyRequest, opts ...grpc.CallOption) (*StreamKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamKeyResponse)
	err := c.cc.Invoke(ctx, StreamKeyService_CreateStreamKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamKeyServiceClient) ListStreamKeys(ctx context.Context, in *ListStreamKeysRequest, opts ...grpc.CallOption) (*ListStreamKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListStreamKeysResponse)
	err := c.cc.Invoke(ctx, StreamKeyService_ListStreamKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamKeyServiceClient) DeactivateStreamKey(ctx context.Context, in *DeactivateStreamKeyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, StreamKeyService_DeactivateStreamKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StreamKeyServiceServer is the server API for StreamKeyService service.
// All implementations must embed UnimplementedStreamKeyServiceServer
// for forward compatibility.
type StreamKeyServiceServer interface {
	CreateStreamKey(context.Context, *CreateStreamKeyRequest) (*StreamKeyResponse, error)
	ListStreamKeys(context.Context, *ListStreamKeysRequest) (*ListStreamKeysResponse, error)
	DeactivateStreamKey(context.Context, *DeactivateStreamKeyRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedStreamKeyServiceServer()
}

// UnimplementedStreamKeyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStreamKeyServiceServer struct{}

func (UnimplementedStreamKeyServiceServer) CreateStreamKey(context.Context, *CreateStreamKeyRequest) (*StreamKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateStreamKey not implemented")
}
func (UnimplementedStreamKeyServiceServer) ListStreamKeys(context.Context, *ListStreamKeysRequest) (*ListStreamKeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListStreamKeys not implemented")
}
func (UnimplementedStreamKeyServiceServer) DeactivateStreamKey(context.Context, *DeactivateStreamKeyRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeactivateStreamKey not implemented")
}
func (UnimplementedStreamKeyServiceServer) mustEmbedUnimplementedStreamKeyServiceServer() {}
func (UnimplementedStreamKeyServiceServer) testEmbeddedByValue()                          {}

// UnsafeStreamKeyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StreamKeyServiceServer will
// result in compilation errors.
type UnsafeStreamKeyServiceServer interface {
	mustEmbedUnimplementedStreamKeyServiceServer()
}

func RegisterStreamKeyServiceServer(s grpc.ServiceRegistrar, srv StreamKeyServiceServer) {
	// If the following call panics, it indicates UnimplementedStreamKeyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StreamKeyService_ServiceDesc, srv)
}

func _StreamKeyService_CreateStreamKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStreamKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamKeyServiceServer).CreateStreamKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamKeyService_CreateStreamKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamKeyServiceServer).CreateStreamKey(ctx, req.(*CreateStreamKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamKeyService_ListStreamKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStreamKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamKeyServiceServer).ListStreamKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamKeyService_ListStreamKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamKeyServiceServer).ListStreamKeys(ctx, req.(*ListStreamKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamKeyService_DeactivateStreamKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeactivateStreamKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamKeyServiceServer).DeactivateStreamKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamKeyService_DeactivateStreamKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamKeyServiceServer).DeactivateStreamKey(ctx, req.(*DeactivateStreamKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StreamKeyService_ServiceDesc is the grpc.ServiceDesc for StreamKeyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StreamKeyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.StreamKeyService",
	HandlerType: (*StreamKeyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateStreamKey",
			Handler:    _StreamKeyService_CreateStreamKey_Handler,
		},
		{
			MethodName: "ListStreamKeys",
			Handler:    _StreamKeyService_ListStreamKeys_Handler,
		},
		{
			MethodName: "DeactivateStreamKey",
			Handler:    _StreamKeyService_DeactivateStreamKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	DeveloperService_CreateAPIToken_FullMethodName = "/commodore.DeveloperService/CreateAPIToken"
	DeveloperService_ListAPITokens_FullMethodName  = "/commodore.DeveloperService/ListAPITokens"
	DeveloperService_RevokeAPIToken_FullMethodName = "/commodore.DeveloperService/RevokeAPIToken"
)

// DeveloperServiceClient is the client API for DeveloperService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeveloperServiceClient interface {
	CreateAPIToken(ctx context.Context, in *CreateAPITokenRequest, opts ...grpc.CallOption) (*CreateAPITokenResponse, error)
	ListAPITokens(ctx context.Context, in *ListAPITokensRequest, opts ...grpc.CallOption) (*ListAPITokensResponse, error)
	RevokeAPIToken(ctx context.Context, in *RevokeAPITokenRequest, opts ...grpc.CallOption) (*RevokeAPITokenResponse, error)
}

type developerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDeveloperServiceClient(cc grpc.ClientConnInterface) DeveloperServiceClient {
	return &developerServiceClient{cc}
}

func (c *developerServiceClient) CreateAPIToken(ctx context.Context, in *CreateAPITokenRequest, opts ...grpc.CallOption) (*CreateAPITokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAPITokenResponse)
	err := c.cc.Invoke(ctx, DeveloperService_CreateAPIToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *developerServiceClient) ListAPITokens(ctx context.Context, in *ListAPITokensRequest, opts ...grpc.CallOption) (*ListAPITokensResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAPITokensResponse)
	err := c.cc.Invoke(ctx, DeveloperService_ListAPITokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *developerServiceClient) RevokeAPIToken(ctx context.Context, in *RevokeAPITokenRequest, opts ...grpc.CallOption) (*RevokeAPITokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeAPITokenResponse)
	err := c.cc.Invoke(ctx, DeveloperService_RevokeAPIToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeveloperServiceServer is the server API for DeveloperService service.
// All implementations must embed UnimplementedDeveloperServiceServer
// for forward compatibility.
type DeveloperServiceServer interface {
	CreateAPIToken(context.Context, *CreateAPITokenRequest) (*CreateAPITokenResponse, error)
	ListAPITokens(context.Context, *ListAPITokensRequest) (*ListAPITokensResponse, error)
	RevokeAPIToken(context.Context, *RevokeAPITokenRequest) (*RevokeAPITokenResponse, error)
	mustEmbedUnimplementedDeveloperServiceServer()
}

// UnimplementedDeveloperServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDeveloperServiceServer struct{}

func (UnimplementedDeveloperServiceServer) CreateAPIToken(context.Context, *CreateAPITokenRequest) (*CreateAPITokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateAPIToken not implemented")
}
func (UnimplementedDeveloperServiceServer) ListAPITokens(context.Context, *ListAPITokensRequest) (*ListAPITokensResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAPITokens not implemented")
}
func (UnimplementedDeveloperServiceServer) RevokeAPIToken(context.Context, *RevokeAPITokenRequest) (*RevokeAPITokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeAPIToken not implemented")
}
func (UnimplementedDeveloperServiceServer) mustEmbedUnimplementedDeveloperServiceServer() {}
func (UnimplementedDeveloperServiceServer) testEmbeddedByValue()                          {}

// UnsafeDeveloperServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeveloperServiceServer will
// result in compilation errors.
type UnsafeDeveloperServiceServer interface {
	mustEmbedUnimplementedDeveloperServiceServer()
}

func RegisterDeveloperServiceServer(s grpc.ServiceRegistrar, srv DeveloperServiceServer) {
	// If the following call panics, it indicates UnimplementedDeveloperServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DeveloperService_ServiceDesc, srv)
}

func _DeveloperService_CreateAPIToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAPITokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeveloperServiceServer).CreateAPIToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeveloperService_CreateAPIToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeveloperServiceServer).CreateAPIToken(ctx, req.(*CreateAPITokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeveloperService_ListAPITokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAPITokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeveloperServiceServer).ListAPITokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeveloperService_ListAPITokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeveloperServiceServer).ListAPITokens(ctx, req.(*ListAPITokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeveloperService_RevokeAPIToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeAPITokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeveloperServiceServer).RevokeAPIToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeveloperService_RevokeAPIToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeveloperServiceServer).RevokeAPIToken(ctx, req.(*RevokeAPITokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DeveloperService_ServiceDesc is the grpc.ServiceDesc for DeveloperService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeveloperService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.DeveloperService",
	HandlerType: (*DeveloperServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAPIToken",
			Handler:    _DeveloperService_CreateAPIToken_Handler,
		},
		{
			MethodName: "ListAPITokens",
			Handler:    _DeveloperService_ListAPITokens_Handler,
		},
		{
			MethodName: "RevokeAPIToken",
			Handler:    _DeveloperService_RevokeAPIToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	ClipService_CreateClip_FullMethodName  = "/commodore.ClipService/CreateClip"
	ClipService_GetClips_FullMethodName    = "/commodore.ClipService/GetClips"
	ClipService_GetClip_FullMethodName     = "/commodore.ClipService/GetClip"
	ClipService_GetClipURLs_FullMethodName = "/commodore.ClipService/GetClipURLs"
	ClipService_DeleteClip_FullMethodName  = "/commodore.ClipService/DeleteClip"
)

// ClipServiceClient is the client API for ClipService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClipServiceClient interface {
	CreateClip(ctx context.Context, in *CreateClipRequest, opts ...grpc.CallOption) (*CreateClipResponse, error)
	GetClips(ctx context.Context, in *GetClipsRequest, opts ...grpc.CallOption) (*GetClipsResponse, error)
	GetClip(ctx context.Context, in *GetClipRequest, opts ...grpc.CallOption) (*ClipInfo, error)
	GetClipURLs(ctx context.Context, in *GetClipURLsRequest, opts ...grpc.CallOption) (*ClipViewingURLs, error)
	DeleteClip(ctx context.Context, in *DeleteClipRequest, opts ...grpc.CallOption) (*DeleteClipResponse, error)
}

type clipServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClipServiceClient(cc grpc.ClientConnInterface) ClipServiceClient {
	return &clipServiceClient{cc}
}

func (c *clipServiceClient) CreateClip(ctx context.Context, in *CreateClipRequest, opts ...grpc.CallOption) (*CreateClipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateClipResponse)
	err := c.cc.Invoke(ctx, ClipService_CreateClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipServiceClient) GetClips(ctx context.Context, in *GetClipsRequest, opts ...grpc.CallOption) (*GetClipsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClipsResponse)
	err := c.cc.Invoke(ctx, ClipService_GetClips_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipServiceClient) GetClip(ctx context.Context, in *GetClipRequest, opts ...grpc.CallOption) (*ClipInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClipInfo)
	err := c.cc.Invoke(ctx, ClipService_GetClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipServiceClient) GetClipURLs(ctx context.Context, in *GetClipURLsRequest, opts ...grpc.CallOption) (*ClipViewingURLs, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClipViewingURLs)
	err := c.cc.Invoke(ctx, ClipService_GetClipURLs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clipServiceClient) DeleteClip(ctx context.Context, in *DeleteClipRequest, opts ...grpc.CallOption) (*DeleteClipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteClipResponse)
	err := c.cc.Invoke(ctx, ClipService_DeleteClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClipServiceServer is the server API for ClipService service.
// All implementations must embed UnimplementedClipServiceServer
// for forward compatibility.
type ClipServiceServer interface {
	CreateClip(context.Context, *CreateClipRequest) (*CreateClipResponse, error)
	GetClips(context.Context, *GetClipsRequest) (*GetClipsResponse, error)
	GetClip(context.Context, *GetClipRequest) (*ClipInfo, error)
	GetClipURLs(context.Context, *GetClipURLsRequest) (*ClipViewingURLs, error)
	DeleteClip(context.Context, *DeleteClipRequest) (*DeleteClipResponse, error)
	mustEmbedUnimplementedClipServiceServer()
}

// UnimplementedClipServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClipServiceServer struct{}

func (UnimplementedClipServiceServer) CreateClip(context.Context, *CreateClipRequest) (*CreateClipResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateClip not implemented")
}
func (UnimplementedClipServiceServer) GetClips(context.Context, *GetClipsRequest) (*GetClipsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClips not implemented")
}
func (UnimplementedClipServiceServer) GetClip(context.Context, *GetClipRequest) (*ClipInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClip not implemented")
}
func (UnimplementedClipServiceServer) GetClipURLs(context.Context, *GetClipURLsRequest) (*ClipViewingURLs, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClipURLs not implemented")
}
func (UnimplementedClipServiceServer) DeleteClip(context.Context, *DeleteClipRequest) (*DeleteClipResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteClip not implemented")
}
func (UnimplementedClipServiceServer) mustEmbedUnimplementedClipServiceServer() {}
func (UnimplementedClipServiceServer) testEmbeddedByValue()                     {}

// UnsafeClipServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClipServiceServer will
// result in compilation errors.
type UnsafeClipServiceServer interface {
	mustEmbedUnimplementedClipServiceServer()
}

func RegisterClipServiceServer(s grpc.ServiceRegistrar, srv ClipServiceServer) {
	// If the following call panics, it indicates UnimplementedClipServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ClipService_ServiceDesc, srv)
}

func _ClipService_CreateClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).CreateClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_CreateClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).CreateClip(ctx, req.(*CreateClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipService_GetClips_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClipsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).GetClips(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_GetClips_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).GetClips(ctx, req.(*GetClipsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipService_GetClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).GetClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_GetClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).GetClip(ctx, req.(*GetClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipService_GetClipURLs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClipURLsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).GetClipURLs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_GetClipURLs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).GetClipURLs(ctx, req.(*GetClipURLsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClipService_DeleteClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClipServiceServer).DeleteClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClipService_DeleteClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClipServiceServer).DeleteClip(ctx, req.(*DeleteClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClipService_ServiceDesc is the grpc.ServiceDesc for ClipService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClipService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.ClipService",
	HandlerType: (*ClipServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateClip",
			Handler:    _ClipService_CreateClip_Handler,
		},
		{
			MethodName: "GetClips",
			Handler:    _ClipService_GetClips_Handler,
		},
		{
			MethodName: "GetClip",
			Handler:    _ClipService_GetClip_Handler,
		},
		{
			MethodName: "GetClipURLs",
			Handler:    _ClipService_GetClipURLs_Handler,
		},
		{
			MethodName: "DeleteClip",
			Handler:    _ClipService_DeleteClip_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	DVRService_StopDVR_FullMethodName         = "/commodore.DVRService/StopDVR"
	DVRService_ListDVRRequests_FullMethodName = "/commodore.DVRService/ListDVRRequests"
	DVRService_GetDVRStatus_FullMethodName    = "/commodore.DVRService/GetDVRStatus"
)

// DVRServiceClient is the client API for DVRService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DVRServiceClient interface {
	// StartDVR is in InternalService (called by Foghorn)
	// These are user-facing DVR management
	StopDVR(ctx context.Context, in *StopDVRRequest, opts ...grpc.CallOption) (*StopDVRResponse, error)
	ListDVRRequests(ctx context.Context, in *ListDVRRecordingsRequest, opts ...grpc.CallOption) (*ListDVRRecordingsResponse, error)
	GetDVRStatus(ctx context.Context, in *GetDVRStatusRequest, opts ...grpc.CallOption) (*DVRInfo, error)
}

type dVRServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDVRServiceClient(cc grpc.ClientConnInterface) DVRServiceClient {
	return &dVRServiceClient{cc}
}

func (c *dVRServiceClient) StopDVR(ctx context.Context, in *StopDVRRequest, opts ...grpc.CallOption) (*StopDVRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopDVRResponse)
	err := c.cc.Invoke(ctx, DVRService_StopDVR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dVRServiceClient) ListDVRRequests(ctx context.Context, in *ListDVRRecordingsRequest, opts ...grpc.CallOption) (*ListDVRRecordingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDVRRecordingsResponse)
	err := c.cc.Invoke(ctx, DVRService_ListDVRRequests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dVRServiceClient) GetDVRStatus(ctx context.Context, in *GetDVRStatusRequest, opts ...grpc.CallOption) (*DVRInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DVRInfo)
	err := c.cc.Invoke(ctx, DVRService_GetDVRStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DVRServiceServer is the server API for DVRService service.
// All implementations must embed UnimplementedDVRServiceServer
// for forward compatibility.
type DVRServiceServer interface {
	// StartDVR is in InternalService (called by Foghorn)
	// These are user-facing DVR management
	StopDVR(context.Context, *StopDVRRequest) (*StopDVRResponse, error)
	ListDVRRequests(context.Context, *ListDVRRecordingsRequest) (*ListDVRRecordingsResponse, error)
	GetDVRStatus(context.Context, *GetDVRStatusRequest) (*DVRInfo, error)
	mustEmbedUnimplementedDVRServiceServer()
}

// UnimplementedDVRServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDVRServiceServer struct{}

func (UnimplementedDVRServiceServer) StopDVR(context.Context, *StopDVRRequest) (*StopDVRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopDVR not implemented")
}
func (UnimplementedDVRServiceServer) ListDVRRequests(context.Context, *ListDVRRecordingsRequest) (*ListDVRRecordingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDVRRequests not implemented")
}
func (UnimplementedDVRServiceServer) GetDVRStatus(context.Context, *GetDVRStatusRequest) (*DVRInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDVRStatus not implemented")
}
func (UnimplementedDVRServiceServer) mustEmbedUnimplementedDVRServiceServer() {}
func (UnimplementedDVRServiceServer) testEmbeddedByValue()                    {}

// UnsafeDVRServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DVRServiceServer will
// result in compilation errors.
type UnsafeDVRServiceServer interface {
	mustEmbedUnimplementedDVRServiceServer()
}

func RegisterDVRServiceServer(s grpc.ServiceRegistrar, srv DVRServiceServer) {
	// If the following call panics, it indicates UnimplementedDVRServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DVRService_ServiceDesc, srv)
}

func _DVRService_StopDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRServiceServer).StopDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRService_StopDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRServiceServer).StopDVR(ctx, req.(*StopDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DVRService_ListDVRRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDVRRecordingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRServiceServer).ListDVRRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRService_ListDVRRequests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRServiceServer).ListDVRRequests(ctx, req.(*ListDVRRecordingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DVRService_GetDVRStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDVRStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DVRServiceServer).GetDVRStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DVRService_GetDVRStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DVRServiceServer).GetDVRStatus(ctx, req.(*GetDVRStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DVRService_ServiceDesc is the grpc.ServiceDesc for DVRService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DVRService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.DVRService",
	HandlerType: (*DVRServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StopDVR",
			Handler:    _DVRService_StopDVR_Handler,
		},
		{
			MethodName: "ListDVRRequests",
			Handler:    _DVRService_ListDVRRequests_Handler,
		},
		{
			MethodName: "GetDVRStatus",
			Handler:    _DVRService_GetDVRStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	RecordingService_ListRecordings_FullMethodName = "/commodore.RecordingService/ListRecordings"
)

// RecordingServiceClient is the client API for RecordingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RecordingServiceClient interface {
	ListRecordings(ctx context.Context, in *ListRecordingsRequest, opts ...grpc.CallOption) (*ListRecordingsResponse, error)
}

type recordingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRecordingServiceClient(cc grpc.ClientConnInterface) RecordingServiceClient {
	return &recordingServiceClient{cc}
}

func (c *recordingServiceClient) ListRecordings(ctx context.Context, in *ListRecordingsRequest, opts ...grpc.CallOption) (*ListRecordingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRecordingsResponse)
	err := c.cc.Invoke(ctx, RecordingService_ListRecordings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RecordingServiceServer is the server API for RecordingService service.
// All implementations must embed UnimplementedRecordingServiceServer
// for forward compatibility.
type RecordingServiceServer interface {
	ListRecordings(context.Context, *ListRecordingsRequest) (*ListRecordingsResponse, error)
	mustEmbedUnimplementedRecordingServiceServer()
}

// UnimplementedRecordingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRecordingServiceServer struct{}

func (UnimplementedRecordingServiceServer) ListRecordings(context.Context, *ListRecordingsRequest) (*ListRecordingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRecordings not implemented")
}
func (UnimplementedRecordingServiceServer) mustEmbedUnimplementedRecordingServiceServer() {}
func (UnimplementedRecordingServiceServer) testEmbeddedByValue()                          {}

// UnsafeRecordingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RecordingServiceServer will
// result in compilation errors.
type UnsafeRecordingServiceServer interface {
	mustEmbedUnimplementedRecordingServiceServer()
}

func RegisterRecordingServiceServer(s grpc.ServiceRegistrar, srv RecordingServiceServer) {
	// If the following call panics, it indicates UnimplementedRecordingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RecordingService_ServiceDesc, srv)
}

func _RecordingService_ListRecordings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRecordingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RecordingServiceServer).ListRecordings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RecordingService_ListRecordings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RecordingServiceServer).ListRecordings(ctx, req.(*ListRecordingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RecordingService_ServiceDesc is the grpc.ServiceDesc for RecordingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RecordingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.RecordingService",
	HandlerType: (*RecordingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListRecordings",
			Handler:    _RecordingService_ListRecordings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}

const (
	ViewerService_ResolveViewerEndpoint_FullMethodName = "/commodore.ViewerService/ResolveViewerEndpoint"
	ViewerService_GetStreamMeta_FullMethodName         = "/commodore.ViewerService/GetStreamMeta"
)

// ViewerServiceClient is the client API for ViewerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ViewerServiceClient interface {
	ResolveViewerEndpoint(ctx context.Context, in *ViewerEndpointRequest, opts ...grpc.CallOption) (*ViewerEndpointResponse, error)
	GetStreamMeta(ctx context.Context, in *StreamMetaRequest, opts ...grpc.CallOption) (*StreamMetaResponse, error)
}

type viewerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewViewerServiceClient(cc grpc.ClientConnInterface) ViewerServiceClient {
	return &viewerServiceClient{cc}
}

func (c *viewerServiceClient) ResolveViewerEndpoint(ctx context.Context, in *ViewerEndpointRequest, opts ...grpc.CallOption) (*ViewerEndpointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ViewerEndpointResponse)
	err := c.cc.Invoke(ctx, ViewerService_ResolveViewerEndpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *viewerServiceClient) GetStreamMeta(ctx context.Context, in *StreamMetaRequest, opts ...grpc.CallOption) (*StreamMetaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StreamMetaResponse)
	err := c.cc.Invoke(ctx, ViewerService_GetStreamMeta_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ViewerServiceServer is the server API for ViewerService service.
// All implementations must embed UnimplementedViewerServiceServer
// for forward compatibility.
type ViewerServiceServer interface {
	ResolveViewerEndpoint(context.Context, *ViewerEndpointRequest) (*ViewerEndpointResponse, error)
	GetStreamMeta(context.Context, *StreamMetaRequest) (*StreamMetaResponse, error)
	mustEmbedUnimplementedViewerServiceServer()
}

// UnimplementedViewerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedViewerServiceServer struct{}

func (UnimplementedViewerServiceServer) ResolveViewerEndpoint(context.Context, *ViewerEndpointRequest) (*ViewerEndpointResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveViewerEndpoint not implemented")
}
func (UnimplementedViewerServiceServer) GetStreamMeta(context.Context, *StreamMetaRequest) (*StreamMetaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStreamMeta not implemented")
}
func (UnimplementedViewerServiceServer) mustEmbedUnimplementedViewerServiceServer() {}
func (UnimplementedViewerServiceServer) testEmbeddedByValue()                       {}

// UnsafeViewerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ViewerServiceServer will
// result in compilation errors.
type UnsafeViewerServiceServer interface {
	mustEmbedUnimplementedViewerServiceServer()
}

func RegisterViewerServiceServer(s grpc.ServiceRegistrar, srv ViewerServiceServer) {
	// If the following call panics, it indicates UnimplementedViewerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ViewerService_ServiceDesc, srv)
}

func _ViewerService_ResolveViewerEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ViewerEndpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerServiceServer).ResolveViewerEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerService_ResolveViewerEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerServiceServer).ResolveViewerEndpoint(ctx, req.(*ViewerEndpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ViewerService_GetStreamMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ViewerServiceServer).GetStreamMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ViewerService_GetStreamMeta_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ViewerServiceServer).GetStreamMeta(ctx, req.(*StreamMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ViewerService_ServiceDesc is the grpc.ServiceDesc for ViewerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ViewerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "commodore.ViewerService",
	HandlerType: (*ViewerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResolveViewerEndpoint",
			Handler:    _ViewerService_ResolveViewerEndpoint_Handler,
		},
		{
			MethodName: "GetStreamMeta",
			Handler:    _ViewerService_GetStreamMeta_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commodore.proto",
}
