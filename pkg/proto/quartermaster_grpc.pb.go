// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.4
// source: quartermaster.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TenantService_GetTenant_FullMethodName           = "/quartermaster.TenantService/GetTenant"
	TenantService_ValidateTenant_FullMethodName      = "/quartermaster.TenantService/ValidateTenant"
	TenantService_ResolveTenant_FullMethodName       = "/quartermaster.TenantService/ResolveTenant"
	TenantService_GetClusterRouting_FullMethodName   = "/quartermaster.TenantService/GetClusterRouting"
	TenantService_ListTenants_FullMethodName         = "/quartermaster.TenantService/ListTenants"
	TenantService_CreateTenant_FullMethodName        = "/quartermaster.TenantService/CreateTenant"
	TenantService_UpdateTenant_FullMethodName        = "/quartermaster.TenantService/UpdateTenant"
	TenantService_DeleteTenant_FullMethodName        = "/quartermaster.TenantService/DeleteTenant"
	TenantService_GetTenantCluster_FullMethodName    = "/quartermaster.TenantService/GetTenantCluster"
	TenantService_UpdateTenantCluster_FullMethodName = "/quartermaster.TenantService/UpdateTenantCluster"
	TenantService_GetTenantsBatch_FullMethodName     = "/quartermaster.TenantService/GetTenantsBatch"
	TenantService_GetTenantsByCluster_FullMethodName = "/quartermaster.TenantService/GetTenantsByCluster"
	TenantService_ListActiveTenants_FullMethodName   = "/quartermaster.TenantService/ListActiveTenants"
)

// TenantServiceClient is the client API for TenantService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// TenantService handles tenant resolution and validation
type TenantServiceClient interface {
	// Get tenant info by ID
	GetTenant(ctx context.Context, in *GetTenantRequest, opts ...grpc.CallOption) (*GetTenantResponse, error)
	// Validate tenant exists and is active
	// Source: pkg/api/quartermaster/types.go:ValidateTenantRequest
	ValidateTenant(ctx context.Context, in *ValidateTenantRequest, opts ...grpc.CallOption) (*ValidateTenantResponse, error)
	// Resolve tenant by domain/subdomain
	// Source: pkg/api/quartermaster/types.go:ResolveTenantRequest (alias to models)
	ResolveTenant(ctx context.Context, in *ResolveTenantRequest, opts ...grpc.CallOption) (*ResolveTenantResponse, error)
	// Resolve cluster routing for a tenant/stream
	// Source: pkg/api/quartermaster/types.go:GetClusterRoutingRequest
	GetClusterRouting(ctx context.Context, in *GetClusterRoutingRequest, opts ...grpc.CallOption) (*ClusterRoutingResponse, error)
	// List tenants (admin)
	ListTenants(ctx context.Context, in *ListTenantsRequest, opts ...grpc.CallOption) (*ListTenantsResponse, error)
	// Create tenant (admin)
	CreateTenant(ctx context.Context, in *CreateTenantRequest, opts ...grpc.CallOption) (*CreateTenantResponse, error)
	// Update tenant
	UpdateTenant(ctx context.Context, in *UpdateTenantRequest, opts ...grpc.CallOption) (*Tenant, error)
	// Delete (soft delete) tenant
	DeleteTenant(ctx context.Context, in *DeleteTenantRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Get tenant cluster/deployment info
	GetTenantCluster(ctx context.Context, in *GetTenantClusterRequest, opts ...grpc.CallOption) (*GetTenantResponse, error)
	// Update tenant cluster assignment
	UpdateTenantCluster(ctx context.Context, in *UpdateTenantClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Batch get tenants by IDs
	GetTenantsBatch(ctx context.Context, in *GetTenantsBatchRequest, opts ...grpc.CallOption) (*ListTenantsResponse, error)
	// Get tenants assigned to a cluster
	GetTenantsByCluster(ctx context.Context, in *GetTenantsByClusterRequest, opts ...grpc.CallOption) (*GetTenantsByClusterResponse, error)
	// ===== CROSS-SERVICE: BILLING BATCH PROCESSING =====
	// List all active tenant IDs for billing job iteration.
	// Called by Purser billing job to avoid cross-service DB access.
	ListActiveTenants(ctx context.Context, in *ListActiveTenantsRequest, opts ...grpc.CallOption) (*ListActiveTenantsResponse, error)
}

type tenantServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTenantServiceClient(cc grpc.ClientConnInterface) TenantServiceClient {
	return &tenantServiceClient{cc}
}

func (c *tenantServiceClient) GetTenant(ctx context.Context, in *GetTenantRequest, opts ...grpc.CallOption) (*GetTenantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTenantResponse)
	err := c.cc.Invoke(ctx, TenantService_GetTenant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) ValidateTenant(ctx context.Context, in *ValidateTenantRequest, opts ...grpc.CallOption) (*ValidateTenantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateTenantResponse)
	err := c.cc.Invoke(ctx, TenantService_ValidateTenant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) ResolveTenant(ctx context.Context, in *ResolveTenantRequest, opts ...grpc.CallOption) (*ResolveTenantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveTenantResponse)
	err := c.cc.Invoke(ctx, TenantService_ResolveTenant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) GetClusterRouting(ctx context.Context, in *GetClusterRoutingRequest, opts ...grpc.CallOption) (*ClusterRoutingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterRoutingResponse)
	err := c.cc.Invoke(ctx, TenantService_GetClusterRouting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) ListTenants(ctx context.Context, in *ListTenantsRequest, opts ...grpc.CallOption) (*ListTenantsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTenantsResponse)
	err := c.cc.Invoke(ctx, TenantService_ListTenants_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) CreateTenant(ctx context.Context, in *CreateTenantRequest, opts ...grpc.CallOption) (*CreateTenantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTenantResponse)
	err := c.cc.Invoke(ctx, TenantService_CreateTenant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) UpdateTenant(ctx context.Context, in *UpdateTenantRequest, opts ...grpc.CallOption) (*Tenant, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tenant)
	err := c.cc.Invoke(ctx, TenantService_UpdateTenant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) DeleteTenant(ctx context.Context, in *DeleteTenantRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TenantService_DeleteTenant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) GetTenantCluster(ctx context.Context, in *GetTenantClusterRequest, opts ...grpc.CallOption) (*GetTenantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTenantResponse)
	err := c.cc.Invoke(ctx, TenantService_GetTenantCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) UpdateTenantCluster(ctx context.Context, in *UpdateTenantClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TenantService_UpdateTenantCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) GetTenantsBatch(ctx context.Context, in *GetTenantsBatchRequest, opts ...grpc.CallOption) (*ListTenantsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTenantsResponse)
	err := c.cc.Invoke(ctx, TenantService_GetTenantsBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) GetTenantsByCluster(ctx context.Context, in *GetTenantsByClusterRequest, opts ...grpc.CallOption) (*GetTenantsByClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTenantsByClusterResponse)
	err := c.cc.Invoke(ctx, TenantService_GetTenantsByCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) ListActiveTenants(ctx context.Context, in *ListActiveTenantsRequest, opts ...grpc.CallOption) (*ListActiveTenantsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListActiveTenantsResponse)
	err := c.cc.Invoke(ctx, TenantService_ListActiveTenants_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantServiceServer is the server API for TenantService service.
// All implementations must embed UnimplementedTenantServiceServer
// for forward compatibility.
//
// TenantService handles tenant resolution and validation
type TenantServiceServer interface {
	// Get tenant info by ID
	GetTenant(context.Context, *GetTenantRequest) (*GetTenantResponse, error)
	// Validate tenant exists and is active
	// Source: pkg/api/quartermaster/types.go:ValidateTenantRequest
	ValidateTenant(context.Context, *ValidateTenantRequest) (*ValidateTenantResponse, error)
	// Resolve tenant by domain/subdomain
	// Source: pkg/api/quartermaster/types.go:ResolveTenantRequest (alias to models)
	ResolveTenant(context.Context, *ResolveTenantRequest) (*ResolveTenantResponse, error)
	// Resolve cluster routing for a tenant/stream
	// Source: pkg/api/quartermaster/types.go:GetClusterRoutingRequest
	GetClusterRouting(context.Context, *GetClusterRoutingRequest) (*ClusterRoutingResponse, error)
	// List tenants (admin)
	ListTenants(context.Context, *ListTenantsRequest) (*ListTenantsResponse, error)
	// Create tenant (admin)
	CreateTenant(context.Context, *CreateTenantRequest) (*CreateTenantResponse, error)
	// Update tenant
	UpdateTenant(context.Context, *UpdateTenantRequest) (*Tenant, error)
	// Delete (soft delete) tenant
	DeleteTenant(context.Context, *DeleteTenantRequest) (*emptypb.Empty, error)
	// Get tenant cluster/deployment info
	GetTenantCluster(context.Context, *GetTenantClusterRequest) (*GetTenantResponse, error)
	// Update tenant cluster assignment
	UpdateTenantCluster(context.Context, *UpdateTenantClusterRequest) (*emptypb.Empty, error)
	// Batch get tenants by IDs
	GetTenantsBatch(context.Context, *GetTenantsBatchRequest) (*ListTenantsResponse, error)
	// Get tenants assigned to a cluster
	GetTenantsByCluster(context.Context, *GetTenantsByClusterRequest) (*GetTenantsByClusterResponse, error)
	// ===== CROSS-SERVICE: BILLING BATCH PROCESSING =====
	// List all active tenant IDs for billing job iteration.
	// Called by Purser billing job to avoid cross-service DB access.
	ListActiveTenants(context.Context, *ListActiveTenantsRequest) (*ListActiveTenantsResponse, error)
	mustEmbedUnimplementedTenantServiceServer()
}

// UnimplementedTenantServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTenantServiceServer struct{}

func (UnimplementedTenantServiceServer) GetTenant(context.Context, *GetTenantRequest) (*GetTenantResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTenant not implemented")
}
func (UnimplementedTenantServiceServer) ValidateTenant(context.Context, *ValidateTenantRequest) (*ValidateTenantResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateTenant not implemented")
}
func (UnimplementedTenantServiceServer) ResolveTenant(context.Context, *ResolveTenantRequest) (*ResolveTenantResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveTenant not implemented")
}
func (UnimplementedTenantServiceServer) GetClusterRouting(context.Context, *GetClusterRoutingRequest) (*ClusterRoutingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClusterRouting not implemented")
}
func (UnimplementedTenantServiceServer) ListTenants(context.Context, *ListTenantsRequest) (*ListTenantsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTenants not implemented")
}
func (UnimplementedTenantServiceServer) CreateTenant(context.Context, *CreateTenantRequest) (*CreateTenantResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTenant not implemented")
}
func (UnimplementedTenantServiceServer) UpdateTenant(context.Context, *UpdateTenantRequest) (*Tenant, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTenant not implemented")
}
func (UnimplementedTenantServiceServer) DeleteTenant(context.Context, *DeleteTenantRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteTenant not implemented")
}
func (UnimplementedTenantServiceServer) GetTenantCluster(context.Context, *GetTenantClusterRequest) (*GetTenantResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTenantCluster not implemented")
}
func (UnimplementedTenantServiceServer) UpdateTenantCluster(context.Context, *UpdateTenantClusterRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTenantCluster not implemented")
}
func (UnimplementedTenantServiceServer) GetTenantsBatch(context.Context, *GetTenantsBatchRequest) (*ListTenantsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTenantsBatch not implemented")
}
func (UnimplementedTenantServiceServer) GetTenantsByCluster(context.Context, *GetTenantsByClusterRequest) (*GetTenantsByClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTenantsByCluster not implemented")
}
func (UnimplementedTenantServiceServer) ListActiveTenants(context.Context, *ListActiveTenantsRequest) (*ListActiveTenantsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListActiveTenants not implemented")
}
func (UnimplementedTenantServiceServer) mustEmbedUnimplementedTenantServiceServer() {}
func (UnimplementedTenantServiceServer) testEmbeddedByValue()                       {}

// UnsafeTenantServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TenantServiceServer will
// result in compilation errors.
type UnsafeTenantServiceServer interface {
	mustEmbedUnimplementedTenantServiceServer()
}

func RegisterTenantServiceServer(s grpc.ServiceRegistrar, srv TenantServiceServer) {
	// If the following call panics, it indicates UnimplementedTenantServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TenantService_ServiceDesc, srv)
}

func _TenantService_GetTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).GetTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_GetTenant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).GetTenant(ctx, req.(*GetTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_ValidateTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).ValidateTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_ValidateTenant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).ValidateTenant(ctx, req.(*ValidateTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_ResolveTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).ResolveTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_ResolveTenant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).ResolveTenant(ctx, req.(*ResolveTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_GetClusterRouting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterRoutingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).GetClusterRouting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_GetClusterRouting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).GetClusterRouting(ctx, req.(*GetClusterRoutingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_ListTenants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTenantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).ListTenants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_ListTenants_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).ListTenants(ctx, req.(*ListTenantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_CreateTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).CreateTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_CreateTenant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).CreateTenant(ctx, req.(*CreateTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_UpdateTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).UpdateTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_UpdateTenant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).UpdateTenant(ctx, req.(*UpdateTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_DeleteTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).DeleteTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_DeleteTenant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).DeleteTenant(ctx, req.(*DeleteTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_GetTenantCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTenantClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).GetTenantCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_GetTenantCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).GetTenantCluster(ctx, req.(*GetTenantClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_UpdateTenantCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTenantClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).UpdateTenantCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_UpdateTenantCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).UpdateTenantCluster(ctx, req.(*UpdateTenantClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_GetTenantsBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTenantsBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).GetTenantsBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_GetTenantsBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).GetTenantsBatch(ctx, req.(*GetTenantsBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_GetTenantsByCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTenantsByClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).GetTenantsByCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_GetTenantsByCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).GetTenantsByCluster(ctx, req.(*GetTenantsByClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_ListActiveTenants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListActiveTenantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).ListActiveTenants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_ListActiveTenants_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).ListActiveTenants(ctx, req.(*ListActiveTenantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TenantService_ServiceDesc is the grpc.ServiceDesc for TenantService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TenantService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quartermaster.TenantService",
	HandlerType: (*TenantServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTenant",
			Handler:    _TenantService_GetTenant_Handler,
		},
		{
			MethodName: "ValidateTenant",
			Handler:    _TenantService_ValidateTenant_Handler,
		},
		{
			MethodName: "ResolveTenant",
			Handler:    _TenantService_ResolveTenant_Handler,
		},
		{
			MethodName: "GetClusterRouting",
			Handler:    _TenantService_GetClusterRouting_Handler,
		},
		{
			MethodName: "ListTenants",
			Handler:    _TenantService_ListTenants_Handler,
		},
		{
			MethodName: "CreateTenant",
			Handler:    _TenantService_CreateTenant_Handler,
		},
		{
			MethodName: "UpdateTenant",
			Handler:    _TenantService_UpdateTenant_Handler,
		},
		{
			MethodName: "DeleteTenant",
			Handler:    _TenantService_DeleteTenant_Handler,
		},
		{
			MethodName: "GetTenantCluster",
			Handler:    _TenantService_GetTenantCluster_Handler,
		},
		{
			MethodName: "UpdateTenantCluster",
			Handler:    _TenantService_UpdateTenantCluster_Handler,
		},
		{
			MethodName: "GetTenantsBatch",
			Handler:    _TenantService_GetTenantsBatch_Handler,
		},
		{
			MethodName: "GetTenantsByCluster",
			Handler:    _TenantService_GetTenantsByCluster_Handler,
		},
		{
			MethodName: "ListActiveTenants",
			Handler:    _TenantService_ListActiveTenants_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "quartermaster.proto",
}

const (
	ClusterService_GetCluster_FullMethodName                 = "/quartermaster.ClusterService/GetCluster"
	ClusterService_ListClusters_FullMethodName               = "/quartermaster.ClusterService/ListClusters"
	ClusterService_CreateCluster_FullMethodName              = "/quartermaster.ClusterService/CreateCluster"
	ClusterService_UpdateCluster_FullMethodName              = "/quartermaster.ClusterService/UpdateCluster"
	ClusterService_ListClustersForTenant_FullMethodName      = "/quartermaster.ClusterService/ListClustersForTenant"
	ClusterService_ListClustersAvailable_FullMethodName      = "/quartermaster.ClusterService/ListClustersAvailable"
	ClusterService_GrantClusterAccess_FullMethodName         = "/quartermaster.ClusterService/GrantClusterAccess"
	ClusterService_SubscribeToCluster_FullMethodName         = "/quartermaster.ClusterService/SubscribeToCluster"
	ClusterService_UnsubscribeFromCluster_FullMethodName     = "/quartermaster.ClusterService/UnsubscribeFromCluster"
	ClusterService_ListMySubscriptions_FullMethodName        = "/quartermaster.ClusterService/ListMySubscriptions"
	ClusterService_ListMarketplaceClusters_FullMethodName    = "/quartermaster.ClusterService/ListMarketplaceClusters"
	ClusterService_GetMarketplaceCluster_FullMethodName      = "/quartermaster.ClusterService/GetMarketplaceCluster"
	ClusterService_UpdateClusterMarketplace_FullMethodName   = "/quartermaster.ClusterService/UpdateClusterMarketplace"
	ClusterService_CreatePrivateCluster_FullMethodName       = "/quartermaster.ClusterService/CreatePrivateCluster"
	ClusterService_CreateClusterInvite_FullMethodName        = "/quartermaster.ClusterService/CreateClusterInvite"
	ClusterService_RevokeClusterInvite_FullMethodName        = "/quartermaster.ClusterService/RevokeClusterInvite"
	ClusterService_ListClusterInvites_FullMethodName         = "/quartermaster.ClusterService/ListClusterInvites"
	ClusterService_ListMyClusterInvites_FullMethodName       = "/quartermaster.ClusterService/ListMyClusterInvites"
	ClusterService_RequestClusterSubscription_FullMethodName = "/quartermaster.ClusterService/RequestClusterSubscription"
	ClusterService_AcceptClusterInvite_FullMethodName        = "/quartermaster.ClusterService/AcceptClusterInvite"
	ClusterService_ListPendingSubscriptions_FullMethodName   = "/quartermaster.ClusterService/ListPendingSubscriptions"
	ClusterService_ApproveClusterSubscription_FullMethodName = "/quartermaster.ClusterService/ApproveClusterSubscription"
	ClusterService_RejectClusterSubscription_FullMethodName  = "/quartermaster.ClusterService/RejectClusterSubscription"
	ClusterService_GetClusterMetadataBatch_FullMethodName    = "/quartermaster.ClusterService/GetClusterMetadataBatch"
)

// ClusterServiceClient is the client API for ClusterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ClusterService handles infrastructure cluster management
type ClusterServiceClient interface {
	GetCluster(ctx context.Context, in *GetClusterRequest, opts ...grpc.CallOption) (*ClusterResponse, error)
	ListClusters(ctx context.Context, in *ListClustersRequest, opts ...grpc.CallOption) (*ListClustersResponse, error)
	CreateCluster(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*ClusterResponse, error)
	UpdateCluster(ctx context.Context, in *UpdateClusterRequest, opts ...grpc.CallOption) (*ClusterResponse, error)
	// Get clusters accessible to a tenant
	ListClustersForTenant(ctx context.Context, in *ListClustersForTenantRequest, opts ...grpc.CallOption) (*ClustersAccessResponse, error)
	// Get clusters available for tenant onboarding
	ListClustersAvailable(ctx context.Context, in *ListClustersAvailableRequest, opts ...grpc.CallOption) (*ClustersAvailableResponse, error)
	// Grant cluster access to tenant
	GrantClusterAccess(ctx context.Context, in *GrantClusterAccessRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Subscribe to a public/shared cluster
	SubscribeToCluster(ctx context.Context, in *SubscribeToClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Unsubscribe from a cluster
	UnsubscribeFromCluster(ctx context.Context, in *UnsubscribeFromClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// List clusters the tenant is subscribed to
	ListMySubscriptions(ctx context.Context, in *ListMySubscriptionsRequest, opts ...grpc.CallOption) (*ListClustersResponse, error)
	// List clusters in marketplace (respects visibility + billing tier)
	ListMarketplaceClusters(ctx context.Context, in *ListMarketplaceClustersRequest, opts ...grpc.CallOption) (*ListMarketplaceClustersResponse, error)
	// Get a marketplace cluster (with optional invite token for unlisted)
	GetMarketplaceCluster(ctx context.Context, in *GetMarketplaceClusterRequest, opts ...grpc.CallOption) (*MarketplaceClusterEntry, error)
	// Update cluster marketplace settings (owner only)
	UpdateClusterMarketplace(ctx context.Context, in *UpdateClusterMarketplaceRequest, opts ...grpc.CallOption) (*ClusterResponse, error)
	// Create a private cluster (self-hosted edge)
	CreatePrivateCluster(ctx context.Context, in *CreatePrivateClusterRequest, opts ...grpc.CallOption) (*CreatePrivateClusterResponse, error)
	// Invite management (cluster owner)
	CreateClusterInvite(ctx context.Context, in *CreateClusterInviteRequest, opts ...grpc.CallOption) (*ClusterInvite, error)
	RevokeClusterInvite(ctx context.Context, in *RevokeClusterInviteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListClusterInvites(ctx context.Context, in *ListClusterInvitesRequest, opts ...grpc.CallOption) (*ListClusterInvitesResponse, error)
	// For invited tenants: list pending invites
	ListMyClusterInvites(ctx context.Context, in *ListMyClusterInvitesRequest, opts ...grpc.CallOption) (*ListClusterInvitesResponse, error)
	// Subscription with approval workflow
	RequestClusterSubscription(ctx context.Context, in *RequestClusterSubscriptionRequest, opts ...grpc.CallOption) (*ClusterSubscription, error)
	AcceptClusterInvite(ctx context.Context, in *AcceptClusterInviteRequest, opts ...grpc.CallOption) (*ClusterSubscription, error)
	// Approval workflow (cluster owner)
	ListPendingSubscriptions(ctx context.Context, in *ListPendingSubscriptionsRequest, opts ...grpc.CallOption) (*ListPendingSubscriptionsResponse, error)
	ApproveClusterSubscription(ctx context.Context, in *ApproveClusterSubscriptionRequest, opts ...grpc.CallOption) (*ClusterSubscription, error)
	RejectClusterSubscription(ctx context.Context, in *RejectClusterSubscriptionRequest, opts ...grpc.CallOption) (*ClusterSubscription, error)
	// Batch metadata lookup for Gateway enrichment (used by Purser marketplace flow)
	GetClusterMetadataBatch(ctx context.Context, in *GetClusterMetadataBatchRequest, opts ...grpc.CallOption) (*GetClusterMetadataBatchResponse, error)
}

type clusterServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClusterServiceClient(cc grpc.ClientConnInterface) ClusterServiceClient {
	return &clusterServiceClient{cc}
}

func (c *clusterServiceClient) GetCluster(ctx context.Context, in *GetClusterRequest, opts ...grpc.CallOption) (*ClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterResponse)
	err := c.cc.Invoke(ctx, ClusterService_GetCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) ListClusters(ctx context.Context, in *ListClustersRequest, opts ...grpc.CallOption) (*ListClustersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClustersResponse)
	err := c.cc.Invoke(ctx, ClusterService_ListClusters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) CreateCluster(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*ClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterResponse)
	err := c.cc.Invoke(ctx, ClusterService_CreateCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) UpdateCluster(ctx context.Context, in *UpdateClusterRequest, opts ...grpc.CallOption) (*ClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterResponse)
	err := c.cc.Invoke(ctx, ClusterService_UpdateCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) ListClustersForTenant(ctx context.Context, in *ListClustersForTenantRequest, opts ...grpc.CallOption) (*ClustersAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClustersAccessResponse)
	err := c.cc.Invoke(ctx, ClusterService_ListClustersForTenant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) ListClustersAvailable(ctx context.Context, in *ListClustersAvailableRequest, opts ...grpc.CallOption) (*ClustersAvailableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClustersAvailableResponse)
	err := c.cc.Invoke(ctx, ClusterService_ListClustersAvailable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) GrantClusterAccess(ctx context.Context, in *GrantClusterAccessRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ClusterService_GrantClusterAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) SubscribeToCluster(ctx context.Context, in *SubscribeToClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ClusterService_SubscribeToCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) UnsubscribeFromCluster(ctx context.Context, in *UnsubscribeFromClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ClusterService_UnsubscribeFromCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) ListMySubscriptions(ctx context.Context, in *ListMySubscriptionsRequest, opts ...grpc.CallOption) (*ListClustersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClustersResponse)
	err := c.cc.Invoke(ctx, ClusterService_ListMySubscriptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) ListMarketplaceClusters(ctx context.Context, in *ListMarketplaceClustersRequest, opts ...grpc.CallOption) (*ListMarketplaceClustersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMarketplaceClustersResponse)
	err := c.cc.Invoke(ctx, ClusterService_ListMarketplaceClusters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) GetMarketplaceCluster(ctx context.Context, in *GetMarketplaceClusterRequest, opts ...grpc.CallOption) (*MarketplaceClusterEntry, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarketplaceClusterEntry)
	err := c.cc.Invoke(ctx, ClusterService_GetMarketplaceCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) UpdateClusterMarketplace(ctx context.Context, in *UpdateClusterMarketplaceRequest, opts ...grpc.CallOption) (*ClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterResponse)
	err := c.cc.Invoke(ctx, ClusterService_UpdateClusterMarketplace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) CreatePrivateCluster(ctx context.Context, in *CreatePrivateClusterRequest, opts ...grpc.CallOption) (*CreatePrivateClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreatePrivateClusterResponse)
	err := c.cc.Invoke(ctx, ClusterService_CreatePrivateCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) CreateClusterInvite(ctx context.Context, in *CreateClusterInviteRequest, opts ...grpc.CallOption) (*ClusterInvite, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterInvite)
	err := c.cc.Invoke(ctx, ClusterService_CreateClusterInvite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) RevokeClusterInvite(ctx context.Context, in *RevokeClusterInviteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ClusterService_RevokeClusterInvite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) ListClusterInvites(ctx context.Context, in *ListClusterInvitesRequest, opts ...grpc.CallOption) (*ListClusterInvitesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClusterInvitesResponse)
	err := c.cc.Invoke(ctx, ClusterService_ListClusterInvites_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) ListMyClusterInvites(ctx context.Context, in *ListMyClusterInvitesRequest, opts ...grpc.CallOption) (*ListClusterInvitesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClusterInvitesResponse)
	err := c.cc.Invoke(ctx, ClusterService_ListMyClusterInvites_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) RequestClusterSubscription(ctx context.Context, in *RequestClusterSubscriptionRequest, opts ...grpc.CallOption) (*ClusterSubscription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterSubscription)
	err := c.cc.Invoke(ctx, ClusterService_RequestClusterSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) AcceptClusterInvite(ctx context.Context, in *AcceptClusterInviteRequest, opts ...grpc.CallOption) (*ClusterSubscription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterSubscription)
	err := c.cc.Invoke(ctx, ClusterService_AcceptClusterInvite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) ListPendingSubscriptions(ctx context.Context, in *ListPendingSubscriptionsRequest, opts ...grpc.CallOption) (*ListPendingSubscriptionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPendingSubscriptionsResponse)
	err := c.cc.Invoke(ctx, ClusterService_ListPendingSubscriptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) ApproveClusterSubscription(ctx context.Context, in *ApproveClusterSubscriptionRequest, opts ...grpc.CallOption) (*ClusterSubscription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterSubscription)
	err := c.cc.Invoke(ctx, ClusterService_ApproveClusterSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) RejectClusterSubscription(ctx context.Context, in *RejectClusterSubscriptionRequest, opts ...grpc.CallOption) (*ClusterSubscription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterSubscription)
	err := c.cc.Invoke(ctx, ClusterService_RejectClusterSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterServiceClient) GetClusterMetadataBatch(ctx context.Context, in *GetClusterMetadataBatchRequest, opts ...grpc.CallOption) (*GetClusterMetadataBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClusterMetadataBatchResponse)
	err := c.cc.Invoke(ctx, ClusterService_GetClusterMetadataBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterServiceServer is the server API for ClusterService service.
// All implementations must embed UnimplementedClusterServiceServer
// for forward compatibility.
//
// ClusterService handles infrastructure cluster management
type ClusterServiceServer interface {
	GetCluster(context.Context, *GetClusterRequest) (*ClusterResponse, error)
	ListClusters(context.Context, *ListClustersRequest) (*ListClustersResponse, error)
	CreateCluster(context.Context, *CreateClusterRequest) (*ClusterResponse, error)
	UpdateCluster(context.Context, *UpdateClusterRequest) (*ClusterResponse, error)
	// Get clusters accessible to a tenant
	ListClustersForTenant(context.Context, *ListClustersForTenantRequest) (*ClustersAccessResponse, error)
	// Get clusters available for tenant onboarding
	ListClustersAvailable(context.Context, *ListClustersAvailableRequest) (*ClustersAvailableResponse, error)
	// Grant cluster access to tenant
	GrantClusterAccess(context.Context, *GrantClusterAccessRequest) (*emptypb.Empty, error)
	// Subscribe to a public/shared cluster
	SubscribeToCluster(context.Context, *SubscribeToClusterRequest) (*emptypb.Empty, error)
	// Unsubscribe from a cluster
	UnsubscribeFromCluster(context.Context, *UnsubscribeFromClusterRequest) (*emptypb.Empty, error)
	// List clusters the tenant is subscribed to
	ListMySubscriptions(context.Context, *ListMySubscriptionsRequest) (*ListClustersResponse, error)
	// List clusters in marketplace (respects visibility + billing tier)
	ListMarketplaceClusters(context.Context, *ListMarketplaceClustersRequest) (*ListMarketplaceClustersResponse, error)
	// Get a marketplace cluster (with optional invite token for unlisted)
	GetMarketplaceCluster(context.Context, *GetMarketplaceClusterRequest) (*MarketplaceClusterEntry, error)
	// Update cluster marketplace settings (owner only)
	UpdateClusterMarketplace(context.Context, *UpdateClusterMarketplaceRequest) (*ClusterResponse, error)
	// Create a private cluster (self-hosted edge)
	CreatePrivateCluster(context.Context, *CreatePrivateClusterRequest) (*CreatePrivateClusterResponse, error)
	// Invite management (cluster owner)
	CreateClusterInvite(context.Context, *CreateClusterInviteRequest) (*ClusterInvite, error)
	RevokeClusterInvite(context.Context, *RevokeClusterInviteRequest) (*emptypb.Empty, error)
	ListClusterInvites(context.Context, *ListClusterInvitesRequest) (*ListClusterInvitesResponse, error)
	// For invited tenants: list pending invites
	ListMyClusterInvites(context.Context, *ListMyClusterInvitesRequest) (*ListClusterInvitesResponse, error)
	// Subscription with approval workflow
	RequestClusterSubscription(context.Context, *RequestClusterSubscriptionRequest) (*ClusterSubscription, error)
	AcceptClusterInvite(context.Context, *AcceptClusterInviteRequest) (*ClusterSubscription, error)
	// Approval workflow (cluster owner)
	ListPendingSubscriptions(context.Context, *ListPendingSubscriptionsRequest) (*ListPendingSubscriptionsResponse, error)
	ApproveClusterSubscription(context.Context, *ApproveClusterSubscriptionRequest) (*ClusterSubscription, error)
	RejectClusterSubscription(context.Context, *RejectClusterSubscriptionRequest) (*ClusterSubscription, error)
	// Batch metadata lookup for Gateway enrichment (used by Purser marketplace flow)
	GetClusterMetadataBatch(context.Context, *GetClusterMetadataBatchRequest) (*GetClusterMetadataBatchResponse, error)
	mustEmbedUnimplementedClusterServiceServer()
}

// UnimplementedClusterServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClusterServiceServer struct{}

func (UnimplementedClusterServiceServer) GetCluster(context.Context, *GetClusterRequest) (*ClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCluster not implemented")
}
func (UnimplementedClusterServiceServer) ListClusters(context.Context, *ListClustersRequest) (*ListClustersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListClusters not implemented")
}
func (UnimplementedClusterServiceServer) CreateCluster(context.Context, *CreateClusterRequest) (*ClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateCluster not implemented")
}
func (UnimplementedClusterServiceServer) UpdateCluster(context.Context, *UpdateClusterRequest) (*ClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateCluster not implemented")
}
func (UnimplementedClusterServiceServer) ListClustersForTenant(context.Context, *ListClustersForTenantRequest) (*ClustersAccessResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListClustersForTenant not implemented")
}
func (UnimplementedClusterServiceServer) ListClustersAvailable(context.Context, *ListClustersAvailableRequest) (*ClustersAvailableResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListClustersAvailable not implemented")
}
func (UnimplementedClusterServiceServer) GrantClusterAccess(context.Context, *GrantClusterAccessRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method GrantClusterAccess not implemented")
}
func (UnimplementedClusterServiceServer) SubscribeToCluster(context.Context, *SubscribeToClusterRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method SubscribeToCluster not implemented")
}
func (UnimplementedClusterServiceServer) UnsubscribeFromCluster(context.Context, *UnsubscribeFromClusterRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UnsubscribeFromCluster not implemented")
}
func (UnimplementedClusterServiceServer) ListMySubscriptions(context.Context, *ListMySubscriptionsRequest) (*ListClustersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMySubscriptions not implemented")
}
func (UnimplementedClusterServiceServer) ListMarketplaceClusters(context.Context, *ListMarketplaceClustersRequest) (*ListMarketplaceClustersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMarketplaceClusters not implemented")
}
func (UnimplementedClusterServiceServer) GetMarketplaceCluster(context.Context, *GetMarketplaceClusterRequest) (*MarketplaceClusterEntry, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMarketplaceCluster not implemented")
}
func (UnimplementedClusterServiceServer) UpdateClusterMarketplace(context.Context, *UpdateClusterMarketplaceRequest) (*ClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateClusterMarketplace not implemented")
}
func (UnimplementedClusterServiceServer) CreatePrivateCluster(context.Context, *CreatePrivateClusterRequest) (*CreatePrivateClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreatePrivateCluster not implemented")
}
func (UnimplementedClusterServiceServer) CreateClusterInvite(context.Context, *CreateClusterInviteRequest) (*ClusterInvite, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateClusterInvite not implemented")
}
func (UnimplementedClusterServiceServer) RevokeClusterInvite(context.Context, *RevokeClusterInviteRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeClusterInvite not implemented")
}
func (UnimplementedClusterServiceServer) ListClusterInvites(context.Context, *ListClusterInvitesRequest) (*ListClusterInvitesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListClusterInvites not implemented")
}
func (UnimplementedClusterServiceServer) ListMyClusterInvites(context.Context, *ListMyClusterInvitesRequest) (*ListClusterInvitesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMyClusterInvites not implemented")
}
func (UnimplementedClusterServiceServer) RequestClusterSubscription(context.Context, *RequestClusterSubscriptionRequest) (*ClusterSubscription, error) {
	return nil, status.Error(codes.Unimplemented, "method RequestClusterSubscription not implemented")
}
func (UnimplementedClusterServiceServer) AcceptClusterInvite(context.Context, *AcceptClusterInviteRequest) (*ClusterSubscription, error) {
	return nil, status.Error(codes.Unimplemented, "method AcceptClusterInvite not implemented")
}
func (UnimplementedClusterServiceServer) ListPendingSubscriptions(context.Context, *ListPendingSubscriptionsRequest) (*ListPendingSubscriptionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPendingSubscriptions not implemented")
}
func (UnimplementedClusterServiceServer) ApproveClusterSubscription(context.Context, *ApproveClusterSubscriptionRequest) (*ClusterSubscription, error) {
	return nil, status.Error(codes.Unimplemented, "method ApproveClusterSubscription not implemented")
}
func (UnimplementedClusterServiceServer) RejectClusterSubscription(context.Context, *RejectClusterSubscriptionRequest) (*ClusterSubscription, error) {
	return nil, status.Error(codes.Unimplemented, "method RejectClusterSubscription not implemented")
}
func (UnimplementedClusterServiceServer) GetClusterMetadataBatch(context.Context, *GetClusterMetadataBatchRequest) (*GetClusterMetadataBatchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClusterMetadataBatch not implemented")
}
func (UnimplementedClusterServiceServer) mustEmbedUnimplementedClusterServiceServer() {}
func (UnimplementedClusterServiceServer) testEmbeddedByValue()                        {}

// UnsafeClusterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClusterServiceServer will
// result in compilation errors.
type UnsafeClusterServiceServer interface {
	mustEmbedUnimplementedClusterServiceServer()
}

func RegisterClusterServiceServer(s grpc.ServiceRegistrar, srv ClusterServiceServer) {
	// If the following call panics, it indicates UnimplementedClusterServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ClusterService_ServiceDesc, srv)
}

func _ClusterService_GetCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).GetCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_GetCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).GetCluster(ctx, req.(*GetClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_ListClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClustersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).ListClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_ListClusters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).ListClusters(ctx, req.(*ListClustersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_CreateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).CreateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_CreateCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).CreateCluster(ctx, req.(*CreateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_UpdateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).UpdateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_UpdateCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).UpdateCluster(ctx, req.(*UpdateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_ListClustersForTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClustersForTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).ListClustersForTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_ListClustersForTenant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).ListClustersForTenant(ctx, req.(*ListClustersForTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_ListClustersAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClustersAvailableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).ListClustersAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_ListClustersAvailable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).ListClustersAvailable(ctx, req.(*ListClustersAvailableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_GrantClusterAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantClusterAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).GrantClusterAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_GrantClusterAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).GrantClusterAccess(ctx, req.(*GrantClusterAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_SubscribeToCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeToClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).SubscribeToCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_SubscribeToCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).SubscribeToCluster(ctx, req.(*SubscribeToClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_UnsubscribeFromCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeFromClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).UnsubscribeFromCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_UnsubscribeFromCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).UnsubscribeFromCluster(ctx, req.(*UnsubscribeFromClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_ListMySubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMySubscriptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).ListMySubscriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_ListMySubscriptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).ListMySubscriptions(ctx, req.(*ListMySubscriptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_ListMarketplaceClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMarketplaceClustersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).ListMarketplaceClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_ListMarketplaceClusters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).ListMarketplaceClusters(ctx, req.(*ListMarketplaceClustersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_GetMarketplaceCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarketplaceClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).GetMarketplaceCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_GetMarketplaceCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).GetMarketplaceCluster(ctx, req.(*GetMarketplaceClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_UpdateClusterMarketplace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateClusterMarketplaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).UpdateClusterMarketplace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_UpdateClusterMarketplace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).UpdateClusterMarketplace(ctx, req.(*UpdateClusterMarketplaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_CreatePrivateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePrivateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).CreatePrivateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_CreatePrivateCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).CreatePrivateCluster(ctx, req.(*CreatePrivateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_CreateClusterInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClusterInviteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).CreateClusterInvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_CreateClusterInvite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).CreateClusterInvite(ctx, req.(*CreateClusterInviteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_RevokeClusterInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeClusterInviteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).RevokeClusterInvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_RevokeClusterInvite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).RevokeClusterInvite(ctx, req.(*RevokeClusterInviteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_ListClusterInvites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClusterInvitesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).ListClusterInvites(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_ListClusterInvites_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).ListClusterInvites(ctx, req.(*ListClusterInvitesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_ListMyClusterInvites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMyClusterInvitesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).ListMyClusterInvites(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_ListMyClusterInvites_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).ListMyClusterInvites(ctx, req.(*ListMyClusterInvitesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_RequestClusterSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestClusterSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).RequestClusterSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_RequestClusterSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).RequestClusterSubscription(ctx, req.(*RequestClusterSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_AcceptClusterInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptClusterInviteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).AcceptClusterInvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_AcceptClusterInvite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).AcceptClusterInvite(ctx, req.(*AcceptClusterInviteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_ListPendingSubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPendingSubscriptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).ListPendingSubscriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_ListPendingSubscriptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).ListPendingSubscriptions(ctx, req.(*ListPendingSubscriptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_ApproveClusterSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveClusterSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).ApproveClusterSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_ApproveClusterSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).ApproveClusterSubscription(ctx, req.(*ApproveClusterSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_RejectClusterSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectClusterSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).RejectClusterSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_RejectClusterSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).RejectClusterSubscription(ctx, req.(*RejectClusterSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterService_GetClusterMetadataBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterMetadataBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServiceServer).GetClusterMetadataBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterService_GetClusterMetadataBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServiceServer).GetClusterMetadataBatch(ctx, req.(*GetClusterMetadataBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClusterService_ServiceDesc is the grpc.ServiceDesc for ClusterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClusterService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quartermaster.ClusterService",
	HandlerType: (*ClusterServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCluster",
			Handler:    _ClusterService_GetCluster_Handler,
		},
		{
			MethodName: "ListClusters",
			Handler:    _ClusterService_ListClusters_Handler,
		},
		{
			MethodName: "CreateCluster",
			Handler:    _ClusterService_CreateCluster_Handler,
		},
		{
			MethodName: "UpdateCluster",
			Handler:    _ClusterService_UpdateCluster_Handler,
		},
		{
			MethodName: "ListClustersForTenant",
			Handler:    _ClusterService_ListClustersForTenant_Handler,
		},
		{
			MethodName: "ListClustersAvailable",
			Handler:    _ClusterService_ListClustersAvailable_Handler,
		},
		{
			MethodName: "GrantClusterAccess",
			Handler:    _ClusterService_GrantClusterAccess_Handler,
		},
		{
			MethodName: "SubscribeToCluster",
			Handler:    _ClusterService_SubscribeToCluster_Handler,
		},
		{
			MethodName: "UnsubscribeFromCluster",
			Handler:    _ClusterService_UnsubscribeFromCluster_Handler,
		},
		{
			MethodName: "ListMySubscriptions",
			Handler:    _ClusterService_ListMySubscriptions_Handler,
		},
		{
			MethodName: "ListMarketplaceClusters",
			Handler:    _ClusterService_ListMarketplaceClusters_Handler,
		},
		{
			MethodName: "GetMarketplaceCluster",
			Handler:    _ClusterService_GetMarketplaceCluster_Handler,
		},
		{
			MethodName: "UpdateClusterMarketplace",
			Handler:    _ClusterService_UpdateClusterMarketplace_Handler,
		},
		{
			MethodName: "CreatePrivateCluster",
			Handler:    _ClusterService_CreatePrivateCluster_Handler,
		},
		{
			MethodName: "CreateClusterInvite",
			Handler:    _ClusterService_CreateClusterInvite_Handler,
		},
		{
			MethodName: "RevokeClusterInvite",
			Handler:    _ClusterService_RevokeClusterInvite_Handler,
		},
		{
			MethodName: "ListClusterInvites",
			Handler:    _ClusterService_ListClusterInvites_Handler,
		},
		{
			MethodName: "ListMyClusterInvites",
			Handler:    _ClusterService_ListMyClusterInvites_Handler,
		},
		{
			MethodName: "RequestClusterSubscription",
			Handler:    _ClusterService_RequestClusterSubscription_Handler,
		},
		{
			MethodName: "AcceptClusterInvite",
			Handler:    _ClusterService_AcceptClusterInvite_Handler,
		},
		{
			MethodName: "ListPendingSubscriptions",
			Handler:    _ClusterService_ListPendingSubscriptions_Handler,
		},
		{
			MethodName: "ApproveClusterSubscription",
			Handler:    _ClusterService_ApproveClusterSubscription_Handler,
		},
		{
			MethodName: "RejectClusterSubscription",
			Handler:    _ClusterService_RejectClusterSubscription_Handler,
		},
		{
			MethodName: "GetClusterMetadataBatch",
			Handler:    _ClusterService_GetClusterMetadataBatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "quartermaster.proto",
}

const (
	NodeService_GetNode_FullMethodName                = "/quartermaster.NodeService/GetNode"
	NodeService_ListNodes_FullMethodName              = "/quartermaster.NodeService/ListNodes"
	NodeService_ListHealthyNodesForDNS_FullMethodName = "/quartermaster.NodeService/ListHealthyNodesForDNS"
	NodeService_CreateNode_FullMethodName             = "/quartermaster.NodeService/CreateNode"
	NodeService_ResolveNodeFingerprint_FullMethodName = "/quartermaster.NodeService/ResolveNodeFingerprint"
	NodeService_GetNodeOwner_FullMethodName           = "/quartermaster.NodeService/GetNodeOwner"
	NodeService_GetNodeByLogicalName_FullMethodName   = "/quartermaster.NodeService/GetNodeByLogicalName"
	NodeService_UpdateNodeHardware_FullMethodName     = "/quartermaster.NodeService/UpdateNodeHardware"
)

// NodeServiceClient is the client API for NodeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// NodeService handles infrastructure node management
type NodeServiceClient interface {
	GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*NodeResponse, error)
	ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error)
	ListHealthyNodesForDNS(ctx context.Context, in *ListHealthyNodesForDNSRequest, opts ...grpc.CallOption) (*ListHealthyNodesForDNSResponse, error)
	CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*NodeResponse, error)
	// Resolve node fingerprint for identity binding
	// Source: pkg/api/quartermaster/types.go:ResolveNodeFingerprintRequest
	ResolveNodeFingerprint(ctx context.Context, in *ResolveNodeFingerprintRequest, opts ...grpc.CallOption) (*ResolveNodeFingerprintResponse, error)
	// Get node owner (tenant) from node ID
	// Source: pkg/api/quartermaster/types.go:NodeOwnerResponse
	GetNodeOwner(ctx context.Context, in *GetNodeOwnerRequest, opts ...grpc.CallOption) (*NodeOwnerResponse, error)
	// Resolve node by logical name (node_id string like "edge-node-1") to get UUID
	// Used by Foghorn to enrich subscription broadcasts with database UUID
	GetNodeByLogicalName(ctx context.Context, in *GetNodeByLogicalNameRequest, opts ...grpc.CallOption) (*NodeResponse, error)
	// Update node hardware specs (detected at startup)
	// Called by Foghorn when Helmsman registers with hardware info
	UpdateNodeHardware(ctx context.Context, in *UpdateNodeHardwareRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type nodeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeServiceClient(cc grpc.ClientConnInterface) NodeServiceClient {
	return &nodeServiceClient{cc}
}

func (c *nodeServiceClient) GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*NodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeResponse)
	err := c.cc.Invoke(ctx, NodeService_GetNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNodesResponse)
	err := c.cc.Invoke(ctx, NodeService_ListNodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) ListHealthyNodesForDNS(ctx context.Context, in *ListHealthyNodesForDNSRequest, opts ...grpc.CallOption) (*ListHealthyNodesForDNSResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListHealthyNodesForDNSResponse)
	err := c.cc.Invoke(ctx, NodeService_ListHealthyNodesForDNS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*NodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeResponse)
	err := c.cc.Invoke(ctx, NodeService_CreateNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) ResolveNodeFingerprint(ctx context.Context, in *ResolveNodeFingerprintRequest, opts ...grpc.CallOption) (*ResolveNodeFingerprintResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveNodeFingerprintResponse)
	err := c.cc.Invoke(ctx, NodeService_ResolveNodeFingerprint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) GetNodeOwner(ctx context.Context, in *GetNodeOwnerRequest, opts ...grpc.CallOption) (*NodeOwnerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeOwnerResponse)
	err := c.cc.Invoke(ctx, NodeService_GetNodeOwner_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) GetNodeByLogicalName(ctx context.Context, in *GetNodeByLogicalNameRequest, opts ...grpc.CallOption) (*NodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeResponse)
	err := c.cc.Invoke(ctx, NodeService_GetNodeByLogicalName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) UpdateNodeHardware(ctx context.Context, in *UpdateNodeHardwareRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeService_UpdateNodeHardware_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServiceServer is the server API for NodeService service.
// All implementations must embed UnimplementedNodeServiceServer
// for forward compatibility.
//
// NodeService handles infrastructure node management
type NodeServiceServer interface {
	GetNode(context.Context, *GetNodeRequest) (*NodeResponse, error)
	ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error)
	ListHealthyNodesForDNS(context.Context, *ListHealthyNodesForDNSRequest) (*ListHealthyNodesForDNSResponse, error)
	CreateNode(context.Context, *CreateNodeRequest) (*NodeResponse, error)
	// Resolve node fingerprint for identity binding
	// Source: pkg/api/quartermaster/types.go:ResolveNodeFingerprintRequest
	ResolveNodeFingerprint(context.Context, *ResolveNodeFingerprintRequest) (*ResolveNodeFingerprintResponse, error)
	// Get node owner (tenant) from node ID
	// Source: pkg/api/quartermaster/types.go:NodeOwnerResponse
	GetNodeOwner(context.Context, *GetNodeOwnerRequest) (*NodeOwnerResponse, error)
	// Resolve node by logical name (node_id string like "edge-node-1") to get UUID
	// Used by Foghorn to enrich subscription broadcasts with database UUID
	GetNodeByLogicalName(context.Context, *GetNodeByLogicalNameRequest) (*NodeResponse, error)
	// Update node hardware specs (detected at startup)
	// Called by Foghorn when Helmsman registers with hardware info
	UpdateNodeHardware(context.Context, *UpdateNodeHardwareRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedNodeServiceServer()
}

// UnimplementedNodeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNodeServiceServer struct{}

func (UnimplementedNodeServiceServer) GetNode(context.Context, *GetNodeRequest) (*NodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNode not implemented")
}
func (UnimplementedNodeServiceServer) ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListNodes not implemented")
}
func (UnimplementedNodeServiceServer) ListHealthyNodesForDNS(context.Context, *ListHealthyNodesForDNSRequest) (*ListHealthyNodesForDNSResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListHealthyNodesForDNS not implemented")
}
func (UnimplementedNodeServiceServer) CreateNode(context.Context, *CreateNodeRequest) (*NodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateNode not implemented")
}
func (UnimplementedNodeServiceServer) ResolveNodeFingerprint(context.Context, *ResolveNodeFingerprintRequest) (*ResolveNodeFingerprintResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveNodeFingerprint not implemented")
}
func (UnimplementedNodeServiceServer) GetNodeOwner(context.Context, *GetNodeOwnerRequest) (*NodeOwnerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeOwner not implemented")
}
func (UnimplementedNodeServiceServer) GetNodeByLogicalName(context.Context, *GetNodeByLogicalNameRequest) (*NodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeByLogicalName not implemented")
}
func (UnimplementedNodeServiceServer) UpdateNodeHardware(context.Context, *UpdateNodeHardwareRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateNodeHardware not implemented")
}
func (UnimplementedNodeServiceServer) mustEmbedUnimplementedNodeServiceServer() {}
func (UnimplementedNodeServiceServer) testEmbeddedByValue()                     {}

// UnsafeNodeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeServiceServer will
// result in compilation errors.
type UnsafeNodeServiceServer interface {
	mustEmbedUnimplementedNodeServiceServer()
}

func RegisterNodeServiceServer(s grpc.ServiceRegistrar, srv NodeServiceServer) {
	// If the following call panics, it indicates UnimplementedNodeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NodeService_ServiceDesc, srv)
}

func _NodeService_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_GetNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetNode(ctx, req.(*GetNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_ListNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).ListNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_ListNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).ListNodes(ctx, req.(*ListNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_ListHealthyNodesForDNS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHealthyNodesForDNSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).ListHealthyNodesForDNS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_ListHealthyNodesForDNS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).ListHealthyNodesForDNS(ctx, req.(*ListHealthyNodesForDNSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_CreateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).CreateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_CreateNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).CreateNode(ctx, req.(*CreateNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_ResolveNodeFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveNodeFingerprintRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).ResolveNodeFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_ResolveNodeFingerprint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).ResolveNodeFingerprint(ctx, req.(*ResolveNodeFingerprintRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_GetNodeOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetNodeOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_GetNodeOwner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetNodeOwner(ctx, req.(*GetNodeOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_GetNodeByLogicalName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeByLogicalNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetNodeByLogicalName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_GetNodeByLogicalName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetNodeByLogicalName(ctx, req.(*GetNodeByLogicalNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_UpdateNodeHardware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNodeHardwareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).UpdateNodeHardware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_UpdateNodeHardware_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).UpdateNodeHardware(ctx, req.(*UpdateNodeHardwareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeService_ServiceDesc is the grpc.ServiceDesc for NodeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quartermaster.NodeService",
	HandlerType: (*NodeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNode",
			Handler:    _NodeService_GetNode_Handler,
		},
		{
			MethodName: "ListNodes",
			Handler:    _NodeService_ListNodes_Handler,
		},
		{
			MethodName: "ListHealthyNodesForDNS",
			Handler:    _NodeService_ListHealthyNodesForDNS_Handler,
		},
		{
			MethodName: "CreateNode",
			Handler:    _NodeService_CreateNode_Handler,
		},
		{
			MethodName: "ResolveNodeFingerprint",
			Handler:    _NodeService_ResolveNodeFingerprint_Handler,
		},
		{
			MethodName: "GetNodeOwner",
			Handler:    _NodeService_GetNodeOwner_Handler,
		},
		{
			MethodName: "GetNodeByLogicalName",
			Handler:    _NodeService_GetNodeByLogicalName_Handler,
		},
		{
			MethodName: "UpdateNodeHardware",
			Handler:    _NodeService_UpdateNodeHardware_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "quartermaster.proto",
}

const (
	BootstrapService_BootstrapEdgeNode_FullMethodName           = "/quartermaster.BootstrapService/BootstrapEdgeNode"
	BootstrapService_BootstrapInfrastructureNode_FullMethodName = "/quartermaster.BootstrapService/BootstrapInfrastructureNode"
	BootstrapService_BootstrapService_FullMethodName            = "/quartermaster.BootstrapService/BootstrapService"
	BootstrapService_DiscoverServices_FullMethodName            = "/quartermaster.BootstrapService/DiscoverServices"
	BootstrapService_CreateBootstrapToken_FullMethodName        = "/quartermaster.BootstrapService/CreateBootstrapToken"
	BootstrapService_ListBootstrapTokens_FullMethodName         = "/quartermaster.BootstrapService/ListBootstrapTokens"
	BootstrapService_RevokeBootstrapToken_FullMethodName        = "/quartermaster.BootstrapService/RevokeBootstrapToken"
)

// BootstrapServiceClient is the client API for BootstrapService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// BootstrapService handles node enrollment and service discovery
type BootstrapServiceClient interface {
	// Bootstrap an edge node with enrollment token
	// Source: pkg/api/quartermaster/types.go:BootstrapEdgeNodeRequest
	BootstrapEdgeNode(ctx context.Context, in *BootstrapEdgeNodeRequest, opts ...grpc.CallOption) (*BootstrapEdgeNodeResponse, error)
	// Bootstrap a general infrastructure node with enrollment token
	BootstrapInfrastructureNode(ctx context.Context, in *BootstrapInfrastructureNodeRequest, opts ...grpc.CallOption) (*BootstrapInfrastructureNodeResponse, error)
	// Bootstrap a core service
	// Source: pkg/api/quartermaster/types.go:BootstrapServiceRequest
	BootstrapService(ctx context.Context, in *BootstrapServiceRequest, opts ...grpc.CallOption) (*BootstrapServiceResponse, error)
	// Service discovery - find instances of a service type
	DiscoverServices(ctx context.Context, in *ServiceDiscoveryRequest, opts ...grpc.CallOption) (*ServiceDiscoveryResponse, error)
	// Create/list bootstrap tokens
	CreateBootstrapToken(ctx context.Context, in *CreateBootstrapTokenRequest, opts ...grpc.CallOption) (*CreateBootstrapTokenResponse, error)
	ListBootstrapTokens(ctx context.Context, in *ListBootstrapTokensRequest, opts ...grpc.CallOption) (*ListBootstrapTokensResponse, error)
	RevokeBootstrapToken(ctx context.Context, in *RevokeBootstrapTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type bootstrapServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBootstrapServiceClient(cc grpc.ClientConnInterface) BootstrapServiceClient {
	return &bootstrapServiceClient{cc}
}

func (c *bootstrapServiceClient) BootstrapEdgeNode(ctx context.Context, in *BootstrapEdgeNodeRequest, opts ...grpc.CallOption) (*BootstrapEdgeNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BootstrapEdgeNodeResponse)
	err := c.cc.Invoke(ctx, BootstrapService_BootstrapEdgeNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bootstrapServiceClient) BootstrapInfrastructureNode(ctx context.Context, in *BootstrapInfrastructureNodeRequest, opts ...grpc.CallOption) (*BootstrapInfrastructureNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BootstrapInfrastructureNodeResponse)
	err := c.cc.Invoke(ctx, BootstrapService_BootstrapInfrastructureNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bootstrapServiceClient) BootstrapService(ctx context.Context, in *BootstrapServiceRequest, opts ...grpc.CallOption) (*BootstrapServiceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BootstrapServiceResponse)
	err := c.cc.Invoke(ctx, BootstrapService_BootstrapService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bootstrapServiceClient) DiscoverServices(ctx context.Context, in *ServiceDiscoveryRequest, opts ...grpc.CallOption) (*ServiceDiscoveryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServiceDiscoveryResponse)
	err := c.cc.Invoke(ctx, BootstrapService_DiscoverServices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bootstrapServiceClient) CreateBootstrapToken(ctx context.Context, in *CreateBootstrapTokenRequest, opts ...grpc.CallOption) (*CreateBootstrapTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBootstrapTokenResponse)
	err := c.cc.Invoke(ctx, BootstrapService_CreateBootstrapToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bootstrapServiceClient) ListBootstrapTokens(ctx context.Context, in *ListBootstrapTokensRequest, opts ...grpc.CallOption) (*ListBootstrapTokensResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBootstrapTokensResponse)
	err := c.cc.Invoke(ctx, BootstrapService_ListBootstrapTokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bootstrapServiceClient) RevokeBootstrapToken(ctx context.Context, in *RevokeBootstrapTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, BootstrapService_RevokeBootstrapToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BootstrapServiceServer is the server API for BootstrapService service.
// All implementations must embed UnimplementedBootstrapServiceServer
// for forward compatibility.
//
// BootstrapService handles node enrollment and service discovery
type BootstrapServiceServer interface {
	// Bootstrap an edge node with enrollment token
	// Source: pkg/api/quartermaster/types.go:BootstrapEdgeNodeRequest
	BootstrapEdgeNode(context.Context, *BootstrapEdgeNodeRequest) (*BootstrapEdgeNodeResponse, error)
	// Bootstrap a general infrastructure node with enrollment token
	BootstrapInfrastructureNode(context.Context, *BootstrapInfrastructureNodeRequest) (*BootstrapInfrastructureNodeResponse, error)
	// Bootstrap a core service
	// Source: pkg/api/quartermaster/types.go:BootstrapServiceRequest
	BootstrapService(context.Context, *BootstrapServiceRequest) (*BootstrapServiceResponse, error)
	// Service discovery - find instances of a service type
	DiscoverServices(context.Context, *ServiceDiscoveryRequest) (*ServiceDiscoveryResponse, error)
	// Create/list bootstrap tokens
	CreateBootstrapToken(context.Context, *CreateBootstrapTokenRequest) (*CreateBootstrapTokenResponse, error)
	ListBootstrapTokens(context.Context, *ListBootstrapTokensRequest) (*ListBootstrapTokensResponse, error)
	RevokeBootstrapToken(context.Context, *RevokeBootstrapTokenRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedBootstrapServiceServer()
}

// UnimplementedBootstrapServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBootstrapServiceServer struct{}

func (UnimplementedBootstrapServiceServer) BootstrapEdgeNode(context.Context, *BootstrapEdgeNodeRequest) (*BootstrapEdgeNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BootstrapEdgeNode not implemented")
}
func (UnimplementedBootstrapServiceServer) BootstrapInfrastructureNode(context.Context, *BootstrapInfrastructureNodeRequest) (*BootstrapInfrastructureNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BootstrapInfrastructureNode not implemented")
}
func (UnimplementedBootstrapServiceServer) BootstrapService(context.Context, *BootstrapServiceRequest) (*BootstrapServiceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BootstrapService not implemented")
}
func (UnimplementedBootstrapServiceServer) DiscoverServices(context.Context, *ServiceDiscoveryRequest) (*ServiceDiscoveryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DiscoverServices not implemented")
}
func (UnimplementedBootstrapServiceServer) CreateBootstrapToken(context.Context, *CreateBootstrapTokenRequest) (*CreateBootstrapTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateBootstrapToken not implemented")
}
func (UnimplementedBootstrapServiceServer) ListBootstrapTokens(context.Context, *ListBootstrapTokensRequest) (*ListBootstrapTokensResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListBootstrapTokens not implemented")
}
func (UnimplementedBootstrapServiceServer) RevokeBootstrapToken(context.Context, *RevokeBootstrapTokenRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeBootstrapToken not implemented")
}
func (UnimplementedBootstrapServiceServer) mustEmbedUnimplementedBootstrapServiceServer() {}
func (UnimplementedBootstrapServiceServer) testEmbeddedByValue()                          {}

// UnsafeBootstrapServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BootstrapServiceServer will
// result in compilation errors.
type UnsafeBootstrapServiceServer interface {
	mustEmbedUnimplementedBootstrapServiceServer()
}

func RegisterBootstrapServiceServer(s grpc.ServiceRegistrar, srv BootstrapServiceServer) {
	// If the following call panics, it indicates UnimplementedBootstrapServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BootstrapService_ServiceDesc, srv)
}

func _BootstrapService_BootstrapEdgeNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BootstrapEdgeNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BootstrapServiceServer).BootstrapEdgeNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BootstrapService_BootstrapEdgeNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BootstrapServiceServer).BootstrapEdgeNode(ctx, req.(*BootstrapEdgeNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BootstrapService_BootstrapInfrastructureNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BootstrapInfrastructureNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BootstrapServiceServer).BootstrapInfrastructureNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BootstrapService_BootstrapInfrastructureNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BootstrapServiceServer).BootstrapInfrastructureNode(ctx, req.(*BootstrapInfrastructureNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BootstrapService_BootstrapService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BootstrapServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BootstrapServiceServer).BootstrapService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BootstrapService_BootstrapService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BootstrapServiceServer).BootstrapService(ctx, req.(*BootstrapServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BootstrapService_DiscoverServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceDiscoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BootstrapServiceServer).DiscoverServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BootstrapService_DiscoverServices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BootstrapServiceServer).DiscoverServices(ctx, req.(*ServiceDiscoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BootstrapService_CreateBootstrapToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBootstrapTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BootstrapServiceServer).CreateBootstrapToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BootstrapService_CreateBootstrapToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BootstrapServiceServer).CreateBootstrapToken(ctx, req.(*CreateBootstrapTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BootstrapService_ListBootstrapTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBootstrapTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BootstrapServiceServer).ListBootstrapTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BootstrapService_ListBootstrapTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BootstrapServiceServer).ListBootstrapTokens(ctx, req.(*ListBootstrapTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BootstrapService_RevokeBootstrapToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeBootstrapTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BootstrapServiceServer).RevokeBootstrapToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BootstrapService_RevokeBootstrapToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BootstrapServiceServer).RevokeBootstrapToken(ctx, req.(*RevokeBootstrapTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BootstrapService_ServiceDesc is the grpc.ServiceDesc for BootstrapService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BootstrapService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quartermaster.BootstrapService",
	HandlerType: (*BootstrapServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BootstrapEdgeNode",
			Handler:    _BootstrapService_BootstrapEdgeNode_Handler,
		},
		{
			MethodName: "BootstrapInfrastructureNode",
			Handler:    _BootstrapService_BootstrapInfrastructureNode_Handler,
		},
		{
			MethodName: "BootstrapService",
			Handler:    _BootstrapService_BootstrapService_Handler,
		},
		{
			MethodName: "DiscoverServices",
			Handler:    _BootstrapService_DiscoverServices_Handler,
		},
		{
			MethodName: "CreateBootstrapToken",
			Handler:    _BootstrapService_CreateBootstrapToken_Handler,
		},
		{
			MethodName: "ListBootstrapTokens",
			Handler:    _BootstrapService_ListBootstrapTokens_Handler,
		},
		{
			MethodName: "RevokeBootstrapToken",
			Handler:    _BootstrapService_RevokeBootstrapToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "quartermaster.proto",
}

const (
	MeshService_SyncMesh_FullMethodName = "/quartermaster.MeshService/SyncMesh"
)

// MeshServiceClient is the client API for MeshService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MeshService handles WireGuard mesh synchronization
type MeshServiceClient interface {
	// Infrastructure sync for WireGuard mesh
	// Source: pkg/api/quartermaster/types.go:InfrastructureSyncRequest
	SyncMesh(ctx context.Context, in *InfrastructureSyncRequest, opts ...grpc.CallOption) (*InfrastructureSyncResponse, error)
}

type meshServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMeshServiceClient(cc grpc.ClientConnInterface) MeshServiceClient {
	return &meshServiceClient{cc}
}

func (c *meshServiceClient) SyncMesh(ctx context.Context, in *InfrastructureSyncRequest, opts ...grpc.CallOption) (*InfrastructureSyncResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InfrastructureSyncResponse)
	err := c.cc.Invoke(ctx, MeshService_SyncMesh_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MeshServiceServer is the server API for MeshService service.
// All implementations must embed UnimplementedMeshServiceServer
// for forward compatibility.
//
// MeshService handles WireGuard mesh synchronization
type MeshServiceServer interface {
	// Infrastructure sync for WireGuard mesh
	// Source: pkg/api/quartermaster/types.go:InfrastructureSyncRequest
	SyncMesh(context.Context, *InfrastructureSyncRequest) (*InfrastructureSyncResponse, error)
	mustEmbedUnimplementedMeshServiceServer()
}

// UnimplementedMeshServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMeshServiceServer struct{}

func (UnimplementedMeshServiceServer) SyncMesh(context.Context, *InfrastructureSyncRequest) (*InfrastructureSyncResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncMesh not implemented")
}
func (UnimplementedMeshServiceServer) mustEmbedUnimplementedMeshServiceServer() {}
func (UnimplementedMeshServiceServer) testEmbeddedByValue()                     {}

// UnsafeMeshServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MeshServiceServer will
// result in compilation errors.
type UnsafeMeshServiceServer interface {
	mustEmbedUnimplementedMeshServiceServer()
}

func RegisterMeshServiceServer(s grpc.ServiceRegistrar, srv MeshServiceServer) {
	// If the following call panics, it indicates UnimplementedMeshServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MeshService_ServiceDesc, srv)
}

func _MeshService_SyncMesh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfrastructureSyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshServiceServer).SyncMesh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshService_SyncMesh_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshServiceServer).SyncMesh(ctx, req.(*InfrastructureSyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MeshService_ServiceDesc is the grpc.ServiceDesc for MeshService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MeshService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quartermaster.MeshService",
	HandlerType: (*MeshServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SyncMesh",
			Handler:    _MeshService_SyncMesh_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "quartermaster.proto",
}

const (
	ServiceRegistryService_ListServices_FullMethodName         = "/quartermaster.ServiceRegistryService/ListServices"
	ServiceRegistryService_ListClusterServices_FullMethodName  = "/quartermaster.ServiceRegistryService/ListClusterServices"
	ServiceRegistryService_ListServiceInstances_FullMethodName = "/quartermaster.ServiceRegistryService/ListServiceInstances"
	ServiceRegistryService_ListServicesHealth_FullMethodName   = "/quartermaster.ServiceRegistryService/ListServicesHealth"
	ServiceRegistryService_GetServiceHealth_FullMethodName     = "/quartermaster.ServiceRegistryService/GetServiceHealth"
)

// ServiceRegistryServiceClient is the client API for ServiceRegistryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServiceRegistryServiceClient interface {
	// List all services in the catalog
	ListServices(ctx context.Context, in *ListServicesRequest, opts ...grpc.CallOption) (*ListServicesResponse, error)
	// Get services assigned to a cluster
	ListClusterServices(ctx context.Context, in *ListClusterServicesRequest, opts ...grpc.CallOption) (*ListClusterServicesResponse, error)
	// Get running service instances
	ListServiceInstances(ctx context.Context, in *ListServiceInstancesRequest, opts ...grpc.CallOption) (*ListServiceInstancesResponse, error)
	// Get health of all service instances
	ListServicesHealth(ctx context.Context, in *ListServicesHealthRequest, opts ...grpc.CallOption) (*ListServicesHealthResponse, error)
	// Get health of specific service instances
	GetServiceHealth(ctx context.Context, in *GetServiceHealthRequest, opts ...grpc.CallOption) (*ListServicesHealthResponse, error)
}

type serviceRegistryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewServiceRegistryServiceClient(cc grpc.ClientConnInterface) ServiceRegistryServiceClient {
	return &serviceRegistryServiceClient{cc}
}

func (c *serviceRegistryServiceClient) ListServices(ctx context.Context, in *ListServicesRequest, opts ...grpc.CallOption) (*ListServicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListServicesResponse)
	err := c.cc.Invoke(ctx, ServiceRegistryService_ListServices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceRegistryServiceClient) ListClusterServices(ctx context.Context, in *ListClusterServicesRequest, opts ...grpc.CallOption) (*ListClusterServicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClusterServicesResponse)
	err := c.cc.Invoke(ctx, ServiceRegistryService_ListClusterServices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceRegistryServiceClient) ListServiceInstances(ctx context.Context, in *ListServiceInstancesRequest, opts ...grpc.CallOption) (*ListServiceInstancesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListServiceInstancesResponse)
	err := c.cc.Invoke(ctx, ServiceRegistryService_ListServiceInstances_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceRegistryServiceClient) ListServicesHealth(ctx context.Context, in *ListServicesHealthRequest, opts ...grpc.CallOption) (*ListServicesHealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListServicesHealthResponse)
	err := c.cc.Invoke(ctx, ServiceRegistryService_ListServicesHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceRegistryServiceClient) GetServiceHealth(ctx context.Context, in *GetServiceHealthRequest, opts ...grpc.CallOption) (*ListServicesHealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListServicesHealthResponse)
	err := c.cc.Invoke(ctx, ServiceRegistryService_GetServiceHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceRegistryServiceServer is the server API for ServiceRegistryService service.
// All implementations must embed UnimplementedServiceRegistryServiceServer
// for forward compatibility.
type ServiceRegistryServiceServer interface {
	// List all services in the catalog
	ListServices(context.Context, *ListServicesRequest) (*ListServicesResponse, error)
	// Get services assigned to a cluster
	ListClusterServices(context.Context, *ListClusterServicesRequest) (*ListClusterServicesResponse, error)
	// Get running service instances
	ListServiceInstances(context.Context, *ListServiceInstancesRequest) (*ListServiceInstancesResponse, error)
	// Get health of all service instances
	ListServicesHealth(context.Context, *ListServicesHealthRequest) (*ListServicesHealthResponse, error)
	// Get health of specific service instances
	GetServiceHealth(context.Context, *GetServiceHealthRequest) (*ListServicesHealthResponse, error)
	mustEmbedUnimplementedServiceRegistryServiceServer()
}

// UnimplementedServiceRegistryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedServiceRegistryServiceServer struct{}

func (UnimplementedServiceRegistryServiceServer) ListServices(context.Context, *ListServicesRequest) (*ListServicesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListServices not implemented")
}
func (UnimplementedServiceRegistryServiceServer) ListClusterServices(context.Context, *ListClusterServicesRequest) (*ListClusterServicesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListClusterServices not implemented")
}
func (UnimplementedServiceRegistryServiceServer) ListServiceInstances(context.Context, *ListServiceInstancesRequest) (*ListServiceInstancesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListServiceInstances not implemented")
}
func (UnimplementedServiceRegistryServiceServer) ListServicesHealth(context.Context, *ListServicesHealthRequest) (*ListServicesHealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListServicesHealth not implemented")
}
func (UnimplementedServiceRegistryServiceServer) GetServiceHealth(context.Context, *GetServiceHealthRequest) (*ListServicesHealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetServiceHealth not implemented")
}
func (UnimplementedServiceRegistryServiceServer) mustEmbedUnimplementedServiceRegistryServiceServer() {
}
func (UnimplementedServiceRegistryServiceServer) testEmbeddedByValue() {}

// UnsafeServiceRegistryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceRegistryServiceServer will
// result in compilation errors.
type UnsafeServiceRegistryServiceServer interface {
	mustEmbedUnimplementedServiceRegistryServiceServer()
}

func RegisterServiceRegistryServiceServer(s grpc.ServiceRegistrar, srv ServiceRegistryServiceServer) {
	// If the following call panics, it indicates UnimplementedServiceRegistryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ServiceRegistryService_ServiceDesc, srv)
}

func _ServiceRegistryService_ListServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceRegistryServiceServer).ListServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceRegistryService_ListServices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceRegistryServiceServer).ListServices(ctx, req.(*ListServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceRegistryService_ListClusterServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClusterServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceRegistryServiceServer).ListClusterServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceRegistryService_ListClusterServices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceRegistryServiceServer).ListClusterServices(ctx, req.(*ListClusterServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceRegistryService_ListServiceInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListServiceInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceRegistryServiceServer).ListServiceInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceRegistryService_ListServiceInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceRegistryServiceServer).ListServiceInstances(ctx, req.(*ListServiceInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceRegistryService_ListServicesHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListServicesHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceRegistryServiceServer).ListServicesHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceRegistryService_ListServicesHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceRegistryServiceServer).ListServicesHealth(ctx, req.(*ListServicesHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceRegistryService_GetServiceHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServiceHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceRegistryServiceServer).GetServiceHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceRegistryService_GetServiceHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceRegistryServiceServer).GetServiceHealth(ctx, req.(*GetServiceHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ServiceRegistryService_ServiceDesc is the grpc.ServiceDesc for ServiceRegistryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServiceRegistryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quartermaster.ServiceRegistryService",
	HandlerType: (*ServiceRegistryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListServices",
			Handler:    _ServiceRegistryService_ListServices_Handler,
		},
		{
			MethodName: "ListClusterServices",
			Handler:    _ServiceRegistryService_ListClusterServices_Handler,
		},
		{
			MethodName: "ListServiceInstances",
			Handler:    _ServiceRegistryService_ListServiceInstances_Handler,
		},
		{
			MethodName: "ListServicesHealth",
			Handler:    _ServiceRegistryService_ListServicesHealth_Handler,
		},
		{
			MethodName: "GetServiceHealth",
			Handler:    _ServiceRegistryService_GetServiceHealth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "quartermaster.proto",
}
