// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.4
// source: foghorn_federation.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	FoghornFederation_QueryStream_FullMethodName             = "/foghorn_federation.FoghornFederation/QueryStream"
	FoghornFederation_NotifyOriginPull_FullMethodName        = "/foghorn_federation.FoghornFederation/NotifyOriginPull"
	FoghornFederation_PrepareArtifact_FullMethodName         = "/foghorn_federation.FoghornFederation/PrepareArtifact"
	FoghornFederation_CreateRemoteClip_FullMethodName        = "/foghorn_federation.FoghornFederation/CreateRemoteClip"
	FoghornFederation_CreateRemoteDVR_FullMethodName         = "/foghorn_federation.FoghornFederation/CreateRemoteDVR"
	FoghornFederation_PeerChannel_FullMethodName             = "/foghorn_federation.FoghornFederation/PeerChannel"
	FoghornFederation_ListTenantArtifacts_FullMethodName     = "/foghorn_federation.FoghornFederation/ListTenantArtifacts"
	FoghornFederation_MigrateArtifactMetadata_FullMethodName = "/foghorn_federation.FoghornFederation/MigrateArtifactMetadata"
	FoghornFederation_ForwardArtifactCommand_FullMethodName  = "/foghorn_federation.FoghornFederation/ForwardArtifactCommand"
)

// FoghornFederationClient is the client API for FoghornFederation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// FoghornFederation enables cross-cluster communication between Foghorn instances.
// Unary RPCs (QueryStream, NotifyOriginPull, PrepareArtifact) are stateless and
// load-balanced across all Foghorn instances via shared Redis state.
// PeerChannel is a sticky bidirectional stream for real-time telemetry exchange.
type FoghornFederationClient interface {
	// QueryStream asks a peer cluster whether it has a stream and returns scored edge candidates.
	QueryStream(ctx context.Context, in *QueryStreamRequest, opts ...grpc.CallOption) (*QueryStreamResponse, error)
	// NotifyOriginPull tells the origin cluster that a peer intends to pull a stream via DTSC.
	NotifyOriginPull(ctx context.Context, in *OriginPullNotification, opts ...grpc.CallOption) (*OriginPullAck, error)
	// PrepareArtifact requests an artifact (clip/DVR/VOD) be made available for cross-cluster access.
	PrepareArtifact(ctx context.Context, in *PrepareArtifactRequest, opts ...grpc.CallOption) (*PrepareArtifactResponse, error)
	// CreateRemoteClip requests the origin cluster to create a clip on behalf of a remote cluster.
	CreateRemoteClip(ctx context.Context, in *RemoteClipRequest, opts ...grpc.CallOption) (*RemoteClipResponse, error)
	// CreateRemoteDVR requests the origin cluster to start a DVR recording on behalf of a remote cluster.
	CreateRemoteDVR(ctx context.Context, in *RemoteDVRRequest, opts ...grpc.CallOption) (*RemoteDVRResponse, error)
	// PeerChannel is a bidirectional stream for real-time telemetry and replication events.
	// One PeerChannel per peer pair handles all replications between two clusters.
	// The receiving instance writes telemetry to Redis; all instances read it for scoring.
	PeerChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[PeerMessage, PeerMessage], error)
	// ListTenantArtifacts returns all artifact metadata for a tenant on this cluster.
	// Used by MigrateArtifactMetadata on the destination to bulk-copy cold storage records.
	ListTenantArtifacts(ctx context.Context, in *ListTenantArtifactsRequest, opts ...grpc.CallOption) (*ListTenantArtifactsResponse, error)
	// MigrateArtifactMetadata bulk-copies artifact records from a source cluster.
	// Destination calls ListTenantArtifacts on source, then inserts locally with origin_cluster_id.
	MigrateArtifactMetadata(ctx context.Context, in *MigrateArtifactMetadataRequest, opts ...grpc.CallOption) (*MigrateArtifactMetadataResponse, error)
	// ForwardArtifactCommand forwards an artifact operation to a peer cluster.
	// Used as a safety net when a command arrives at the wrong cluster (stale cache, race).
	// The receiving cluster tries to handle it locally and reports whether it succeeded.
	ForwardArtifactCommand(ctx context.Context, in *ForwardArtifactCommandRequest, opts ...grpc.CallOption) (*ForwardArtifactCommandResponse, error)
}

type foghornFederationClient struct {
	cc grpc.ClientConnInterface
}

func NewFoghornFederationClient(cc grpc.ClientConnInterface) FoghornFederationClient {
	return &foghornFederationClient{cc}
}

func (c *foghornFederationClient) QueryStream(ctx context.Context, in *QueryStreamRequest, opts ...grpc.CallOption) (*QueryStreamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryStreamResponse)
	err := c.cc.Invoke(ctx, FoghornFederation_QueryStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *foghornFederationClient) NotifyOriginPull(ctx context.Context, in *OriginPullNotification, opts ...grpc.CallOption) (*OriginPullAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OriginPullAck)
	err := c.cc.Invoke(ctx, FoghornFederation_NotifyOriginPull_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *foghornFederationClient) PrepareArtifact(ctx context.Context, in *PrepareArtifactRequest, opts ...grpc.CallOption) (*PrepareArtifactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrepareArtifactResponse)
	err := c.cc.Invoke(ctx, FoghornFederation_PrepareArtifact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *foghornFederationClient) CreateRemoteClip(ctx context.Context, in *RemoteClipRequest, opts ...grpc.CallOption) (*RemoteClipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoteClipResponse)
	err := c.cc.Invoke(ctx, FoghornFederation_CreateRemoteClip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *foghornFederationClient) CreateRemoteDVR(ctx context.Context, in *RemoteDVRRequest, opts ...grpc.CallOption) (*RemoteDVRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoteDVRResponse)
	err := c.cc.Invoke(ctx, FoghornFederation_CreateRemoteDVR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *foghornFederationClient) PeerChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[PeerMessage, PeerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &FoghornFederation_ServiceDesc.Streams[0], FoghornFederation_PeerChannel_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[PeerMessage, PeerMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type FoghornFederation_PeerChannelClient = grpc.BidiStreamingClient[PeerMessage, PeerMessage]

func (c *foghornFederationClient) ListTenantArtifacts(ctx context.Context, in *ListTenantArtifactsRequest, opts ...grpc.CallOption) (*ListTenantArtifactsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTenantArtifactsResponse)
	err := c.cc.Invoke(ctx, FoghornFederation_ListTenantArtifacts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *foghornFederationClient) MigrateArtifactMetadata(ctx context.Context, in *MigrateArtifactMetadataRequest, opts ...grpc.CallOption) (*MigrateArtifactMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MigrateArtifactMetadataResponse)
	err := c.cc.Invoke(ctx, FoghornFederation_MigrateArtifactMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *foghornFederationClient) ForwardArtifactCommand(ctx context.Context, in *ForwardArtifactCommandRequest, opts ...grpc.CallOption) (*ForwardArtifactCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ForwardArtifactCommandResponse)
	err := c.cc.Invoke(ctx, FoghornFederation_ForwardArtifactCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FoghornFederationServer is the server API for FoghornFederation service.
// All implementations must embed UnimplementedFoghornFederationServer
// for forward compatibility.
//
// FoghornFederation enables cross-cluster communication between Foghorn instances.
// Unary RPCs (QueryStream, NotifyOriginPull, PrepareArtifact) are stateless and
// load-balanced across all Foghorn instances via shared Redis state.
// PeerChannel is a sticky bidirectional stream for real-time telemetry exchange.
type FoghornFederationServer interface {
	// QueryStream asks a peer cluster whether it has a stream and returns scored edge candidates.
	QueryStream(context.Context, *QueryStreamRequest) (*QueryStreamResponse, error)
	// NotifyOriginPull tells the origin cluster that a peer intends to pull a stream via DTSC.
	NotifyOriginPull(context.Context, *OriginPullNotification) (*OriginPullAck, error)
	// PrepareArtifact requests an artifact (clip/DVR/VOD) be made available for cross-cluster access.
	PrepareArtifact(context.Context, *PrepareArtifactRequest) (*PrepareArtifactResponse, error)
	// CreateRemoteClip requests the origin cluster to create a clip on behalf of a remote cluster.
	CreateRemoteClip(context.Context, *RemoteClipRequest) (*RemoteClipResponse, error)
	// CreateRemoteDVR requests the origin cluster to start a DVR recording on behalf of a remote cluster.
	CreateRemoteDVR(context.Context, *RemoteDVRRequest) (*RemoteDVRResponse, error)
	// PeerChannel is a bidirectional stream for real-time telemetry and replication events.
	// One PeerChannel per peer pair handles all replications between two clusters.
	// The receiving instance writes telemetry to Redis; all instances read it for scoring.
	PeerChannel(grpc.BidiStreamingServer[PeerMessage, PeerMessage]) error
	// ListTenantArtifacts returns all artifact metadata for a tenant on this cluster.
	// Used by MigrateArtifactMetadata on the destination to bulk-copy cold storage records.
	ListTenantArtifacts(context.Context, *ListTenantArtifactsRequest) (*ListTenantArtifactsResponse, error)
	// MigrateArtifactMetadata bulk-copies artifact records from a source cluster.
	// Destination calls ListTenantArtifacts on source, then inserts locally with origin_cluster_id.
	MigrateArtifactMetadata(context.Context, *MigrateArtifactMetadataRequest) (*MigrateArtifactMetadataResponse, error)
	// ForwardArtifactCommand forwards an artifact operation to a peer cluster.
	// Used as a safety net when a command arrives at the wrong cluster (stale cache, race).
	// The receiving cluster tries to handle it locally and reports whether it succeeded.
	ForwardArtifactCommand(context.Context, *ForwardArtifactCommandRequest) (*ForwardArtifactCommandResponse, error)
	mustEmbedUnimplementedFoghornFederationServer()
}

// UnimplementedFoghornFederationServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFoghornFederationServer struct{}

func (UnimplementedFoghornFederationServer) QueryStream(context.Context, *QueryStreamRequest) (*QueryStreamResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method QueryStream not implemented")
}
func (UnimplementedFoghornFederationServer) NotifyOriginPull(context.Context, *OriginPullNotification) (*OriginPullAck, error) {
	return nil, status.Error(codes.Unimplemented, "method NotifyOriginPull not implemented")
}
func (UnimplementedFoghornFederationServer) PrepareArtifact(context.Context, *PrepareArtifactRequest) (*PrepareArtifactResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PrepareArtifact not implemented")
}
func (UnimplementedFoghornFederationServer) CreateRemoteClip(context.Context, *RemoteClipRequest) (*RemoteClipResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateRemoteClip not implemented")
}
func (UnimplementedFoghornFederationServer) CreateRemoteDVR(context.Context, *RemoteDVRRequest) (*RemoteDVRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateRemoteDVR not implemented")
}
func (UnimplementedFoghornFederationServer) PeerChannel(grpc.BidiStreamingServer[PeerMessage, PeerMessage]) error {
	return status.Error(codes.Unimplemented, "method PeerChannel not implemented")
}
func (UnimplementedFoghornFederationServer) ListTenantArtifacts(context.Context, *ListTenantArtifactsRequest) (*ListTenantArtifactsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTenantArtifacts not implemented")
}
func (UnimplementedFoghornFederationServer) MigrateArtifactMetadata(context.Context, *MigrateArtifactMetadataRequest) (*MigrateArtifactMetadataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MigrateArtifactMetadata not implemented")
}
func (UnimplementedFoghornFederationServer) ForwardArtifactCommand(context.Context, *ForwardArtifactCommandRequest) (*ForwardArtifactCommandResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ForwardArtifactCommand not implemented")
}
func (UnimplementedFoghornFederationServer) mustEmbedUnimplementedFoghornFederationServer() {}
func (UnimplementedFoghornFederationServer) testEmbeddedByValue()                           {}

// UnsafeFoghornFederationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FoghornFederationServer will
// result in compilation errors.
type UnsafeFoghornFederationServer interface {
	mustEmbedUnimplementedFoghornFederationServer()
}

func RegisterFoghornFederationServer(s grpc.ServiceRegistrar, srv FoghornFederationServer) {
	// If the following call panics, it indicates UnimplementedFoghornFederationServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FoghornFederation_ServiceDesc, srv)
}

func _FoghornFederation_QueryStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FoghornFederationServer).QueryStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FoghornFederation_QueryStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FoghornFederationServer).QueryStream(ctx, req.(*QueryStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FoghornFederation_NotifyOriginPull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OriginPullNotification)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FoghornFederationServer).NotifyOriginPull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FoghornFederation_NotifyOriginPull_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FoghornFederationServer).NotifyOriginPull(ctx, req.(*OriginPullNotification))
	}
	return interceptor(ctx, in, info, handler)
}

func _FoghornFederation_PrepareArtifact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareArtifactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FoghornFederationServer).PrepareArtifact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FoghornFederation_PrepareArtifact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FoghornFederationServer).PrepareArtifact(ctx, req.(*PrepareArtifactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FoghornFederation_CreateRemoteClip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoteClipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FoghornFederationServer).CreateRemoteClip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FoghornFederation_CreateRemoteClip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FoghornFederationServer).CreateRemoteClip(ctx, req.(*RemoteClipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FoghornFederation_CreateRemoteDVR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoteDVRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FoghornFederationServer).CreateRemoteDVR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FoghornFederation_CreateRemoteDVR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FoghornFederationServer).CreateRemoteDVR(ctx, req.(*RemoteDVRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FoghornFederation_PeerChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FoghornFederationServer).PeerChannel(&grpc.GenericServerStream[PeerMessage, PeerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type FoghornFederation_PeerChannelServer = grpc.BidiStreamingServer[PeerMessage, PeerMessage]

func _FoghornFederation_ListTenantArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTenantArtifactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FoghornFederationServer).ListTenantArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FoghornFederation_ListTenantArtifacts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FoghornFederationServer).ListTenantArtifacts(ctx, req.(*ListTenantArtifactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FoghornFederation_MigrateArtifactMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrateArtifactMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FoghornFederationServer).MigrateArtifactMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FoghornFederation_MigrateArtifactMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FoghornFederationServer).MigrateArtifactMetadata(ctx, req.(*MigrateArtifactMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FoghornFederation_ForwardArtifactCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForwardArtifactCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FoghornFederationServer).ForwardArtifactCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FoghornFederation_ForwardArtifactCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FoghornFederationServer).ForwardArtifactCommand(ctx, req.(*ForwardArtifactCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FoghornFederation_ServiceDesc is the grpc.ServiceDesc for FoghornFederation service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FoghornFederation_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "foghorn_federation.FoghornFederation",
	HandlerType: (*FoghornFederationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryStream",
			Handler:    _FoghornFederation_QueryStream_Handler,
		},
		{
			MethodName: "NotifyOriginPull",
			Handler:    _FoghornFederation_NotifyOriginPull_Handler,
		},
		{
			MethodName: "PrepareArtifact",
			Handler:    _FoghornFederation_PrepareArtifact_Handler,
		},
		{
			MethodName: "CreateRemoteClip",
			Handler:    _FoghornFederation_CreateRemoteClip_Handler,
		},
		{
			MethodName: "CreateRemoteDVR",
			Handler:    _FoghornFederation_CreateRemoteDVR_Handler,
		},
		{
			MethodName: "ListTenantArtifacts",
			Handler:    _FoghornFederation_ListTenantArtifacts_Handler,
		},
		{
			MethodName: "MigrateArtifactMetadata",
			Handler:    _FoghornFederation_MigrateArtifactMetadata_Handler,
		},
		{
			MethodName: "ForwardArtifactCommand",
			Handler:    _FoghornFederation_ForwardArtifactCommand_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PeerChannel",
			Handler:       _FoghornFederation_PeerChannel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "foghorn_federation.proto",
}
