# FrameWorks Bridge GraphQL Schema
# Unified API for all FrameWorks services

# Root Query type
# Note: List and object fields are nullable per GraphQL best practices.
# This enables graceful degradation - if one service is down, other fields still work.
# Connection types remain non-null as they always return a valid structure (empty edges if no data).
type Query {

  # Streams (from Commodore)
  streamsConnection(first: Int = 50, after: String, last: Int, before: String): StreamsConnection!
  stream(id: ID!): Stream
  validateStreamKey(streamKey: String!): StreamValidation

  # Platform Analytics (from Periscope Query)
  # Note: Stream-specific analytics moved to Stream.analytics edge
  platformOverview(timeRange: TimeRangeInput): PlatformOverview

  # Geographic Analytics
  viewerGeographicsConnection(stream: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String): ViewerGeographicsConnection!
  geographicDistribution(stream: String, timeRange: TimeRangeInput, topN: Int = 10): GeographicDistribution

  # Connection and Routing Analytics (Relay-style pagination)
  # subjectTenantId = filter by stream owner (customer) tenant
  # clusterId = filter by emitting cluster
  routingEventsConnection(stream: String, timeRange: TimeRangeInput, subjectTenantId: ID, clusterId: String, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): RoutingEventsConnection!
  connectionEventsConnection(stream: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): ConnectionEventsConnection!
  viewerSessionsConnection(stream: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): ViewerSessionsConnection!

  # Artifact State (current status of clips/DVR from live_artifacts)
  artifactState(requestId: ID!): ArtifactState
  artifactStatesConnection(internalName: String, contentType: String, stage: String, first: Int = 100, after: String, last: Int, before: String): ArtifactStatesConnection!

  # Node Performance Metrics (Relay-style pagination)
  nodeMetricsConnection(nodeId: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): NodeMetricsConnection!
  nodeMetrics1hConnection(timeRange: TimeRangeInput, nodeId: String, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): NodeMetrics1hConnection!

  # Pre-Aggregated Analytics (Materialized Views)
  # Note: Stream-specific analytics (clientMetrics5m, streamConnectionHourly, qualityTierDaily, clipEvents, storageEvents) moved to Stream edges
  storageUsageConnection(nodeId: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): StorageUsageConnection!
  nodePerformance5mConnection(nodeId: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): NodePerformance5mConnection!
  viewerHoursHourlyConnection(stream: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): ViewerHoursHourlyConnection!
  viewerGeoHourlyConnection(stream: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): ViewerGeoHourlyConnection!

  # Processing/Transcoding Usage (from process_billing table via Periscope)
  processingUsageConnection(streamName: String, processType: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): ProcessingUsageConnection!

  # Rebuffering Events (buffer state transitions via Periscope)
  rebufferingEventsConnection(internalName: String, nodeId: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): RebufferingEventsConnection!

  # Daily Analytics Rollups (from ClickHouse materialized views via Periscope)
  tenantAnalyticsDailyConnection(timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): TenantAnalyticsDailyConnection!
  streamAnalyticsDailyConnection(internalName: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): StreamAnalyticsDailyConnection!

  # Infrastructure Service Monitoring
  serviceInstancesConnection(clusterId: String, nodeId: String, status: InstanceStatus, first: Int = 50, after: String, last: Int, before: String): ServiceInstancesConnection!

  # Stream Management
  streamKeysConnection(streamId: ID!, first: Int = 50, after: String, last: Int, before: String): StreamKeysConnection!
  clipsConnection(streamId: ID, first: Int = 50, after: String, last: Int, before: String): ClipsConnection!
  clip(id: ID!): Clip
  clipViewingUrls(clipId: ID!): ClipViewingUrls

  # Billing (from Purser)
  billingTiers: [BillingTier!]
  invoicesConnection(first: Int = 50, after: String, last: Int, before: String): InvoicesConnection!
  invoice(id: ID!): Invoice
  billingStatus: BillingStatus
  tenantUsage(timeRange: TimeRangeInput): TenantUsage
  usageRecordsConnection(timeRange: TimeRangeInput, first: Int = 50, after: String, last: Int, before: String): UsageRecordsConnection!

  # Tenants & Infrastructure (from Quartermaster)
  tenant: Tenant
  clustersConnection(first: Int = 50, after: String, last: Int, before: String): ClustersConnection!
  cluster(id: ID!): Cluster
  nodesConnection(clusterId: String, status: NodeStatus, type: String, first: Int = 50, after: String, last: Int, before: String): NodesConnection!
  node(id: ID!): Node

  # Service discovery and access (Quartermaster)
  discoverServicesConnection(type: String!, clusterId: String, first: Int = 50, after: String, last: Int, before: String): ServiceInstancesConnection!
  clustersAccess(first: Int = 50, after: String): [ClusterAccess!] @deprecated(reason: "Use clustersAccessConnection instead")
  clustersAccessConnection(first: Int = 50, after: String, last: Int, before: String): ClusterAccessConnection!
  clustersAvailable(first: Int = 50, after: String): [AvailableCluster!] @deprecated(reason: "Use clustersAvailableConnection instead")
  clustersAvailableConnection(first: Int = 50, after: String, last: Int, before: String): AvailableClusterConnection!
  mySubscriptions(first: Int = 50, after: String): [Cluster!]! @deprecated(reason: "Use mySubscriptionsConnection instead")
  mySubscriptionsConnection(first: Int = 50, after: String, last: Int, before: String): MySubscriptionsConnection!
  serviceInstancesHealth(serviceId: String): [ServiceInstanceHealth!]

  # Cluster Marketplace (Quartermaster)
  marketplaceClusters(pricingModel: ClusterPricingModel, first: Int = 50, after: String): [MarketplaceCluster!]! @deprecated(reason: "Use marketplaceClustersConnection instead")
  marketplaceClustersConnection(pricingModel: ClusterPricingModel, first: Int = 50, after: String, last: Int, before: String): MarketplaceClusterConnection!
  marketplaceCluster(clusterId: String!): MarketplaceCluster
  pendingSubscriptions(clusterId: ID!): [ClusterSubscription!]! @deprecated(reason: "Use pendingSubscriptionsConnection instead")
  pendingSubscriptionsConnection(clusterId: ID!, first: Int = 50, after: String, last: Int, before: String): ClusterSubscriptionConnection!
  clusterInvites(clusterId: ID!): [ClusterInvite!]! @deprecated(reason: "Use clusterInvitesConnection instead")
  clusterInvitesConnection(clusterId: ID!, first: Int = 50, after: String, last: Int, before: String): ClusterInviteConnection!
  myClusterInvites: [ClusterInvite!]! @deprecated(reason: "Use myClusterInvitesConnection instead")
  myClusterInvitesConnection(first: Int = 50, after: String, last: Int, before: String): ClusterInviteConnection!

  # Developer API (from Commodore)
  developerTokensConnection(first: Int = 50, after: String, last: Int, before: String): DeveloperTokensConnection!

  # Bootstrap token management (admin/provider only via Quartermaster)
  bootstrapTokensConnection(kind: String, first: Int = 50, after: String, last: Int, before: String): BootstrapTokenConnection!

  # DVR recording requests (cursor-paginated)
  dvrRecordingsConnection(internalName: String, first: Int, after: String, last: Int, before: String): DVRRecordingsConnection

  # VOD Assets (user-uploaded video files)
  vodAsset(id: ID!): VodAsset
  vodAssetsConnection(first: Int = 50, after: String, last: Int, before: String): VodAssetsConnection!

  # Viewer endpoint resolution (via Foghorn)
  resolveViewerEndpoint(contentType: String!, contentId: String!): ViewerEndpointResponse
  # Ingest endpoint resolution for StreamCrafter (via Foghorn)
  resolveIngestEndpoint(streamKey: String!): IngestEndpointResponse
  # Mist JSON meta (via Commodore -> Foghorn)
  streamMeta(streamKey: String!, targetBaseUrl: String, targetNodeId: String, includeRaw: Boolean): StreamMetaResponse
}

# Root Mutation type
type Mutation {
  # Stream operations (via Commodore)
  createStream(input: CreateStreamInput!): CreateStreamResult!
  updateStream(id: ID!, input: UpdateStreamInput!): UpdateStreamResult!
  deleteStream(id: ID!): DeleteStreamResult!
  refreshStreamKey(id: ID!): UpdateStreamResult!

  # Clip operations (via Commodore)
  createClip(input: CreateClipInput!): CreateClipResult!
  deleteClip(id: ID!): DeleteClipResult!

  # DVR operations (via Commodore)
  startDVR(internalName: String!, streamId: ID, expiresAt: Int): StartDVRResult!
  stopDVR(dvrHash: ID!): StopDVRResult!
  deleteDVR(dvrHash: ID!): DeleteDVRResult!

  # VOD upload operations (via Foghorn)
  createVodUpload(input: CreateVodUploadInput!): CreateVodUploadResult!
  completeVodUpload(input: CompleteVodUploadInput!): CompleteVodUploadResult!
  abortVodUpload(uploadId: ID!): AbortVodUploadResult!
  deleteVodAsset(id: ID!): DeleteVodAssetResult!

  # Billing operations (via Purser)
  createPayment(input: CreatePaymentInput!): CreatePaymentResult!
  updateSubscriptionCustomTerms(tenantId: ID!, input: UpdateSubscriptionCustomTermsInput!): TenantSubscription

  # Infrastructure operations (via Quartermaster)
  updateTenant(input: UpdateTenantInput!): UpdateTenantResult!
  subscribeToCluster(clusterId: ID!): Boolean!
  unsubscribeFromCluster(clusterId: ID!): Boolean!

  # Cluster Marketplace operations (via Quartermaster)
  createPrivateCluster(input: CreatePrivateClusterInput!): CreatePrivateClusterResult!
  updateClusterMarketplace(clusterId: ID!, input: UpdateClusterMarketplaceInput!): UpdateClusterResult!
  createClusterInvite(input: CreateClusterInviteInput!): CreateClusterInviteResult!
  revokeClusterInvite(inviteId: ID!): RevokeClusterInviteResult!
  requestClusterSubscription(clusterId: ID!, inviteToken: String): ClusterSubscriptionResult!
  acceptClusterInvite(inviteToken: String!): ClusterSubscriptionResult!
  approveClusterSubscription(subscriptionId: ID!): ClusterSubscriptionResult!
  rejectClusterSubscription(subscriptionId: ID!, reason: String): ClusterSubscriptionResult!

  # Developer API operations (via Commodore)
  createDeveloperToken(input: CreateDeveloperTokenInput!): CreateDeveloperTokenResult!
  revokeDeveloperToken(id: ID!): RevokeDeveloperTokenResult!

  # Bootstrap token operations (admin/provider only via Quartermaster)
  createBootstrapToken(input: CreateBootstrapTokenInput!): CreateBootstrapTokenResult!
  revokeBootstrapToken(id: ID!): RevokeBootstrapTokenResult!

  # Stream key operations (via Commodore)
  createStreamKey(streamId: ID!, input: CreateStreamKeyInput!): CreateStreamKeyResult!
  deleteStreamKey(streamId: ID!, keyId: ID!): DeleteStreamKeyResult!
}

# Error interface and types for mutation results
# Per GraphQL best practices: mutations should return union types with explicit error states

interface Error {
  message: String!
  code: String
}

type ValidationError implements Error {
  message: String!
  code: String
  field: String
  constraint: String
}

type AuthError implements Error {
  message: String!
  code: String
}

type NotFoundError implements Error {
  message: String!
  code: String
  resourceType: String!
  resourceId: ID!
}

type RateLimitError implements Error {
  message: String!
  code: String
  retryAfter: Int
}

type DeleteSuccess {
  success: Boolean!
  deletedId: ID!
}

# Mutation Result union types
union CreateStreamResult = Stream | ValidationError | AuthError
union UpdateStreamResult = Stream | ValidationError | NotFoundError | AuthError
union DeleteStreamResult = DeleteSuccess | NotFoundError | AuthError

union CreateClipResult = Clip | ValidationError | NotFoundError | AuthError
union DeleteClipResult = DeleteSuccess | NotFoundError | AuthError

union CreateStreamKeyResult = StreamKey | ValidationError | NotFoundError | AuthError
union DeleteStreamKeyResult = DeleteSuccess | NotFoundError | AuthError

union StartDVRResult = DVRRequest | ValidationError | NotFoundError | AuthError
union StopDVRResult = DeleteSuccess | NotFoundError | AuthError
union DeleteDVRResult = DeleteSuccess | NotFoundError | AuthError

union CreateVodUploadResult = VodUploadSession | ValidationError | AuthError
union CompleteVodUploadResult = VodAsset | ValidationError | NotFoundError | AuthError
union AbortVodUploadResult = DeleteSuccess | NotFoundError | AuthError
union DeleteVodAssetResult = DeleteSuccess | NotFoundError | AuthError

union CreatePaymentResult = Payment | ValidationError | AuthError
union UpdateTenantResult = Tenant | ValidationError | AuthError

union CreateDeveloperTokenResult = DeveloperToken | ValidationError | RateLimitError | AuthError
union RevokeDeveloperTokenResult = DeleteSuccess | NotFoundError | AuthError

union CreateBootstrapTokenResult = BootstrapToken | ValidationError | AuthError
union RevokeBootstrapTokenResult = DeleteSuccess | NotFoundError | AuthError

# Cluster Marketplace Result Types
union CreatePrivateClusterResult = CreatePrivateClusterResponse | ValidationError | AuthError
union UpdateClusterResult = Cluster | ValidationError | NotFoundError | AuthError
union CreateClusterInviteResult = ClusterInvite | ValidationError | NotFoundError | AuthError
union RevokeClusterInviteResult = DeleteSuccess | NotFoundError | AuthError
union ClusterSubscriptionResult = ClusterSubscription | ValidationError | NotFoundError | AuthError

# Root Subscription type for real-time updates
type Subscription {
  # Stream lifecycle events (real-time from Signalman)
  # Returns rich payload with proto enum event types (EVENT_TYPE_STREAM_LIFECYCLE_UPDATE, etc.)
  streamEvents(stream: String): StreamSubscriptionEvent!

  # Viewer metrics updates
  viewerMetrics(stream: String!): ViewerMetrics!

  # Track list updates (real-time from Signalman)
  trackListUpdates(stream: String!): TrackListUpdate!

  # Clip lifecycle updates (real-time from Signalman)
  clipLifecycle(stream: String!): ClipLifecycle!
  dvrLifecycle(stream: String!): DVREvent!
  vodLifecycle: VodLifecycle!

  # System health (admin only)
  systemHealth: SystemHealthEvent!

  # Firehose: All tenant events (streams, analytics, system) in a single subscription
  # Useful for dashboards that need to display all events in real-time
  firehose: TenantEvent!
}

# Union type for all possible tenant events in firehose
type TenantEvent {
  type: String!     # Proto enum string (e.g., EVENT_TYPE_STREAM_LIFECYCLE_UPDATE, EVENT_TYPE_VIEWER_CONNECT)
  channel: String!  # STREAMS, ANALYTICS, or SYSTEM
  timestamp: Time!

  # One of these will be populated based on event type
  streamEvent: StreamSubscriptionEvent
  viewerMetrics: ViewerMetrics
  trackListUpdate: TrackListUpdate  # Real-time track updates from Signalman
  clipLifecycle: ClipLifecycle      # Real-time clip lifecycle from Signalman
  dvrEvent: DVREvent
  vodLifecycle: VodLifecycle        # Real-time VOD upload lifecycle from Signalman
  systemHealthEvent: SystemHealthEvent
}

# DVR lifecycle event - bound to proto.DVRLifecycleData
type DVREvent {
  status: String!
  dvrHash: String!
  requestId: String
  manifestPath: String
  startedAt: Int
  endedAt: Int
  sizeBytes: Float
  segmentCount: Int
  error: String
  nodeId: String
  internalName: String
}

# Real-time track list update from Signalman - bound to proto.StreamTrackListTrigger
type TrackListUpdate {
  streamName: String!
  tracks: [StreamTrack!]
  totalTracks: Int
  videoTrackCount: Int
  audioTrackCount: Int
  qualityTier: String
  primaryWidth: Int
  primaryHeight: Int
  primaryFps: Float
  primaryVideoBitrate: Int
  primaryVideoCodec: String
  primaryAudioBitrate: Int
  primaryAudioCodec: String
  primaryAudioChannels: Int
  primaryAudioSampleRate: Int
}

# Real-time clip lifecycle event from Signalman - bound to proto.ClipLifecycleData
type ClipLifecycle {
  stage: Int!
  clipHash: String!
  requestId: String
  progressPercent: Int
  filePath: String
  s3Url: String
  sizeBytes: Float
  error: String
  startedAt: Int
  completedAt: Int
  nodeId: String
  internalName: String
  # Timing info for progress display (enriched by Foghorn)
  startUnix: Int
  stopUnix: Int
  durationSec: Int
  clipMode: String
}

# Real-time VOD upload lifecycle event from Signalman - bound to proto.VodLifecycleData
type VodLifecycle {
  status: Int!             # VodLifecycleData.Status enum value
  vodHash: String!         # Artifact hash (from Commodore)
  uploadId: String         # S3 multipart upload ID
  filename: String
  contentType: String      # MIME type (video/mp4, etc.)
  sizeBytes: Float         # Expected or actual size
  s3Url: String            # Final S3 URL when completed
  filePath: String         # Local file path (if applicable)
  error: String
  startedAt: Int           # When upload started (unix timestamp)
  completedAt: Int         # When upload/processing completed
  nodeId: String           # Processing node (if any)
  expiresAt: Int           # Retention expiration (unix timestamp)
  # Media metadata (populated after processing)
  durationMs: Int
  resolution: String       # "1920x1080"
  videoCodec: String
  audioCodec: String
}

# Input types

input CreateStreamInput {
  name: String!
  description: String
  record: Boolean = false
}

input UpdateStreamInput {
  name: String
  description: String
  record: Boolean
}

# Clip creation mode - determines how time fields are interpreted
enum ClipCreationMode {
  ABSOLUTE     # start_unix + stop_unix (Unix timestamps)
  RELATIVE     # start (media time) + stop (media time from stream start)
  DURATION     # start + duration
  CLIP_NOW     # duration only (relative to live - clips last N seconds from now)
}

input CreateClipInput {
  stream: String!
  title: String!
  description: String

  # Mode selection (default: ABSOLUTE for backward compatibility)
  mode: ClipCreationMode

  # ABSOLUTE mode: Unix timestamps in seconds
  startUnix: Int
  stopUnix: Int

  # RELATIVE mode: Media time in seconds from stream start
  startMedia: Int
  stopMedia: Int

  # DURATION / CLIP_NOW: Duration in seconds
  duration: Int

  # Expiry time (Unix timestamp in seconds)
  expiresAt: Int

  # Legacy fields (deprecated, map to startUnix/stopUnix)
  startTime: Int @deprecated(reason: "Use startUnix instead")
  endTime: Int @deprecated(reason: "Use stopUnix instead")
}

# DVR types
type DVRRequest {
  # Business metadata (from Commodore registry)
  id: ID                     # UUID from Commodore business registry
  dvrHash: ID!
  internalName: String!
  title: String              # Stream title or custom title
  createdAt: Time!
  updatedAt: Time!
  expiresAt: Time
  # Lifecycle data (from Periscope via artifactStatesConnection, or Foghorn for single-item queries)
  storageNodeId: String
  status: String
  startedAt: Time
  endedAt: Time
  durationSeconds: Int
  sizeBytes: Float
  manifestPath: String
  errorMessage: String
  # Cold storage info
  storageLocation: String   # "local", "s3", "freezing", "defrosting"
  isFrozen: Boolean!
  frozenAt: Time
  s3Url: String
}

# DVR Recordings Connection (cursor-paginated)
type DVRRecordingsConnection {
  edges: [DVRRecordingEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DVRRecordingEdge {
  cursor: String!
  node: DVRRequest!
}

# ============================================================================
# VOD UPLOAD TYPES
# ============================================================================

# VOD asset status enumeration
enum VodAssetStatus {
  UPLOADING      # S3 multipart upload in progress
  PROCESSING     # Upload complete, validating and extracting metadata
  READY          # Validated and ready for playback
  FAILED         # Validation failed or upload error
  DELETED        # Marked for deletion
}

# Input for initiating a VOD upload
input CreateVodUploadInput {
  filename: String!          # Original filename (for metadata)
  sizeBytes: Int!            # File size in bytes (required for part calculation)
  contentType: String        # MIME type (video/mp4, video/webm, etc.)
  title: String              # Optional title for the asset
  description: String        # Optional description
}

# Input for completing a VOD upload (after all parts uploaded to S3)
input CompleteVodUploadInput {
  uploadId: ID!              # Upload session ID from createVodUpload
  parts: [VodUploadCompletedPart!]!  # ETags from each uploaded part
}

# Completed part info (returned by S3 after each part upload)
input VodUploadCompletedPart {
  partNumber: Int!           # 1-indexed part number
  etag: String!              # ETag header returned by S3 on part upload
}

# Response from createVodUpload with S3 multipart upload instructions
type VodUploadSession {
  id: ID!                    # Upload session ID (S3 uploadId)
  artifactId: ID!            # Artifact ID in live_artifacts table
  artifactHash: String!      # Hash for playback URL resolution
  partSize: Int!             # Recommended part size in bytes
  parts: [VodUploadPart!]!   # Presigned URLs for each part
  expiresAt: Time!           # When presigned URLs expire (typically 2 hours)
}

# Individual part upload instruction
type VodUploadPart {
  partNumber: Int!           # 1-indexed part number
  presignedUrl: String!      # Presigned PUT URL for this part
}

# VOD asset type (user-uploaded video file)
type VodAsset {
  id: ID!
  artifactHash: String!      # Hash for playback URL resolution
  title: String
  description: String
  filename: String           # Original uploaded filename
  status: VodAssetStatus!
  storageLocation: String!   # "s3", "local", "freezing", "defrosting"

  # File metadata (populated after validation)
  sizeBytes: Float
  durationMs: Int            # Video duration in milliseconds
  resolution: String         # e.g., "1920x1080"
  videoCodec: String         # e.g., "h264", "h265", "vp9"
  audioCodec: String         # e.g., "aac", "opus"
  bitrateKbps: Int           # Average bitrate

  # Timestamps
  createdAt: Time!
  updatedAt: Time!
  expiresAt: Time            # Optional expiration

  # Error info (if status is FAILED)
  errorMessage: String
}

# VOD Assets Connection (cursor-paginated)
type VodAssetsConnection {
  edges: [VodAssetEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type VodAssetEdge {
  cursor: String!
  node: VodAsset!
}

input CreatePaymentInput {
  invoiceId: ID!
  amount: Money!
  currency: Currency
  method: PaymentMethod!
  returnUrl: String
}

# Input for updating custom subscription terms (admin/provider only)
input UpdateSubscriptionCustomTermsInput {
  customPricing: CustomPricingInput
  customFeatures: BillingFeaturesInput
  customAllocations: AllocationDetailsInput
}

input CustomPricingInput {
  basePrice: Float
  discountRate: Float
  overageRates: OverageRatesInput
}

input OverageRatesInput {
  bandwidth: AllocationDetailsInput
  storage: AllocationDetailsInput
  compute: AllocationDetailsInput
}

input AllocationDetailsInput {
  limit: Float                # nil = unlimited
  unitPrice: Float
  unit: String
}

input BillingFeaturesInput {
  recording: Boolean
  analytics: Boolean
  customBranding: Boolean
  apiAccess: Boolean
  supportLevel: String
  sla: Boolean
}

# UpdateSubscriptionResult - returns subscription on success, errors through standard GraphQL error handling

input UpdateTenantInput {
  name: String
  settings: JSON
}

input CreateDeveloperTokenInput {
  name: String!
  permissions: String
  expiresIn: Int
}

input CreateBootstrapTokenInput {
  name: String!
  type: BootstrapTokenType!
  expiresIn: Int    # Days until expiration
  usageLimit: Int   # Max uses allowed
  clusterId: ID     # Required for edge_node tokens, binds token to specific cluster
}

input CreateStreamKeyInput {
  name: String!
}

# Cluster Marketplace Inputs
input CreatePrivateClusterInput {
  clusterName: String!
  region: String
  shortDescription: String
}

input UpdateClusterMarketplaceInput {
  visibility: ClusterVisibility
  pricingModel: ClusterPricingModel
  monthlyPriceCents: Int
  requiredBillingTier: String
  requiresApproval: Boolean
  shortDescription: String
  longDescription: String
}

input CreateClusterInviteInput {
  clusterId: ID!
  invitedTenantId: ID!
  accessLevel: String
  resourceLimits: JSON
  expiresInDays: Int
}

input TimeRangeInput {
  start: Time!
  end: Time!
}

enum SortOrder {
  ASC
  DESC
}

type TimeRange {
  start: Time!
  end: Time!
}

# Enums
enum PaymentMethod {
  CARD
  CRYPTO
  BANK_TRANSFER
}

# Added payment status enum
enum PaymentStatus {
  PENDING
  CONFIRMED
  FAILED
}

# Added invoice status enum
enum InvoiceStatus {
  PENDING
  PAID
  FAILED
  CANCELLED
}

# Service instance lifecycle status
enum InstanceStatus {
  RUNNING
  STARTING
  STOPPING
  STOPPED
  ERROR
  UNKNOWN
}

enum StreamStatus {
  OFFLINE
  LIVE
  RECORDING
  ENDED
}

enum NodeStatus {
  HEALTHY
  DEGRADED
  UNHEALTHY
}

enum BootstrapTokenType {
  EDGE_NODE
  SERVICE
}

# Cluster Marketplace Enums
enum ClusterVisibility {
  PUBLIC
  UNLISTED
  PRIVATE
}

enum ClusterPricingModel {
  FREE_UNMETERED
  METERED
  MONTHLY
  TIER_INHERIT
  CUSTOM
}

enum ClusterSubscriptionStatus {
  PENDING_APPROVAL
  ACTIVE
  SUSPENDED
  REJECTED
}

# Real-time stream subscription event types (direct proto passthrough)
# NOTE: These types omit tenant_id/user_id fields for security (internal only)

# Bound to proto.StreamLifecycleUpdate
type StreamLifecycleUpdate {
  nodeId: String!
  internalName: String!
  status: String!           # "live", "offline"
  bufferState: String       # "FULL", "EMPTY", "DRY", "RECOVER"
  uploadedBytes: Float
  downloadedBytes: Float
  totalViewers: Int
  totalInputs: Int
  viewerSeconds: Float
}

# Bound to proto.StreamEndTrigger
type StreamEndEvent {
  streamName: String!
  nodeId: String
  downloadedBytes: Float
  uploadedBytes: Float
  totalViewers: Float
  totalInputs: Float
  totalOutputs: Float
  viewerSeconds: Float
}

# Bound to proto.StreamBufferTrigger - rich health diagnostics
type StreamBufferEvent {
  streamName: String!
  bufferState: String!      # "FULL", "EMPTY", "DRY", "RECOVER"
  hasIssues: Boolean
  issuesDescription: String
  trackCount: Int
  qualityTier: String
  streamBufferMs: Int       # Overall buffer depth in ms
  streamJitterMs: Int       # Max jitter across tracks
  mistIssues: String        # Mist's issue string (e.g., "HLSnoaudio!")
  maxKeepawaMs: Int         # Max viewer distance from live edge
  tracks: [StreamTrack!]    # Full track details
}

# Real-time subscription event wrapper (uses optional fields pattern like TenantEvent)
type StreamSubscriptionEvent {
  eventType: String!        # Proto enum string: EVENT_TYPE_STREAM_LIFECYCLE_UPDATE, EVENT_TYPE_STREAM_END, EVENT_TYPE_STREAM_BUFFER
  timestamp: Time!
  # One of these will be populated based on eventType
  lifecycleUpdate: StreamLifecycleUpdate
  endEvent: StreamEndEvent
  bufferEvent: StreamBufferEvent  # Rich health diagnostics (jitter, issues, buffer depth)
}

# Historical stream event type (for eventsConnection query - from ClickHouse)
# Bound to proto.StreamEvent from periscope.proto
type StreamEvent {
  type: StreamEventType!
  stream: String!
  status: StreamStatus!
  timestamp: Time!
  details: JSON
}

enum StreamEventType {
  STREAM_START
  STREAM_END
  STREAM_ERROR
  BUFFER_UPDATE
  TRACK_LIST_UPDATE
}

# ViewerMetrics maps to proto ClientLifecycleUpdate
# These are per-client connection metrics, not aggregated viewer counts
type ViewerMetrics {
  nodeId: String!
  internalName: String!
  action: String!              # "connect" or "disconnect"
  protocol: String!
  host: String                 # Client IP - redacted for privacy (returns null)
  sessionId: String
  connectionTime: Float        # seconds connected
  position: Float              # playback position
  bandwidthInBps: Int          # upload bandwidth (bits/sec)
  bandwidthOutBps: Int         # download bandwidth (bits/sec)
  bytesDownloaded: Float
  bytesUploaded: Float
  packetsSent: Int
  packetsLost: Int
  packetsRetransmitted: Int
  timestamp: Int!
  # GeoIP enriched fields (added by Foghorn)
  # clientIp removed - was never populated (IP in 'host', redacted for privacy)
  clientCountry: String
  clientCity: String
  clientLatitude: Float
  clientLongitude: Float
}

type TrackListEvent {
  stream: String!
  nodeId: String
  trackList: String!
  trackCount: Int!
  timestamp: Time!
  tracks: [StreamTrack!]
}

type StreamTrack {
  trackName: String!
  trackType: String!
  codec: String
  bitrateKbps: Int
  bitrateBps: Int
  buffer: Int
  jitter: Int
  width: Int
  height: Int
  fps: Float
  resolution: String
  hasBFrames: Boolean
  channels: Int
  sampleRate: Int
}

type SystemHealthEvent {
  nodeId: ID                  # Database UUID (for reliable lookups)
  node: String!               # Logical name (for display/fallback)
  location: String!           # Region/city name (e.g. "NYC")
  status: NodeStatus!
  cpuTenths: Int!             # CPU usage 0-1000 (divide by 10 for %)
  isHealthy: Boolean!

  # Raw resource metrics (Bytes)
  ramMax: Float               # Max RAM in MiB
  ramCurrent: Float           # Current RAM usage in MiB
  diskTotalBytes: Float
  diskUsedBytes: Float
  shmTotalBytes: Float
  shmUsedBytes: Float

  timestamp: Time!
}

# Custom scalars
scalar Time
scalar JSON
scalar Currency
scalar Money

# Core types (some will map to pkg/models types)
type User {
  id: ID!
  email: String!
  name: String
  role: String!
  createdAt: Time!
}


type Tenant {
  id: ID!
  name: String!
  cluster: String
  createdAt: Time!
}

type Stream {
  # === CONFIG FIELDS (from Commodore Control Plane) ===
  id: ID!
  name: String!
  description: String
  streamKey: String!
  playbackId: String!
  record: Boolean!
  createdAt: Time!
  updatedAt: Time!

  # === EDGES ===
  # Operational metrics (from Periscope Data Plane) - lazy loaded
  metrics: StreamMetrics

  # === ANALYTICS EDGES (from ClickHouse) ===

  # Aggregated analytics (stream_events + client_metrics)
  analytics(timeRange: TimeRangeInput): StreamAnalytics

  # Time-series for charts (5m/15m/1h/1d buckets)
  viewerTimeSeriesConnection(timeRange: TimeRangeInput, interval: String = "5m", first: Int = 100, after: String, last: Int, before: String): ViewerTimeSeriesConnection!

  # Health monitoring (stream_buffer events)
  currentHealth: StreamHealthMetric
  healthConnection(timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): StreamHealthMetricsConnection!
  rebufferingEventsConnection(timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String): RebufferingEventsConnection!

  # Track metadata (track_list events)
  trackListConnection(timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): TrackListEventsConnection!

  # Client/viewer quality (client_metrics_5m MV)
  clientMetricsConnection(timeRange: TimeRangeInput, nodeId: String, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): ClientMetrics5mConnection!

  # Hourly aggregates (stream_connection_hourly MV)
  connectionHourlyConnection(timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): StreamConnectionHourlyConnection!

  # Quality distribution (quality_tier_daily MV)
  qualityDailyConnection(timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): QualityTierDailyConnection!

  # Clip/DVR lifecycle (clip_events)
  clipEventsConnection(stage: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): ClipEventsConnection!

  # Storage lifecycle (storage_events)
  storageEventsConnection(assetType: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): StorageEventsConnection!

  # Raw stream events (stream_events table)
  eventsConnection(timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): StreamEventsConnection

  # Individual viewer sessions for this stream (viewer_sessions table)
  viewerSessionsConnection(timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): ViewerSessionsConnection!

  # 5-minute aggregated health metrics (from stream_health_5m MV)
  health5mConnection(timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): StreamHealth5mConnection!
}

# Operational metrics from Periscope Data Plane
# Resolved lazily via StreamMetrics loader
type StreamMetrics {
  status: StreamStatus!
  isLive: Boolean!
  currentViewers: Int!
  peakViewers: Int!
  totalViews: Int!
  startedAt: Time
  endedAt: Time
  duration: Int!
  lastEventAt: Time
  lastEventType: String

  # Quality metrics (from live_streams table)
  bufferState: String
  qualityTier: String
  primaryWidth: Int
  primaryHeight: Int
  primaryFps: Float
  primaryCodec: String
  primaryBitrate: Int
  hasIssues: Boolean
  issuesDescription: String
}

# Validation status enum - avoids ambiguous null booleans per Yelp guidelines
enum ValidationStatus {
  VALID
  INVALID
  ERROR
}

type StreamValidation {
  status: ValidationStatus!
  streamKey: String!
  error: String
}

type StreamAnalytics {
  # Core identifiers
  id: ID!
  streamId: ID
  internalName: String!

  # Session timing
  sessionStartTime: Time
  sessionEndTime: Time
  totalSessionDuration: Int!

  # Viewer metrics
  currentViewers: Int!
  peakViewers: Int!
  totalConnections: Int!
  totalViews: Int!        # Total view count (session starts)
  uniqueViewers: Int!     # Unique viewer count (distinct sessions/IPs)
  
  # Bandwidth metrics
  bandwidthIn: Float!
  bandwidthOut: Float!
  totalBandwidthGb: Float!
  upbytes: Float!
  downbytes: Float!
  
  # Stream quality
  bitrateKbps: Int
  resolution: String
  
  # Network performance
  packetsSent: Float!
  packetsLost: Float!
  packetsRetrans: Float!
  firstMs: Int
  lastMs: Int
  
  # Stream details
  trackCount: Int!
  inputs: Int!
  outputs: Int!
  
  # Location
  nodeId: String
  nodeName: String
  latitude: Float
  longitude: Float
  location: String
  
  # Status
  status: String
  lastUpdated: Time!

  # Current health state (from STREAM_BUFFER events)
  currentBufferState: String
  currentIssues: String
  currentCodec: String
  currentFps: Float
  currentResolution: String
  mistStatus: String
  qualityTier: String
  
  # Enriched analytics from ClickHouse (computed)
  avgViewers: Float
  uniqueCountries: Int
  uniqueCities: Int
  avgBufferHealth: Float
  avgBitrate: Int
  packetLossRate: Float
}

# Time-bucketed viewer count for charts (from ClickHouse aggregation)
type ViewerCountBucket {
  timestamp: Time!
  viewerCount: Int!
  stream: String      # Optional stream identifier when querying across streams
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

# Routing Events Connection
type RoutingEventEdge {
  cursor: String!
  node: RoutingEvent!
}

type RoutingEventsConnection {
  edges: [RoutingEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Connection Events Connection
type ConnectionEventEdge {
  cursor: String!
  node: ConnectionEvent!
}

type ConnectionEventsConnection {
  edges: [ConnectionEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Viewer Geographic Events Connection
type ViewerGeographicEdge {
  cursor: String!
  node: ViewerGeographic!
}

type ViewerGeographicsConnection {
  edges: [ViewerGeographicEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Viewer Time Series Connection
type ViewerCountBucketEdge {
  cursor: String!
  node: ViewerCountBucket!
}

type ViewerTimeSeriesConnection {
  edges: [ViewerCountBucketEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Rebuffering Events Connection
type RebufferingEventEdge {
  cursor: String!
  node: RebufferingEvent!
}

type RebufferingEventsConnection {
  edges: [RebufferingEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Stream Keys Connection
type StreamKeyEdge {
  cursor: String!
  node: StreamKey!
}

type StreamKeysConnection {
  edges: [StreamKeyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Individual viewer session (from viewer_sessions ClickHouse table)
type ViewerSession {
  id: ID!
  timestamp: Time!
  internalName: String!
  nodeId: String
  sessionId: String!
  connector: String                    # Protocol: HLS, WebRTC, RTMP
  countryCode: String
  city: String
  latitude: Float
  longitude: Float
  durationSeconds: Int
  bytesUp: Int
  bytesDown: Int
  connectionQuality: Float
  bufferHealth: Float
  clientBucket: GeoBucket
}

type ViewerSessionEdge {
  cursor: String!
  node: ViewerSession!
}

type ViewerSessionsConnection {
  edges: [ViewerSessionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Stream Health 5-Minute Aggregates (from stream_health_5m MV)
type StreamHealth5m {
  id: ID!
  timestamp: Time!
  nodeId: String
  rebufferCount: Int!
  issueCount: Int!
  sampleIssues: String
  avgBitrate: Int!
  avgFps: Float!
  bufferDryCount: Int!
  qualityTier: String
}

type StreamHealth5mEdge {
  cursor: String!
  node: StreamHealth5m!
}

type StreamHealth5mConnection {
  edges: [StreamHealth5mEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Node Performance 5-Minute Aggregates (from node_performance_5m MV)
type NodePerformance5m {
  id: ID!
  timestamp: Time!
  nodeId: String!
  avgCpu: Float!
  maxCpu: Float!
  avgMemory: Float!
  maxMemory: Float!
  totalBandwidth: Int!
  avgStreams: Int!
  maxStreams: Int!
}

type NodePerformance5mEdge {
  cursor: String!
  node: NodePerformance5m!
}

type NodePerformance5mConnection {
  edges: [NodePerformance5mEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Viewer Hours Hourly Aggregates (from viewer_hours_hourly MV)
type ViewerHoursHourly {
  id: ID!
  hour: Time!
  internalName: String
  countryCode: String
  uniqueViewers: Int!
  totalSessionSeconds: Int!
  totalBytes: Float!
  viewerHours: Float!
  egressGb: Float!
}

type ViewerHoursHourlyEdge {
  cursor: String!
  node: ViewerHoursHourly!
}

type ViewerHoursHourlyConnection {
  edges: [ViewerHoursHourlyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Viewer Geographic Hourly Aggregates (from viewer_geo_hourly MV)
type ViewerGeoHourly {
  id: ID!
  hour: Time!
  countryCode: String!
  viewerCount: Int!
  viewerHours: Float!
  egressGb: Float!
}

type ViewerGeoHourlyEdge {
  cursor: String!
  node: ViewerGeoHourly!
}

type ViewerGeoHourlyConnection {
  edges: [ViewerGeoHourlyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Tenant Daily Stats (from tenant_viewer_daily for PlatformOverview.dailyStats)
type TenantDailyStat {
  id: ID!
  date: Time!
  egressGb: Float!
  viewerHours: Float!
  uniqueViewers: Int!
  totalSessions: Int!
  totalViews: Int!
}

# Node Metrics Connection
type NodeMetricEdge {
  cursor: String!
  node: NodeMetric!
}

type NodeMetricsConnection {
  edges: [NodeMetricEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Node Metrics Hourly Connection
type NodeMetricHourlyEdge {
  cursor: String!
  node: NodeMetricHourly!
}

type NodeMetrics1hConnection {
  edges: [NodeMetricHourlyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Pre-Aggregated Analytics Types (Materialized Views)

# Hourly connection aggregates
type StreamConnectionHourly {
  id: ID!
  hour: Time!
  internalName: String!
  totalBytes: Float!
  uniqueViewers: Int!
  totalSessions: Int!
}

type StreamConnectionHourlyEdge {
  cursor: String!
  node: StreamConnectionHourly!
}

type StreamConnectionHourlyConnection {
  edges: [StreamConnectionHourlyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# 5-minute client metrics aggregates
type ClientMetrics5m {
  id: ID!
  timestamp: Time!
  internalName: String!
  nodeId: String!
  activeSessions: Int!
  avgBandwidthIn: Float!
  avgBandwidthOut: Float!
  avgConnectionTime: Float!
  packetLossRate: Float
}

type ClientMetrics5mEdge {
  cursor: String!
  node: ClientMetrics5m!
}

type ClientMetrics5mConnection {
  edges: [ClientMetrics5mEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Daily quality tier distribution
type QualityTierDaily {
  id: ID!
  day: Time!
  internalName: String!
  tier1080pMinutes: Int!
  tier720pMinutes: Int!
  tier480pMinutes: Int!
  tierSdMinutes: Int!
  primaryTier: String!
  codecH264Minutes: Int!
  codecH265Minutes: Int!
  avgBitrate: Int!
  avgFps: Float!
}

type QualityTierDailyEdge {
  cursor: String!
  node: QualityTierDaily!
}

type QualityTierDailyConnection {
  edges: [QualityTierDailyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Storage usage records
type StorageUsageRecord {
  id: ID!
  timestamp: Time!
  nodeId: String!
  totalBytes: Float!
  fileCount: Int!
  dvrBytes: Float!
  clipBytes: Float!
  vodBytes: Float!
  # Frozen storage breakdown (cold storage in S3)
  frozenDvrBytes: Float!
  frozenClipBytes: Float!
  frozenVodBytes: Float!
}

type StorageUsageEdge {
  cursor: String!
  node: StorageUsageRecord!
}

type StorageUsageConnection {
  edges: [StorageUsageEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Storage lifecycle events (freeze/defrost operations)
type StorageEvent {
  id: ID!
  timestamp: Time!
  internalName: String!
  assetHash: String!         # clip_hash or dvr_hash
  action: String!            # freeze_started, frozen, defrost_started, defrosted, freeze_failed, defrost_failed
  assetType: String!         # clip, dvr
  sizeBytes: Float!
  s3Url: String
  localPath: String
  nodeId: String!
  durationMs: Int            # Time taken for operation
  warmDurationMs: Int        # For evicted: how long asset was cached before eviction
  error: String
}

type StorageEventEdge {
  cursor: String!
  node: StorageEvent!
}

type StorageEventsConnection {
  edges: [StorageEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# ============================================================================
# Processing/Transcoding Usage (from process_billing table)
# ============================================================================

# Detailed transcoding record for analytics display
type ProcessingUsageRecord {
  id: ID!
  timestamp: Time!
  nodeId: String!
  streamName: String!
  processType: String!              # "Livepeer", "AV", "FFmpeg"
  trackType: String                 # "audio" or "video" (KEY FOR BILLING)
  durationMs: Int!                  # Segment duration or time since last event
  inputCodec: String
  outputCodec: String

  # Livepeer-specific fields
  segmentNumber: Int
  width: Int                        # Source width
  height: Int                       # Source height
  renditionCount: Int
  broadcasterUrl: String
  livepeerSessionId: String
  segmentStartMs: Int
  inputBytes: Float
  outputBytesTotal: Float
  attemptCount: Int
  turnaroundMs: Int                 # Full transcode roundtrip
  speedFactor: Float                # Real-time factor (1.0 = real-time)
  renditionsJson: String            # JSON array: [{name, bytes}, ...]

  # MistProcAV cumulative fields
  inputFrames: Int
  outputFrames: Int
  decodeUsPerFrame: Int
  transformUsPerFrame: Int
  encodeUsPerFrame: Int
  isFinal: Boolean                  # Session end flag

  # MistProcAV delta values (this reporting window)
  inputFramesDelta: Int
  outputFramesDelta: Int
  inputBytesDelta: Float
  outputBytesDelta: Float

  # MistProcAV dimensions
  inputWidth: Int
  inputHeight: Int
  outputWidth: Int
  outputHeight: Int

  # MistProcAV frame/audio info
  inputFpks: Int                    # Input frames per 1000s
  outputFpsMeasured: Float          # Measured output FPS
  sampleRate: Int                   # Audio sample rate
  channels: Int                     # Audio channels

  # MistProcAV timing
  sourceTimestampMs: Int
  sinkTimestampMs: Int
  sourceAdvancedMs: Int
  sinkAdvancedMs: Int

  # MistProcAV performance
  rtfIn: Float                      # Real-time factor input
  rtfOut: Float                     # Real-time factor output
  pipelineLagMs: Int                # Processing delay
  outputBitrateBps: Int             # Output bitrate
}

# Daily summary for billing display
type ProcessingUsageSummary {
  date: Time!
  # Livepeer (totals)
  livepeerSeconds: Float!           # Total Livepeer Gateway transcode seconds
  livepeerSegmentCount: Int!        # Number of segments transcoded via Livepeer
  livepeerUniqueStreams: Int!       # Unique streams using Livepeer
  # Livepeer per-codec breakdown
  livepeerH264Seconds: Float!
  livepeerVp9Seconds: Float!
  livepeerAv1Seconds: Float!
  livepeerHevcSeconds: Float!
  # Native AV (totals)
  nativeAvSeconds: Float!           # Total local audio/video transcode seconds
  nativeAvSegmentCount: Int!        # Number of segments processed locally
  nativeAvUniqueStreams: Int!       # Unique streams using local AV processing
  # Native AV per-codec breakdown
  nativeAvH264Seconds: Float!
  nativeAvVp9Seconds: Float!
  nativeAvAv1Seconds: Float!
  nativeAvHevcSeconds: Float!
  nativeAvAacSeconds: Float!        # Audio is FREE but tracked
  nativeAvOpusSeconds: Float!       # Audio is FREE but tracked
  # Track type aggregates
  audioSeconds: Float!              # Total audio transcode seconds (free)
  videoSeconds: Float!              # Total video transcode seconds (billable)
}

type ProcessingUsageEdge {
  cursor: String!
  node: ProcessingUsageRecord!
}

type ProcessingUsageConnection {
  edges: [ProcessingUsageEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
  summaries: [ProcessingUsageSummary!]!  # Daily summaries (always returned)
}

# Tenant Analytics Daily (daily tenant-level rollup)
type TenantAnalyticsDaily {
  id: ID!
  day: Time!
  totalStreams: Int!                 # Unique streams with activity
  totalViews: Int!                   # Total view events
  uniqueViewers: Int!                # Unique viewer count
  egressBytes: Int!                  # Total bytes delivered
}

type TenantAnalyticsDailyEdge {
  cursor: String!
  node: TenantAnalyticsDaily!
}

type TenantAnalyticsDailyConnection {
  edges: [TenantAnalyticsDailyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Stream Analytics Daily (daily stream-level rollup)
type StreamAnalyticsDaily {
  id: ID!
  day: Time!
  internalName: String!
  totalViews: Int!                   # Total view events
  uniqueViewers: Int!                # Unique viewer count
  uniqueCountries: Int!              # Geographic diversity
  uniqueCities: Int!                 # City-level diversity
  egressBytes: Int!                  # Total bytes delivered
}

type StreamAnalyticsDailyEdge {
  cursor: String!
  node: StreamAnalyticsDaily!
}

type StreamAnalyticsDailyConnection {
  edges: [StreamAnalyticsDailyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Track List Events Connection
type TrackListEventEdge {
  cursor: String!
  node: TrackListEvent!
}

type TrackListEventsConnection {
  edges: [TrackListEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Stream Health Metrics Connection
type StreamHealthMetricEdge {
  cursor: String!
  node: StreamHealthMetric!
}

type StreamHealthMetricsConnection {
  edges: [StreamHealthMetricEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Clip Events Connection
type ClipEventEdge {
  cursor: String!
  node: ClipEvent!
}

type ClipEventsConnection {
  edges: [ClipEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Stream Events Connection
type StreamEventEdge {
  cursor: String!
  node: StreamEvent!
}

type StreamEventsConnection {
  edges: [StreamEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Streams Connection (for paginated stream list)
type StreamEdge {
  cursor: String!
  node: Stream!
}

type StreamsConnection {
  edges: [StreamEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Clips Connection (for paginated clips list)
type ClipEdge {
  cursor: String!
  node: Clip!
}

type ClipsConnection {
  edges: [ClipEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Clusters Connection (for paginated clusters list)
type ClusterEdge {
  cursor: String!
  node: Cluster!
}

type ClustersConnection {
  edges: [ClusterEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Nodes Connection (for paginated nodes list)
type NodeEdge {
  cursor: String!
  node: Node!
}

type NodesConnection {
  edges: [NodeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Developer Tokens Connection (for paginated tokens list)
type DeveloperTokenEdge {
  cursor: String!
  node: DeveloperToken!
}

type DeveloperTokensConnection {
  edges: [DeveloperTokenEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Service Instances Connection (for paginated service instances list)
type ServiceInstanceEdge {
  cursor: String!
  node: ServiceInstance!
}

type ServiceInstancesConnection {
  edges: [ServiceInstanceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Cluster Access Connection (Tier 2)
type ClusterAccessEdge {
  cursor: String!
  node: ClusterAccess!
}

type ClusterAccessConnection {
  edges: [ClusterAccessEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Available Cluster Connection (Tier 2)
type AvailableClusterEdge {
  cursor: String!
  node: AvailableCluster!
}

type AvailableClusterConnection {
  edges: [AvailableClusterEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Marketplace Cluster Connection (Tier 2)
type MarketplaceClusterEdge {
  cursor: String!
  node: MarketplaceCluster!
}

type MarketplaceClusterConnection {
  edges: [MarketplaceClusterEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Cluster Subscription Connection (Tier 2)
type ClusterSubscriptionEdge {
  cursor: String!
  node: ClusterSubscription!
}

type ClusterSubscriptionConnection {
  edges: [ClusterSubscriptionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Cluster Invite Connection (Tier 2)
type ClusterInviteEdge {
  cursor: String!
  node: ClusterInvite!
}

type ClusterInviteConnection {
  edges: [ClusterInviteEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# My Subscriptions Connection (Tier 2)
type MySubscriptionEdge {
  cursor: String!
  node: Cluster!
}

type MySubscriptionsConnection {
  edges: [MySubscriptionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Bootstrap Token Connection (Tier 2)
type BootstrapTokenEdge {
  cursor: String!
  node: BootstrapToken!
}

type BootstrapTokenConnection {
  edges: [BootstrapTokenEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PlatformOverview {
  totalStreams: Int!
  totalViewers: Int!
  totalBandwidth: Float!
  streamHours: Float!        # Total streaming hours in time range (ingest hours)
  egressGb: Float!           # Total egress bandwidth in GB
  peakViewers: Int!          # Peak concurrent viewers (NOTE: currently unique_viewers, not true peak)
  timeRange: TimeRange!
  # Real-time bandwidth metrics (from live_streams)
  totalUploadBytes: Float!     # Total ingest bytes (sum across all streams)
  totalDownloadBytes: Float!   # Total egress bytes (sum across all streams)
  # Viewer consumption metrics (from tenant_viewer_daily)
  viewerHours: Float!        # Total accumulated viewer watch time in hours
  deliveredMinutes: Float!   # viewer_hours * 60 (convenience field)
  uniqueViewers: Int!        # Unique viewer count for the time range
  ingestHours: Float!        # Total hours streams were live (alias for streamHours)
  # True peak concurrent (from stream_events max(total_viewers))
  peakConcurrentViewers: Int! # Maximum concurrent viewers at any instant in time range
  # Total views (session starts from tenant_analytics_daily)
  totalViews: Int!           # Total number of view sessions started in time range
  # Daily breakdown for charts (from tenant_viewer_daily)
  dailyStats(days: Int = 7): [TenantDailyStat!]!
}

type BillingTier {
  id: ID!
  name: String!
  description: String
  basePrice: Float!
  currency: String!
  billingPeriod: String!
  features: BillingFeatures!
  bandwidthAllocation: AllocationDetails
  storageAllocation: AllocationDetails
  computeAllocation: AllocationDetails  # Compute resource allocation (from Purser proto)
  overageRates: OverageRates
  supportLevel: String
  slaLevel: String                      # SLA level for enterprise tiers (from Purser proto)
  meteringEnabled: Boolean!
  isEnterprise: Boolean!
}

# BillingFeatures - feature flags for billing tiers
# NOTE: Enforcement limits (max_streams, max_viewers, bandwidth caps) belong
# in tenant cluster assignments (quartermaster), not here. This is billing only.
type BillingFeatures {
  recording: Boolean!
  analytics: Boolean!
  customBranding: Boolean!
  apiAccess: Boolean!
  supportLevel: String!
  sla: Boolean!
}

type AllocationDetails {
  limit: Float
  unitPrice: Float
  unit: String
}

type OverageRates {
  bandwidth: AllocationDetails
  storage: AllocationDetails
  compute: AllocationDetails
}

type Invoice {
  id: ID!
  amount: Money!
  currency: Currency!
  status: InvoiceStatus!
  dueDate: Time!
  createdAt: Time!
  lineItems: [LineItem!]!
}

type LineItem {
  description: String!
  quantity: Int!
  unitPrice: Money!
  total: Money!
}

# Invoices Connection (for paginated invoices list)
type InvoiceEdge {
  cursor: String!
  node: Invoice!
}

type InvoicesConnection {
  edges: [InvoiceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Custom pricing override for enterprise tenants
type CustomPricing {
  basePrice: Float                # Custom base price (overrides tier)
  discountRate: Float             # Discount rate (0-1)
  overageRates: OverageRates      # Custom overage rates
}

# Tenant subscription with custom terms
type TenantSubscription {
  id: ID!
  tenantId: ID!
  tierId: String!
  status: String!
  billingEmail: String!
  startedAt: Time!
  trialEndsAt: Time
  nextBillingDate: Time
  cancelledAt: Time
  # Custom enterprise terms
  customPricing: CustomPricing
  customFeatures: BillingFeatures
  customAllocations: AllocationDetails
  # Payment
  paymentMethod: String
  createdAt: Time!
  updatedAt: Time!
}

# Bound to proto.BillingStatusResponse
type BillingStatus {
  currentTier: BillingTier
  subscription: TenantSubscription  # Full subscription details with custom terms
  billingStatus: String!
  nextBillingDate: Time
  trialEndsAt: Time               # Trial end date (from TenantSubscription.trial_ends_at)
  outstandingAmount: Float!
  currency: String!
  usageSummary: UsageSummary      # Current month usage aggregation
}

# Bound to proto.UsageSummary - rich usage metrics from Purser
type UsageSummary {
  clusterId: String
  period: String!                 # "15m", "1h", "1d"
  billingMonth: String!
  timestamp: Time

  # Core billing metrics
  streamHours: Float!
  egressGb: Float!
  recordingGb: Float!
  peakBandwidthMbps: Float!

  # Processing/transcoding usage (from Livepeer Gateway and local AV processing)
  livepeerSeconds: Float!           # Total Livepeer Gateway transcode seconds
  livepeerSegmentCount: Int!        # Number of segments transcoded via Livepeer
  livepeerUniqueStreams: Int!       # Unique streams using Livepeer
  nativeAvSeconds: Float!           # Total local audio/video transcode seconds
  nativeAvSegmentCount: Int!        # Number of segments processed locally
  nativeAvUniqueStreams: Int!       # Unique streams using local AV processing

  # Storage metrics
  storageGb: Float!
  averageStorageGb: Float!
  clipsAdded: Int!
  clipsDeleted: Int!
  clipStorageAddedGb: Float!
  clipStorageDeletedGb: Float!
  dvrAdded: Int!
  dvrDeleted: Int!
  dvrStorageAddedGb: Float!
  dvrStorageDeletedGb: Float!
  vodAdded: Int!
  vodDeleted: Int!
  vodStorageAddedGb: Float!
  vodStorageDeletedGb: Float!

  # Viewer metrics
  totalStreams: Int!
  totalViewers: Int!
  viewerHours: Float!
  peakViewers: Int!
  maxViewers: Int!
  uniqueUsers: Int!
  avgViewers: Float!

  # Geographic
  uniqueCountries: Int!
  uniqueCities: Int!
  geoBreakdown: [CountryMetrics!]!   # Rich geo breakdown with viewers, hours, percentage
}

# Rich country-level billing metrics (bound to purser.CountryMetrics)
type CountryMetrics {
  countryCode: String!
  viewerCount: Int!
  viewerHours: Float!
  percentage: Float!
  egressGb: Float!
}

# Bound to proto.TenantUsageResponse - date-range usage with costs
type TenantUsage {
  billingPeriod: String!
  usage: [UsageEntry!]!
  costs: [CostEntry!]!
  totalCost: Float!
  currency: String!
}

type UsageEntry {
  resourceType: String!
  amount: Float!
}

type CostEntry {
  resourceType: String!
  cost: Float!
}

type Payment {
  id: ID!
  amount: Money!
  currency: Currency!
  method: PaymentMethod!
  status: PaymentStatus!
  createdAt: Time!
}

# Bound to proto.UsageRecord - individual usage records
type UsageRecord {
  id: ID!
  clusterId: String
  clusterName: String
  usageType: String!
  usageValue: Float!
  billingMonth: String
  createdAt: Time
}

# Usage Records Connection (for paginated usage records list)
type UsageRecordEdge {
  cursor: String!
  node: UsageRecord!
}

type UsageRecordsConnection {
  edges: [UsageRecordEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Bound to proto.InfrastructureCluster
type Cluster {
  id: ID!
  clusterId: String!
  clusterName: String!
  clusterType: String!
  deploymentModel: String!
  baseUrl: String!
  databaseUrl: String
  periscopeUrl: String
  kafkaBrokers: [String!]
  maxConcurrentStreams: Int!
  maxConcurrentViewers: Int!
  maxBandwidthMbps: Int!
  currentStreamCount: Int!
  currentViewerCount: Int!
  currentBandwidthMbps: Int!
  healthStatus: String!
  isActive: Boolean!
  isDefaultCluster: Boolean!
  isSubscribed: Boolean!
  createdAt: Time
  updatedAt: Time

  # Marketplace fields
  ownerTenantId: ID
  visibility: ClusterVisibility!
  pricingModel: ClusterPricingModel!
  monthlyPriceCents: Int
  requiredBillingTier: String
  requiresApproval: Boolean!
  shortDescription: String
  longDescription: String
  isPlatformCluster: Boolean!

  # Edges (nullable - separate data fetches via resolvers)
  nodesConnection(first: Int = 50, after: String, last: Int, before: String): NodesConnection
}

# Marketplace cluster listing entry
type MarketplaceCluster {
  clusterId: String!
  clusterName: String!
  shortDescription: String
  visibility: ClusterVisibility!
  pricingModel: ClusterPricingModel!
  monthlyPriceCents: Int
  requiredBillingTier: String
  requiresApproval: Boolean!
  ownerName: String
  isPlatformCluster: Boolean!
  maxConcurrentStreams: Int!
  maxConcurrentViewers: Int!
  currentUtilization: Float
  isSubscribed: Boolean!
  subscriptionStatus: ClusterSubscriptionStatus
}

# Cluster subscription/access record
type ClusterSubscription {
  id: ID!
  tenantId: ID!
  clusterId: String!
  accessLevel: String!
  subscriptionStatus: ClusterSubscriptionStatus!
  resourceLimits: JSON
  requestedAt: Time
  approvedAt: Time
  approvedBy: ID
  rejectionReason: String
  expiresAt: Time
  createdAt: Time!
  updatedAt: Time!
  clusterName: String
  tenantName: String
}

# Cluster invite for tenant access
type ClusterInvite {
  id: ID!
  clusterId: String!
  invitedTenantId: ID!
  inviteToken: String
  accessLevel: String!
  resourceLimits: JSON
  status: String!
  createdBy: ID!
  createdAt: Time!
  expiresAt: Time
  acceptedAt: Time
  invitedTenantName: String
  clusterName: String
}

# Private cluster creation response
type CreatePrivateClusterResponse {
  cluster: Cluster!
  bootstrapToken: BootstrapToken!
}

# Bound to proto.InfrastructureNode
type Node {
  id: ID!
  nodeId: String!
  clusterId: String!
  nodeName: String!
  nodeType: String!
  internalIp: String
  externalIp: String
  wireguardIp: String
  wireguardPublicKey: String
  region: String
  availabilityZone: String
  latitude: Float
  longitude: Float
  cpuCores: Int
  memoryGb: Int
  diskGb: Int
  status: String!
  lastHeartbeat: Time
  tags: JSON
  metadata: JSON
  createdAt: Time
  updatedAt: Time
  metricsConnection(timeRange: TimeRangeInput, first: Int = 100, after: String): NodeMetricsConnection!
  metrics1hConnection(timeRange: TimeRangeInput, first: Int = 100, after: String): NodeMetrics1hConnection!
  # Real-time state from live_nodes (ReplacingMergeTree)
  liveState: LiveNode
}

# Bound to proto.ClipInfo
type Clip {
  id: ID!
  clipHash: String!
  streamName: String!
  title: String!
  description: String
  startTime: Int!           # Resolved start time (unix seconds)
  duration: Int!            # Resolved duration (seconds)
  nodeId: String
  storagePath: String
  sizeBytes: Float
  status: String!
  accessCount: Int
  createdAt: Time
  updatedAt: Time
  # Original request parameters for display/audit
  clipMode: String          # Mode used: ABSOLUTE, RELATIVE, DURATION, CLIP_NOW
  requestedParams: JSON     # Full original request params (startUnix, stopUnix, etc.)
  # Cold storage info
  storageLocation: String   # "local" or "s3"
  isFrozen: Boolean!
  expiresAt: Time
}

# Bound to proto.ClipViewingURLs - uses map for flexibility
type ClipViewingUrls {
  urls: JSON
  expiresAt: Time
}

# Bound to proto.APITokenInfo / proto.CreateAPITokenResponse
type DeveloperToken {
  id: ID!
  tokenName: String!
  tokenValue: String           # Only returned on creation, null otherwise
  permissions: [String!]!
  status: String!
  lastUsedAt: Time
  expiresAt: Time
  createdAt: Time
}

# Bound to proto.BootstrapToken
type BootstrapToken {
  id: ID!
  name: String!
  token: String          # Only returned on creation
  kind: String!          # was 'type' enum, now string matching proto
  clusterId: String
  expectedIp: String
  metadata: JSON
  usageLimit: Int
  usageCount: Int!
  expiresAt: Time
  usedAt: Time
  createdBy: String
  createdAt: Time!
}

# ============================================================================
# STREAM HEALTH & QUALITY TYPES
# ============================================================================

# Buffer state enumeration
enum BufferState {
  FULL
  EMPTY
  DRY
  RECOVER
}


# Stream health metrics from detailed monitoring
# Note: For packet stats, see client_metrics or live_streams tables
type StreamHealthMetric {
  timestamp: Time!
  stream: String!
  nodeId: String!

  # Health indicators (raw signals)
  issuesDescription: String
  hasIssues: Boolean!

  # Video quality
  bitrate: Int
  fps: Float
  width: Int
  height: Int
  codec: String
  qualityTier: String           # Rich quality string e.g. "1080p60 H264 @ 6Mbps"

  # Encoding parameters
  gopSize: Int                  # Group of Pictures size (frames between keyframes)

  # Buffer state
  bufferState: BufferState!
  bufferHealth: Float           # Ratio of buffer_size / max_keepaway (0.0-1.0)
  bufferSize: Int               # Buffer duration in milliseconds

  # Audio metrics
  audioChannels: Int
  audioSampleRate: Int
  audioCodec: String
  audioBitrate: Int

  # Raw track metadata
  trackMetadata: JSON
}

# Rebuffering events for UX analysis
type RebufferingEvent {
  timestamp: Time!
  stream: String!
  nodeId: String!

  # Rebuffer details
  bufferState: BufferState!
  previousState: BufferState!
  rebufferStart: Boolean!
  rebufferEnd: Boolean!
}

# ============================================================================
# GEOGRAPHIC ANALYTICS TYPES
# ============================================================================

# Geographic data for individual viewer/connection events
type ViewerGeographic {
  timestamp: Time!
  stream: String
  nodeId: String

  # Geographic location
  countryCode: String
  city: String
  latitude: Float
  longitude: Float

  # Event details
  viewerCount: Int
  connectionAddr: String
  eventType: String
  source: String

  # Session metrics (for disconnect events)
  sessionDurationSeconds: Int  # Duration in seconds
  bytesTransferred: Int        # Bytes transferred during session
  connector: String            # Protocol: HLS, DASH, WebRTC, etc.
}

# Aggregated geographic distribution analytics
type GeographicDistribution {
  timeRange: TimeRange!
  stream: String
  
  # Top countries and cities
  topCountries: [CountryMetric!]!
  topCities: [CityMetric!]!
  
  # Geographic spread metrics
  uniqueCountries: Int!
  uniqueCities: Int!
  totalViewers: Int!
  
  # Geographic viewer distribution over time
  viewersByCountry: [CountryTimeSeries!]!
}

# Country-level metrics
type CountryMetric {
  countryCode: String!
  viewerCount: Int!
  percentage: Float!
}

# City-level metrics  
type CityMetric {
  city: String!
  countryCode: String
  viewerCount: Int!
  percentage: Float!
  latitude: Float
  longitude: Float
}

# Time series data for countries
type CountryTimeSeries {
  timestamp: Time!
  countryCode: String!
  viewerCount: Int!
}

# ============================================================================
# CONNECTION AND ROUTING EVENT TYPES
# ============================================================================

# Routing event for load balancing decisions
type RoutingEvent {
  timestamp: Time!
  streamName: String!
  selectedNode: String!
  nodeId: String
  status: String!
  details: String
  score: Int

  # Client location info
  clientCountry: String
  clientLatitude: Float
  clientLongitude: Float
  clientBucket: GeoBucket

  # Node location info
  nodeLatitude: Float
  nodeLongitude: Float
  nodeName: String
  nodeBucket: GeoBucket

  # Distance metrics
  routingDistance: Float

  # Routing decision metadata
  candidatesCount: Int        # Number of candidate nodes evaluated
  latencyMs: Float            # Routing decision latency in milliseconds
  eventType: String
  source: String

  # Dual-tenant attribution (RFC: routing-events-dual-tenant-attribution)
  # streamTenantId = stream owner (customer) for filtering
  # clusterId = emitting cluster identifier
  streamTenantId: ID
  clusterId: String
}

# Connection event for viewer connections/disconnections
type ConnectionEvent {
  eventId: String!
  timestamp: Time!
  internalName: String!
  sessionId: String!
  connectionAddr: String       # Client IP - redacted for privacy (returns null)
  connector: String!
  nodeId: String!
  countryCode: String
  city: String
  latitude: Float
  longitude: Float
  clientBucket: GeoBucket
  nodeBucket: GeoBucket
  eventType: String! # "connect" or "disconnect"

  # Session metrics (for disconnect events)
  sessionDurationSeconds: Int  # Duration in seconds
  bytesTransferred: Int        # Bytes transferred during session
}

# Coarse geospatial bucket (H3)
type GeoBucket {
  h3Index: String!
  resolution: Int!
}

# ============================================================================
# CLIP LIFECYCLE ANALYTICS TYPES
# ============================================================================

type ClipEvent {
  timestamp: Time!
  internalName: String!
  requestId: String!
  stage: String!
  contentType: String
  startUnix: Int
  stopUnix: Int
  ingestNodeId: String
  percent: Int
  message: String
  filePath: String
  s3Url: String
  sizeBytes: Float
  expiresAt: Int
}

# Current state of clips/DVR from live_artifacts table
# Bound to proto.ArtifactState
type ArtifactState {
  requestId: ID!
  internalName: String!
  contentType: String!
  stage: String!
  progressPercent: Int!
  errorMessage: String
  requestedAt: Time!
  startedAt: Time
  completedAt: Time
  clipStartUnix: Int
  clipStopUnix: Int
  segmentCount: Int
  manifestPath: String
  filePath: String
  s3Url: String
  sizeBytes: Float
  processingNodeId: String
  expiresAt: Time
}

type ArtifactStateEdge {
  cursor: String!
  node: ArtifactState!
}

type ArtifactStatesConnection {
  edges: [ArtifactStateEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# ============================================================================
# NODE PERFORMANCE METRICS TYPES
# ============================================================================

# Node performance metrics from ClickHouse
type NodeMetric {
  timestamp: Time!
  nodeId: String!

  # Resource usage
  cpuUsage: Float!

  # Raw resource metrics (Bytes)
  memoryTotal: Float
  memoryUsed: Float
  diskTotal: Float
  diskUsed: Float
  shmTotal: Float
  shmUsed: Float

  # Network bandwidth (cumulative bytes)
  networkRx: Int!
  networkTx: Int!

  # Network throughput rates (bytes/sec) - use for real-time display
  upSpeed: Int
  downSpeed: Int

  # Current viewer connections (gauge)
  connectionsCurrent: Int

  # Status
  status: String!

  # Optional geo and metadata available from Periscope
  latitude: Float
  longitude: Float
  metadata: JSON
}

# Hourly aggregated node metrics
type NodeMetricHourly {
  timestamp: Time!
  nodeId: String!
  avgCpu: Float!
  peakCpu: Float!
  avgMemory: Float!
  peakMemory: Float!
  avgDisk: Float!
  peakDisk: Float!
  avgShm: Float!
  peakShm: Float!
  totalBandwidthIn: Int!
  totalBandwidthOut: Int!
  wasHealthy: Boolean!
}

# Real-time node state from live_nodes (ReplacingMergeTree - current state snapshot)
# Bound to proto.LiveNode
type LiveNode {
  nodeId: String!
  tenantId: ID!

  # Resources
  cpuPercent: Float!
  ramUsedBytes: Float!
  ramTotalBytes: Float!
  diskUsedBytes: Float!
  diskTotalBytes: Float!

  # Network throughput (bytes/sec)
  upSpeed: Float!
  downSpeed: Float!

  # Streams
  activeStreams: Int!

  # Health
  isHealthy: Boolean!

  # Location
  latitude: Float!
  longitude: Float!
  location: String!

  # Metadata
  metadata: JSON

  # Timing
  updatedAt: Time!
}

# ============================================================================
# INFRASTRUCTURE SERVICE MONITORING TYPES
# ============================================================================

# Service instance status and health
type ServiceInstance {
  id: ID!
  instanceId: String!
  clusterId: String!
  nodeId: String
  serviceId: String!
  
  # Instance details
  version: String
  port: Int
  processId: Int
  containerId: String
  
  # Status tracking
  status: InstanceStatus!
  healthStatus: NodeStatus!
  
  # Timestamps
  startedAt: Time
  stoppedAt: Time
  lastHealthCheck: Time
  
  # Resource usage
  cpuUsagePercent: Float
  memoryUsageMb: Int

  # Note: Use nodeId/clusterId directly - edges removed for efficiency
}

# Cluster access entry (Quartermaster)
type ClusterAccess {
  clusterId: String!
  clusterName: String!
  accessLevel: String!
  resourceLimits: JSON
}

# Available cluster entry (Quartermaster)
type AvailableCluster {
  clusterId: String!
  clusterName: String!
  tiers: [String!]!
  autoEnroll: Boolean!
}

# Service instance health (Quartermaster)
type ServiceInstanceHealth {
  instanceId: String!
  serviceId: String!
  clusterId: String!
  protocol: String!
  host: String
  port: Int!
  healthEndpoint: String
  status: String!
  lastHealthCheck: Time
}

# ============================================================================
# STREAM MANAGEMENT TYPES
# ============================================================================

# Stream key management
type StreamKey {
  id: ID!
  streamId: ID!
  keyValue: String!
  keyName: String
  isActive: Boolean!
  lastUsedAt: Time
  createdAt: Time!
}

# ============================================================================
# INGEST ENDPOINT RESOLUTION TYPES
# ============================================================================

# Response from Foghorn's ingest endpoint resolution for StreamCrafter
type IngestEndpointResponse {
  primary: IngestEndpoint!
  fallbacks: [IngestEndpoint!]!
  metadata: IngestMetadata
}

# Individual ingest endpoint with node and protocol info
type IngestEndpoint {
  nodeId: String!
  baseUrl: String!
  whipUrl: String          # WHIP ingest URL
  rtmpUrl: String          # RTMP ingest URL
  srtUrl: String           # SRT ingest URL
  region: String
  loadScore: Float
}

# Ingest metadata for the stream
type IngestMetadata {
  streamId: String!
  streamKey: String!
  tenantId: String!
  recordingEnabled: Boolean!
}

# ============================================================================
# VIEWER ENDPOINT RESOLUTION TYPES
# ============================================================================

# Response from Foghorn's viewer endpoint resolution (matches proto ViewerEndpointResponse)
type ViewerEndpointResponse {
  primary: ViewerEndpoint
  fallbacks: [ViewerEndpoint!]!
  metadata: PlaybackMetadata
}

# Individual viewer endpoint with node and protocol info (matches proto ViewerEndpoint)
type ViewerEndpoint {
  nodeId: String!
  baseUrl: String!
  protocol: String!        # "webrtc", "hls", "dash", etc from MistServer outputs
  url: String!             # Complete URL with stream name substituted
  geoDistance: Float       # Distance from viewer in km
  loadScore: Float         # Load balancer score
  outputs: JSON            # MistServer outputs configuration (map<string, OutputEndpoint> in proto)
}

# Playback metadata for any content type (matches proto PlaybackMetadata)
type PlaybackMetadata {
  status: String!
  isLive: Boolean!
  viewers: Int!
  bufferState: String
  tracks: [PlaybackTrack!]
  protocolHints: [String!]
  instances: [PlaybackInstance!]
  dvrStatus: String
  dvrSourceUri: String
  contentId: String!
  contentType: String!
  title: String
  description: String
  durationSeconds: Int
  recordingSizeBytes: Float
  clipSource: String
  createdAt: Time
}

# Track information for playback (matches proto PlaybackTrack)
type PlaybackTrack {
  type: String!
  codec: String!
  bitrateKbps: Int!
  width: Int!
  height: Int!
  channels: Int!
  sampleRate: Int!
}

# Per-node stream instance stats (matches proto PlaybackInstance)
# Shows which nodes are serving a stream and their load/stats
type PlaybackInstance {
  nodeId: String!
  viewers: Int!
  bufferState: String
  bytesUp: Float
  bytesDown: Float
  totalConnections: Int
  inputs: Int
  lastUpdate: Time
}

# ============================================================================
# STREAM META TYPES
# ============================================================================

# Stream metadata response (matches proto StreamMetaResponse)
type StreamMetaResponse {
  metaSummary: MetaSummary!
  raw: JSON                    # bytes in proto - raw JSON from MistServer
}

# Stream meta summary (matches proto MetaSummary)
type MetaSummary {
  isLive: Boolean!
  bufferWindowMs: Int!         # int64 in proto
  jitterMs: Int!               # int64 in proto
  unixOffsetMs: Int!           # int64 in proto
  nowMs: Int                   # optional int64 in proto
  lastMs: Int                  # optional int64 in proto
  width: Int                   # optional int32 in proto
  height: Int                  # optional int32 in proto
  version: Int                 # optional int32 in proto
  type: String!
  tracks: [TrackSummary!]
}

# Track summary (matches proto TrackSummary)
type TrackSummary {
  id: String!
  type: String!
  codec: String!
  channels: Int                # optional int32 in proto
  rate: Int                    # optional int32 in proto
  width: Int                   # optional int32 in proto
  height: Int                  # optional int32 in proto
  bitrateBps: Int              # optional int32 in proto
  nowMs: Int                   # optional int64 in proto
  lastMs: Int                  # optional int64 in proto
  firstMs: Int                 # optional int64 in proto
}
