# FrameWorks Bridge GraphQL Schema
# Unified API for all FrameWorks services

# Root Query type
# Note: List and object fields are nullable per GraphQL best practices.
# This enables graceful degradation - if one service is down, other fields still work.
# Connection types remain non-null as they always return a valid structure (empty edges if no data).
type Query {

  # Streams (from Commodore)
  streams: [Stream!]
  streamsConnection(first: Int = 50, after: String, last: Int, before: String): StreamsConnection!
  stream(id: ID!): Stream
  validateStreamKey(streamKey: String!): StreamValidation

  # Analytics (from Periscope Query)
  streamAnalytics(stream: String!, timeRange: TimeRangeInput): StreamAnalytics
  platformOverview(timeRange: TimeRangeInput): PlatformOverview

  # Time-series viewer counts (aggregated from ClickHouse, for charts)
  # interval: "5m", "15m", "1h", or "1d"
  viewerCountTimeSeries(stream: String, timeRange: TimeRangeInput, interval: String = "5m"): [ViewerCountBucket!]!

  # Geographic Analytics
  viewerGeographics(stream: String, timeRange: TimeRangeInput): [ViewerGeographic!]
  geographicDistribution(stream: String, timeRange: TimeRangeInput, topN: Int = 10): GeographicDistribution
  loadBalancingMetrics(timeRange: TimeRangeInput, pagination: PaginationInput, sortOrder: SortOrder): [LoadBalancingMetric!]

  # Connection and Routing Analytics (Relay-style pagination)
  routingEventsConnection(stream: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): RoutingEventsConnection!
  connectionEventsConnection(stream: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): ConnectionEventsConnection!
  clipEventsConnection(internalName: String, stage: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): ClipEventsConnection!

  # Artifact State (current status of clips/DVR from live_artifacts)
  artifactState(requestId: ID!): ArtifactState
  artifactStatesConnection(internalName: String, contentType: String, stage: String, first: Int = 100, after: String, last: Int, before: String): ArtifactStatesConnection!

  # Node Performance Metrics (Relay-style pagination)
  nodeMetricsConnection(nodeId: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): NodeMetricsConnection!
  nodeMetrics1hConnection(timeRange: TimeRangeInput, nodeId: String, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): NodeMetrics1hConnection!

  # Pre-Aggregated Analytics (Materialized Views)
  streamConnectionHourlyConnection(stream: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): StreamConnectionHourlyConnection!
  clientMetrics5mConnection(stream: String, nodeId: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): ClientMetrics5mConnection!
  qualityTierDailyConnection(stream: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): QualityTierDailyConnection!
  storageUsageConnection(nodeId: String, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): StorageUsageConnection!

  # Infrastructure Service Monitoring
  serviceInstances(clusterId: String, nodeId: String, status: InstanceStatus, pagination: PaginationInput): [ServiceInstance!]
  serviceInstancesConnection(clusterId: String, nodeId: String, status: InstanceStatus, first: Int = 50, after: String, last: Int, before: String): ServiceInstancesConnection!

  # Stream Management
  streamKeys(streamId: ID!): [StreamKey!]
  recordings(streamId: ID): [Recording!]
  recordingsConnection(streamId: ID, first: Int = 50, after: String, last: Int, before: String): RecordingsConnection!
  clips(streamId: ID): [Clip!]
  clipsConnection(streamId: ID, first: Int = 50, after: String, last: Int, before: String): ClipsConnection!
  clip(id: ID!): Clip
  clipViewingUrls(clipId: ID!): ClipViewingUrls

  # Health and quality queries (Relay-style pagination)
  streamHealthMetricsConnection(stream: String!, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): StreamHealthMetricsConnection!
  trackListEventsConnection(stream: String!, timeRange: TimeRangeInput, first: Int = 100, after: String, last: Int, before: String, noCache: Boolean = false): TrackListEventsConnection!
  currentStreamHealth(stream: String!): StreamHealthMetric
  rebufferingEvents(stream: String!, timeRange: TimeRangeInput): [RebufferingEvent!]

  # Billing (from Purser)
  billingTiers: [BillingTier!]
  invoices: [Invoice!]
  invoice(id: ID!): Invoice
  billingStatus: BillingStatus
  tenantUsage(timeRange: TimeRangeInput): TenantUsage
  usageRecords(timeRange: TimeRangeInput): [UsageRecord!]

  # Tenants & Infrastructure (from Quartermaster)
  tenant: Tenant
  clusters(pagination: PaginationInput): [Cluster!]
  clustersConnection(first: Int = 50, after: String, last: Int, before: String): ClustersConnection!
  cluster(id: ID!): Cluster
  nodes(clusterId: String, status: NodeStatus, type: String, tag: String, pagination: PaginationInput): [Node!]
  nodesConnection(clusterId: String, status: NodeStatus, type: String, first: Int = 50, after: String, last: Int, before: String): NodesConnection!
  node(id: ID!): Node

  # Service discovery and access (Quartermaster)
  discoverServices(type: String!, clusterId: String, pagination: PaginationInput): [ServiceInstance!]
  clustersAccess(pagination: PaginationInput): [ClusterAccess!]
  clustersAvailable(pagination: PaginationInput): [AvailableCluster!]
  mySubscriptions(pagination: PaginationInput): [Cluster!]!
  serviceInstancesHealth(serviceId: String): [ServiceInstanceHealth!]

  # Developer API (from Commodore)
  developerTokens: [DeveloperToken!]
  developerTokensConnection(first: Int = 50, after: String, last: Int, before: String): DeveloperTokensConnection!

  # Bootstrap token management (admin/provider only via Quartermaster)
  bootstrapTokens: [BootstrapToken!]

  # DVR recording requests (cursor-paginated)
  dvrRecordingsConnection(internalName: String, first: Int, after: String, last: Int, before: String): DVRRecordingsConnection

  # Viewer endpoint resolution (via Foghorn)
  resolveViewerEndpoint(contentType: String!, contentId: String!): ViewerEndpointResponse
  # Mist JSON meta (via Commodore -> Foghorn)
  streamMeta(streamKey: String!, targetBaseUrl: String, targetNodeId: String, includeRaw: Boolean): StreamMetaResponse
}

# Root Mutation type
type Mutation {
  # Stream operations (via Commodore)
  createStream(input: CreateStreamInput!): CreateStreamResult!
  updateStream(id: ID!, input: UpdateStreamInput!): UpdateStreamResult!
  deleteStream(id: ID!): DeleteStreamResult!
  refreshStreamKey(id: ID!): UpdateStreamResult!

  # Clip operations (via Commodore)
  createClip(input: CreateClipInput!): CreateClipResult!
  deleteClip(id: ID!): DeleteClipResult!

  # DVR operations (via Commodore)
  startDVR(internalName: String!, streamId: ID): StartDVRResult!
  stopDVR(dvrHash: ID!): StopDVRResult!

  # Billing operations (via Purser)
  createPayment(input: CreatePaymentInput!): CreatePaymentResult!

  # Infrastructure operations (via Quartermaster)
  updateTenant(input: UpdateTenantInput!): UpdateTenantResult!
  subscribeToCluster(clusterId: ID!): Boolean!
  unsubscribeFromCluster(clusterId: ID!): Boolean!

  # Developer API operations (via Commodore)
  createDeveloperToken(input: CreateDeveloperTokenInput!): CreateDeveloperTokenResult!
  revokeDeveloperToken(id: ID!): RevokeDeveloperTokenResult!

  # Bootstrap token operations (admin/provider only via Quartermaster)
  createBootstrapToken(input: CreateBootstrapTokenInput!): CreateBootstrapTokenResult!
  revokeBootstrapToken(id: ID!): RevokeBootstrapTokenResult!

  # Stream key operations (via Commodore)
  createStreamKey(streamId: ID!, input: CreateStreamKeyInput!): CreateStreamKeyResult!
  deleteStreamKey(streamId: ID!, keyId: ID!): DeleteStreamKeyResult!
}

# Error interface and types for mutation results
# Per GraphQL best practices: mutations should return union types with explicit error states

interface Error {
  message: String!
  code: String
}

type ValidationError implements Error {
  message: String!
  code: String
  field: String
  constraint: String
}

type AuthError implements Error {
  message: String!
  code: String
}

type NotFoundError implements Error {
  message: String!
  code: String
  resourceType: String!
  resourceId: ID!
}

type RateLimitError implements Error {
  message: String!
  code: String
  retryAfter: Int
}

type DeleteSuccess {
  success: Boolean!
  deletedId: ID!
}

# Mutation Result union types
union CreateStreamResult = Stream | ValidationError | AuthError
union UpdateStreamResult = Stream | ValidationError | NotFoundError | AuthError
union DeleteStreamResult = DeleteSuccess | NotFoundError | AuthError

union CreateClipResult = Clip | ValidationError | NotFoundError | AuthError
union DeleteClipResult = DeleteSuccess | NotFoundError | AuthError

union CreateStreamKeyResult = StreamKey | ValidationError | NotFoundError | AuthError
union DeleteStreamKeyResult = DeleteSuccess | NotFoundError | AuthError

union StartDVRResult = DVRRequest | ValidationError | NotFoundError | AuthError
union StopDVRResult = DeleteSuccess | NotFoundError | AuthError

union CreatePaymentResult = Payment | ValidationError | AuthError
union UpdateTenantResult = Tenant | ValidationError | AuthError

union CreateDeveloperTokenResult = DeveloperToken | ValidationError | RateLimitError | AuthError
union RevokeDeveloperTokenResult = DeleteSuccess | NotFoundError | AuthError

union CreateBootstrapTokenResult = BootstrapToken | ValidationError | AuthError
union RevokeBootstrapTokenResult = DeleteSuccess | NotFoundError | AuthError

# Root Subscription type for real-time updates
type Subscription {
  # Stream lifecycle events
  streamEvents(stream: String): StreamEvent!

  # Viewer metrics updates
  viewerMetrics(stream: String!): ViewerMetrics!

  # Track list updates (real-time from Signalman)
  trackListUpdates(stream: String!): TrackListUpdate!

  # Clip lifecycle updates (real-time from Signalman)
  clipLifecycle(stream: String!): ClipLifecycle!
  dvrLifecycle(stream: String!): DVREvent!

  # System health (admin only)
  systemHealth: SystemHealthEvent!

  # Firehose: All tenant events (streams, analytics, system) in a single subscription
  # Useful for dashboards that need to display all events in real-time
  firehose: TenantEvent!
}

# Union type for all possible tenant events in firehose
type TenantEvent {
  type: String!
  channel: String!  # STREAMS, ANALYTICS, or SYSTEM
  timestamp: Time!

  # One of these will be populated based on event type
  streamEvent: StreamEvent
  viewerMetrics: ViewerMetrics
  trackListUpdate: TrackListUpdate  # Real-time track updates from Signalman
  clipLifecycle: ClipLifecycle      # Real-time clip lifecycle from Signalman
  dvrEvent: DVREvent
  systemHealthEvent: SystemHealthEvent
}

# DVR lifecycle event - bound to proto.DVRLifecycleData
type DVREvent {
  status: String!
  dvrHash: String!
  requestId: String
  manifestPath: String
  startedAt: Int
  endedAt: Int
  sizeBytes: Int
  segmentCount: Int
  error: String
  nodeId: String
  internalName: String
}

# Real-time track list update from Signalman - bound to proto.StreamTrackListTrigger
type TrackListUpdate {
  streamName: String!
  tracks: [StreamTrack!]
  totalTracks: Int
  videoTrackCount: Int
  audioTrackCount: Int
  qualityTier: String
  primaryWidth: Int
  primaryHeight: Int
  primaryFps: Float
  primaryVideoBitrate: Int
  primaryVideoCodec: String
  primaryAudioBitrate: Int
  primaryAudioCodec: String
  primaryAudioChannels: Int
  primaryAudioSampleRate: Int
}

# Real-time clip lifecycle event from Signalman - bound to proto.ClipLifecycleData
type ClipLifecycle {
  stage: Int!
  clipHash: String!
  requestId: String
  progressPercent: Int
  filePath: String
  s3Url: String
  sizeBytes: Int
  error: String
  startedAt: Int
  completedAt: Int
  nodeId: String
  internalName: String
  # Timing info for progress display (enriched by Foghorn)
  startUnix: Int
  stopUnix: Int
  durationSec: Int
  clipMode: String
}

# Input types

input CreateStreamInput {
  name: String!
  description: String
  record: Boolean = false
}

input UpdateStreamInput {
  name: String
  description: String
  record: Boolean
}

# Clip creation mode - determines how time fields are interpreted
enum ClipCreationMode {
  ABSOLUTE     # start_unix + stop_unix (Unix timestamps)
  RELATIVE     # start (media time) + stop (media time from stream start)
  DURATION     # start + duration
  CLIP_NOW     # duration only (relative to live - clips last N seconds from now)
}

input CreateClipInput {
  stream: String!
  title: String!
  description: String

  # Mode selection (default: ABSOLUTE for backward compatibility)
  mode: ClipCreationMode

  # ABSOLUTE mode: Unix timestamps in seconds
  startUnix: Int
  stopUnix: Int

  # RELATIVE mode: Media time in seconds from stream start
  startMedia: Int
  stopMedia: Int

  # DURATION / CLIP_NOW: Duration in seconds
  duration: Int

  # Legacy fields (deprecated, map to startUnix/stopUnix)
  startTime: Int @deprecated(reason: "Use startUnix instead")
  endTime: Int @deprecated(reason: "Use stopUnix instead")
}

# DVR types
type DVRRequest {
  dvrHash: ID!
  internalName: String!
  storageNodeId: String
  status: String!
  startedAt: Time
  endedAt: Time
  durationSeconds: Int
  sizeBytes: Int
  manifestPath: String
  errorMessage: String
  createdAt: Time!
  updatedAt: Time!
}

# DVR Recordings Connection (cursor-paginated)
type DVRRecordingsConnection {
  edges: [DVRRecordingEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DVRRecordingEdge {
  cursor: String!
  node: DVRRequest!
}

input CreatePaymentInput {
  invoiceId: ID!
  amount: Money!
  currency: Currency
  method: PaymentMethod!
  returnUrl: String
}

input UpdateTenantInput {
  name: String
  settings: JSON
}

input CreateDeveloperTokenInput {
  name: String!
  permissions: String
  expiresIn: Int
}

input CreateBootstrapTokenInput {
  name: String!
  type: BootstrapTokenType!
  expiresIn: Int    # Days until expiration
  usageLimit: Int   # Max uses allowed
}

input CreateStreamKeyInput {
  name: String!
}

input TimeRangeInput {
  start: Time!
  end: Time!
}

input PaginationInput {
  limit: Int
  offset: Int
}

enum SortOrder {
  ASC
  DESC
}

type TimeRange {
  start: Time!
  end: Time!
}

# Enums
enum PaymentMethod {
  CARD
  CRYPTO
  BANK_TRANSFER
}

# Added payment status enum
enum PaymentStatus {
  PENDING
  CONFIRMED
  FAILED
}

# Added invoice status enum
enum InvoiceStatus {
  PENDING
  PAID
  FAILED
  CANCELLED
}

# Service instance lifecycle status
enum InstanceStatus {
  RUNNING
  STARTING
  STOPPING
  STOPPED
  ERROR
  UNKNOWN
}

enum StreamStatus {
  OFFLINE
  LIVE
  RECORDING
  ENDED
}

enum NodeStatus {
  HEALTHY
  DEGRADED
  UNHEALTHY
}

enum BootstrapTokenType {
  EDGE_NODE
  SERVICE
}

# Real-time event types
type StreamEvent {
  type: StreamEventType!
  stream: String!
  status: StreamStatus!
  timestamp: Time!
  details: JSON
}

enum StreamEventType {
  STREAM_START
  STREAM_END
  STREAM_ERROR
  BUFFER_UPDATE
  TRACK_LIST_UPDATE
}

# ViewerMetrics maps to proto ClientLifecycleUpdate
# These are per-client connection metrics, not aggregated viewer counts
type ViewerMetrics {
  nodeId: String!
  internalName: String!
  action: String!              # "connect" or "disconnect"
  protocol: String!
  host: String!
  sessionId: String
  connectionTime: Float        # seconds connected
  position: Float              # playback position
  bandwidthInBps: Int          # upload bandwidth (bits/sec)
  bandwidthOutBps: Int         # download bandwidth (bits/sec)
  bytesDownloaded: Int
  bytesUploaded: Int
  packetsSent: Int
  packetsLost: Int
  packetsRetransmitted: Int
  timestamp: Int!
  # GeoIP enriched fields (added by Foghorn)
  clientIp: String
  clientCountry: String
  clientCity: String
  clientLatitude: Float
  clientLongitude: Float
}

type TrackListEvent {
  stream: String!
  nodeId: String
  trackList: String!
  trackCount: Int!
  timestamp: Time!
  tracks: [StreamTrack!]
}

type StreamTrack {
  trackName: String!
  trackType: String!
  codec: String
  bitrateKbps: Int
  bitrateBps: Int
  buffer: Int
  jitter: Int
  width: Int
  height: Int
  fps: Float
  resolution: String
  hasBFrames: Boolean
  channels: Int
  sampleRate: Int
}

type SystemHealthEvent {
  node: String!
  location: String!           # Region/city name (e.g. "NYC")
  status: NodeStatus!
  cpuTenths: Int!             # CPU usage 0-1000 (divide by 10 for %)
  isHealthy: Boolean!

  # Raw resource metrics (Bytes)
  ramMax: Float               # Max RAM in MiB
  ramCurrent: Float           # Current RAM usage in MiB
  diskTotalBytes: Float
  diskUsedBytes: Float
  shmTotalBytes: Float
  shmUsedBytes: Float

  timestamp: Time!
}

# Custom scalars
scalar Time
scalar JSON
scalar Currency
scalar Money

# Core types (some will map to pkg/models types)
type User {
  id: ID!
  email: String!
  name: String
  role: String!
  createdAt: Time!
}


type Tenant {
  id: ID!
  name: String!
  cluster: String
  createdAt: Time!
}

type Stream {
  # === CONFIG FIELDS (from Commodore Control Plane) ===
  id: ID!
  name: String!
  description: String
  streamKey: String!
  playbackId: String!
  record: Boolean!
  createdAt: Time!
  updatedAt: Time!

  # === EDGES ===
  # Operational metrics (from Periscope Data Plane) - lazy loaded
  metrics: StreamMetrics

  # Config edges
  recordings: [Recording!]

  # Analytics edges (Data Plane)
  eventsConnection(timeRange: TimeRangeInput, first: Int = 100, after: String): StreamEventsConnection
  healthConnection(timeRange: TimeRangeInput, first: Int = 100, after: String): StreamHealthMetricsConnection
}

# Operational metrics from Periscope Data Plane
# Resolved lazily via StreamMetrics loader
type StreamMetrics {
  status: StreamStatus!
  isLive: Boolean!
  currentViewers: Int!
  peakViewers: Int!
  totalViews: Int!
  startedAt: Time
  endedAt: Time
  duration: Int!
  lastEventAt: Time
  lastEventType: String

  # Quality metrics (from live_streams table)
  bufferState: String
  qualityTier: String
  primaryWidth: Int
  primaryHeight: Int
  primaryFps: Float
  primaryCodec: String
  primaryBitrate: Int
  hasIssues: Boolean
  issuesDescription: String
}

# Validation status enum - avoids ambiguous null booleans per Yelp guidelines
enum ValidationStatus {
  VALID
  INVALID
  ERROR
}

type StreamValidation {
  status: ValidationStatus!
  streamKey: String!
  error: String
}

type StreamAnalytics {
  # Core identifiers
  id: ID!
  streamId: ID
  internalName: String!

  # Session timing
  sessionStartTime: Time
  sessionEndTime: Time
  totalSessionDuration: Int!

  # Viewer metrics
  currentViewers: Int!
  peakViewers: Int!
  totalConnections: Int!
  totalViews: Int!        # Total view count (session starts)
  uniqueViewers: Int!     # Unique viewer count (distinct sessions/IPs)
  
  # Bandwidth metrics
  bandwidthIn: Float!
  bandwidthOut: Float!
  totalBandwidthGb: Float!
  upbytes: Float!
  downbytes: Float!
  
  # Stream quality
  bitrateKbps: Int
  resolution: String
  
  # Network performance
  packetsSent: Float!
  packetsLost: Float!
  packetsRetrans: Float!
  firstMs: Int
  lastMs: Int
  
  # Stream details
  trackCount: Int!
  inputs: Int!
  outputs: Int!
  
  # Location
  nodeId: String
  nodeName: String
  latitude: Float
  longitude: Float
  location: String
  
  # Status
  status: String
  lastUpdated: Time!
  createdAt: Time!
  
  # Current health state (from STREAM_BUFFER events)
  currentBufferState: String
  currentIssues: String
  currentCodec: String
  currentFps: Float
  currentResolution: String
  mistStatus: String
  qualityTier: String
  
  # Enriched analytics from ClickHouse (computed)
  avgViewers: Float
  uniqueCountries: Int
  uniqueCities: Int
  avgBufferHealth: Float
  avgBitrate: Int
  packetLossRate: Float
  avgConnectionQuality: Float
}

# Time-bucketed viewer count for charts (from ClickHouse aggregation)
type ViewerCountBucket {
  timestamp: Time!
  viewerCount: Int!
  stream: String      # Optional stream identifier when querying across streams
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

# Routing Events Connection
type RoutingEventEdge {
  cursor: String!
  node: RoutingEvent!
}

type RoutingEventsConnection {
  edges: [RoutingEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Connection Events Connection
type ConnectionEventEdge {
  cursor: String!
  node: ConnectionEvent!
}

type ConnectionEventsConnection {
  edges: [ConnectionEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Node Metrics Connection
type NodeMetricEdge {
  cursor: String!
  node: NodeMetric!
}

type NodeMetricsConnection {
  edges: [NodeMetricEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Node Metrics Hourly Connection
type NodeMetricHourlyEdge {
  cursor: String!
  node: NodeMetricHourly!
}

type NodeMetrics1hConnection {
  edges: [NodeMetricHourlyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Pre-Aggregated Analytics Types (Materialized Views)

# Hourly connection aggregates
type StreamConnectionHourly {
  id: ID!
  hour: Time!
  internalName: String!
  totalBytes: Int!
  uniqueViewers: Int!
  totalSessions: Int!
}

type StreamConnectionHourlyEdge {
  cursor: String!
  node: StreamConnectionHourly!
}

type StreamConnectionHourlyConnection {
  edges: [StreamConnectionHourlyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# 5-minute client metrics aggregates
type ClientMetrics5m {
  id: ID!
  timestamp: Time!
  internalName: String!
  nodeId: String!
  activeSessions: Int!
  avgBandwidthIn: Float!
  avgBandwidthOut: Float!
  avgConnectionTime: Float!
  packetLossRate: Float
  avgConnectionQuality: Float
}

type ClientMetrics5mEdge {
  cursor: String!
  node: ClientMetrics5m!
}

type ClientMetrics5mConnection {
  edges: [ClientMetrics5mEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Daily quality tier distribution
type QualityTierDaily {
  id: ID!
  day: Time!
  internalName: String!
  tier1080pMinutes: Int!
  tier720pMinutes: Int!
  tier480pMinutes: Int!
  tierSdMinutes: Int!
  primaryTier: String!
  codecH264Minutes: Int!
  codecH265Minutes: Int!
  avgBitrate: Int!
  avgFps: Float!
}

type QualityTierDailyEdge {
  cursor: String!
  node: QualityTierDaily!
}

type QualityTierDailyConnection {
  edges: [QualityTierDailyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Storage usage records
type StorageUsageRecord {
  id: ID!
  timestamp: Time!
  nodeId: String!
  totalBytes: Int!
  fileCount: Int!
  dvrBytes: Int!
  clipBytes: Int!
  recordingBytes: Int!
}

type StorageUsageEdge {
  cursor: String!
  node: StorageUsageRecord!
}

type StorageUsageConnection {
  edges: [StorageUsageEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Track List Events Connection
type TrackListEventEdge {
  cursor: String!
  node: TrackListEvent!
}

type TrackListEventsConnection {
  edges: [TrackListEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Stream Health Metrics Connection
type StreamHealthMetricEdge {
  cursor: String!
  node: StreamHealthMetric!
}

type StreamHealthMetricsConnection {
  edges: [StreamHealthMetricEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Clip Events Connection
type ClipEventEdge {
  cursor: String!
  node: ClipEvent!
}

type ClipEventsConnection {
  edges: [ClipEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Stream Events Connection
type StreamEventEdge {
  cursor: String!
  node: StreamEvent!
}

type StreamEventsConnection {
  edges: [StreamEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Streams Connection (for paginated stream list)
type StreamEdge {
  cursor: String!
  node: Stream!
}

type StreamsConnection {
  edges: [StreamEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Recordings Connection (for paginated recordings list)
type RecordingEdge {
  cursor: String!
  node: Recording!
}

type RecordingsConnection {
  edges: [RecordingEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Clips Connection (for paginated clips list)
type ClipEdge {
  cursor: String!
  node: Clip!
}

type ClipsConnection {
  edges: [ClipEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Clusters Connection (for paginated clusters list)
type ClusterEdge {
  cursor: String!
  node: Cluster!
}

type ClustersConnection {
  edges: [ClusterEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Nodes Connection (for paginated nodes list)
type NodeEdge {
  cursor: String!
  node: Node!
}

type NodesConnection {
  edges: [NodeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Developer Tokens Connection (for paginated tokens list)
type DeveloperTokenEdge {
  cursor: String!
  node: DeveloperToken!
}

type DeveloperTokensConnection {
  edges: [DeveloperTokenEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Service Instances Connection (for paginated service instances list)
type ServiceInstanceEdge {
  cursor: String!
  node: ServiceInstance!
}

type ServiceInstancesConnection {
  edges: [ServiceInstanceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PlatformOverview {
  totalStreams: Int!
  totalViewers: Int!
  totalBandwidth: Float!
  totalUsers: Int!
  streamHours: Float!        # Total streaming hours in time range (ingest hours)
  egressGb: Float!           # Total egress bandwidth in GB
  peakViewers: Int!          # Peak concurrent viewers (NOTE: currently unique_viewers, not true peak)
  timeRange: TimeRange!
  # Real-time bandwidth metrics (from live_streams)
  totalUploadBytes: Int!     # Total ingest bytes (sum across all streams)
  totalDownloadBytes: Int!   # Total egress bytes (sum across all streams)
  # Viewer consumption metrics (from tenant_viewer_daily)
  viewerHours: Float!        # Total accumulated viewer watch time in hours
  deliveredMinutes: Float!   # viewer_hours * 60 (convenience field)
  uniqueViewers: Int!        # Unique viewer count for the time range
  ingestHours: Float!        # Total hours streams were live (alias for streamHours)
  # True peak concurrent (from stream_events max(total_viewers))
  peakConcurrentViewers: Int! # Maximum concurrent viewers at any instant in time range
  # Total views (session starts from tenant_analytics_daily)
  totalViews: Int!           # Total number of view sessions started in time range
}

type BillingTier {
  id: ID!
  name: String!
  description: String
  basePrice: Float!
  currency: String!
  billingPeriod: String!
  features: BillingFeatures!
  bandwidthAllocation: AllocationDetails
  storageAllocation: AllocationDetails
  computeAllocation: AllocationDetails  # Compute resource allocation (from Purser proto)
  overageRates: OverageRates
  supportLevel: String
  slaLevel: String                      # SLA level for enterprise tiers (from Purser proto)
  meteringEnabled: Boolean!
  isEnterprise: Boolean!
}

# BillingFeatures - feature flags for billing tiers
# NOTE: Enforcement limits (max_streams, max_viewers, bandwidth caps) belong
# in tenant cluster assignments (quartermaster), not here. This is billing only.
type BillingFeatures {
  recording: Boolean!
  analytics: Boolean!
  customBranding: Boolean!
  apiAccess: Boolean!
  supportLevel: String!
  sla: Boolean!
}

type AllocationDetails {
  limit: Float
  unitPrice: Float
  unit: String
}

type OverageRates {
  bandwidth: AllocationDetails
  storage: AllocationDetails
  compute: AllocationDetails
}

type Invoice {
  id: ID!
  amount: Money!
  currency: Currency!
  status: InvoiceStatus!
  dueDate: Time!
  createdAt: Time!
  lineItems: [LineItem!]!
}

type LineItem {
  description: String!
  quantity: Int!
  unitPrice: Money!
  total: Money!
}

# Bound to proto.BillingStatusResponse
type BillingStatus {
  currentTier: BillingTier
  billingStatus: String!
  nextBillingDate: Time
  trialEndsAt: Time               # Trial end date (from TenantSubscription.trial_ends_at)
  outstandingAmount: Float!
  currency: String!
  usageSummary: UsageSummary      # Current month usage aggregation
}

# Bound to proto.UsageSummary - rich usage metrics from Purser
type UsageSummary {
  clusterId: String
  period: String!                 # "15m", "1h", "1d"
  billingMonth: String!
  timestamp: Time

  # Core billing metrics
  streamHours: Float!
  egressGb: Float!
  recordingGb: Float!
  peakBandwidthMbps: Float!
  transcodingMinutes: Float!      # Placeholder - returns 0 until Livepeer metering enabled

  # Storage metrics
  storageGb: Float!
  averageStorageGb: Float!
  clipsAdded: Int!
  clipsDeleted: Int!
  clipStorageAddedGb: Float!
  clipStorageDeletedGb: Float!

  # Viewer metrics
  totalStreams: Int!
  totalViewers: Int!
  viewerHours: Float!
  peakViewers: Int!
  maxViewers: Int!
  uniqueUsers: Int!
  avgViewers: Float!

  # Geographic
  uniqueCountries: Int!
  uniqueCities: Int!
  geoBreakdown: [CountryMetrics!]!   # Rich geo breakdown with viewers, hours, percentage

  # Quality metrics
  avgBufferHealth: Float!
  avgBitrate: Int!
  packetLossRate: Float!
}

# Rich country-level billing metrics (bound to purser.CountryMetrics)
type CountryMetrics {
  countryCode: String!
  viewerCount: Int!
  viewerHours: Float!
  percentage: Float!
  egressGb: Float!
}

# Bound to proto.TenantUsageResponse - date-range usage with costs
type TenantUsage {
  billingPeriod: String!
  usage: [UsageEntry!]!
  costs: [CostEntry!]!
  totalCost: Float!
  currency: String!
}

type UsageEntry {
  resourceType: String!
  amount: Float!
}

type CostEntry {
  resourceType: String!
  cost: Float!
}

type Payment {
  id: ID!
  amount: Money!
  currency: Currency!
  method: PaymentMethod!
  status: PaymentStatus!
  createdAt: Time!
}

# Bound to proto.UsageRecord - individual usage records
type UsageRecord {
  id: ID!
  clusterId: String
  clusterName: String
  usageType: String!
  usageValue: Float!
  billingMonth: String
  createdAt: Time
}

# Bound to proto.InfrastructureCluster
type Cluster {
  id: ID!
  clusterId: String!
  clusterName: String!
  clusterType: String!
  deploymentModel: String!
  baseUrl: String!
  databaseUrl: String
  periscopeUrl: String
  kafkaBrokers: [String!]
  maxConcurrentStreams: Int!
  maxConcurrentViewers: Int!
  maxBandwidthMbps: Int!
  currentStreamCount: Int!
  currentViewerCount: Int!
  currentBandwidthMbps: Int!
  healthStatus: String!
  isActive: Boolean!
  isDefaultCluster: Boolean!
  isSubscribed: Boolean!
  createdAt: Time
  updatedAt: Time

  # Edges (nullable - separate data fetches via resolvers)
  nodes: [Node!]
}

# Bound to proto.InfrastructureNode
type Node {
  id: ID!
  nodeId: String!
  clusterId: String!
  nodeName: String!
  nodeType: String!
  internalIp: String
  externalIp: String
  wireguardIp: String
  wireguardPublicKey: String
  region: String
  availabilityZone: String
  latitude: Float
  longitude: Float
  cpuCores: Int
  memoryGb: Int
  diskGb: Int
  status: String!
  lastHeartbeat: Time
  tags: JSON
  metadata: JSON
  createdAt: Time
  updatedAt: Time
  metricsConnection(timeRange: TimeRangeInput, first: Int = 100, after: String): NodeMetricsConnection!
  metrics1hConnection(timeRange: TimeRangeInput, first: Int = 100, after: String): NodeMetrics1hConnection!
}

# Bound to proto.ClipInfo
type Clip {
  id: ID!
  clipHash: String!
  streamName: String!
  title: String!
  description: String
  startTime: Int!           # Resolved start time (unix seconds)
  duration: Int!            # Resolved duration (seconds)
  nodeId: String
  storagePath: String
  sizeBytes: Int
  status: String!
  accessCount: Int
  createdAt: Time
  updatedAt: Time
  # Original request parameters for display/audit
  clipMode: String          # Mode used: ABSOLUTE, RELATIVE, DURATION, CLIP_NOW
  requestedParams: JSON     # Full original request params (startUnix, stopUnix, etc.)
}

# Bound to proto.ClipViewingURLs - uses map for flexibility
type ClipViewingUrls {
  urls: JSON
  expiresAt: Time
}

# Bound to proto.APITokenInfo / proto.CreateAPITokenResponse
type DeveloperToken {
  id: ID!
  tokenName: String!
  tokenValue: String           # Only returned on creation, null otherwise
  permissions: [String!]!
  status: String!
  lastUsedAt: Time
  expiresAt: Time
  createdAt: Time
}

# Bound to proto.BootstrapToken
type BootstrapToken {
  id: ID!
  name: String!
  token: String          # Only returned on creation
  kind: String!          # was 'type' enum, now string matching proto
  clusterId: String
  expectedIp: String
  metadata: JSON
  usageLimit: Int
  usageCount: Int!
  expiresAt: Time
  usedAt: Time
  createdBy: String
  createdAt: Time!
}

# ============================================================================
# STREAM HEALTH & QUALITY TYPES
# ============================================================================

# Buffer state enumeration
enum BufferState {
  FULL
  EMPTY
  DRY
  RECOVER
}


# Stream health metrics from detailed monitoring
type StreamHealthMetric {
  timestamp: Time!
  stream: String!
  nodeId: String!

  # Health indicators (raw signals)
  issuesDescription: String
  hasIssues: Boolean!

  # Video quality
  bitrate: Int
  fps: Float
  width: Int
  height: Int
  codec: String
  profile: String               # Encoding profile (from Periscope proto)
  qualityTier: String

  # Encoding parameters (from Periscope proto)
  gopSize: Int                  # Group of Pictures size

  # Network performance
  packetsSent: Int
  packetsLost: Int
  packetLossPercentage: Float

  # Buffer state
  bufferState: BufferState!
  bufferHealth: Float
  bufferSize: Int               # Total buffer size
  bufferUsed: Int               # Current buffer usage

  # Audio metrics
  audioChannels: Int
  audioSampleRate: Int
  audioCodec: String
  audioBitrate: Int

  # Raw track metadata
  trackMetadata: JSON
}

# Rebuffering events for UX analysis
type RebufferingEvent {
  timestamp: Time!
  stream: String!
  nodeId: String!

  # Rebuffer details
  bufferState: BufferState!
  previousState: BufferState!
  rebufferStart: Boolean!
  rebufferEnd: Boolean!

  # Performance at rebuffer time
  packetLossPercentage: Float
}

# ============================================================================
# GEOGRAPHIC ANALYTICS TYPES
# ============================================================================

# Geographic data for individual viewer/connection events
type ViewerGeographic {
  timestamp: Time!
  stream: String
  nodeId: String

  # Geographic location
  countryCode: String
  city: String
  latitude: Float
  longitude: Float

  # Event details
  viewerCount: Int
  connectionAddr: String
  eventType: String
  source: String

  # Session metrics (for disconnect events)
  sessionDurationSeconds: Int  # Duration in seconds
  bytesTransferred: Int        # Bytes transferred during session
  connector: String            # Protocol: HLS, DASH, WebRTC, etc.
}

# Aggregated geographic distribution analytics
type GeographicDistribution {
  timeRange: TimeRange!
  stream: String
  
  # Top countries and cities
  topCountries: [CountryMetric!]!
  topCities: [CityMetric!]!
  
  # Geographic spread metrics
  uniqueCountries: Int!
  uniqueCities: Int!
  totalViewers: Int!
  
  # Geographic viewer distribution over time
  viewersByCountry: [CountryTimeSeries!]!
}

# Country-level metrics
type CountryMetric {
  countryCode: String!
  viewerCount: Int!
  percentage: Float!
}

# City-level metrics  
type CityMetric {
  city: String!
  countryCode: String
  viewerCount: Int!
  percentage: Float!
  latitude: Float
  longitude: Float
}

# Time series data for countries
type CountryTimeSeries {
  timestamp: Time!
  countryCode: String!
  viewerCount: Int!
}

# Load balancing and routing metrics with geographic context
type LoadBalancingMetric {
  timestamp: Time!
  stream: String!

  # Node and routing info
  selectedNode: String!
  nodeId: String

  # Client geographic data
  clientCountry: String
  clientLatitude: Float
  clientLongitude: Float
  clientBucket: GeoBucket

  # Node geographic data
  nodeLatitude: Float
  nodeLongitude: Float
  nodeName: String
  nodeBucket: GeoBucket

  # Performance metrics
  score: Int
  status: String!
  details: String

  # Geographic routing efficiency
  routingDistance: Float  # Distance between client and selected node

  # Event context
  eventType: String
  source: String

  # Routing decision metadata (from Periscope proto)
  candidatesCount: Int        # Number of candidate nodes evaluated
  latencyMs: Float            # Routing decision latency in milliseconds
}

# ============================================================================
# CONNECTION AND ROUTING EVENT TYPES
# ============================================================================

# Routing event for load balancing decisions
type RoutingEvent {
  timestamp: Time!
  streamName: String!
  selectedNode: String!
  status: String!
  details: String
  score: Int
  
  # Client location info
  clientCountry: String
  clientLatitude: Float
  clientLongitude: Float
  clientBucket: GeoBucket
  
  # Node location info
  nodeLatitude: Float
  nodeLongitude: Float
  nodeName: String
  nodeBucket: GeoBucket
  
  # Distance metrics
  routingDistance: Float
}

# Connection event for viewer connections/disconnections
type ConnectionEvent {
  eventId: String!
  timestamp: Time!
  internalName: String!
  sessionId: String!
  connectionAddr: String!
  connector: String!
  nodeId: String!
  countryCode: String
  city: String
  latitude: Float
  longitude: Float
  clientBucket: GeoBucket
  nodeBucket: GeoBucket
  eventType: String! # "connect" or "disconnect"

  # Session metrics (for disconnect events)
  sessionDurationSeconds: Int  # Duration in seconds
  bytesTransferred: Int        # Bytes transferred during session
}

# Coarse geospatial bucket (H3)
type GeoBucket {
  h3Index: String!
  resolution: Int!
}

# ============================================================================
# CLIP LIFECYCLE ANALYTICS TYPES
# ============================================================================

type ClipEvent {
  timestamp: Time!
  internalName: String!
  requestId: String!
  stage: String!
  contentType: String
  startUnix: Int
  stopUnix: Int
  ingestNodeId: String
  percent: Int
  message: String
  filePath: String
  s3Url: String
  sizeBytes: Int
}

# Current state of clips/DVR from live_artifacts table
# Bound to proto.ArtifactState
type ArtifactState {
  requestId: ID!
  internalName: String!
  contentType: String!
  stage: String!
  progressPercent: Int!
  errorMessage: String
  requestedAt: Time!
  startedAt: Time
  completedAt: Time
  clipStartUnix: Int
  clipStopUnix: Int
  segmentCount: Int
  manifestPath: String
  filePath: String
  s3Url: String
  sizeBytes: Int
  processingNodeId: String
}

type ArtifactStateEdge {
  cursor: String!
  node: ArtifactState!
}

type ArtifactStatesConnection {
  edges: [ArtifactStateEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# ============================================================================
# NODE PERFORMANCE METRICS TYPES
# ============================================================================

# Node performance metrics from ClickHouse
type NodeMetric {
  timestamp: Time!
  nodeId: String!

  # Resource usage
  cpuUsage: Float!

  # Raw resource metrics (Bytes)
  memoryTotal: Float
  memoryUsed: Float
  diskTotal: Float
  diskUsed: Float
  shmTotal: Float
  shmUsed: Float

  # Network bandwidth (cumulative bytes)
  networkRx: Int!
  networkTx: Int!

  # Network throughput rates (bytes/sec) - use for real-time display
  upSpeed: Int
  downSpeed: Int

  # Current viewer connections (gauge)
  connectionsCurrent: Int

  # Status
  status: String!

  # Optional geo and metadata available from Periscope
  latitude: Float
  longitude: Float
  metadata: JSON
}

# Hourly aggregated node metrics
type NodeMetricHourly {
  timestamp: Time!
  nodeId: String!
  avgCpu: Float!
  peakCpu: Float!
  avgMemory: Float!
  peakMemory: Float!
  avgDisk: Float!
  peakDisk: Float!
  avgShm: Float!
  peakShm: Float!
  totalBandwidthIn: Int!
  totalBandwidthOut: Int!
  wasHealthy: Boolean!
}

# ============================================================================
# INFRASTRUCTURE SERVICE MONITORING TYPES
# ============================================================================

# Service instance status and health
type ServiceInstance {
  id: ID!
  instanceId: String!
  clusterId: String!
  nodeId: String
  serviceId: String!
  
  # Instance details
  version: String
  port: Int
  processId: Int
  containerId: String
  
  # Status tracking
  status: InstanceStatus!
  healthStatus: NodeStatus!
  
  # Timestamps
  startedAt: Time
  stoppedAt: Time
  lastHealthCheck: Time
  
  # Resource usage
  cpuUsagePercent: Float
  memoryUsageMb: Int

  # Edges
  node: Node
  cluster: Cluster
}

# Cluster access entry (Quartermaster)
type ClusterAccess {
  clusterId: String!
  clusterName: String!
  accessLevel: String!
  resourceLimits: JSON
}

# Available cluster entry (Quartermaster)
type AvailableCluster {
  clusterId: String!
  clusterName: String!
  tiers: [String!]!
  autoEnroll: Boolean!
}

# Service instance health (Quartermaster)
type ServiceInstanceHealth {
  instanceId: String!
  serviceId: String!
  clusterId: String!
  protocol: String!
  host: String
  port: Int!
  healthEndpoint: String
  status: String!
  lastHealthCheck: Time
}

# ============================================================================
# STREAM MANAGEMENT TYPES
# ============================================================================

# Stream key management
type StreamKey {
  id: ID!
  streamId: ID!
  keyValue: String!
  keyName: String
  isActive: Boolean!
  lastUsedAt: Time
  createdAt: Time!
}

# Recording management
type Recording {
  id: ID!
  streamId: ID!
  
  # Recording metadata
  title: String
  duration: Int
  fileSizeBytes: Int
  playbackId: String
  thumbnailUrl: String
  startTime: Time
  endTime: Time
  
  # Processing status
  status: String!
  
  createdAt: Time!
  updatedAt: Time!
}

# ============================================================================
# VIEWER ENDPOINT RESOLUTION TYPES
# ============================================================================

# Response from Foghorn's viewer endpoint resolution (matches proto ViewerEndpointResponse)
type ViewerEndpointResponse {
  primary: ViewerEndpoint
  fallbacks: [ViewerEndpoint!]!
  metadata: PlaybackMetadata
}

# Individual viewer endpoint with node and protocol info (matches proto ViewerEndpoint)
type ViewerEndpoint {
  nodeId: String!
  baseUrl: String!
  protocol: String!        # "webrtc", "hls", "dash", etc from MistServer outputs
  url: String!             # Complete URL with stream name substituted
  geoDistance: Float       # Distance from viewer in km
  loadScore: Float         # Load balancer score
  outputs: JSON            # MistServer outputs configuration (map<string, OutputEndpoint> in proto)
}

# Playback metadata for any content type (matches proto PlaybackMetadata)
type PlaybackMetadata {
  status: String!
  isLive: Boolean!
  viewers: Int!
  bufferState: String
  tracks: [PlaybackTrack!]
  protocolHints: [String!]
  instances: [PlaybackInstance!]
  dvrStatus: String
  dvrSourceUri: String
  contentId: String!
  contentType: String!
  title: String
  description: String
  durationSeconds: Int
  recordingSizeBytes: Int
  clipSource: String
  createdAt: Time
}

# Track information for playback (matches proto PlaybackTrack)
type PlaybackTrack {
  type: String!
  codec: String!
  bitrateKbps: Int!
  width: Int!
  height: Int!
  channels: Int!
  sampleRate: Int!
}

# Per-node stream instance stats (matches proto PlaybackInstance)
# Shows which nodes are serving a stream and their load/stats
type PlaybackInstance {
  nodeId: String!
  viewers: Int!
  bufferState: String
  bytesUp: Int
  bytesDown: Int
  totalConnections: Int
  inputs: Int
  lastUpdate: Time
}

# ============================================================================
# STREAM META TYPES
# ============================================================================

# Stream metadata response (matches proto StreamMetaResponse)
type StreamMetaResponse {
  metaSummary: MetaSummary!
  raw: JSON                    # bytes in proto - raw JSON from MistServer
}

# Stream meta summary (matches proto MetaSummary)
type MetaSummary {
  isLive: Boolean!
  bufferWindowMs: Int!         # int64 in proto
  jitterMs: Int!               # int64 in proto
  unixOffsetMs: Int!           # int64 in proto
  nowMs: Int                   # optional int64 in proto
  lastMs: Int                  # optional int64 in proto
  width: Int                   # optional int32 in proto
  height: Int                  # optional int32 in proto
  version: Int                 # optional int32 in proto
  type: String!
  tracks: [TrackSummary!]
}

# Track summary (matches proto TrackSummary)
type TrackSummary {
  id: String!
  type: String!
  codec: String!
  channels: Int                # optional int32 in proto
  rate: Int                    # optional int32 in proto
  width: Int                   # optional int32 in proto
  height: Int                  # optional int32 in proto
  bitrateBps: Int              # optional int32 in proto
  nowMs: Int                   # optional int64 in proto
  lastMs: Int                  # optional int64 in proto
  firstMs: Int                 # optional int64 in proto
}
