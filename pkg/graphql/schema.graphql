# FrameWorks Bridge GraphQL Schema
# Unified API for all FrameWorks services

# Root Query type
type Query {

  # Streams (from Commodore)
  streams: [Stream!]!
  stream(id: ID!): Stream
  validateStreamKey(streamKey: String!): StreamValidation!
  streamEmbed(id: ID!): StreamEmbed!

  # Analytics (from Periscope Query)
  streamAnalytics(stream: String!, timeRange: TimeRangeInput): StreamAnalytics
  viewerMetrics(stream: String, timeRange: TimeRangeInput): [ViewerMetric!]!
  platformOverview(timeRange: TimeRangeInput): PlatformOverview!
  
  # New health and quality queries
  streamHealthMetrics(stream: String!, timeRange: TimeRangeInput): [StreamHealthMetric!]!
  streamQualityChanges(stream: String!, timeRange: TimeRangeInput): [StreamQualityChange!]!
  streamHealthAlerts(stream: String, timeRange: TimeRangeInput): [StreamHealthAlert!]!
  currentStreamHealth(stream: String!): StreamHealthMetric
  rebufferingEvents(stream: String!, timeRange: TimeRangeInput): [RebufferingEvent!]!
  
  # Billing (from Purser)  
  billingTiers: [BillingTier!]!
  invoices: [Invoice!]!
  invoice(id: ID!): Invoice
  billingStatus: BillingStatus!
  usageRecords(timeRange: TimeRangeInput): [UsageRecord!]!

  # Tenants & Infrastructure (from Quartermaster)
  tenant: Tenant
  clusters: [Cluster!]!
  cluster(id: ID!): Cluster
  nodes: [Node!]!
  node(id: ID!): Node

  # Developer API (from Commodore)
  developerTokens: [DeveloperToken!]!
}

# Root Mutation type
type Mutation {
  # Stream operations (via Commodore)
  createStream(input: CreateStreamInput!): Stream!
  updateStream(id: ID!, input: UpdateStreamInput!): Stream!
  deleteStream(id: ID!): Boolean!
  refreshStreamKey(id: ID!): Stream!

  # Clip operations (via Commodore)
  createClip(input: CreateClipInput!): Clip!

  # Billing operations (via Purser)
  createPayment(input: CreatePaymentInput!): Payment!
  updateBillingTier(tierId: ID!): BillingStatus!

  # Infrastructure operations (via Quartermaster)
  updateTenant(input: UpdateTenantInput!): Tenant!

  # Developer API operations (via Commodore)
  createDeveloperToken(input: CreateDeveloperTokenInput!): DeveloperToken!
  revokeDeveloperToken(id: ID!): Boolean!
}

# Root Subscription type for real-time updates
type Subscription {
  # Stream lifecycle events
  streamEvents(stream: String): StreamEvent!
  
  # Viewer metrics updates  
  viewerMetrics(stream: String!): ViewerMetrics!
  
  # Track list updates
  trackListUpdates(stream: String!): TrackListEvent!
  
  # System health (admin only)
  systemHealth: SystemHealthEvent!
  
  # All events for authenticated user
  userEvents: TenantEvent!
}

# Input types

input CreateStreamInput {
  name: String!
  description: String
  record: Boolean = false
}

input UpdateStreamInput {
  name: String
  description: String
  record: Boolean
}

input CreateClipInput {
  stream: String!
  startTime: Int!
  endTime: Int!
  title: String!
  description: String
}

input CreatePaymentInput {
  amount: Float!
  currency: String = "USD"
  method: PaymentMethod!
}

input UpdateTenantInput {
  name: String
  settings: JSON
}

input CreateDeveloperTokenInput {
  name: String!
  permissions: String
  expiresIn: Int
}

input TimeRangeInput {
  start: Time!
  end: Time!
}

type TimeRange {
  start: Time!
  end: Time!
}

# Enums
enum PaymentMethod {
  CARD
  CRYPTO
  BANK_TRANSFER
}

enum StreamStatus {
  OFFLINE
  LIVE
  RECORDING
  ENDED
}

enum NodeStatus {
  HEALTHY
  DEGRADED
  UNHEALTHY
}

# Real-time event types
type StreamEvent {
  type: StreamEventType!
  stream: String!
  status: StreamStatus!
  timestamp: Time!
  details: String
}

enum StreamEventType {
  STREAM_START
  STREAM_END
  STREAM_ERROR
  BUFFER_UPDATE
  TRACK_LIST_UPDATE
}

type ViewerMetrics {
  stream: String!
  currentViewers: Int!
  peakViewers: Int!
  bandwidth: Float!
  connectionQuality: Float
  bufferHealth: Float
  timestamp: Time!
}

type TrackListEvent {
  stream: String!
  trackList: String!
  trackCount: Int!
  timestamp: Time!
}

type SystemHealthEvent {
  node: String!
  cluster: String!
  status: NodeStatus!
  cpuUsage: Float!
  memoryUsage: Float!
  diskUsage: Float!
  healthScore: Float!
  timestamp: Time!
}

union TenantEvent = StreamEvent | ViewerMetrics | TrackListEvent

# Custom scalars
scalar Time
scalar JSON

# Core types (some will map to pkg/models types)
type User {
  id: ID!
  email: String!
  name: String
  role: String!
  createdAt: Time!
}


type Tenant {
  id: ID!
  name: String!
  settings: JSON
  cluster: String
  createdAt: Time!
}

type Stream {
  id: ID!
  name: String!
  description: String
  streamKey: String!
  playbackId: String!
  status: StreamStatus!
  record: Boolean!
  createdAt: Time!
  updatedAt: Time!
}

type StreamValidation {
  valid: Boolean!
  streamKey: String!
  error: String
}

type StreamEmbed {
  stream: String!
  embedCode: String!
  iframeUrl: String!
  width: Int!
  height: Int!
}

type StreamAnalytics {
  stream: String!
  totalViews: Int!
  totalViewTime: Float!
  peakViewers: Int!
  averageViewers: Float!
  uniqueViewers: Int!
  timeRange: TimeRange!
  
  # New health metrics
  currentHealthScore: Float
  averageHealthScore: Float
  frameJitterMs: Float
  keyframeStabilityMs: Float
  currentIssues: String
  bufferState: BufferState
  packetLossPercentage: Float
  qualityTier: String
  currentCodec: String
  currentResolution: String
  currentBitrate: Int
  currentFps: Float
  rebufferCount: Int
  alertCount: Int
}

type ViewerMetric {
  timestamp: Time!
  viewerCount: Int!
}

type PlatformOverview {
  totalStreams: Int!
  totalViewers: Int!
  totalBandwidth: Float!
  totalUsers: Int!
  timeRange: TimeRange!
}

type BillingTier {
  id: ID!
  name: String!
  description: String
  price: Float!
  currency: String!
  features: [String!]!
}

type Invoice {
  id: ID!
  amount: Float!
  currency: String!
  status: String!
  dueDate: Time!
  createdAt: Time!
  lineItems: [LineItem!]!
}

type LineItem {
  description: String!
  quantity: Int!
  unitPrice: Float!
  total: Float!
}

type BillingStatus {
  currentTier: BillingTier!
  nextBillingDate: Time!
  outstandingAmount: Float!
  status: String!
}

type Payment {
  id: ID!
  amount: Float!
  currency: String!
  method: PaymentMethod!
  status: String!
  createdAt: Time!
}

type UsageRecord {
  id: ID!
  resourceType: String!
  quantity: Float!
  unit: String!
  cost: Float!
  timestamp: Time!
}

type Cluster {
  id: ID!
  name: String!
  region: String!
  status: NodeStatus!
  nodes: [Node!]!
  createdAt: Time!
}

type Node {
  id: ID!
  name: String!
  cluster: String!
  type: String!
  status: NodeStatus!
  region: String!
  ipAddress: String
  lastSeen: Time!
  createdAt: Time!
}

type Clip {
  id: ID!
  stream: String!
  title: String!
  description: String
  startTime: Int!
  endTime: Int!
  duration: Int!
  playbackId: String!
  status: String!
  createdAt: Time!
  updatedAt: Time!
}

type DeveloperToken {
  id: ID!
  name: String!
  token: String
  permissions: String!
  status: String!
  lastUsedAt: Time
  expiresAt: Time
  createdAt: Time!
}

# ============================================================================
# STREAM HEALTH & QUALITY TYPES
# ============================================================================

# Buffer state enumeration
enum BufferState {
  FULL
  EMPTY
  DRY
  RECOVER
}

# Quality change types
enum QualityChangeType {
  CODEC_CHANGE
  RESOLUTION_CHANGE
  BITRATE_CHANGE
  TRACK_ADDED
  TRACK_REMOVED
  TRACK_UPDATE
}

# Alert severity levels
enum AlertSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

# Alert types
enum AlertType {
  HIGH_JITTER
  KEYFRAME_INSTABILITY
  PACKET_LOSS
  REBUFFERING
  QUALITY_DEGRADATION
}

# Stream health metrics from detailed monitoring
type StreamHealthMetric {
  timestamp: Time!
  stream: String!
  nodeId: String!
  
  # Health scores and indicators
  healthScore: Float!
  frameJitterMs: Float
  keyframeStabilityMs: Float
  issuesDescription: String
  hasIssues: Boolean!
  
  # Video quality
  bitrate: Int
  fps: Float
  width: Int
  height: Int
  codec: String
  qualityTier: String
  
  # Network performance
  packetsSent: Int
  packetsLost: Int
  packetLossPercentage: Float
  
  # Buffer state
  bufferState: BufferState!
  bufferHealth: Float
  
  # Audio metrics
  audioChannels: Int
  audioSampleRate: Int
  audioCodec: String
  audioBitrate: Int
}

# Stream quality changes tracking
type StreamQualityChange {
  timestamp: Time!
  stream: String!
  nodeId: String!
  changeType: QualityChangeType!
  
  # Change details
  previousQualityTier: String
  newQualityTier: String
  previousResolution: String
  newResolution: String
  previousCodec: String
  newCodec: String
  
  # Track data
  previousTracks: String  # JSON
  newTracks: String       # JSON
}

# Stream health alerts for issues
type StreamHealthAlert {
  timestamp: Time!
  stream: String!
  nodeId: String!
  alertType: AlertType!
  severity: AlertSeverity!
  
  # Alert details
  healthScore: Float
  frameJitterMs: Float
  packetLossPercentage: Float
  issuesDescription: String
  
  # Context
  bufferState: BufferState
  qualityTier: String
}

# Rebuffering events for UX analysis
type RebufferingEvent {
  timestamp: Time!
  stream: String!
  nodeId: String!
  
  # Rebuffer details
  bufferState: BufferState!
  previousState: BufferState!
  rebufferStart: Boolean!
  rebufferEnd: Boolean!
  healthScore: Float
  
  # Performance at rebuffer time
  frameJitterMs: Float
  packetLossPercentage: Float
}