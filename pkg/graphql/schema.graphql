# FrameWorks Bridge GraphQL Schema
# Unified API for all FrameWorks services

# Root Query type
type Query {

  # Streams (from Commodore)
  streams: [Stream!]!
  stream(id: ID!): Stream
  validateStreamKey(streamKey: String!): StreamValidation!

  # Analytics (from Periscope Query)
  streamAnalytics(stream: String!, timeRange: TimeRangeInput): StreamAnalytics
  viewerMetrics(stream: String, timeRange: TimeRangeInput): [ViewerMetric!]!
  platformOverview(timeRange: TimeRangeInput): PlatformOverview!
  
  # Geographic Analytics
  viewerGeographics(stream: String, timeRange: TimeRangeInput): [ViewerGeographic!]!
  geographicDistribution(stream: String, timeRange: TimeRangeInput): GeographicDistribution!
  loadBalancingMetrics(timeRange: TimeRangeInput, pagination: PaginationInput, sortOrder: SortOrder): [LoadBalancingMetric!]!
  
  # Connection and Routing Analytics
  routingEvents(stream: String, timeRange: TimeRangeInput, pagination: PaginationInput, sortOrder: SortOrder): [RoutingEvent!]!
  connectionEvents(stream: String, timeRange: TimeRangeInput, pagination: PaginationInput, sortOrder: SortOrder): [ConnectionEvent!]!
  clipEvents(internalName: String, stage: String, timeRange: TimeRangeInput, pagination: PaginationInput): [ClipEvent!]!
  
  # Node Performance Metrics
  nodeMetrics(nodeId: String, timeRange: TimeRangeInput): [NodeMetric!]!
  nodeMetrics1h(timeRange: TimeRangeInput, nodeId: String): [NodeMetricHourly!]!
  
  # Aggregated Analytics
  viewerMetrics5m(stream: String, timeRange: TimeRangeInput): [ViewerMetrics5m!]!
  
  # Infrastructure Service Monitoring
  serviceInstances(clusterId: String, nodeId: String, status: InstanceStatus): [ServiceInstance!]!
  
  # Stream Management
  streamKeys(streamId: ID!): [StreamKey!]!
  recordings(streamId: ID): [Recording!]!
  clips(streamId: ID): [Clip!]!
  clip(id: ID!): Clip
  clipViewingUrls(clipId: ID!): ClipViewingUrls!
  
  # Tenant Resource Management
  tenantClusterAssignments: [TenantClusterAssignment!]!
  
  # New health and quality queries
  streamHealthMetrics(stream: String!, timeRange: TimeRangeInput): [StreamHealthMetric!]!
  trackListEvents(stream: String!, timeRange: TimeRangeInput): [TrackListEvent!]!
  streamHealthAlerts(stream: String, timeRange: TimeRangeInput): [StreamHealthAlert!]!
  currentStreamHealth(stream: String!): StreamHealthMetric
  rebufferingEvents(stream: String!, timeRange: TimeRangeInput): [RebufferingEvent!]!
  
  # Billing (from Purser)  
  billingTiers: [BillingTier!]!
  invoices: [Invoice!]!
  invoice(id: ID!): Invoice
  billingStatus: BillingStatus!
  usageRecords(timeRange: TimeRangeInput): [UsageRecord!]!

  # Tenants & Infrastructure (from Quartermaster)
  tenant: Tenant
  clusters: [Cluster!]!
  cluster(id: ID!): Cluster
  nodes(clusterId: String, status: NodeStatus, type: String, tag: String): [Node!]!
  node(id: ID!): Node
  
  # Service discovery and access (Quartermaster)
  discoverServices(type: String!, clusterId: String): [ServiceInstance!]!
  clustersAccess: [ClusterAccess!]!
  clustersAvailable: [AvailableCluster!]!
  serviceInstancesHealth(serviceId: String): [ServiceInstanceHealth!]!

  # Developer API (from Commodore)
  developerTokens: [DeveloperToken!]!
  
  # Bootstrap token management (admin/provider only via Quartermaster)
  bootstrapTokens: [BootstrapToken!]!
  
  # DVR & recording
  recordingConfig(internalName: String!): RecordingConfig!
  dvrRequests(internalName: String, status: String, pagination: PaginationInput): DVRRequestList!
  
  # Viewer endpoint resolution (via Foghorn)
  resolveViewerEndpoint(contentType: String!, contentId: String!): ViewerEndpointResponse!
  # Mist JSON meta (via Commodore -> Foghorn)
  streamMeta(streamKey: String!, targetBaseUrl: String, targetNodeId: String, includeRaw: Boolean): StreamMetaResponse!
}

# Root Mutation type
type Mutation {
  # Stream operations (via Commodore)
  createStream(input: CreateStreamInput!): Stream!
  updateStream(id: ID!, input: UpdateStreamInput!): Stream!
  deleteStream(id: ID!): Boolean!
  refreshStreamKey(id: ID!): Stream!

  # Clip operations (via Commodore)
  createClip(input: CreateClipInput!): Clip!
  deleteClip(id: ID!): Boolean!

  # DVR operations (via Commodore)
  startDVR(internalName: String!, streamId: ID): DVRRequest!
  stopDVR(dvrHash: ID!): Boolean!

  # Stream recording config (via Commodore)
  setStreamRecordingConfig(internalName: String!, enabled: Boolean!, retentionDays: Int, format: String, segmentDuration: Int): RecordingConfig!

  # Billing operations (via Purser)
  createPayment(input: CreatePaymentInput!): Payment!

  # Infrastructure operations (via Quartermaster)
  updateTenant(input: UpdateTenantInput!): Tenant!

  # Developer API operations (via Commodore)
  createDeveloperToken(input: CreateDeveloperTokenInput!): DeveloperToken!
  revokeDeveloperToken(id: ID!): Boolean!
  
  # Bootstrap token operations (admin/provider only via Quartermaster)
  createBootstrapToken(input: CreateBootstrapTokenInput!): BootstrapToken!
  revokeBootstrapToken(id: ID!): Boolean!
  
  # Stream key operations (via Commodore)
  createStreamKey(streamId: ID!, input: CreateStreamKeyInput!): StreamKey!
  deleteStreamKey(streamId: ID!, keyId: ID!): Boolean!
}

# Root Subscription type for real-time updates
type Subscription {
  # Stream lifecycle events
  streamEvents(stream: String): StreamEvent!
  
  # Viewer metrics updates  
  viewerMetrics(stream: String!): ViewerMetrics!
  
  # Track list updates
  trackListUpdates(stream: String!): TrackListEvent!
  
  # Clip lifecycle updates (includes DVR lifecycle mapped as clip events)
  clipLifecycle(stream: String!): ClipEvent!
  dvrLifecycle(stream: String!): ClipEvent!
  
  # System health (admin only)
  systemHealth: SystemHealthEvent!
}

# Input types

input CreateStreamInput {
  name: String!
  description: String
  record: Boolean = false
}

input UpdateStreamInput {
  name: String
  description: String
  record: Boolean
}

input CreateClipInput {
  stream: String!
  startTime: Int!
  endTime: Int!
  title: String!
  description: String
}

# DVR types
type DVRRequest {
  dvrHash: ID!
  internalName: String!
  storageNodeId: String
  status: String!
  startedAt: Time
  endedAt: Time
  durationSeconds: Int
  sizeBytes: Int
  manifestPath: String
  errorMessage: String
  createdAt: Time!
  updatedAt: Time!
}

type DVRRequestList {
  dvrRecordings: [DVRRequest!]!
  total: Int!
  page: Int!
  limit: Int!
}

type RecordingConfig {
  enabled: Boolean!
  retentionDays: Int!
  format: String!
  segmentDuration: Int!
}

input CreatePaymentInput {
  invoiceId: ID!
  amount: Money!
  currency: Currency
  method: PaymentMethod!
  returnUrl: String
}

input UpdateTenantInput {
  name: String
  settings: JSON
}

input CreateDeveloperTokenInput {
  name: String!
  permissions: String
  expiresIn: Int
}

input CreateBootstrapTokenInput {
  name: String!
  type: BootstrapTokenType!
  expiresIn: Int    # Days until expiration
  usageLimit: Int   # Max uses allowed
}

input CreateStreamKeyInput {
  name: String!
}

input TimeRangeInput {
  start: Time!
  end: Time!
}

input PaginationInput {
  limit: Int
  offset: Int
}

enum SortOrder {
  ASC
  DESC
}

type TimeRange {
  start: Time!
  end: Time!
}

# Enums
enum PaymentMethod {
  CARD
  CRYPTO
  BANK_TRANSFER
}

# Added payment status enum
enum PaymentStatus {
  PENDING
  CONFIRMED
  FAILED
}

# Added invoice status enum
enum InvoiceStatus {
  PENDING
  PAID
  FAILED
  CANCELLED
}

# Service instance lifecycle status
enum InstanceStatus {
  RUNNING
  STARTING
  STOPPING
  STOPPED
  ERROR
  UNKNOWN
}

enum StreamStatus {
  OFFLINE
  LIVE
  RECORDING
  ENDED
}

enum NodeStatus {
  HEALTHY
  DEGRADED
  UNHEALTHY
}

enum BootstrapTokenType {
  EDGE_NODE
  SERVICE
}

# Real-time event types
type StreamEvent {
  type: StreamEventType!
  stream: String!
  status: StreamStatus!
  timestamp: Time!
  details: JSON
}

enum StreamEventType {
  STREAM_START
  STREAM_END
  STREAM_ERROR
  BUFFER_UPDATE
  TRACK_LIST_UPDATE
}

type ViewerMetrics {
  stream: String!
  currentViewers: Int!
  viewerCount: Int!
  peakViewers: Int!
  bandwidth: Float!
  connectionQuality: Float
  bufferHealth: Float
  timestamp: Time!
}

type TrackListEvent {
  stream: String!
  nodeId: String
  trackList: String!
  trackCount: Int!
  timestamp: Time!
  tracks: [StreamTrack!]
}

type StreamTrack {
  trackName: String!
  trackType: String!
  codec: String
  bitrateKbps: Int
  bitrateBps: Int
  buffer: Int
  jitter: Int
  width: Int
  height: Int
  fps: Float
  resolution: String
  hasBFrames: Boolean
  channels: Int
  sampleRate: Int
}

type SystemHealthEvent {
  node: String!
  cluster: String!
  status: NodeStatus!
  cpuUsage: Float!
  memoryUsage: Float!
  diskUsage: Float!
  healthScore: Float!
  timestamp: Time!
}

# Custom scalars
scalar Time
scalar JSON
scalar Currency
scalar Money

# Core types (some will map to pkg/models types)
type User {
  id: ID!
  email: String!
  name: String
  role: String!
  createdAt: Time!
}


type Tenant {
  id: ID!
  name: String!
  settings: JSON
  cluster: String
  createdAt: Time!
}

type Stream {
  id: ID!
  name: String!
  description: String
  streamKey: String!
  playbackId: String!
  status: StreamStatus!
  record: Boolean!
  createdAt: Time!
  updatedAt: Time!

  # Edges
  recordings: [Recording!]!
  events(timeRange: TimeRangeInput, pagination: PaginationInput): [StreamEvent!]!
  health(timeRange: TimeRangeInput): [StreamHealthMetric!]!
  viewerMetrics5m(timeRange: TimeRangeInput): [ViewerMetrics5m!]!
}

type StreamValidation {
  valid: Boolean!
  streamKey: String!
  error: String
}

type StreamAnalytics {
  # Core identifiers
  id: ID!
  tenantId: ID!
  streamId: ID
  internalName: String!
  
  # Session timing
  sessionStartTime: Time
  sessionEndTime: Time
  totalSessionDuration: Int!
  
  # Viewer metrics
  currentViewers: Int!
  peakViewers: Int!
  totalConnections: Int!
  
  # Bandwidth metrics
  bandwidthIn: Float!
  bandwidthOut: Float!
  totalBandwidthGb: Float!
  upbytes: Float!
  downbytes: Float!
  
  # Stream quality
  bitrateKbps: Int
  resolution: String
  
  # Network performance
  packetsSent: Float!
  packetsLost: Float!
  packetsRetrans: Float!
  firstMs: Int
  lastMs: Int
  
  # Stream details
  trackCount: Int!
  inputs: Int!
  outputs: Int!
  
  # Location
  nodeId: String
  nodeName: String
  latitude: Float
  longitude: Float
  location: String
  
  # Status
  status: String
  lastUpdated: Time!
  createdAt: Time!
  
  # Current health state (from STREAM_BUFFER events)
  currentHealthScore: Float
  currentBufferState: String
  currentIssues: String
  currentCodec: String
  currentFps: Float
  currentResolution: String
  mistStatus: String
  qualityTier: String
  
  # Enriched analytics from ClickHouse (computed)
  avgViewers: Float
  uniqueCountries: Int
  uniqueCities: Int
  avgBufferHealth: Float
  avgBitrate: Int
  packetLossRate: Float
}

type ViewerMetric {
  timestamp: Time!
  viewerCount: Int!
}

type PlatformOverview {
  totalStreams: Int!
  totalViewers: Int!
  totalBandwidth: Float!
  totalUsers: Int!
  timeRange: TimeRange!
}

type BillingTier {
  id: ID!
  name: String!
  description: String
  price: Float!
  currency: String!
  features: [String!]!
}

type Invoice {
  id: ID!
  amount: Money!
  currency: Currency!
  status: InvoiceStatus!
  dueDate: Time!
  createdAt: Time!
  lineItems: [LineItem!]!
}

type LineItem {
  description: String!
  quantity: Int!
  unitPrice: Money!
  total: Money!
}

type BillingStatus {
  currentTier: BillingTier!
  nextBillingDate: Time!
  outstandingAmount: Float!
  status: String!
}

type Payment {
  id: ID!
  amount: Money!
  currency: Currency!
  method: PaymentMethod!
  status: PaymentStatus!
  createdAt: Time!
}

type UsageRecord {
  id: ID!
  resourceType: String!
  quantity: Float!
  unit: String!
  cost: Float!
  timestamp: Time!
}

type Cluster {
  id: ID!
  name: String!
  region: String!
  status: NodeStatus!
  nodes: [Node!]!
  serviceInstances(status: InstanceStatus, nodeId: String): [ServiceInstance!]!
  createdAt: Time!
}

type Node {
  id: ID!
  name: String!
  cluster: String!
  clusterInfo: Cluster
  type: String!
  status: NodeStatus!
  region: String!
  ipAddress: String
  lastSeen: Time!
  createdAt: Time!
  
  # Geographic location
  latitude: Float
  longitude: Float
  location: String

  # Edges
  serviceInstances(status: InstanceStatus): [ServiceInstance!]
  metrics(timeRange: TimeRangeInput): [NodeMetric!]
  metrics1h(timeRange: TimeRangeInput): [NodeMetricHourly!]
}

type Clip {
  id: ID!
  stream: String!
  title: String!
  description: String
  startTime: Int!
  endTime: Int!
  duration: Int!
  playbackId: String!
  status: String!
  createdAt: Time!
  updatedAt: Time!
  viewingUrls: ClipViewingUrls
}

type ClipViewingUrls {
  hls: String
  dash: String
  mp4: String
  webm: String
}

type DeveloperToken {
  id: ID!
  name: String!
  token: String
  permissions: String!
  status: String!
  lastUsedAt: Time
  expiresAt: Time
  createdAt: Time!
}

type BootstrapToken {
  id: ID!
  name: String!
  token: String          # Only returned on creation
  type: BootstrapTokenType!
  usageLimit: Int
  usageCount: Int!
  expiresAt: Time
  createdAt: Time!
  lastUsedAt: Time
  isActive: Boolean!
}

# ============================================================================
# STREAM HEALTH & QUALITY TYPES
# ============================================================================

# Buffer state enumeration
enum BufferState {
  FULL
  EMPTY
  DRY
  RECOVER
}

# Alert severity levels
enum AlertSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

# Alert types
enum AlertType {
  HIGH_JITTER
  KEYFRAME_INSTABILITY
  PACKET_LOSS
  REBUFFERING
  QUALITY_DEGRADATION
}

# Stream health metrics from detailed monitoring
type StreamHealthMetric {
  timestamp: Time!
  stream: String!
  nodeId: String!
  
  # Health scores and indicators
  healthScore: Float!
  frameJitterMs: Float
  keyframeStabilityMs: Float
  issuesDescription: String
  hasIssues: Boolean!
  
  # Video quality
  bitrate: Int
  fps: Float
  width: Int
  height: Int
  codec: String
  qualityTier: String
  
  # Network performance
  packetsSent: Int
  packetsLost: Int
  packetLossPercentage: Float
  
  # Buffer state
  bufferState: BufferState!
  bufferHealth: Float
  
  # Audio metrics
  audioChannels: Int
  audioSampleRate: Int
  audioCodec: String
  audioBitrate: Int
  
  # Raw track metadata
  trackMetadata: JSON
}

# Stream health alerts for issues
type StreamHealthAlert {
  timestamp: Time!
  stream: String!
  nodeId: String!
  alertType: AlertType!
  severity: AlertSeverity!
  
  # Alert details
  healthScore: Float
  frameJitterMs: Float
  packetLossPercentage: Float
  issuesDescription: String
  
  # Context
  bufferState: BufferState
  qualityTier: String
}

# Rebuffering events for UX analysis
type RebufferingEvent {
  timestamp: Time!
  stream: String!
  nodeId: String!
  
  # Rebuffer details
  bufferState: BufferState!
  previousState: BufferState!
  rebufferStart: Boolean!
  rebufferEnd: Boolean!
  healthScore: Float
  
  # Performance at rebuffer time
  frameJitterMs: Float
  packetLossPercentage: Float
}

# ============================================================================
# GEOGRAPHIC ANALYTICS TYPES
# ============================================================================

# Geographic data for individual viewer/connection events
type ViewerGeographic {
  timestamp: Time!
  stream: String
  nodeId: String
  
  # Geographic location
  countryCode: String
  city: String
  latitude: Float
  longitude: Float
  
  # Event details
  viewerCount: Int
  connectionAddr: String
  eventType: String
  source: String
}

# Aggregated geographic distribution analytics
type GeographicDistribution {
  timeRange: TimeRange!
  stream: String
  
  # Top countries and cities
  topCountries: [CountryMetric!]!
  topCities: [CityMetric!]!
  
  # Geographic spread metrics
  uniqueCountries: Int!
  uniqueCities: Int!
  totalViewers: Int!
  
  # Geographic viewer distribution over time
  viewersByCountry: [CountryTimeSeries!]!
}

# Country-level metrics
type CountryMetric {
  countryCode: String!
  viewerCount: Int!
  percentage: Float!
  
  # Optional detailed city breakdown
  cities: [CityMetric!]
}

# City-level metrics  
type CityMetric {
  city: String!
  countryCode: String
  viewerCount: Int!
  percentage: Float!
  latitude: Float
  longitude: Float
}

# Time series data for countries
type CountryTimeSeries {
  timestamp: Time!
  countryCode: String!
  viewerCount: Int!
}

# Load balancing and routing metrics with geographic context
type LoadBalancingMetric {
  timestamp: Time!
  stream: String!
  
  # Node and routing info
  selectedNode: String!
  nodeId: String
  
  # Client geographic data
  clientIp: String
  clientCountry: String
  clientLatitude: Float
  clientLongitude: Float
  
  # Node geographic data
  nodeLatitude: Float
  nodeLongitude: Float
  nodeName: String
  
  # Performance metrics
  score: Int
  status: String!
  details: String
  
  # Geographic routing efficiency
  routingDistance: Float  # Distance between client and selected node
  
  # Event context
  eventType: String
  source: String
}

# ============================================================================
# CONNECTION AND ROUTING EVENT TYPES
# ============================================================================

# Routing event for load balancing decisions
type RoutingEvent {
  timestamp: Time!
  streamName: String!
  selectedNode: String!
  status: String!
  details: String
  score: Int
  
  # Client location info
  clientIp: String
  clientCountry: String
  clientLatitude: Float
  clientLongitude: Float
  
  # Node location info
  nodeLatitude: Float
  nodeLongitude: Float
  nodeName: String
}

# Connection event for viewer connections/disconnections
type ConnectionEvent {
  eventId: String!
  timestamp: Time!
  tenantId: String!
  internalName: String!
  sessionId: String!
  connectionAddr: String!
  connector: String!
  nodeId: String!
  countryCode: String
  city: String
  latitude: Float
  longitude: Float
  eventType: String! # "connect" or "disconnect"
}

# ============================================================================
# CLIP LIFECYCLE ANALYTICS TYPES
# ============================================================================

type ClipEvent {
  timestamp: Time!
  internalName: String!
  requestId: String!
  stage: String!
  contentType: String
  startUnix: Int
  stopUnix: Int
  ingestNodeId: String
  percent: Int
  message: String
  filePath: String
  s3Url: String
  sizeBytes: Int
}

# ============================================================================
# NODE PERFORMANCE METRICS TYPES
# ============================================================================

# Node performance metrics from ClickHouse
type NodeMetric {
  timestamp: Time!
  nodeId: String!
  
  # Resource usage
  cpuUsage: Float!
  memoryUsage: Float!
  diskUsage: Float!
  networkRx: Int!
  networkTx: Int!
  
  # Health
  healthScore: Float!
  status: String!
  
  # Optional geo and metadata available from Periscope
  latitude: Float
  longitude: Float
  tags: [String!]
  metadata: JSON
}

# Hourly aggregated node metrics
type NodeMetricHourly {
  timestamp: Time!
  nodeId: String!
  avgCpu: Float!
  peakCpu: Float!
  avgMemory: Float!
  peakMemory: Float!
  totalBandwidthIn: Int!
  totalBandwidthOut: Int!
  avgHealthScore: Float!
  wasHealthy: Boolean!
}

# ============================================================================
# AGGREGATED ANALYTICS TYPES  
# ============================================================================

# 5-minute aggregated viewer metrics
type ViewerMetrics5m {
  timestamp: Time!
  internalName: String!
  nodeId: String!
  
  # Viewer metrics
  peakViewers: Int!
  avgViewers: Float!
  
  # Geographic distribution
  uniqueCountries: Int!
  uniqueCities: Int!
  
  # Quality metrics
  avgConnectionQuality: Float!
  avgBufferHealth: Float!
}

# ============================================================================
# INFRASTRUCTURE SERVICE MONITORING TYPES
# ============================================================================

# Service instance status and health
type ServiceInstance {
  id: ID!
  instanceId: String!
  clusterId: String!
  nodeId: String
  serviceId: String!
  
  # Instance details
  version: String
  port: Int
  processId: Int
  containerId: String
  
  # Status tracking
  status: InstanceStatus!
  healthStatus: NodeStatus!
  
  # Timestamps
  startedAt: Time
  stoppedAt: Time
  lastHealthCheck: Time
  
  # Resource usage
  cpuUsagePercent: Float
  memoryUsageMb: Int

  # Edges
  node: Node
  cluster: Cluster
}

# Cluster access entry (Quartermaster)
type ClusterAccess {
  clusterId: String!
  clusterName: String!
  accessLevel: String!
  resourceLimits: JSON
}

# Available cluster entry (Quartermaster)
type AvailableCluster {
  clusterId: String!
  clusterName: String!
  tiers: [String!]!
  autoEnroll: Boolean!
}

# Service instance health (Quartermaster)
type ServiceInstanceHealth {
  instanceId: String!
  serviceId: String!
  clusterId: String!
  protocol: String!
  host: String
  port: Int!
  healthEndpoint: String
  status: String!
  lastHealthCheck: Time
}

# ============================================================================
# STREAM MANAGEMENT TYPES
# ============================================================================

# Stream key management
type StreamKey {
  id: ID!
  streamId: ID!
  keyValue: String!
  keyName: String
  isActive: Boolean!
  lastUsedAt: Time
  createdAt: Time!
}

# Recording management
type Recording {
  id: ID!
  streamId: ID!
  
  # Recording metadata
  title: String
  duration: Int
  fileSizeBytes: Int
  playbackId: String
  thumbnailUrl: String
  startTime: Time
  endTime: Time
  
  # Processing status
  status: String!
  
  createdAt: Time!
  updatedAt: Time!
}

# ============================================================================
# TENANT RESOURCE MANAGEMENT TYPES
# ============================================================================

# Tenant cluster resource assignments
type TenantClusterAssignment {
  id: ID!
  tenantId: ID!
  clusterId: String!
  
  # Assignment configuration
  deploymentTier: String
  priority: Int!
  isPrimary: Boolean!
  isActive: Boolean!
  
  # Resource limits
  maxStreamsOnCluster: Int
  maxViewersOnCluster: Int
  maxBandwidthMbpsOnCluster: Int
  fallbackWhenFull: Boolean!
  
  createdAt: Time!
  updatedAt: Time!
}

# ============================================================================
# VIEWER ENDPOINT RESOLUTION TYPES
# ============================================================================

# Response from Foghorn's viewer endpoint resolution
type ViewerEndpointResponse {
  endpoints: [ViewerEndpoint!]!
  metadata: ContentMetadata
}

# Individual viewer endpoint with node and protocol info
type ViewerEndpoint {
  nodeId: String!
  baseUrl: String!
  protocol: String!        # "webrtc", "hls", "dash", etc from MistServer outputs
  url: String!             # Complete URL with stream name substituted
  geoDistance: Float       # Distance from viewer in km
  loadScore: Float         # Load balancer score
  healthScore: Float       # Node health score
  outputs: JSON            # MistServer outputs configuration
}

# Content metadata for any content type
type ContentMetadata {
  contentType: String!      # "live", "dvr", "clip"
  contentId: String!        # internal name or hash
  tenantId: String!
  title: String
  description: String
  duration: Int             # seconds, null for live
  status: String!
  isLive: Boolean!
  viewCount: Int
  recordingSize: Int        # bytes for DVR content
  clipSource: String        # source info for clips
  createdAt: String
}

# ============================================================================
# STREAM META TYPES
# ============================================================================

type StreamMetaResponse {
  metaSummary: StreamMetaSummary!
  raw: JSON
}

type StreamMetaSummary {
  isLive: Boolean!
  bufferWindowMs: Int!
  jitterMs: Int!
  unixOffsetMs: Int!
  nowMs: Int
  lastMs: Int
  width: Int
  height: Int
  version: Int
  type: String
  tracks: [StreamMetaTrack!]!
}

type StreamMetaTrack {
  id: String!
  type: String!
  codec: String!
  channels: Int
  rate: Int
  width: Int
  height: Int
  bitrateBps: Int
  nowMs: Int
  lastMs: Int
  firstMs: Int
}
