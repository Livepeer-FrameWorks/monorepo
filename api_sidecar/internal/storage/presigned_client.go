package storage

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"time"

	"frameworks/pkg/logging"
)

// PresignedClient handles uploads/downloads using presigned URLs.
// This client holds NO AWS credentials - it only uses pre-authorized URLs
// provided by Foghorn. This is the only S3-related code that runs on edge nodes.
type PresignedClient struct {
	httpClient *http.Client
	logger     logging.Logger
}

// ProgressCallback is called periodically during upload/download with bytes transferred
type ProgressCallback func(bytesTransferred int64)

// NewPresignedClient creates a new presigned URL client for edge nodes.
// This client contains NO credentials and cannot access S3 directly.
func NewPresignedClient(logger logging.Logger) *PresignedClient {
	return &PresignedClient{
		httpClient: &http.Client{
			Timeout: 30 * time.Minute, // Long timeout for large files
			Transport: &http.Transport{
				MaxIdleConns:          10,
				IdleConnTimeout:       90 * time.Second,
				DisableCompression:    true, // Videos are already compressed
				MaxConnsPerHost:       5,
				ResponseHeaderTimeout: 30 * time.Second,
			},
		},
		logger: logger,
	}
}

// UploadToPresignedURL uploads data to S3 using a presigned PUT URL.
// The URL was generated by Foghorn and is time-limited.
func (c *PresignedClient) UploadToPresignedURL(ctx context.Context, presignedURL string, reader io.Reader, size int64, onProgress ProgressCallback) error {
	// Wrap reader with progress tracking if callback provided
	var uploadReader io.Reader = reader
	if onProgress != nil {
		uploadReader = &progressReader{
			reader:     reader,
			onProgress: onProgress,
		}
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPut, presignedURL, uploadReader)
	if err != nil {
		return fmt.Errorf("failed to create upload request: %w", err)
	}

	req.ContentLength = size
	req.Header.Set("Content-Type", "application/octet-stream")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("upload request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))
		return fmt.Errorf("upload failed with status %d: %s", resp.StatusCode, string(body))
	}

	c.logger.WithFields(logging.Fields{
		"size":   size,
		"status": resp.StatusCode,
	}).Info("Uploaded to presigned URL")

	return nil
}

// UploadFileToPresignedURL uploads a local file to S3 using a presigned PUT URL.
func (c *PresignedClient) UploadFileToPresignedURL(ctx context.Context, presignedURL, localPath string, onProgress ProgressCallback) error {
	file, err := os.Open(localPath)
	if err != nil {
		return fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	stat, err := file.Stat()
	if err != nil {
		return fmt.Errorf("failed to stat file: %w", err)
	}

	return c.UploadToPresignedURL(ctx, presignedURL, file, stat.Size(), onProgress)
}

// DownloadFromPresignedURL downloads data from S3 using a presigned GET URL.
// The URL was generated by Foghorn and is time-limited.
func (c *PresignedClient) DownloadFromPresignedURL(ctx context.Context, presignedURL string, writer io.Writer, onProgress ProgressCallback) (int64, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, presignedURL, nil)
	if err != nil {
		return 0, fmt.Errorf("failed to create download request: %w", err)
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return 0, fmt.Errorf("download request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))
		return 0, fmt.Errorf("download failed with status %d: %s", resp.StatusCode, string(body))
	}

	// Wrap writer with progress tracking if callback provided
	var downloaded int64
	if onProgress != nil {
		downloaded, err = io.Copy(&progressWriter{writer: writer, onProgress: onProgress}, resp.Body)
	} else {
		downloaded, err = io.Copy(writer, resp.Body)
	}

	if err != nil {
		return downloaded, fmt.Errorf("failed to write downloaded data: %w", err)
	}

	c.logger.WithFields(logging.Fields{
		"size":   downloaded,
		"status": resp.StatusCode,
	}).Info("Downloaded from presigned URL")

	return downloaded, nil
}

// DownloadToFileFromPresignedURL downloads from S3 to a local file using a presigned GET URL.
func (c *PresignedClient) DownloadToFileFromPresignedURL(ctx context.Context, presignedURL, localPath string, onProgress ProgressCallback) error {
	// Ensure parent directory exists
	if err := os.MkdirAll(filepath.Dir(localPath), 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Download to temp file first, then rename (atomic)
	tempPath := localPath + ".downloading"
	file, err := os.Create(tempPath)
	if err != nil {
		return fmt.Errorf("failed to create temp file: %w", err)
	}

	_, err = c.DownloadFromPresignedURL(ctx, presignedURL, file, onProgress)
	file.Close()
	if err != nil {
		os.Remove(tempPath)
		return err
	}

	// Atomic rename
	if err := os.Rename(tempPath, localPath); err != nil {
		os.Remove(tempPath)
		return fmt.Errorf("failed to rename temp file: %w", err)
	}

	return nil
}

// progressReader wraps an io.Reader to track upload progress
type progressReader struct {
	reader     io.Reader
	onProgress ProgressCallback
	read       int64
}

func (r *progressReader) Read(p []byte) (int, error) {
	n, err := r.reader.Read(p)
	if n > 0 {
		r.read += int64(n)
		if r.onProgress != nil {
			r.onProgress(r.read)
		}
	}
	return n, err
}

// progressWriter wraps an io.Writer to track download progress
type progressWriter struct {
	writer     io.Writer
	onProgress ProgressCallback
	written    int64
}

func (w *progressWriter) Write(p []byte) (int, error) {
	n, err := w.writer.Write(p)
	if n > 0 {
		w.written += int64(n)
		if w.onProgress != nil {
			w.onProgress(w.written)
		}
	}
	return n, err
}
