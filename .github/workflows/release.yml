name: Release Platform

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write # create release, upload assets
  packages: write # push images to GHCR

env:
  REGISTRY: ghcr.io/livepeer-frameworks

jobs:
  build-images:
    name: Build & Push Images
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        service:
          - { name: bridge, context: api_gateway, dockerfile: api_gateway/Dockerfile }
          - { name: quartermaster, context: api_tenants, dockerfile: api_tenants/Dockerfile }
          - { name: commodore, context: api_control, dockerfile: api_control/Dockerfile }
          - { name: purser, context: api_billing, dockerfile: api_billing/Dockerfile }
          - { name: foghorn, context: api_balancing, dockerfile: api_balancing/Dockerfile }
          - { name: decklog, context: api_firehose, dockerfile: api_firehose/Dockerfile }
          - {
              name: periscope-ingest,
              context: api_analytics_ingest,
              dockerfile: api_analytics_ingest/Dockerfile,
            }
          - {
              name: periscope-query,
              context: api_analytics_query,
              dockerfile: api_analytics_query/Dockerfile,
            }
          - { name: signalman, context: api_realtime, dockerfile: api_realtime/Dockerfile }
          - { name: helmsman, context: api_sidecar, dockerfile: api_sidecar/Dockerfile }
          - { name: steward, context: api_forms, dockerfile: api_forms/Dockerfile }
          - { name: deckhand, context: api_ticketing, dockerfile: api_ticketing/Dockerfile }
          - { name: navigator, context: api_dns, dockerfile: api_dns/Dockerfile }
          - { name: skipper, context: api_consultant, dockerfile: api_consultant/Dockerfile }
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Read service component version (optional)
        id: svcver
        run: |
          VERSION_FILE="${{ matrix.service.context }}/VERSION"
          PACKAGE_JSON="${{ matrix.service.context }}/package.json"
          if [[ -f "$VERSION_FILE" ]]; then
            echo "version=$(tr -d '\n' < "$VERSION_FILE")" >> "$GITHUB_OUTPUT"
          elif [[ -f "$PACKAGE_JSON" ]]; then
            echo "version=$(jq -r .version "$PACKAGE_JSON")" >> "$GITHUB_OUTPUT"
          else
            echo "version=0.0.0" >> "$GITHUB_OUTPUT"
          fi

      - name: Build & push ${{ matrix.service.name }}
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ matrix.service.dockerfile }}
          platforms: linux/amd64,linux/arm64
          push: true
          provenance: true
          sbom: true
          build-args: |
            VERSION=${{ github.ref_name }}
            GIT_COMMIT=${{ github.sha }}
            BUILD_DATE=${{ github.event.repository.updated_at }}
            COMPONENT_NAME=${{ matrix.service.name }}
            COMPONENT_VERSION=${{ steps.svcver.outputs.version }}
          tags: |
            ${{ env.REGISTRY }}/frameworks-${{ matrix.service.name }}:${{ github.ref_name }}
            livepeerframeworks/frameworks-${{ matrix.service.name }}:${{ github.ref_name }}
          cache-from: type=gha,scope=${{ matrix.service.name }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service.name }}

      - name: Write digest artifact
        run: |
          mkdir -p dist
          cat > dist/image-${{ matrix.service.name }}.json <<JSON
          {
            "name": "${{ matrix.service.name }}",
            "image": "docker.io/livepeerframeworks/frameworks-${{ matrix.service.name }}:${{ github.ref_name }}",
            "digest": "${{ steps.build.outputs.digest }}",
            "service_version": "${{ steps.svcver.outputs.version }}",
            "git_commit": "${{ github.sha }}"
          }
          JSON
      - name: Upload artifact
        uses: actions/upload-artifact@v6
        with:
          name: image-digest-${{ matrix.service.name }}
          path: dist/image-${{ matrix.service.name }}.json

  build-webapps:
    name: Build Web Applications
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        webapp:
          - { name: chartroom, context: website_application, env_prefix: VITE, build_dir: build }
          - { name: foredeck, context: website_marketing, env_prefix: VITE, build_dir: dist }
          - { name: logbook, context: website_docs, env_prefix: VITE, build_dir: dist }
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: "24"
          cache: "pnpm"
          cache-dependency-path: "pnpm-lock.yaml"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build player package
        run: |
          cd npm_player
          pnpm run build

      - name: Build studio package
        run: |
          cd npm_studio
          pnpm run build

      - name: Build application
        env:
          # chartroom (website_application) variables
          VITE_AUTH_URL: ${{ secrets.VITE_AUTH_URL }}
          VITE_GRAPHQL_HTTP_URL: ${{ secrets.VITE_GRAPHQL_HTTP_URL }}
          VITE_GRAPHQL_WS_URL: ${{ secrets.VITE_GRAPHQL_WS_URL }}
          VITE_STREAMING_INGEST_URL: ${{ secrets.VITE_STREAMING_INGEST_URL }}
          VITE_STREAMING_PLAY_URL: ${{ secrets.VITE_STREAMING_PLAY_URL }}
          VITE_STREAMING_EDGE_URL: ${{ secrets.VITE_STREAMING_EDGE_URL }}
          VITE_STREAMING_RTMP_PORT: ${{ secrets.VITE_STREAMING_RTMP_PORT }}
          VITE_STREAMING_SRT_PORT: ${{ secrets.VITE_STREAMING_SRT_PORT }}
          VITE_STREAMING_RTMP_PATH: ${{ secrets.VITE_STREAMING_RTMP_PATH }}
          VITE_STREAMING_HLS_PATH: ${{ secrets.VITE_STREAMING_HLS_PATH }}
          VITE_STREAMING_WEBRTC_PATH: ${{ secrets.VITE_STREAMING_WEBRTC_PATH }}
          VITE_STREAMING_EMBED_PATH: ${{ secrets.VITE_STREAMING_EMBED_PATH }}
          VITE_MARKETING_SITE_URL: ${{ secrets.VITE_MARKETING_SITE_URL }}
          VITE_DOCS_SITE_URL: ${{ secrets.VITE_DOCS_SITE_URL }}
          VITE_TURNSTILE_AUTH_SITE_KEY: ${{ secrets.VITE_TURNSTILE_AUTH_SITE_KEY }}
          BASE_PATH: ${{ secrets.BASE_PATH }}
          # foredeck (website_marketing) variables
          VITE_APP_URL: ${{ secrets.VITE_APP_URL }}
          VITE_CONTACT_API_URL: ${{ secrets.VITE_CONTACT_API_URL }}
          VITE_GATEWAY_URL: ${{ secrets.VITE_GATEWAY_URL }}
          VITE_GITHUB_URL: ${{ secrets.VITE_GITHUB_URL }}
          VITE_LIVEPEER_URL: ${{ secrets.VITE_LIVEPEER_URL }}
          VITE_LIVEPEER_EXPLORER_URL: ${{ secrets.VITE_LIVEPEER_EXPLORER_URL }}
          VITE_CONTACT_EMAIL: ${{ secrets.VITE_CONTACT_EMAIL }}
          VITE_FORUM_URL: ${{ secrets.VITE_FORUM_URL }}
          VITE_DISCORD_URL: ${{ secrets.VITE_DISCORD_URL }}
          VITE_DEMO_STREAM_NAME: ${{ secrets.VITE_DEMO_STREAM_NAME }}
          VITE_COMPANY_NAME: ${{ secrets.VITE_COMPANY_NAME }}
          VITE_DOMAIN: ${{ secrets.VITE_DOMAIN }}
          VITE_TURNSTILE_FORMS_SITE_KEY: ${{ secrets.VITE_TURNSTILE_FORMS_SITE_KEY }}
        run: |
          cd ${{ matrix.webapp.context }}
          pnpm run build

      - name: Create static bundle
        run: |
          cd ${{ matrix.webapp.context }}
          tar czf ../${{ matrix.webapp.name }}-build.tar.gz ${{ matrix.webapp.build_dir }}/

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ matrix.webapp.context }}/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          provenance: true
          sbom: true
          build-args: |
            BUILD_ENV=production
            VITE_AUTH_URL=${{ secrets.VITE_AUTH_URL }}
            VITE_GRAPHQL_HTTP_URL=${{ secrets.VITE_GRAPHQL_HTTP_URL }}
            VITE_GRAPHQL_WS_URL=${{ secrets.VITE_GRAPHQL_WS_URL }}
            VITE_STREAMING_INGEST_URL=${{ secrets.VITE_STREAMING_INGEST_URL }}
            VITE_STREAMING_PLAY_URL=${{ secrets.VITE_STREAMING_PLAY_URL }}
            VITE_STREAMING_EDGE_URL=${{ secrets.VITE_STREAMING_EDGE_URL }}
            VITE_STREAMING_RTMP_PORT=${{ secrets.VITE_STREAMING_RTMP_PORT }}
            VITE_STREAMING_SRT_PORT=${{ secrets.VITE_STREAMING_SRT_PORT }}
            VITE_STREAMING_RTMP_PATH=${{ secrets.VITE_STREAMING_RTMP_PATH }}
            VITE_STREAMING_HLS_PATH=${{ secrets.VITE_STREAMING_HLS_PATH }}
            VITE_STREAMING_WEBRTC_PATH=${{ secrets.VITE_STREAMING_WEBRTC_PATH }}
            VITE_STREAMING_EMBED_PATH=${{ secrets.VITE_STREAMING_EMBED_PATH }}
            VITE_MARKETING_SITE_URL=${{ secrets.VITE_MARKETING_SITE_URL }}
            VITE_DOCS_SITE_URL=${{ secrets.VITE_DOCS_SITE_URL }}
            VITE_TURNSTILE_AUTH_SITE_KEY=${{ secrets.VITE_TURNSTILE_AUTH_SITE_KEY }}
            BASE_PATH=${{ secrets.BASE_PATH }}
            VITE_APP_URL=${{ secrets.VITE_APP_URL }}
            VITE_CONTACT_API_URL=${{ secrets.VITE_CONTACT_API_URL }}
            VITE_GATEWAY_URL=${{ secrets.VITE_GATEWAY_URL }}
            VITE_GITHUB_URL=${{ secrets.VITE_GITHUB_URL }}
            VITE_LIVEPEER_URL=${{ secrets.VITE_LIVEPEER_URL }}
            VITE_LIVEPEER_EXPLORER_URL=${{ secrets.VITE_LIVEPEER_EXPLORER_URL }}
            VITE_CONTACT_EMAIL=${{ secrets.VITE_CONTACT_EMAIL }}
            VITE_FORUM_URL=${{ secrets.VITE_FORUM_URL }}
            VITE_DISCORD_URL=${{ secrets.VITE_DISCORD_URL }}
            VITE_DEMO_STREAM_NAME=${{ secrets.VITE_DEMO_STREAM_NAME }}
            VITE_COMPANY_NAME=${{ secrets.VITE_COMPANY_NAME }}
            VITE_DOMAIN=${{ secrets.VITE_DOMAIN }}
            VITE_TURNSTILE_FORMS_SITE_KEY=${{ secrets.VITE_TURNSTILE_FORMS_SITE_KEY }}
          tags: |
            ${{ env.REGISTRY }}/frameworks-${{ matrix.webapp.name }}:${{ github.ref_name }}
            livepeerframeworks/frameworks-${{ matrix.webapp.name }}:${{ github.ref_name }}
          cache-from: type=gha,scope=${{ matrix.webapp.name }}
          cache-to: type=gha,mode=max,scope=${{ matrix.webapp.name }}

      - name: Write digest artifact
        run: |
          mkdir -p dist
          cat > dist/image-${{ matrix.webapp.name }}.json <<JSON
          {
            "name": "${{ matrix.webapp.name }}",
            "image": "docker.io/livepeerframeworks/frameworks-${{ matrix.webapp.name }}:${{ github.ref_name }}",
            "digest": "${{ steps.build.outputs.digest }}",
            "git_commit": "${{ github.sha }}"
          }
          JSON

      - name: Upload digest artifact
        uses: actions/upload-artifact@v6
        with:
          name: image-digest-${{ matrix.webapp.name }}
          path: dist/image-${{ matrix.webapp.name }}.json

      - name: Upload static bundle artifact
        uses: actions/upload-artifact@v6
        with:
          name: ${{ matrix.webapp.name }}-bundle
          path: ${{ matrix.webapp.name }}-build.tar.gz

  build-cli:
    name: Build CLI binaries
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
            ext: ""
          - goos: linux
            goarch: arm64
            ext: ""
          - goos: darwin
            goarch: amd64
            ext: ""
          - goos: darwin
            goarch: arm64
            ext: ""
    steps:
      - uses: actions/checkout@v6
      - name: Sanitize platform tag to component version
        id: compver
        run: |
          ver="${GITHUB_REF_NAME#v}"
          echo "value=${ver}" >> "$GITHUB_OUTPUT"
      - uses: actions/setup-go@v6
        with:
          go-version: "1.24"
          cache-dependency-path: cli/go.sum
      - name: Build CLI ${{ matrix.goos }}/${{ matrix.goarch }}
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          set -euo pipefail
          cd cli
          out="frameworks-${{ matrix.goos }}-${{ matrix.goarch }}${{ matrix.ext }}"
          go build -ldflags "-X frameworks/pkg/version.Version=${{ github.ref_name }} -X frameworks/pkg/version.GitCommit=${{ github.sha }} -X frameworks/pkg/version.BuildDate=$(date -u '+%Y-%m-%dT%H:%M:%SZ') -X frameworks/pkg/version.ComponentName=cli -X frameworks/pkg/version.ComponentVersion=${{ steps.compver.outputs.value }}" -o "$out" .
          cd ..
          mkdir -p dist/cli
          mv "cli/$out" "dist/cli/$out"
      - name: Upload CLI artifacts
        uses: actions/upload-artifact@v6
        with:
          name: cli-${{ matrix.goos }}-${{ matrix.goarch }}
          path: dist/cli/*

  build-service-binaries:
    name: Build Service Binaries
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        service:
          - { name: bridge, context: api_gateway, cmd_path: ./cmd/bridge, cgo: false }
          - { name: quartermaster, context: api_tenants, cmd_path: ./cmd/quartermaster, cgo: false }
          - { name: commodore, context: api_control, cmd_path: ./cmd/commodore, cgo: false }
          - { name: purser, context: api_billing, cmd_path: ./cmd/purser, cgo: false }
          - { name: foghorn, context: api_balancing, cmd_path: ./cmd/foghorn, cgo: true }
          - { name: decklog, context: api_firehose, cmd_path: cmd/decklog/main.go, cgo: false }
          - {
              name: periscope-ingest,
              context: api_analytics_ingest,
              cmd_path: ./cmd/periscope,
              cgo: false,
            }
          - {
              name: periscope-query,
              context: api_analytics_query,
              cmd_path: ./cmd/periscope,
              cgo: false,
            }
          - { name: signalman, context: api_realtime, cmd_path: ./cmd/signalman, cgo: false }
          - { name: helmsman, context: api_sidecar, cmd_path: ./cmd/helmsman, cgo: false }
          - { name: steward, context: api_forms, cmd_path: ./cmd/forms, cgo: false }
          - { name: navigator, context: api_dns, cmd_path: ./cmd/navigator, cgo: false }
          - { name: deckhand, context: api_ticketing, cmd_path: ./cmd/deckhand, cgo: false }
          - { name: privateer, context: api_mesh, cmd_path: ./cmd/privateer, cgo: false }
          - { name: skipper, context: api_consultant, cmd_path: ./cmd/skipper, cgo: false }
        arch:
          - { goos: linux, goarch: amd64, zig_target: x86_64-linux-musl }
          - { goos: linux, goarch: arm64, zig_target: aarch64-linux-musl }
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: "1.24"
          cache-dependency-path: ${{ matrix.service.context }}/go.sum

      - name: Install zig (for CGO cross-compilation)
        if: matrix.service.cgo
        uses: mlugg/setup-zig@v2

      - name: Read service version
        id: svcver
        run: |
          VERSION_FILE="${{ matrix.service.context }}/VERSION"
          if [[ -f "$VERSION_FILE" ]]; then
            echo "version=$(tr -d '\n' < "$VERSION_FILE")" >> "$GITHUB_OUTPUT"
          else
            echo "version=0.0.0" >> "$GITHUB_OUTPUT"
          fi

      - name: Build binary
        env:
          GOOS: ${{ matrix.arch.goos }}
          GOARCH: ${{ matrix.arch.goarch }}
          CGO_ENABLED: ${{ matrix.service.cgo && '1' || '0' }}
          CC: ${{ matrix.service.cgo && format('zig cc -target {0}', matrix.arch.zig_target) || '' }}
          CXX: ${{ matrix.service.cgo && format('zig c++ -target {0}', matrix.arch.zig_target) || '' }}
        run: |
          set -euo pipefail
          cd ${{ matrix.service.context }}

          BINARY_NAME="frameworks-${{ matrix.service.name }}-${{ matrix.arch.goos }}-${{ matrix.arch.goarch }}"
          OUTPUT="frameworks-${{ matrix.service.name }}-${{ github.ref_name }}-${{ matrix.arch.goos }}-${{ matrix.arch.goarch }}"

          go build -ldflags "\
            -X frameworks/pkg/version.Version=${{ github.ref_name }} \
            -X frameworks/pkg/version.GitCommit=${{ github.sha }} \
            -X frameworks/pkg/version.BuildDate=$(date -u '+%Y-%m-%dT%H:%M:%SZ') \
            -X frameworks/pkg/version.ComponentName=${{ matrix.service.name }} \
            -X frameworks/pkg/version.ComponentVersion=${{ steps.svcver.outputs.version }} \
            -s -w" \
            -o "${BINARY_NAME}" \
            ${{ matrix.service.cmd_path }}

          # Create output directory
          mkdir -p ../dist/binaries/${{ matrix.service.name }}

          # Package binary with platform version in filename
          tar czf "../dist/binaries/${{ matrix.service.name }}/${OUTPUT}.tar.gz" "${BINARY_NAME}"

      - name: Upload binary artifact
        uses: actions/upload-artifact@v6
        with:
          name: binary-${{ matrix.service.name }}-${{ matrix.arch.goos }}-${{ matrix.arch.goarch }}
          path: dist/binaries/${{ matrix.service.name }}/*.tar.gz

  manifest:
    name: Generate & Publish Manifest
    needs: [build-images, build-webapps, build-cli, build-service-binaries]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - name: Download image digest artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: image-digest-*
          path: dist/digests
          merge-multiple: true

      - name: Fetch MistServer metadata from latest release
        id: mistserver
        run: |
          set -euo pipefail

          # Get latest MistServer release info via GitHub API
          RELEASE=$(curl -sL https://api.github.com/repos/Livepeer-FrameWorks/mistserver/releases/latest)

          # Extract tag_name and asset download URLs
          TAG=$(echo "$RELEASE" | jq -r '.tag_name')
          DIGEST_URL=$(echo "$RELEASE" | jq -r '.assets[] | select(.name=="docker-digest.txt") | .browser_download_url')
          TAG_URL=$(echo "$RELEASE" | jq -r '.assets[] | select(.name=="docker-tag.txt") | .browser_download_url')
          RELEASE_URL=$(echo "$RELEASE" | jq -r '.html_url')
          ASSETS=$(echo "$RELEASE" | jq -c '[.assets[] | {name:.name, url:.browser_download_url, size:.size}]')

          # Download the metadata files
          DIGEST=$(curl -sL "$DIGEST_URL")
          DOCKER_TAG=$(curl -sL "$TAG_URL")

          echo "digest=${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "tag=${DOCKER_TAG}" >> "$GITHUB_OUTPUT"
          echo "release_tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "release_url=${RELEASE_URL}" >> "$GITHUB_OUTPUT"
          echo "assets=${ASSETS}" >> "$GITHUB_OUTPUT"
          echo "Fetched MistServer latest release: ${TAG}"
          echo "Docker tag: ${DOCKER_TAG}, Digest: ${DIGEST}"

      - name: Generate manifest
        run: |
          set -euo pipefail

          # Header
          cat > dist/manifest.yaml <<YAML
          platform_version: ${{ github.ref_name }}
          git_commit: ${{ github.sha }}
          release_date: $(date -u '+%Y-%m-%dT%H:%M:%SZ')

          YAML

          # Services (microservices with service_version field)
          echo "services:" >> dist/manifest.yaml
          for f in dist/digests/*.json; do
            name=$(jq -r .name "$f")
            # Skip interfaces - they go in interfaces section
            if [[ "$name" == "chartroom" || "$name" == "foredeck" || "$name" == "logbook" ]]; then
              continue
            fi

            image=$(jq -r .image "$f")
            digest=$(jq -r .digest "$f")
            svcver=$(jq -r .service_version "$f")

            cat >> dist/manifest.yaml <<YAML
            - name: ${name}
              service_version: ${svcver}
              image: ${image}
              digest: ${digest}
          YAML
          done

          # Native Binaries (for bare-metal deployment)
          echo "" >> dist/manifest.yaml
          echo "native_binaries:" >> dist/manifest.yaml
          for f in dist/digests/*.json; do
            name=$(jq -r .name "$f")
            # Skip interfaces - they don't have native binaries
            if [[ "$name" == "chartroom" || "$name" == "foredeck" || "$name" == "logbook" ]]; then
              continue
            fi

            cat >> dist/manifest.yaml <<YAML
            - name: ${name}
              artifacts:
                - arch: linux-amd64
                  file: frameworks-${name}-${{ github.ref_name }}-linux-amd64.tar.gz
                - arch: linux-arm64
                  file: frameworks-${name}-${{ github.ref_name }}-linux-arm64.tar.gz
          YAML
          done

          # Interfaces (reference implementations)
          echo "" >> dist/manifest.yaml
          echo "interfaces:" >> dist/manifest.yaml
          for f in dist/digests/*.json; do
            name=$(jq -r .name "$f")
            # Only include interfaces
            if [[ "$name" != "chartroom" && "$name" != "foredeck" && "$name" != "logbook" ]]; then
              continue
            fi

            image=$(jq -r .image "$f")
            digest=$(jq -r .digest "$f")

            bundle="${name}-build.tar.gz"

            cat >> dist/manifest.yaml <<YAML
            - name: ${name}
              image: ${image}
              digest: ${digest}
              static_bundle: ${bundle}
          YAML
          done

          # External Dependencies (MistServer from separate repo)
          echo "" >> dist/manifest.yaml
          cat >> dist/manifest.yaml <<YAML
          external_dependencies:
            - name: mistserver
              image: docker.io/livepeerframeworks/mistserver:${{ steps.mistserver.outputs.tag }}
              digest: "${{ steps.mistserver.outputs.digest }}"
              release_url: "${{ steps.mistserver.outputs.release_url }}"
              release_tag: "${{ steps.mistserver.outputs.release_tag }}"
          YAML

          mist_assets='${{ steps.mistserver.outputs.assets }}'
          if [[ -n "$mist_assets" && "$mist_assets" != "null" && "$mist_assets" != "[]" ]]; then
            echo "    binaries:" >> dist/manifest.yaml
            echo "$mist_assets" | jq -r '.[] | "      - name: \(.name)\n        url: \(.url)" + (if .size then "\n        size_bytes: \(.size)" else "" end)' >> dist/manifest.yaml
          fi

          # Infrastructure Requirements (from config/infrastructure.yaml)
          echo "" >> dist/manifest.yaml
          cat config/infrastructure.yaml >> dist/manifest.yaml
      - name: Upload manifest artifact
        uses: actions/upload-artifact@v6
        with:
          name: release-manifest
          path: dist/manifest.yaml
      - name: Download CLI artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: cli-*
          path: dist/cli
          merge-multiple: true
      - name: Download service binary artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: binary-*
          path: dist/binaries
          merge-multiple: true
      - name: Download chartroom bundle
        uses: actions/download-artifact@v7
        with:
          name: chartroom-bundle
          path: dist/
      - name: Download foredeck bundle
        uses: actions/download-artifact@v7
        with:
          name: foredeck-bundle
          path: dist/
      - name: Download logbook bundle
        uses: actions/download-artifact@v7
        with:
          name: logbook-bundle
          path: dist/
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: ${{ github.ref_name }}
          generate_release_notes: true
          files: |
            dist/manifest.yaml
            dist/cli/*
            dist/binaries/*.tar.gz
            dist/chartroom-build.tar.gz
            dist/foredeck-build.tar.gz
            dist/logbook-build.tar.gz

  update-env:
    name: Update GitOps Environment Repo
    needs: [manifest]
    runs-on: ubuntu-latest
    env:
      ENV_REPO: Livepeer-FrameWorks/gitops
      RELEASE_BRANCH: release/${{ github.ref_name }}
    steps:
      - name: Checkout env repo
        uses: actions/checkout@v6
        with:
          repository: ${{ env.ENV_REPO }}
          token: ${{ secrets.GITOPS_REPO_TOKEN }}
          path: env-repo
      - name: Download manifest artifact
        uses: actions/download-artifact@v7
        with:
          name: release-manifest
          path: dist
      - name: Commit and push manifest to env repo
        run: |
          set -euo pipefail
          cd env-repo

          # Create release manifest
          mkdir -p releases
          cp ../dist/manifest.yaml releases/${{ github.ref_name }}.yaml

          # Update channel pointer
          channel="stable"
          if [[ "${{ github.ref_name }}" =~ -rc($|([.-]?[0-9]+)$) ]]; then channel="rc"; fi
          mkdir -p channels
          cat > channels/${channel}.yaml <<YAML
          platform_version: ${{ github.ref_name }}
          manifest: releases/${{ github.ref_name }}.yaml
          updated_at: $(date -u '+%Y-%m-%dT%H:%M:%SZ')
          YAML

          # Commit and push
          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"

          # Fetch branch if it exists
          git fetch origin "${RELEASE_BRANCH}" || true

          # Create or reset to new content
          git checkout -B "${RELEASE_BRANCH}"
          git add releases/${{ github.ref_name }}.yaml channels/${channel}.yaml
          git commit -m "Release manifest for ${{ github.ref_name }}"
          git push --force origin "${RELEASE_BRANCH}"

      - name: Create or update PR to env repo
        env:
          GH_TOKEN: ${{ secrets.GITOPS_REPO_TOKEN }}
        run: |
          cd env-repo

          # Check if PR already exists
          PR_NUMBER=$(gh pr list \
            --repo "${{ env.ENV_REPO }}" \
            --head "${RELEASE_BRANCH}" \
            --base main \
            --json number \
            --jq '.[0].number' 2>/dev/null || echo "")

          if [[ -n "$PR_NUMBER" ]]; then
            echo "PR #${PR_NUMBER} already exists and was updated via branch push"
            echo "https://github.com/${{ env.ENV_REPO }}/pull/${PR_NUMBER}"
          else
            gh pr create \
              --repo "${{ env.ENV_REPO }}" \
              --base main \
              --head "${RELEASE_BRANCH}" \
              --title "Release ${{ github.ref_name }} manifest" \
              --body "This PR adds the release manifest for ${{ github.ref_name }}.

          It maps each service to image@digest and includes component versions.

          **Platform Version:** \`${{ github.ref_name }}\`
          **Git Commit:** \`${{ github.sha }}\`
          **Release Date:** \`$(date -u '+%Y-%m-%dT%H:%M:%SZ')\`"
          fi
